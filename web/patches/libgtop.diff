
Author: rmh

diff -Nur libgtop-2.13.3.old/configure.in libgtop-2.13.3/configure.in
--- libgtop-2.13.3.old/configure.in	2006-01-23 16:56:26.000000000 +0100
+++ libgtop-2.13.3/configure.in	2006-02-16 15:57:14.000000000 +0100
@@ -160,6 +160,12 @@
 	AC_DEFINE(HAVE_ISDN_H, 1, [defined if you have linux/isdn.h])
 fi
 
+dnl Linux-style procfs (used by GNU/k*BSD)
+AC_CHECK_FILES(/proc/cpuinfo /proc/stat)
+AC_CHECK_FILE(/proc/$$/stat, AC_DEFINE(HAVE__PROC_PID_STAT, 1, [Define to 1 if you have /proc/<pid>/stat]))
+AC_CHECK_FILE(/proc/$$/status, AC_DEFINE(HAVE__PROC_PID_STATUS, 1, [Define to 1 if you have /proc/<pid>/status]))
+AC_CHECK_FILE(/proc/$$/statm, AC_DEFINE(HAVE__PROC_PID_STATM, 1, [Define to 1 if you have /proc/<pid>/statm]))
+
 dnl AIX
 AC_CHECK_LIB(perfstat, vmgetinfo,
     AC_DEFINE(HAVE_VMGETINFO, 1,
@@ -192,6 +198,10 @@
        fi
     ])
      ;;
+     *)
+       dnl For *BSD (and GNU/k*BSD)
+       AC_CHECK_LIB(kvm, kvm_open)
+     ;;
 esac
 
 dnl For DEC OSF1
diff -Nur libgtop-2.13.3.old/debian/control.in libgtop-2.13.3/debian/control.in
--- libgtop-2.13.3.old/debian/control.in	2006-02-16 11:30:15.000000000 +0100
+++ libgtop-2.13.3/debian/control.in	2006-02-16 14:55:34.000000000 +0100
@@ -3,7 +3,7 @@
 Priority: optional
 Maintainer: Sebastien Bacher <seb128@debian.org>
 Uploaders: @GNOME_TEAM@
-Build-Depends: debhelper (>= 4.0), gettext, pkg-config, libpopt-dev, libxau-dev, libglib2.0-dev, gnome-pkg-tools, cdbs, texinfo
+Build-Depends: debhelper (>= 4.0), gettext, pkg-config, libpopt-dev, libxau-dev, libglib2.0-dev, gnome-pkg-tools, cdbs, texinfo, libfreebsd-dev [kfreebsd-i386 kfreebsd-amd64], libkvm-dev [kfreebsd-i386 kfreebsd-amd64]
 Standards-Version: 3.6.2
 
 Package: libgtop2-5
diff -Nur libgtop-2.13.3.old/libgtop-sysdeps.m4 libgtop-2.13.3/libgtop-sysdeps.m4
--- libgtop-2.13.3.old/libgtop-sysdeps.m4	2005-12-12 11:09:37.000000000 +0100
+++ libgtop-2.13.3/libgtop-sysdeps.m4	2006-02-16 15:29:27.000000000 +0100
@@ -68,11 +68,12 @@
 	  libgtop_have_sysinfo=yes
 	  libgtop_need_server=no
 	  ;;
-	freebsd*|netbsd*|openbsd*|bsdi*)
+	freebsd*|netbsd*|openbsd*|bsdi*|k*bsd*-gnu)
 	  libgtop_sysdeps_dir=freebsd
 	  libgtop_use_machine_h=yes
 	  libgtop_need_server=yes
 	  libgtop_postinstall='chgrp kmem $(bindir)/libgtop_server && chmod 2755 $(bindir)/libgtop_server'
+	  case "$host_os" in kfreebsd*-gnu) libgtop_have_sysinfo=yes ;; esac
 	  ;;
 	solaris*)
 	  libgtop_sysdeps_dir=solaris
@@ -126,7 +127,7 @@
 
 	case "$host_os" in
 	*bsd*)
-	  AC_CHECK_HEADERS(net/if_var.h)
+	  AC_CHECK_HEADERS(net/if_var.h net/if_sppp.h)
 	  AC_MSG_CHECKING([for I4B])
 	  AC_TRY_COMPILE([
 #include <sys/types.h>
@@ -142,7 +143,7 @@
 #include <net/netisr.h>
 #include <net/route.h>
 
-#if defined(__FreeBSD__) || defined(__NetBSD__)
+#ifdef HAVE_NET_IF_SPPP_H
 #include <net/if_sppp.h>
 #else
 #include <i4b/sppp/if_sppp.h>
@@ -168,7 +169,7 @@
 #include <net/netisr.h>
 #include <net/route.h>
 
-#if defined(__FreeBSD__) || defined(__NetBSD__)
+#ifdef HAVE_NET_IF_SPPP_H
 #include <net/if_sppp.h>
 #else
 #include <i4b/sppp/if_sppp.h>
diff -Nur libgtop-2.13.3.old/sysdeps/common/Makefile.am libgtop-2.13.3/sysdeps/common/Makefile.am
--- libgtop-2.13.3.old/sysdeps/common/Makefile.am	2005-06-15 00:21:05.000000000 +0200
+++ libgtop-2.13.3/sysdeps/common/Makefile.am	2006-02-16 15:41:13.000000000 +0100
@@ -18,12 +18,13 @@
                                   mountlist.c \
                                   procargs.c \
 				  default.c \
+				  sysinfo.c glibtop_private.c \
 				  $(inodedb_SRCLIST)
 
 # libgtop_common_2_0_la_LDFLAGS	= $(LT_VERSION_INFO)
 libgtop_common_2_0_la_LIBADD	= $(LIBGTOP_EXTRA_LIBS)
 
-libgtop_suid_common_2_0_la_SOURCES	= error.c sysdeps_suid.c
+libgtop_suid_common_2_0_la_SOURCES	= error.c sysdeps_suid.c sysinfo.c glibtop_private.c
 
 # libgtop_suid_common_2_0_la_LDFLAGS	= $(LT_VERSION_INFO)
 
diff -Nur libgtop-2.13.3.old/sysdeps/common/Makefile.in libgtop-2.13.3/sysdeps/common/Makefile.in
--- libgtop-2.13.3.old/sysdeps/common/Makefile.in	2006-01-23 17:01:24.000000000 +0100
+++ libgtop-2.13.3/sysdeps/common/Makefile.in	2006-02-16 15:58:18.000000000 +0100
@@ -51,13 +51,13 @@
 am__DEPENDENCIES_1 =
 libgtop_common_2_0_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am__libgtop_common_2_0_la_SOURCES_DIST = error.c gnuslib.c fsusage.c \
-	mountlist.c procargs.c default.c inodedb.c
+	mountlist.c procargs.c default.c sysinfo.c glibtop_private.c inodedb.c
 @INODEDB_TRUE@am__objects_1 = inodedb.lo
 am_libgtop_common_2_0_la_OBJECTS = error.lo gnuslib.lo fsusage.lo \
-	mountlist.lo procargs.lo default.lo $(am__objects_1)
+	mountlist.lo procargs.lo default.lo sysinfo.lo glibtop_private.lo $(am__objects_1)
 libgtop_common_2_0_la_OBJECTS = $(am_libgtop_common_2_0_la_OBJECTS)
 libgtop_suid_common_2_0_la_LIBADD =
-am_libgtop_suid_common_2_0_la_OBJECTS = error.lo sysdeps_suid.lo
+am_libgtop_suid_common_2_0_la_OBJECTS = error.lo sysdeps_suid.lo sysinfo.lo glibtop_private.lo
 libgtop_suid_common_2_0_la_OBJECTS =  \
 	$(am_libgtop_suid_common_2_0_la_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
@@ -254,12 +254,14 @@
                                   mountlist.c \
                                   procargs.c \
 				  default.c \
+				  sysinfo.c \
+				  glibtop_private.c \
 				  $(inodedb_SRCLIST)
 
 
 # libgtop_common_2_0_la_LDFLAGS	= $(LT_VERSION_INFO)
 libgtop_common_2_0_la_LIBADD = $(LIBGTOP_EXTRA_LIBS)
-libgtop_suid_common_2_0_la_SOURCES = error.c sysdeps_suid.c
+libgtop_suid_common_2_0_la_SOURCES = error.c sysdeps_suid.c sysinfo.c glibtop_private.c
 
 # libgtop_suid_common_2_0_la_LDFLAGS	= $(LT_VERSION_INFO)
 EXTRA_DIST = inodedb.c
@@ -322,6 +324,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnuslib.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/inodedb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mountlist.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sysinfo.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glibtop_private.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/procargs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sysdeps_suid.Plo@am__quote@
 
diff -Nur libgtop-2.13.3.old/sysdeps/common/glibtop_private.c libgtop-2.13.3/sysdeps/common/glibtop_private.c
--- libgtop-2.13.3.old/sysdeps/common/glibtop_private.c	1970-01-01 01:00:00.000000000 +0100
+++ libgtop-2.13.3/sysdeps/common/glibtop_private.c	2006-02-16 15:58:08.000000000 +0100
@@ -0,0 +1,165 @@
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+
+#include "glibtop_private.h"
+
+#include <glib.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+
+
+unsigned long long
+get_scaled(const char *buffer, const char *key)
+{
+	const char    *ptr;
+	char	      *next;
+	unsigned long long value = 0;
+
+	if (G_LIKELY((ptr = strstr(buffer, key))))
+	{
+		ptr += strlen(key);
+		value = strtoull(ptr, &next, 0);
+		if (strchr(next, 'k'))
+			value *= 1024;
+		else if (strchr(next, 'M'))
+			value *= 1024 * 1024;
+	} else
+		g_warning("Could not read key '%s' in buffer '%s'",
+			  key, buffer);
+
+	return value;
+}
+
+
+char *
+skip_token (const char *p)
+{
+	p = next_token(p);
+	while (*p && !isspace(*p)) p++;
+	p = next_token(p);
+	return (char *)p;
+}
+
+
+/*
+ * Read functions
+ */
+enum TRY_FILE_TO_BUFFER
+{
+	TRY_FILE_TO_BUFFER_OK = 0,
+	TRY_FILE_TO_BUFFER_OPEN = -1,
+	TRY_FILE_TO_BUFFER_READ = -2
+};
+
+int try_file_to_buffer(char *buffer, const char *format, ...)
+{
+	char path[4096];
+	int fd;
+	ssize_t len;
+	va_list pa;
+
+	va_start(pa, format);
+
+	/* C99 also provides vsnprintf */
+	g_vsnprintf(path, sizeof path, format, pa);
+
+	va_end(pa);
+
+	buffer [0] = '\0';
+
+	if((fd = open (path, O_RDONLY)) < 0)
+		return TRY_FILE_TO_BUFFER_OPEN;
+
+	len = read (fd, buffer, BUFSIZ-1);
+	close (fd);
+
+	if (len < 0)
+		return TRY_FILE_TO_BUFFER_READ;
+
+	buffer [len] = '\0';
+
+	return TRY_FILE_TO_BUFFER_OK;
+}
+
+
+void
+file_to_buffer(glibtop *server, char *buffer, const char *filename)
+{
+	switch(try_file_to_buffer(buffer, filename))
+	{
+	case TRY_FILE_TO_BUFFER_OPEN:
+		glibtop_error_io_r (server, "open (%s)", filename);
+	case TRY_FILE_TO_BUFFER_READ:
+		glibtop_error_io_r (server, "read (%s)", filename);
+	}
+}
+
+
+
+#ifdef HAVE__PROC_STAT
+static unsigned long
+read_boot_time(glibtop *server)
+{
+	char buffer[BUFSIZ];
+	char *btime;
+
+	file_to_buffer(server, buffer, "/proc/stat");
+
+	btime = strstr(buffer, "btime");
+
+	if (!btime) {
+		glibtop_warn_io_r(server, "cannot find btime in /proc/stat");
+		return 0UL;
+	}
+
+	btime = skip_token(btime);
+	return strtoul(btime, NULL, 10);
+}
+
+
+unsigned long
+get_boot_time(glibtop *server)
+{
+	static unsigned long boot_time = 0UL;
+
+	if(G_UNLIKELY(!boot_time))
+	{
+		boot_time = read_boot_time(server);
+	}
+
+	return boot_time;
+}
+#endif
+
+
+size_t
+get_page_size(void)
+{
+	static size_t pagesize = 0;
+
+	if(G_UNLIKELY(!pagesize))
+	{
+		pagesize = getpagesize();
+	}
+
+	return pagesize;
+}
+
+
+
+gboolean
+check_cpu_line(glibtop *server, const char *line, unsigned i)
+{
+	char start[10];
+
+	g_snprintf(start, sizeof start, "cpu%u", i);
+
+	return g_str_has_prefix(line, start);
+}
+
diff -Nur libgtop-2.13.3.old/sysdeps/common/glibtop_private.h libgtop-2.13.3/sysdeps/common/glibtop_private.h
--- libgtop-2.13.3.old/sysdeps/common/glibtop_private.h	1970-01-01 01:00:00.000000000 +0100
+++ libgtop-2.13.3/sysdeps/common/glibtop_private.h	2006-02-16 15:58:11.000000000 +0100
@@ -0,0 +1,152 @@
+/* Copyright (C) 2004 BenoÃ®t Dejean
+   This file is part of LibGTop 2.0.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __GLIBTOP_PRIVATE_H__
+#define __GLIBTOP_PRIVATE_H__
+
+#include <glibtop.h>
+#include <glibtop/error.h>
+
+#include <glib.h>
+
+#include <fcntl.h>
+#include <ctype.h>
+#include <string.h>
+
+G_BEGIN_DECLS
+
+static inline char*
+next_token(const char *p)
+{
+	while (isspace(*p)) p++;
+	return (char*) p;
+}
+
+char *
+skip_token (const char *p) G_GNUC_INTERNAL;
+
+static inline char *
+skip_multiple_token (const char *p, size_t count)
+{
+	while(count--)
+		p = skip_token (p);
+
+	return (char *)p;
+}
+
+
+static inline char *
+skip_line (const char *p)
+{
+	while (*p && *p != '\n') p++;
+	return (char *) (*p ? p+1 : p);
+}
+
+
+unsigned long long
+get_scaled(const char *buffer, const char *key) G_GNUC_INTERNAL;
+
+
+/* aborts on error */
+void G_GNUC_INTERNAL
+file_to_buffer(glibtop *server, char *buffer, const char *filename);
+
+/* return < 0 on error, otherwise 0 on success */
+int G_GNUC_INTERNAL
+try_file_to_buffer(char *buffer, const char *format, ...) G_GNUC_PRINTF(2, 3);
+
+
+/* some inline functions that wrap proc path
+ * as fast as macros :)
+ */
+
+static inline int
+proc_file_to_buffer (char *buffer, const char *fmt, pid_t pid)
+{
+	return try_file_to_buffer(buffer, fmt, pid);
+}
+
+#ifdef HAVE__PROC_PID_STAT
+static inline int
+proc_stat_to_buffer (char *buffer, pid_t pid)
+{
+	return proc_file_to_buffer (buffer, "/proc/%d/stat", pid);
+}
+#endif
+
+#ifdef HAVE__PROC_PID_STATUS
+static inline int
+proc_status_to_buffer (char *buffer, pid_t pid)
+{
+	return proc_file_to_buffer (buffer, "/proc/%d/status", pid);
+}
+#endif
+
+#ifdef HAVE__PROC_PID_STATM
+static inline int
+proc_statm_to_buffer (char *buffer, pid_t pid)
+{
+	return proc_file_to_buffer (buffer, "/proc/%d/statm", pid);
+}
+#endif
+
+
+static inline char *
+proc_stat_after_cmd (char *p)
+{
+	p = strrchr (p, ')');
+	if (G_LIKELY(p))
+		*p++ = '\0';
+	return p;
+}
+
+
+#ifdef HAVE__PROC_STAT
+unsigned long
+get_boot_time(glibtop *server) G_GNUC_INTERNAL;
+#endif
+
+
+size_t
+get_page_size(void) G_GNUC_INTERNAL;
+
+
+gboolean
+check_cpu_line(glibtop *server, const char *line, unsigned n) G_GNUC_INTERNAL;
+
+
+static inline gboolean
+check_cpu_line_warn(glibtop *server, const char *line, unsigned i)
+{
+	gboolean ret;
+
+	ret = check_cpu_line(server, line, i);
+
+	if (G_UNLIKELY(!ret))
+		glibtop_warn_io_r(server,
+				  "'%s' does not start with 'cpu%u'",
+				  line, i);
+
+	return ret;
+}
+
+
+G_END_DECLS
+
+#endif /* __LINUX__GLIBTOP_PRIVATE_H__ */
diff -Nur libgtop-2.13.3.old/sysdeps/common/sysinfo.c libgtop-2.13.3/sysdeps/common/sysinfo.c
--- libgtop-2.13.3.old/sysdeps/common/sysinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ libgtop-2.13.3/sysdeps/common/sysinfo.c	2006-02-16 15:58:03.000000000 +0100
@@ -0,0 +1,105 @@
+/* $Id: sysinfo.c,v 1.22 2004/11/28 01:32:55 bdejean Exp $ */
+
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#ifdef HAVE__PROC_CPUINFO
+#include <glibtop/error.h>
+#include <glibtop/cpu.h>
+#include <glibtop/sysinfo.h>
+
+#include "glibtop_private.h"
+
+#define FILENAME "/proc/cpuinfo"
+
+static const unsigned long _glibtop_sysdeps_sysinfo =
+(1L << GLIBTOP_SYSINFO_CPUINFO);
+
+static glibtop_sysinfo sysinfo = { .flags = 0 };
+
+static void
+init_sysinfo (glibtop *server)
+{
+	char buffer [BUFSIZ];
+	gchar ** processors;
+
+	if(G_LIKELY(sysinfo.flags)) return;
+
+	glibtop_init_s (&server, GLIBTOP_SYSDEPS_CPU, 0);
+
+	file_to_buffer(server, buffer, FILENAME);
+
+	/* cpuinfo records are seperated by a blank line */
+	processors = g_strsplit(buffer, "\n\n", 0);
+
+	for(sysinfo.ncpu = 0;
+	    sysinfo.ncpu < GLIBTOP_NCPU && processors[sysinfo.ncpu] && *processors[sysinfo.ncpu];
+	    sysinfo.ncpu++) {
+
+		gchar **parts, **p;
+
+		glibtop_entry * const cpuinfo = &sysinfo.cpuinfo[sysinfo.ncpu];
+
+		cpuinfo->labels = g_ptr_array_new ();
+
+		cpuinfo->values = g_hash_table_new_full(g_str_hash, g_str_equal,
+							g_free, g_free);
+
+		cpuinfo->descriptions = g_hash_table_new_full(g_str_hash, g_str_equal,
+							g_free, g_free);
+
+		/* "<key>    : <value>" */
+		parts = g_strsplit_set(processors[sysinfo.ncpu], ":\n", 0);
+
+		for(p = parts; *p && *(p+1); p += 2) {
+
+			/* stole the allocated memory */
+			gchar * const key   = g_strstrip(   *p   );
+			gchar * const value = g_strstrip( *(p+1) );
+
+			g_ptr_array_add(cpuinfo->labels, key);
+			g_hash_table_insert(cpuinfo->values, key, value);
+		}
+
+
+		/* the last key has no value and has not been added */
+		if(*p) g_free(*p);
+
+		/* just g_free instead of g_strvfree because we stole
+		   the memory*/
+
+		g_free(parts);
+
+	}
+
+	g_strfreev(processors);
+
+	sysinfo.flags = _glibtop_sysdeps_sysinfo;
+}
+
+const glibtop_sysinfo *
+glibtop_get_sysinfo_s (glibtop *server)
+{
+	init_sysinfo (server);
+	return &sysinfo;
+}
+#endif			/* HAVE__PROC_CPUINFO */
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/glibtop_server.h libgtop-2.13.3/sysdeps/freebsd/glibtop_server.h
--- libgtop-2.13.3.old/sysdeps/freebsd/glibtop_server.h	2003-10-20 17:19:49.000000000 +0200
+++ libgtop-2.13.3/sysdeps/freebsd/glibtop_server.h	2006-02-16 15:03:07.000000000 +0100
@@ -44,6 +44,7 @@
 #define GLIBTOP_SUID_PROC_SEGMENT	(1 << GLIBTOP_SYSDEPS_PROC_SEGMENT)
 #define GLIBTOP_SUID_PROC_ARGS		(1 << GLIBTOP_SYSDEPS_PROC_ARGS)
 #define GLIBTOP_SUID_PROC_MAP		(1 << GLIBTOP_SYSDEPS_PROC_MAP)
+#define GLIBTOP_SUID_NETLIST		0
 #define GLIBTOP_SUID_NETLOAD		(1 << GLIBTOP_SYSDEPS_NETLOAD)
 #define GLIBTOP_SUID_PPP		(1 << GLIBTOP_SYSDEPS_PPP)
 
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/mem.c libgtop-2.13.3/sysdeps/freebsd/mem.c
--- libgtop-2.13.3.old/sysdeps/freebsd/mem.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/mem.c	2006-02-16 14:55:34.000000000 +0100
@@ -43,7 +43,7 @@
 (1L << GLIBTOP_MEM_FREE) +
 (1L << GLIBTOP_MEM_SHARED) +
 (1L << GLIBTOP_MEM_BUFFER) +
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 (1L << GLIBTOP_MEM_CACHED) +
 #endif
 (1L << GLIBTOP_MEM_USER) + (1L << GLIBTOP_MEM_LOCKED);
@@ -66,7 +66,7 @@
 #else
 #if defined(__bsdi__)
 	{ "_bufcachemem" },
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	{ "_bufspace" },
 #else
 	{ "_bufpages" },
@@ -171,7 +171,7 @@
 
 	/* convert memory stats to Kbytes */
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	v_total_count = vmm.v_page_count;
 #else
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
@@ -198,7 +198,7 @@
 	buf->used  = (guint64) pagetok (v_used_count) << LOG1024;
 	buf->free  = (guint64) pagetok (v_free_count) << LOG1024;
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	buf->cached = (guint64) pagetok (vmm.v_cache_count) << LOG1024;
 #endif
 
@@ -210,7 +210,7 @@
 
 	buf->shared = (guint64) pagetok (vmt.t_rmshr) << LOG1024;
 
-#if __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	buf->buffer = (guint64) bufspace;
 #else
 	buf->buffer = (guint64) pagetok (bufspace) << LOG1024;
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/msg_limits.c libgtop-2.13.3/sysdeps/freebsd/msg_limits.c
--- libgtop-2.13.3.old/sysdeps/freebsd/msg_limits.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/msg_limits.c	2006-02-16 14:55:34.000000000 +0100
@@ -49,6 +49,15 @@
 
 #if (defined(__FreeBSD__) && (__FreeBSD_version < 410000)) || (defined __bsdi__)
 #define KERNEL 1
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+struct msginfo {
+	int	msgmax,		/* max chars in a message */
+		msgmni,		/* max message queue identifiers */
+		msgmnb,		/* max chars in a queue */
+		msgtql,		/* max messages in system */
+		msgssz,		/* size of a message segment (see notes above) */
+		msgseg;		/* number of message segments */
+};
 #else
 #define _KERNEL 1
 #endif
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/netload.c libgtop-2.13.3/sysdeps/freebsd/netload.c
--- libgtop-2.13.3.old/sysdeps/freebsd/netload.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/netload.c	2006-02-16 14:55:34.000000000 +0100
@@ -122,7 +122,7 @@
 #else
 	    g_strlcpy (name, ifnet.if_xname, sizeof(name));
 #endif
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 300000)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 300000)) || defined(__FreeBSD_kernel__)
 	    ifnetaddr = (u_long) ifnet.if_link.tqe_next;
 #elif defined(__FreeBSD__) || defined(__bsdi__)
 	    ifnetaddr = (u_long) ifnet.if_next;
@@ -133,7 +133,7 @@
 	    if (strcmp (name, interface) != 0)
 		    continue;
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 300000)
+#if defined(__FreeBSD__) && (__FreeBSD_version >= 300000) || defined(__FreeBSD_kernel__)
 	    ifaddraddr = (u_long) ifnet.if_addrhead.tqh_first;
 #elif defined(__FreeBSD__) || defined(__bsdi__)
 	    ifaddraddr = (u_long) ifnet.if_addrlist;
@@ -169,7 +169,7 @@
 		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK1);
 	if (ifnet.if_flags & IFF_LINK2)
 		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK2);
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	if (ifnet.if_flags & IFF_ALTPHYS)
 		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALTPHYS);
 #endif
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/open.c libgtop-2.13.3/sysdeps/freebsd/open.c
--- libgtop-2.13.3.old/sysdeps/freebsd/open.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/open.c	2006-02-16 14:55:34.000000000 +0100
@@ -26,6 +26,11 @@
 #include <glibtop/open.h>
 #include <glibtop/init_hooks.h>
 
+#if defined(__FreeBSD_kernel__) && !defined(__FreeBSD_version)
+#include <sys/param.h>		/* __FreeBSD_kernel_version */
+#define __FreeBSD_version __FreeBSD_kernel_version
+#endif
+
 /* !!! THIS FUNCTION RUNS SUID ROOT - CHANGE WITH CAUTION !!! */
 
 void
@@ -65,7 +70,7 @@
 	server->machine.gid = getgid ();
 	server->machine.egid = getegid ();
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	server->os_version_code = __FreeBSD_version;
 #endif
 
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/ppp.c libgtop-2.13.3/sysdeps/freebsd/ppp.c
--- libgtop-2.13.3.old/sysdeps/freebsd/ppp.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/ppp.c	2006-02-16 14:55:34.000000000 +0100
@@ -40,7 +40,7 @@
 #include <net/netisr.h>
 #include <net/route.h>
 
-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#ifdef HAVE_NET_IF_SPPP_H
 #include <net/if_sppp.h>
 #else
 #include <i4b/sppp/if_sppp.h>
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/prockernel.c libgtop-2.13.3/sysdeps/freebsd/prockernel.c
--- libgtop-2.13.3.old/sysdeps/freebsd/prockernel.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/prockernel.c	2006-02-16 14:55:34.000000000 +0100
@@ -94,7 +94,7 @@
 			   pid_t pid)
 {
 	struct kinfo_proc *pinfo;
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__)
 	struct user *u_addr = (struct user *)USRSTACK;
 	struct pstats pstats;
 	struct pcb pcb;
@@ -119,7 +119,7 @@
 	if ((pinfo == NULL) || (count != 1))
 		glibtop_error_io_r (server, "kvm_getprocs (%d)", pid);
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 
 #define	PROC_WCHAN	ki_wchan
 #define	PROC_WMESG	ki_wmesg
@@ -147,7 +147,7 @@
 	}
 #endif
 
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__)
 
 	/* Taken from `saveuser ()' in `/usr/src/bin/ps/ps.c'. */
 
@@ -203,9 +203,9 @@
 		       (unsigned long) &u_addr->u_pcb,
 		       (char *) &pcb, sizeof (pcb)) == sizeof (pcb))
 		{
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #ifndef __alpha__
-#if (__FreeBSD_version >= 300003)
+#if (__FreeBSD_version >= 300003) || defined(__FreeBSD_kernel__)
 			buf->kstk_esp = (guint64) pcb.pcb_esp;
 			buf->kstk_eip = (guint64) pcb.pcb_eip;
 #else
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/proclist.c libgtop-2.13.3/sysdeps/freebsd/proclist.c
--- libgtop-2.13.3.old/sysdeps/freebsd/proclist.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/proclist.c	2006-02-16 14:55:34.000000000 +0100
@@ -86,7 +86,7 @@
 	pids = g_realloc (pids, count * sizeof (unsigned));
 	/* Copy the pids over to this chain */
 	for (i=j=0; i < count; i++) {
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 #define PROC_STAT	ki_stat
 #define PROC_RUID	ki_ruid
 #define PROC_PID	ki_pid
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/procmap.c libgtop-2.13.3/sysdeps/freebsd/procmap.c
--- libgtop-2.13.3.old/sysdeps/freebsd/procmap.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/procmap.c	2006-02-16 14:55:34.000000000 +0100
@@ -30,6 +30,9 @@
 
 #include <kvm.h>
 #include <sys/param.h>
+#if defined(__FreeBSD__) && !defined(__FreeBSD_kernel_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
 #include <sys/proc.h>
 #include <sys/resource.h>
 #if defined(__NetBSD__) && (__NetBSD_Version__ < 105020000)
@@ -41,18 +44,18 @@
 #else
 #include <vm/vm_object.h>
 #include <vm/vm_map.h>
-#if (__FreeBSD_version >= 400011)
+#if (defined(__FreeBSD_version) && __FreeBSD_version >= 400011) || defined(__FreeBSD_kernel__)
 #include <vm/vm.h>
 #else
 #include <vm/vm_prot.h>
 #endif
 #endif
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #define _KVM_VNODE
 #endif
 #include <sys/vnode.h>
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #undef _KVM_VNODE
 #endif
 #include <sys/mount.h>
@@ -109,9 +112,9 @@
 	struct vm_object object;
 #endif
 	glibtop_map_entry *maps;
-#if defined __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 	struct vnode vnode;
-#if __FreeBSD_version < 500039
+#if defined(__FreeBSD_version) && __FreeBSD_version < 500039
 	struct inode inode;
 #endif
 #endif
@@ -137,7 +140,7 @@
 	/* Now we get the memory maps. */
 
 	if (kvm_read (server->machine.kd,
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 		      (unsigned long) pinfo [0].ki_vmspace,
 #else
 		      (unsigned long) pinfo [0].kp_proc.p_vmspace,
@@ -179,8 +182,8 @@
 			update = 1;
 		}
 
-#ifdef __FreeBSD__
-#if __FreeBSD__ >= 4
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if __FreeBSD__ >= 4 || defined(__FreeBSD_kernel__)
 		if (entry.eflags & (MAP_ENTRY_IS_SUB_MAP))
 			continue;
 #else
@@ -256,7 +259,7 @@
 #endif
 
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 		/* If the object is of type vnode, add its size */
 
 		if (object.type != OBJT_VNODE)
@@ -270,10 +273,10 @@
 			      &vnode, sizeof (vnode)) != sizeof (vnode))
 			glibtop_error_io_r (server, "kvm_read (vnode)");
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500039)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500039)) || defined(__FreeBSD_kernel__)
                switch (vnode.v_type) {
                    case VREG:
-#if __FreeBSD_version < 600006
+#if __FreeBSD_kernel_version < 600006
                        maps [i-1].inode = vnode.v_cachedid;
                        maps [i-1].device = vnode.v_cachedfs;
 #endif
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/procmem.c libgtop-2.13.3/sysdeps/freebsd/procmem.c
--- libgtop-2.13.3.old/sysdeps/freebsd/procmem.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/procmem.c	2006-02-16 14:55:34.000000000 +0100
@@ -73,7 +73,7 @@
 static const unsigned long _glibtop_sysdeps_proc_mem_share =
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 104000000)
 (1L << GLIBTOP_PROC_MEM_SHARE);
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 (1L << GLIBTOP_PROC_MEM_SHARE);
 #else
 0;
@@ -126,7 +126,7 @@
 #else
 	struct vm_object object;
 #endif
-#if !defined(__FreeBSD__) || (__FreeBSD_version < 500013)
+#if (!defined(__FreeBSD__) || (__FreeBSD_version < 500013)) && !defined(__FreeBSD_kernel__)
 	struct plimit plimit;
 #endif
 	int count;
@@ -147,7 +147,7 @@
 		glibtop_warn_io_r (server, "kvm_getprocs (%d)", pid);
 		return;
 	}
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 
 #define        PROC_VMSPACE   ki_vmspace
 
@@ -214,8 +214,8 @@
 			return;
 		}
 
-#ifdef __FreeBSD__
-#if __FreeBSD__ >= 4
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if (defined(__FreeBSD__) && __FreeBSD__ >= 4) || defined(__FreeBSD_kernel__)
 		if (entry.eflags & (MAP_ENTRY_IS_SUB_MAP))
 			continue;
 #else
@@ -282,7 +282,7 @@
 #endif /* __NetBSD_Version__ >= 105250000 */
 #endif
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 		if (object.type != OBJT_VNODE)
 			continue;
 
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/procsignal.c libgtop-2.13.3/sysdeps/freebsd/procsignal.c
--- libgtop-2.13.3.old/sysdeps/freebsd/procsignal.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/procsignal.c	2006-02-16 14:55:34.000000000 +0100
@@ -70,7 +70,7 @@
 		return;
 	}
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 
 #define	PROC_SIGLIST	ki_siglist
 #define	PROC_SIGMASK	ki_sigmask
@@ -92,7 +92,8 @@
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 105150000)
 	buf->signal [0] = pinfo [0].kp_proc.p_sigctx.ps_siglist.__bits[0];
 #elif (defined(__NetBSD__) && (NSIG > 32)) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011))
+      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011)) || \
+      defined(__FreeBSD_kernel__)
 	buf->signal [0] = pinfo [0].PROC_SIGLIST.__bits[0];
 #else
 	buf->signal [0] = pinfo [0].kp_proc.p_siglist;
@@ -104,7 +105,8 @@
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 105150000)
 	buf->blocked [0] = pinfo [0].kp_proc.p_sigctx.ps_sigmask.__bits[0];
 #elif (defined(__NetBSD__) && (NSIG > 32)) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011))
+      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011)) || \
+      defined(__FreeBSD_kernel__)
 	buf->blocked [0] = pinfo [0].PROC_SIGMASK.__bits[0];
 #else
 	buf->blocked [0] = pinfo [0].kp_proc.p_sigmask;
@@ -116,7 +118,8 @@
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 105150000)
 	buf->sigignore [0] = pinfo [0].kp_proc.p_sigctx.ps_sigignore.__bits[0];
 #elif (defined(__NetBSD__) && (NSIG > 32)) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011))
+      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011)) || \
+      defined(__FreeBSD_kernel__)
 	buf->sigignore [0] = pinfo [0].PROC_SIGIGNORE.__bits[0];
 #else
 	buf->sigignore [0] = pinfo [0].kp_proc.p_sigignore;
@@ -128,7 +131,8 @@
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 105150000)
 	buf->sigcatch [0] = pinfo [0].kp_proc.p_sigctx.ps_sigcatch.__bits[0];
 #elif (defined(__NetBSD__) && (NSIG > 32)) || \
-      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011))
+      (defined(__FreeBSD__) && (__FreeBSD_version >= 400011)) || \
+      defined(__FreeBSD_kernel__)
 	buf->sigcatch [0] = pinfo [0].PROC_SIGCATCH.__bits[0];
 #else
 	buf->sigcatch [0] = pinfo [0].kp_proc.p_sigcatch;
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/procstate.c libgtop-2.13.3/sysdeps/freebsd/procstate.c
--- libgtop-2.13.3.old/sysdeps/freebsd/procstate.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/procstate.c	2006-02-16 14:55:34.000000000 +0100
@@ -73,7 +73,7 @@
 		return;
 	}
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 #define	PROC_COMM	ki_comm
 #define	PROC_SVUID	ki_svuid
 #define	PROC_SVGID	ki_svgid
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/proctime.c libgtop-2.13.3/sysdeps/freebsd/proctime.c
--- libgtop-2.13.3.old/sysdeps/freebsd/proctime.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/proctime.c	2006-02-16 14:55:34.000000000 +0100
@@ -58,9 +58,7 @@
  * system, and interrupt time usage.
  */
 
-#ifndef __FreeBSD__
-
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__)
 static void
 calcru(p, up, sp, ip)
      struct proc *p;
@@ -109,8 +107,6 @@
 		ip->tv_usec = it % 1000000;
 	}
 }
-#endif
-
 #endif /* !__FreeBSD__ */
 
 /* Provides detailed information about a process. */
@@ -150,7 +146,7 @@
 	if ((pinfo == NULL) || (count != 1))
 		glibtop_error_io_r (server, "kvm_getprocs (%d)", pid);
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 	buf->rtime = pinfo [0].ki_runtime;
 #elif (defined __FreeBSD__) && (__FreeBSD_version <= 500013)
 	buf->rtime = pinfo [0].kp_proc.p_runtime;
@@ -187,8 +183,8 @@
 
 	buf->flags |= _glibtop_sysdeps_proc_time_user;
 #else
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
-#if __FreeBSD_version >= 500016
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
+#if __FreeBSD_version >= 500016 || defined(__FreeBSD_kernel__)
        if ((pinfo [0].ki_flag & PS_INMEM)) {
 #else
        if ((pinfo [0].ki_flag & P_INMEM)) {
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/procuid.c libgtop-2.13.3/sysdeps/freebsd/procuid.c
--- libgtop-2.13.3.old/sysdeps/freebsd/procuid.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/procuid.c	2006-02-16 14:55:34.000000000 +0100
@@ -77,7 +77,7 @@
 		return;
 	}
 
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500013)
+#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500013)) || defined(__FreeBSD_kernel__)
 
 #define	PROC_RUID	ki_ruid
 #define	PROC_SVUID	ki_svuid
@@ -87,7 +87,7 @@
 #define	PROC_PGID	ki_pgid
 #define	PROC_TPGID	ki_tpgid
 #define	PROC_NICE	ki_nice
-#if __FreeBSD_version >= 500013
+#if __FreeBSD_version >= 500013 || defined(__FreeBSD_kernel__)
 #define	PROC_PRIORITY	ki_pri.pri_user
 #else
 #define	PROC_PRIORITY	ki_priority
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/sem_limits.c libgtop-2.13.3/sysdeps/freebsd/sem_limits.c
--- libgtop-2.13.3.old/sysdeps/freebsd/sem_limits.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/sem_limits.c	2006-02-16 14:55:34.000000000 +0100
@@ -49,6 +49,19 @@
 
 #if (defined(__FreeBSD__) && (__FreeBSD_version < 410000)) || defined(__bsdi__)
 #define KERNEL 1
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+struct seminfo {
+	int	semmap,		/* # of entries in semaphore map */
+		semmni,		/* # of semaphore identifiers */
+		semmns,		/* # of semaphores in system */
+		semmnu,		/* # of undo structures in system */
+		semmsl,		/* max # of semaphores per id */
+		semopm,		/* max # of operations per semop call */
+		semume,		/* max # of undo entries per process */
+		semusz,		/* size in bytes of undo structure */
+		semvmx,		/* semaphore maximum value */
+		semaem;		/* adjust on exit max value */
+};
 #else
 #define _KERNEL 1
 #endif
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/shm_limits.c libgtop-2.13.3/sysdeps/freebsd/shm_limits.c
--- libgtop-2.13.3.old/sysdeps/freebsd/shm_limits.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/shm_limits.c	2006-02-16 14:55:34.000000000 +0100
@@ -49,6 +49,14 @@
 
 #if (defined(__FreeBSD__) && (__FreeBSD_version < 410000)) || defined(__bsdi__)
 #define KERNEL 1
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+struct shminfo {
+	int	shmmax,		/* max shared memory segment size (bytes) */
+		shmmin,		/* min shared memory segment size (bytes) */
+		shmmni,		/* max number of shared memory identifiers */
+		shmseg,		/* max shared memory segments per process */
+		shmall;		/* max amount of shared memory (pages) */
+};
 #else
 #define _KERNEL 1
 #endif
diff -Nur libgtop-2.13.3.old/sysdeps/freebsd/swap.c libgtop-2.13.3/sysdeps/freebsd/swap.c
--- libgtop-2.13.3.old/sysdeps/freebsd/swap.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/freebsd/swap.c	2006-02-16 14:55:34.000000000 +0100
@@ -33,13 +33,13 @@
 (1L << GLIBTOP_SWAP_FREE) + (1L << GLIBTOP_SWAP_PAGEIN) +
 (1L << GLIBTOP_SWAP_PAGEOUT);
 
-#if defined(__FreeBSD__) || defined(__bsdi__)
+#if defined(__FreeBSD__) || defined(__bsdi__) || defined(__FreeBSD_kernel__)
 
 #include <sys/conf.h>
 #ifdef __bsdi__
 #include <vm/swap_pager.h>
 #else
-#if __FreeBSD_version < 400005
+#if defined(__FreeBSD_version) && __FreeBSD_version < 400005
 #include <sys/rlist.h>
 #endif
 #endif
@@ -52,7 +52,7 @@
 	{ "_swapstats" }, /* general swap info */
 	{ 0 }
 };
-#elif __FreeBSD__ < 4
+#elif defined(__FreeBSD__) && __FreeBSD__ < 4
 static struct nlist nlst [] = {
 #define VM_SWAPLIST	0
 	{ "_swaplist" },/* list of free swap areas */
@@ -94,8 +94,8 @@
 void
 glibtop_init_swap_p (glibtop *server)
 {
-#if defined(__FreeBSD__) || defined(__bsdi__)
-#if __FreeBSD__ < 4 || defined(__bsdi__)
+#if defined(__FreeBSD__) || defined(__bsdi__) || defined(__FreeBSD_kernel__)
+#if (defined(__FreeBSD__) && __FreeBSD__ < 4) || defined(__bsdi__)
 	if (kvm_nlist (server->machine.kd, nlst) < 0) {
 		glibtop_warn_io_r (server, "kvm_nlist (swap)");
 		return;
@@ -130,9 +130,9 @@
 void
 glibtop_get_swap_p (glibtop *server, glibtop_swap *buf)
 {
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 
-# if __FreeBSD__ < 4
+# if defined(__FreeBSD__) && __FreeBSD__ < 4
 	char *header;
 	int hlen, nswdev, dmmax;
 	int div, nfree, npfree;
@@ -194,7 +194,7 @@
 		buf->pagein = 0;
 		buf->pageout = 0;
 	} else {
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 		buf->pagein = vmm.v_swappgsin - swappgsin;
 		buf->pageout = vmm.v_swappgsout - swappgsout;
 #else
@@ -208,7 +208,7 @@
 #endif
 	}
 
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
         swappgsin = vmm.v_swappgsin;
 	swappgsout = vmm.v_swappgsout;
 #else
@@ -221,9 +221,9 @@
 #endif
 #endif
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 
-#if __FreeBSD__ < 4
+#if defined(__FreeBSD__) && __FreeBSD__ < 4
 
 	/* Size of largest swap device. */
 
diff -Nur libgtop-2.13.3.old/sysdeps/linux/Makefile.am libgtop-2.13.3/sysdeps/linux/Makefile.am
--- libgtop-2.13.3.old/sysdeps/linux/Makefile.am	2005-06-15 00:21:06.000000000 +0200
+++ libgtop-2.13.3/sysdeps/linux/Makefile.am	2006-02-16 15:39:25.000000000 +0100
@@ -7,7 +7,7 @@
 				  sem_limits.c proclist.c procstate.c procuid.c \
 				  proctime.c procmem.c procsignal.c prockernel.c \
 				  procsegment.c procargs.c procmap.c siglist.c \
-				  sysinfo.c netload.c ppp.c glibtop_private.c \
+				  netload.c ppp.c glibtop_private.c \
 				  fsusage.c netlist.c procopenfiles.c
 
 libgtop_sysdeps_2_0_la_LIBADD	=  @GLIB_LIBS@
diff -Nur libgtop-2.13.3.old/sysdeps/linux/glibtop_private.c libgtop-2.13.3/sysdeps/linux/glibtop_private.c
--- libgtop-2.13.3.old/sysdeps/linux/glibtop_private.c	2005-12-12 11:09:39.000000000 +0100
+++ libgtop-2.13.3/sysdeps/linux/glibtop_private.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,165 +0,0 @@
-#include <config.h>
-#include <glibtop.h>
-#include <glibtop/error.h>
-
-#include "glibtop_private.h"
-
-#include <glib.h>
-
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-
-#include <fcntl.h>
-#include <unistd.h>
-
-
-unsigned long long
-get_scaled(const char *buffer, const char *key)
-{
-	const char    *ptr;
-	char	      *next;
-	unsigned long long value = 0;
-
-	if (G_LIKELY((ptr = strstr(buffer, key))))
-	{
-		ptr += strlen(key);
-		value = strtoull(ptr, &next, 0);
-		if (strchr(next, 'k'))
-			value *= 1024;
-		else if (strchr(next, 'M'))
-			value *= 1024 * 1024;
-	} else
-		g_warning("Could not read key '%s' in buffer '%s'",
-			  key, buffer);
-
-	return value;
-}
-
-
-char *
-skip_token (const char *p)
-{
-	p = next_token(p);
-	while (*p && !isspace(*p)) p++;
-	p = next_token(p);
-	return (char *)p;
-}
-
-
-/*
- * Read functions
- */
-enum TRY_FILE_TO_BUFFER
-{
-	TRY_FILE_TO_BUFFER_OK = 0,
-	TRY_FILE_TO_BUFFER_OPEN = -1,
-	TRY_FILE_TO_BUFFER_READ = -2
-};
-
-int try_file_to_buffer(char *buffer, const char *format, ...)
-{
-	char path[4096];
-	int fd;
-	ssize_t len;
-	va_list pa;
-
-	va_start(pa, format);
-
-	/* C99 also provides vsnprintf */
-	g_vsnprintf(path, sizeof path, format, pa);
-
-	va_end(pa);
-
-	buffer [0] = '\0';
-
-	if((fd = open (path, O_RDONLY)) < 0)
-		return TRY_FILE_TO_BUFFER_OPEN;
-
-	len = read (fd, buffer, BUFSIZ-1);
-	close (fd);
-
-	if (len < 0)
-		return TRY_FILE_TO_BUFFER_READ;
-
-	buffer [len] = '\0';
-
-	return TRY_FILE_TO_BUFFER_OK;
-}
-
-
-void
-file_to_buffer(glibtop *server, char *buffer, const char *filename)
-{
-	switch(try_file_to_buffer(buffer, filename))
-	{
-	case TRY_FILE_TO_BUFFER_OPEN:
-		glibtop_error_io_r (server, "open (%s)", filename);
-	case TRY_FILE_TO_BUFFER_READ:
-		glibtop_error_io_r (server, "read (%s)", filename);
-	}
-}
-
-
-
-
-static unsigned long
-read_boot_time(glibtop *server)
-{
-	char buffer[BUFSIZ];
-	char *btime;
-
-	file_to_buffer(server, buffer, "/proc/stat");
-
-	btime = strstr(buffer, "btime");
-
-	if (!btime) {
-		glibtop_warn_io_r(server, "cannot find btime in /proc/stat");
-		return 0UL;
-	}
-
-	btime = skip_token(btime);
-	return strtoul(btime, NULL, 10);
-}
-
-
-
-unsigned long
-get_boot_time(glibtop *server)
-{
-	static unsigned long boot_time = 0UL;
-
-	if(G_UNLIKELY(!boot_time))
-	{
-		boot_time = read_boot_time(server);
-	}
-
-	return boot_time;
-}
-
-
-size_t
-get_page_size(void)
-{
-	static size_t pagesize = 0;
-
-	if(G_UNLIKELY(!pagesize))
-	{
-		pagesize = getpagesize();
-	}
-
-	return pagesize;
-}
-
-
-
-gboolean
-check_cpu_line(glibtop *server, const char *line, unsigned i)
-{
-	char start[10];
-
-	g_snprintf(start, sizeof start, "cpu%u", i);
-
-	return g_str_has_prefix(line, start);
-}
-
diff -Nur libgtop-2.13.3.old/sysdeps/linux/glibtop_private.h libgtop-2.13.3/sysdeps/linux/glibtop_private.h
--- libgtop-2.13.3.old/sysdeps/linux/glibtop_private.h	2005-12-10 10:18:24.000000000 +0100
+++ libgtop-2.13.3/sysdeps/linux/glibtop_private.h	2006-02-16 16:13:21.000000000 +0100
@@ -20,128 +20,10 @@
 #ifndef __LINUX__GLIBTOP_PRIVATE_H__
 #define __LINUX__GLIBTOP_PRIVATE_H__
 
-#include <glibtop.h>
-#include <glibtop/error.h>
-
-#include <glib.h>
-
-#include <fcntl.h>
-#include <ctype.h>
-#include <string.h>
-
 G_BEGIN_DECLS
 
 #define LINUX_VERSION_CODE(x,y,z)   (0x10000*(x) + 0x100*(y) + z)
 
-
-static inline char*
-next_token(const char *p)
-{
-	while (isspace(*p)) p++;
-	return (char*) p;
-}
-
-char *
-skip_token (const char *p) G_GNUC_INTERNAL;
-
-static inline char *
-skip_multiple_token (const char *p, size_t count)
-{
-	while(count--)
-		p = skip_token (p);
-
-	return (char *)p;
-}
-
-
-static inline char *
-skip_line (const char *p)
-{
-	while (*p && *p != '\n') p++;
-	return (char *) (*p ? p+1 : p);
-}
-
-
-unsigned long long
-get_scaled(const char *buffer, const char *key) G_GNUC_INTERNAL;
-
-
-/* aborts on error */
-void G_GNUC_INTERNAL
-file_to_buffer(glibtop *server, char *buffer, const char *filename);
-
-/* return < 0 on error, otherwise 0 on success */
-int G_GNUC_INTERNAL
-try_file_to_buffer(char *buffer, const char *format, ...) G_GNUC_PRINTF(2, 3);
-
-
-/* some inline functions that wrap proc path
- * as fast as macros :)
- */
-
-static inline int
-proc_file_to_buffer (char *buffer, const char *fmt, pid_t pid)
-{
-	return try_file_to_buffer(buffer, fmt, pid);
-}
-
-static inline int
-proc_stat_to_buffer (char *buffer, pid_t pid)
-{
-	return proc_file_to_buffer (buffer, "/proc/%d/stat", pid);
-}
-
-static inline int
-proc_status_to_buffer (char *buffer, pid_t pid)
-{
-	return proc_file_to_buffer (buffer, "/proc/%d/status", pid);
-}
-
-static inline int
-proc_statm_to_buffer (char *buffer, pid_t pid)
-{
-	return proc_file_to_buffer (buffer, "/proc/%d/statm", pid);
-}
-
-
-static inline char *
-proc_stat_after_cmd (char *p)
-{
-	p = strrchr (p, ')');
-	if (G_LIKELY(p))
-		*p++ = '\0';
-	return p;
-}
-
-
-unsigned long
-get_boot_time(glibtop *server) G_GNUC_INTERNAL;
-
-
-size_t
-get_page_size(void) G_GNUC_INTERNAL;
-
-
-gboolean
-check_cpu_line(glibtop *server, const char *line, unsigned n) G_GNUC_INTERNAL;
-
-
-static inline gboolean
-check_cpu_line_warn(glibtop *server, const char *line, unsigned i)
-{
-	gboolean ret;
-
-	ret = check_cpu_line(server, line, i);
-
-	if (G_UNLIKELY(!ret))
-		glibtop_warn_io_r(server,
-				  "'%s' does not start with 'cpu%u'",
-				  line, i);
-
-	return ret;
-}
-
-
 G_END_DECLS
 
 #endif /* __LINUX__GLIBTOP_PRIVATE_H__ */
diff -Nur libgtop-2.13.3.old/sysdeps/linux/sysinfo.c libgtop-2.13.3/sysdeps/linux/sysinfo.c
--- libgtop-2.13.3.old/sysdeps/linux/sysinfo.c	2004-11-28 02:32:55.000000000 +0100
+++ libgtop-2.13.3/sysdeps/linux/sysinfo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-/* $Id: sysinfo.c,v 1.22 2004/11/28 01:32:55 bdejean Exp $ */
-
-/* Copyright (C) 1998-99 Martin Baulig
-   This file is part of LibGTop 1.0.
-
-   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
-
-   LibGTop is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License,
-   or (at your option) any later version.
-
-   LibGTop is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with LibGTop; see the file COPYING. If not, write to the
-   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.
-*/
-
-#include <config.h>
-#include <glibtop/error.h>
-#include <glibtop/cpu.h>
-#include <glibtop/sysinfo.h>
-
-#include "glibtop_private.h"
-
-#define FILENAME "/proc/cpuinfo"
-
-static const unsigned long _glibtop_sysdeps_sysinfo =
-(1L << GLIBTOP_SYSINFO_CPUINFO);
-
-static glibtop_sysinfo sysinfo = { .flags = 0 };
-
-static void
-init_sysinfo (glibtop *server)
-{
-	char buffer [BUFSIZ];
-	gchar ** processors;
-
-	if(G_LIKELY(sysinfo.flags)) return;
-
-	glibtop_init_s (&server, GLIBTOP_SYSDEPS_CPU, 0);
-
-	file_to_buffer(server, buffer, FILENAME);
-
-	/* cpuinfo records are seperated by a blank line */
-	processors = g_strsplit(buffer, "\n\n", 0);
-
-	for(sysinfo.ncpu = 0;
-	    sysinfo.ncpu < GLIBTOP_NCPU && processors[sysinfo.ncpu] && *processors[sysinfo.ncpu];
-	    sysinfo.ncpu++) {
-
-		gchar **parts, **p;
-
-		glibtop_entry * const cpuinfo = &sysinfo.cpuinfo[sysinfo.ncpu];
-
-		cpuinfo->labels = g_ptr_array_new ();
-
-		cpuinfo->values = g_hash_table_new_full(g_str_hash, g_str_equal,
-							g_free, g_free);
-
-		cpuinfo->descriptions = g_hash_table_new_full(g_str_hash, g_str_equal,
-							g_free, g_free);
-
-		/* "<key>    : <value>" */
-		parts = g_strsplit_set(processors[sysinfo.ncpu], ":\n", 0);
-
-		for(p = parts; *p && *(p+1); p += 2) {
-
-			/* stole the allocated memory */
-			gchar * const key   = g_strstrip(   *p   );
-			gchar * const value = g_strstrip( *(p+1) );
-
-			g_ptr_array_add(cpuinfo->labels, key);
-			g_hash_table_insert(cpuinfo->values, key, value);
-		}
-
-
-		/* the last key has no value and has not been added */
-		if(*p) g_free(*p);
-
-		/* just g_free instead of g_strvfree because we stole
-		   the memory*/
-
-		g_free(parts);
-
-	}
-
-	g_strfreev(processors);
-
-	sysinfo.flags = _glibtop_sysdeps_sysinfo;
-}
-
-const glibtop_sysinfo *
-glibtop_get_sysinfo_s (glibtop *server)
-{
-	init_sysinfo (server);
-	return &sysinfo;
-}
