Author: aurel32
Status: in work

diff -u glibc-2.3.5/debian/control glibc-2.3.5/debian/control
--- glibc-2.3.5/debian/control
+++ glibc-2.3.5/debian/control
@@ -1,7 +1,7 @@
 Source: glibc
 Section: libs
 Priority: required
-Build-Depends: gettext (>= 0.10.37-1), make (>= 3.80-1), dpkg-dev (>= 1.13.5), debianutils (>= 1.13.1), tar (>= 1.13.11), bzip2, texinfo (>= 4.0), linux-kernel-headers (>= 2.5.999-test7-bk-9) [!hurd-i386], mig (>= 1.3-2) [hurd-i386], hurd-dev (>= 20020608-1) [hurd-i386], gnumach-dev [hurd-i386], texi2html, file, gcc-4.0 [!powerpc !m68k !hppa], gcc-4.0 (>= 4.0.1-5) [hppa], gcc-3.4 (>= 3.4.4-6) [powerpc], gcc-3.4 [m68k], autoconf, binutils (>= 2.14.90.0.7-5), sed (>= 4.0.5-4), gawk, debhelper (>= 4.1.76)
+Build-Depends: gettext (>= 0.10.37-1), make (>= 3.80-1), dpkg-dev (>= 1.13.5), debianutils (>= 1.13.1), tar (>= 1.13.11), bzip2, texinfo (>= 4.0), linux-kernel-headers (>= 2.5.999-test7-bk-9) [!hurd-i386 !kfreebsd-i386], mig (>= 1.3-2) [hurd-i386], hurd-dev (>= 20020608-1) [hurd-i386], gnumach-dev [hurd-i386], kfreebsd-kernel-headers (>= 0.01), texi2html, file, gcc-4.0 [!powerpc !m68k !hppa], gcc-4.0 (>= 4.0.1-5) [hppa], gcc-3.4 (>= 3.4.4-6) [powerpc], gcc-3.4 [m68k], autoconf, binutils (>= 2.14.90.0.7-5), sed (>= 4.0.5-4), gawk, debhelper (>= 4.1.76)
 Build-Depends-Indep: perl, po-debconf
 Maintainer: GNU Libc Maintainers <debian-glibc@lists.debian.org>
 Uploaders: Ben Collins <bcollins@debian.org>, GOTO Masanori <gotom@debian.org>, Philip Blundell <pb@nexus.co.uk>, Jeff Bailey <jbailey@raspberryginger.com>, Daniel Jacobowitz <dan@debian.org>
@@ -26,7 +26,7 @@
 Provides: i18ndata
 Depends: ${locale:Depends}, debconf (>= 0.2.26)
 Conflicts: localebin, wg15-locale, i18ndata, locale-ja, locale-ko, locale-vi, locale-zh
-Replaces: localebin, wg15-locale, libc6-bin, i18ndata, glibc2, locale-ja, locale-ko, locale-vi, locale-zh
+Replaces: localebin, wg15-locale, libc0.1-bin, i18ndata, glibc2, locale-ja, locale-ko, locale-vi, locale-zh
 Description: GNU C Library: National Language (locale) data [support]
  Machine-readable data files, shared objects and programs used by the
  C library for localization (l10n) and internationalization (i18n) support.
@@ -38,11 +38,11 @@
  by default. This created a package that unpacked to an excess of 30 megs.
 
 Package: nscd
-Architecture: alpha amd64 arm i386 m68k mips mipsel powerpc sparc ia64 hppa s390 sh3 sh4 sh3eb sh4eb freebsd-i386
+Architecture: alpha amd64 arm i386 m68k mips mipsel powerpc sparc ia64 hppa s390 sh3 sh4 sh3eb sh4eb kfreebsd-i386
 Section: admin
 Priority: optional
-Depends: libc6 (>= ${Source-Version})
-Replaces: libc6 (<< 2.1-4)
+Depends: libc0.1 (>= ${Source-Version})
+Replaces: libc0.1 (<< 2.1-4)
 Description: GNU C Library: Name Service Cache Daemon
  A daemon which handles passwd, group and host lookups
  for running programs and caches the results for the next
@@ -265,8 +265,8 @@
  This package contains a minimal set of libraries needed for the Debian
  installer.  Do not install it on a normal system.
 
-Package: libc1
-Architecture: freebsd-i386
+Package: libc0.1
+Architecture: kfreebsd-i386
 Section: base
 Priority: required
 Provides: ${locale:Depends}
@@ -276,22 +276,22 @@
  and the standard math library, as well as many others.
  Timezone data is also included.
 
-Package: libc1-dev
-Architecture: freebsd-i386
+Package: libc0.1-dev
+Architecture: kfreebsd-i386
 Section: libdevel
 Priority: standard
-Depends: libc1 (= ${Source-Version})
+Depends: libc0.1 (= ${Source-Version})
 Recommends: gcc | c-compiler
 Description: GNU C Library: Development Libraries and Header Files
  Contains the symlinks, headers, and object files needed to compile
  and link programs which use the standard C library.
 
-Package: libc1-dbg
-Architecture: freebsd-i386
+Package: libc0.1-dbg
+Architecture: kfreebsd-i386
 Section: libdevel
 Priority: extra
 Provides: libc-dbg
-Depends: libc1 (= ${Source-Version})
+Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: Libraries with debugging symbols
  Contains unstripped shared libraries.
  This package is provided primarily to provide a backtrace with
@@ -300,22 +300,22 @@
  used by placing that directory in LD_LIBRARY_PATH.
  Most people will not need this package.
 
-Package: libc1-prof
-Architecture: freebsd-i386
+Package: libc0.1-prof
+Architecture: kfreebsd-i386
 Section: libdevel
 Priority: extra
-Depends: libc1 (= ${Source-Version})
+Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: Profiling Libraries
  Static libraries compiled with profiling info (-pg) suitable for use
  with gprof.
 
-Package: libc1-pic
-Architecture: freebsd-i386
+Package: libc0.1-pic
+Architecture: kfreebsd-i386
 Section: libdevel
 Priority: optional
 Conflicts: libc-pic
 Provides: libc-pic, glibc-pic
-Depends: libc1 (= ${Source-Version})
+Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: PIC archive library
  Contains an archive library (ar file) composed of individual shared objects.
  This is used for creating a library which is a smaller subset of the
@@ -323,12 +323,13 @@
  boot floppies. If you are not making your own set of Debian boot floppies
  using the `boot-floppies' package, you probably don't need this package.
 
-Package: libc1-udeb
+Package: libc0.1-udeb
 XC-Package-Type: udeb
-Architecture: freebsd-i386
+Architecture: kfreebsd-i386
 Section: debian-installer
 Priority: extra
-Provides: libc1, libc-udeb, ${locale:Depends}
+Provides: libc0.1, libc-udeb, ${locale:Depends}
+Depends: libnss-dns-udeb, libnss-files-udeb
 Description: GNU C Library: Shared libraries - udeb
  Contains the standard libraries that are used by nearly all programs on
  the system. This package includes shared versions of the standard C library
@@ -404,7 +405,7 @@
 Architecture: sparc
 Section: libs
 Priority: extra
-Pre-Depends: libc6 (= ${Source-Version})
+Pre-Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: Shared libraries [v9 optimized]
  Contains the standard libraries that are used by nearly all programs on
  the system. This package includes shared versions of the standard C
@@ -422,7 +423,7 @@
 Architecture: sparc
 Section: libs
 Priority: extra
-Pre-Depends: libc6 (= ${Source-Version})
+Pre-Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: Shared libraries [v9b optimized]
  Contains the standard libraries that are used by nearly all programs on
  the system. This package includes shared versions of the standard C
@@ -440,7 +441,7 @@
 Architecture: i386
 Section: libs
 Priority: extra
-Pre-Depends: libc6 (= ${Source-Version})
+Pre-Depends: libc0.1 (= ${Source-Version})
 Description: GNU C Library: Shared libraries [i686 optimized]
  Contains the standard libraries that are used by nearly all programs on
  the system. This package includes shared versions of the standard C
diff -u glibc-2.3.5/debian/control.in/main glibc-2.3.5/debian/control.in/main
--- glibc-2.3.5/debian/control.in/main
+++ glibc-2.3.5/debian/control.in/main
@@ -1,7 +1,7 @@
 Source: @glibc@
 Section: libs
 Priority: required
-Build-Depends: gettext (>= 0.10.37-1), make (>= 3.80-1), dpkg-dev (>= 1.13.5), debianutils (>= 1.13.1), tar (>= 1.13.11), bzip2, texinfo (>= 4.0), linux-kernel-headers (>= 2.5.999-test7-bk-9) [!hurd-i386], mig (>= 1.3-2) [hurd-i386], hurd-dev (>= 20020608-1) [hurd-i386], gnumach-dev [hurd-i386], texi2html, file, gcc-4.0 [!powerpc !m68k !hppa], gcc-4.0 (>= 4.0.1-5) [hppa], gcc-3.4 (>= 3.4.4-6) [powerpc], gcc-3.4 [m68k], autoconf, binutils (>= 2.14.90.0.7-5), sed (>= 4.0.5-4), gawk, debhelper (>= 4.1.76)
+Build-Depends: gettext (>= 0.10.37-1), make (>= 3.80-1), dpkg-dev (>= 1.13.5), debianutils (>= 1.13.1), tar (>= 1.13.11), bzip2, texinfo (>= 4.0), linux-kernel-headers (>= 2.5.999-test7-bk-9) [!hurd-i386 !kfreebsd-i386], mig (>= 1.3-2) [hurd-i386], hurd-dev (>= 20020608-1) [hurd-i386], gnumach-dev [hurd-i386], kfreebsd-kernel-headers (>= 0.01), texi2html, file, gcc-4.0 [!powerpc !m68k !hppa], gcc-4.0 (>= 4.0.1-5) [hppa], gcc-3.4 (>= 3.4.4-6) [powerpc], gcc-3.4 [m68k], autoconf, binutils (>= 2.14.90.0.7-5), sed (>= 4.0.5-4), gawk, debhelper (>= 4.1.76)
 Build-Depends-Indep: perl, po-debconf
 Maintainer: GNU Libc Maintainers <debian-glibc@lists.debian.org>
 Uploaders: Ben Collins <bcollins@debian.org>, GOTO Masanori <gotom@debian.org>, Philip Blundell <pb@nexus.co.uk>, Jeff Bailey <jbailey@raspberryginger.com>, Daniel Jacobowitz <dan@debian.org>
diff -u glibc-2.3.5/debian/patches/00list glibc-2.3.5/debian/patches/00list
--- glibc-2.3.5/debian/patches/00list
+++ glibc-2.3.5/debian/patches/00list
@@ -83,0 +84,4 @@
+kfreebsd-sysdeps
+kfreebsd-scripts
+kfreebsd-fixes
+kfreebsd-ugly-hacks
--- glibc-2.3.5/debian/sysdeps/kfreebsd-gnu.mk
+++ glibc-2.3.5.orig/debian/sysdeps/kfreebsd-gnu.mk
@@ -1,13 +0,0 @@
-# This is for a Glibc-using FreeBSD system.
-
-# FIXME: Have to do both nptl and linuxthreads for now, because of the
-# patch system.  Should be only linuxthreads.
-GLIBC_OVERLAYS ?= $(shell ls nptl* glibc-linuxthreads* glibc-ports* glibc-libidn*)
-
-libc = libc1
-
-# Linuxthreads Config
-threads = yes
-libc_add-ons = linuxthreads $(add-ons)
-
-extra_config_options = $(extra_config_options) --disable-compatible-utmp --enable-kernel-include=4.6
diff -u glibc-2.3.5/debian/sysdeps/linux.mk glibc-2.3.5/debian/sysdeps/linux.mk
--- glibc-2.3.5/debian/sysdeps/linux.mk
+++ glibc-2.3.5/debian/sysdeps/linux.mk
@@ -34,7 +34,7 @@
 nptl_MIN_KERNEL_SUPPORTED = 2.6.0
 nptl_LIBDIR = /tls
 
-LINUX_HEADER_DIR = $(stamp)mkincludedir
+KERNEL_HEADER_DIR = $(stamp)mkincludedir
 $(stamp)mkincludedir:
 	rm -rf debian/include
 	mkdir debian/include
diff -u glibc-2.3.5/debian/rules.d/build.mk glibc-2.3.5/debian/rules.d/build.mk
--- glibc-2.3.5/debian/rules.d/build.mk
+++ glibc-2.3.5/debian/rules.d/build.mk
@@ -4,7 +4,7 @@
 xx=$(if $($(curpass)_$(1)),$($(curpass)_$(1)),$($(1)))
 
 $(patsubst %,mkbuilddir_%,$(GLIBC_PASSES)) :: mkbuilddir_% : $(stamp)mkbuilddir_%
-$(stamp)mkbuilddir_%: $(stamp)patch-stamp $(LINUX_HEADER_DIR)
+$(stamp)mkbuilddir_%: $(stamp)patch-stamp $(KERNEL_HEADER_DIR)
 	@echo Making builddir for $(curpass)
 	test -d $(DEB_BUILDDIR) || mkdir $(DEB_BUILDDIR)
 	touch $@
diff -u glibc-2.3.5/debian/rules.d/control.mk glibc-2.3.5/debian/rules.d/control.mk
--- glibc-2.3.5/debian/rules.d/control.mk
+++ glibc-2.3.5/debian/rules.d/control.mk
@@ -1,6 +1,6 @@
-control_deps := $(addprefix debian/control.in/, libc6 libc6.1 libc0.3 libc1 sparc64 s390x ppc64 opt)
+control_deps := $(addprefix debian/control.in/, libc6 libc6.1 libc0.3 libc0.1 sparc64 s390x ppc64 opt)
 
-threads_archs := alpha amd64 arm i386 m68k mips mipsel powerpc sparc ia64 hppa s390 sh3 sh4 sh3eb sh4eb freebsd-i386
+threads_archs := alpha amd64 arm i386 m68k mips mipsel powerpc sparc ia64 hppa s390 sh3 sh4 sh3eb sh4eb kfreebsd-i386
 
 debian/control.in/libc6: debian/control.in/libc debian/rules.d/control.mk
 	sed -e 's%@libc@%libc6%g' \
@@ -12,8 +12,8 @@
 debian/control.in/libc0.3: debian/control.in/libc debian/rules.d/control.mk
 	sed -e 's%@libc@%libc0.3%g;s%@archs@%hurd-i386%g;s/nscd, //' < $< > $@
 
-debian/control.in/libc1: debian/control.in/libc debian/rules.d/control.mk
-	sed -e 's%@libc@%libc1%g;s%@archs@%freebsd-i386%g' < $< > $@
+debian/control.in/libc0.1: debian/control.in/libc debian/rules.d/control.mk
+	sed -e 's%@libc@%libc0.1%g;s%@archs@%kfreebsd-i386%g' < $< > $@
 
 debian/control: debian/control.in/main $(control_deps) \
 		   debian/rules.d/control.mk # debian/sysdeps/depflags.pl
@@ -21,7 +21,7 @@
 	cat debian/control.in/libc6		>> $@T
 	cat debian/control.in/libc6.1		>> $@T
 	cat debian/control.in/libc0.3		>> $@T
-	cat debian/control.in/libc1		>> $@T
+	cat debian/control.in/libc0.1		>> $@T
 	cat debian/control.in/sparc64		>> $@T
 	cat debian/control.in/s390x		>> $@T
 	cat debian/control.in/ppc64		>> $@T
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/control.in/libc6
+++ glibc-2.3.5/debian/control.in/libc6
@@ -0,0 +1,72 @@
+Package: libc6
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: base
+Priority: required
+Provides: ${locale:Depends}
+Description: GNU C Library: Shared libraries and Timezone data
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ Timezone data is also included.
+
+Package: libc6-dev
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: libdevel
+Priority: standard
+Depends: libc6 (= ${Source-Version})
+Recommends: gcc | c-compiler
+Description: GNU C Library: Development Libraries and Header Files
+ Contains the symlinks, headers, and object files needed to compile
+ and link programs which use the standard C library.
+
+Package: libc6-dbg
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: libdevel
+Priority: extra
+Provides: libc-dbg
+Depends: libc6 (= ${Source-Version})
+Description: GNU C Library: Libraries with debugging symbols
+ Contains unstripped shared libraries.
+ This package is provided primarily to provide a backtrace with
+ names in a debugger, this makes it somewhat easier to interpret core
+ dumps. The libraries are installed in /usr/lib/debug and can be
+ used by placing that directory in LD_LIBRARY_PATH.
+ Most people will not need this package.
+
+Package: libc6-prof
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: libdevel
+Priority: extra
+Depends: libc6 (= ${Source-Version})
+Description: GNU C Library: Profiling Libraries
+ Static libraries compiled with profiling info (-pg) suitable for use
+ with gprof.
+
+Package: libc6-pic
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: libdevel
+Priority: optional
+Conflicts: libc-pic
+Provides: libc-pic, glibc-pic
+Depends: libc6 (= ${Source-Version})
+Description: GNU C Library: PIC archive library
+ Contains an archive library (ar file) composed of individual shared objects.
+ This is used for creating a library which is a smaller subset of the
+ standard libc shared library. The reduced library is used on the Debian
+ boot floppies. If you are not making your own set of Debian boot floppies
+ using the `boot-floppies' package, you probably don't need this package.
+
+Package: libc6-udeb
+XC-Package-Type: udeb
+Architecture: amd64 arm i386 m68k mips mipsel powerpc sparc s390 hppa sh3 sh4 sh3eb sh4eb
+Section: debian-installer
+Priority: extra
+Provides: libc6, libc-udeb, ${locale:Depends}
+Description: GNU C Library: Shared libraries - udeb
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ .
+ This package contains a minimal set of libraries needed for the Debian
+ installer.  Do not install it on a normal system.
+
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/control.in/libc6.1
+++ glibc-2.3.5/debian/control.in/libc6.1
@@ -0,0 +1,72 @@
+Package: libc6.1
+Architecture: alpha ia64
+Section: base
+Priority: required
+Provides: ${locale:Depends}
+Description: GNU C Library: Shared libraries and Timezone data
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ Timezone data is also included.
+
+Package: libc6.1-dev
+Architecture: alpha ia64
+Section: libdevel
+Priority: standard
+Depends: libc6.1 (= ${Source-Version})
+Recommends: gcc | c-compiler
+Description: GNU C Library: Development Libraries and Header Files
+ Contains the symlinks, headers, and object files needed to compile
+ and link programs which use the standard C library.
+
+Package: libc6.1-dbg
+Architecture: alpha ia64
+Section: libdevel
+Priority: extra
+Provides: libc-dbg
+Depends: libc6.1 (= ${Source-Version})
+Description: GNU C Library: Libraries with debugging symbols
+ Contains unstripped shared libraries.
+ This package is provided primarily to provide a backtrace with
+ names in a debugger, this makes it somewhat easier to interpret core
+ dumps. The libraries are installed in /usr/lib/debug and can be
+ used by placing that directory in LD_LIBRARY_PATH.
+ Most people will not need this package.
+
+Package: libc6.1-prof
+Architecture: alpha ia64
+Section: libdevel
+Priority: extra
+Depends: libc6.1 (= ${Source-Version})
+Description: GNU C Library: Profiling Libraries
+ Static libraries compiled with profiling info (-pg) suitable for use
+ with gprof.
+
+Package: libc6.1-pic
+Architecture: alpha ia64
+Section: libdevel
+Priority: optional
+Conflicts: libc-pic
+Provides: libc-pic, glibc-pic
+Depends: libc6.1 (= ${Source-Version})
+Description: GNU C Library: PIC archive library
+ Contains an archive library (ar file) composed of individual shared objects.
+ This is used for creating a library which is a smaller subset of the
+ standard libc shared library. The reduced library is used on the Debian
+ boot floppies. If you are not making your own set of Debian boot floppies
+ using the `boot-floppies' package, you probably don't need this package.
+
+Package: libc6.1-udeb
+XC-Package-Type: udeb
+Architecture: alpha ia64
+Section: debian-installer
+Priority: extra
+Provides: libc6.1, libc-udeb, ${locale:Depends}
+Description: GNU C Library: Shared libraries - udeb
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ .
+ This package contains a minimal set of libraries needed for the Debian
+ installer.  Do not install it on a normal system.
+
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/control.in/libc0.1
+++ glibc-2.3.5/debian/control.in/libc0.1
@@ -0,0 +1,73 @@
+Package: libc0.1
+Architecture: kfreebsd-i386
+Section: base
+Priority: required
+Provides: ${locale:Depends}
+Description: GNU C Library: Shared libraries and Timezone data
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ Timezone data is also included.
+
+Package: libc0.1-dev
+Architecture: kfreebsd-i386
+Section: libdevel
+Priority: standard
+Depends: libc0.1 (= ${Source-Version})
+Recommends: gcc | c-compiler
+Description: GNU C Library: Development Libraries and Header Files
+ Contains the symlinks, headers, and object files needed to compile
+ and link programs which use the standard C library.
+
+Package: libc0.1-dbg
+Architecture: kfreebsd-i386
+Section: libdevel
+Priority: extra
+Provides: libc-dbg
+Depends: libc0.1 (= ${Source-Version})
+Description: GNU C Library: Libraries with debugging symbols
+ Contains unstripped shared libraries.
+ This package is provided primarily to provide a backtrace with
+ names in a debugger, this makes it somewhat easier to interpret core
+ dumps. The libraries are installed in /usr/lib/debug and can be
+ used by placing that directory in LD_LIBRARY_PATH.
+ Most people will not need this package.
+
+Package: libc0.1-prof
+Architecture: kfreebsd-i386
+Section: libdevel
+Priority: extra
+Depends: libc0.1 (= ${Source-Version})
+Description: GNU C Library: Profiling Libraries
+ Static libraries compiled with profiling info (-pg) suitable for use
+ with gprof.
+
+Package: libc0.1-pic
+Architecture: kfreebsd-i386
+Section: libdevel
+Priority: optional
+Conflicts: libc-pic
+Provides: libc-pic, glibc-pic
+Depends: libc0.1 (= ${Source-Version})
+Description: GNU C Library: PIC archive library
+ Contains an archive library (ar file) composed of individual shared objects.
+ This is used for creating a library which is a smaller subset of the
+ standard libc shared library. The reduced library is used on the Debian
+ boot floppies. If you are not making your own set of Debian boot floppies
+ using the `boot-floppies' package, you probably don't need this package.
+
+Package: libc0.1-udeb
+XC-Package-Type: udeb
+Architecture: kfreebsd-i386
+Section: debian-installer
+Priority: extra
+Provides: libc0.1, libc-udeb, ${locale:Depends}
+Depends: libnss-dns-udeb, libnss-files-udeb
+Description: GNU C Library: Shared libraries - udeb
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ .
+ This package contains a minimal set of libraries needed for the Debian
+ installer.  Do not install it on a normal system.
+
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/control.in/libc0.3
+++ glibc-2.3.5/debian/control.in/libc0.3
@@ -0,0 +1,72 @@
+Package: libc0.3
+Architecture: hurd-i386
+Section: base
+Priority: required
+Provides: ${locale:Depends}
+Description: GNU C Library: Shared libraries and Timezone data
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ Timezone data is also included.
+
+Package: libc0.3-dev
+Architecture: hurd-i386
+Section: libdevel
+Priority: standard
+Depends: libc0.3 (= ${Source-Version})
+Recommends: gcc | c-compiler
+Description: GNU C Library: Development Libraries and Header Files
+ Contains the symlinks, headers, and object files needed to compile
+ and link programs which use the standard C library.
+
+Package: libc0.3-dbg
+Architecture: hurd-i386
+Section: libdevel
+Priority: extra
+Provides: libc-dbg
+Depends: libc0.3 (= ${Source-Version})
+Description: GNU C Library: Libraries with debugging symbols
+ Contains unstripped shared libraries.
+ This package is provided primarily to provide a backtrace with
+ names in a debugger, this makes it somewhat easier to interpret core
+ dumps. The libraries are installed in /usr/lib/debug and can be
+ used by placing that directory in LD_LIBRARY_PATH.
+ Most people will not need this package.
+
+Package: libc0.3-prof
+Architecture: hurd-i386
+Section: libdevel
+Priority: extra
+Depends: libc0.3 (= ${Source-Version})
+Description: GNU C Library: Profiling Libraries
+ Static libraries compiled with profiling info (-pg) suitable for use
+ with gprof.
+
+Package: libc0.3-pic
+Architecture: hurd-i386
+Section: libdevel
+Priority: optional
+Conflicts: libc-pic
+Provides: libc-pic, glibc-pic
+Depends: libc0.3 (= ${Source-Version})
+Description: GNU C Library: PIC archive library
+ Contains an archive library (ar file) composed of individual shared objects.
+ This is used for creating a library which is a smaller subset of the
+ standard libc shared library. The reduced library is used on the Debian
+ boot floppies. If you are not making your own set of Debian boot floppies
+ using the `boot-floppies' package, you probably don't need this package.
+
+Package: libc0.3-udeb
+XC-Package-Type: udeb
+Architecture: hurd-i386
+Section: debian-installer
+Priority: extra
+Provides: libc0.3, libc-udeb, ${locale:Depends}
+Description: GNU C Library: Shared libraries - udeb
+ Contains the standard libraries that are used by nearly all programs on
+ the system. This package includes shared versions of the standard C library
+ and the standard math library, as well as many others.
+ .
+ This package contains a minimal set of libraries needed for the Debian
+ installer.  Do not install it on a normal system.
+
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/patches/kfreebsd-fixes.dpatch
+++ glibc-2.3.5/debian/patches/kfreebsd-fixes.dpatch
@@ -0,0 +1,709 @@
+#! /bin/sh -e
+
+# All lines beginning with `# DP:' are a description of the patch.
+# DP: Description: Fixes for GNU/kFreeBSD
+# DP: Related bugs: 
+# DP: Dpatch author: aurel32@debian.org
+# DP: Patch author: aurel32@debian.org
+# DP: Upstream status: Not submitted
+# DP: Status Details: 
+# DP: Date: 20050616
+
+if [ $# -ne 2 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+case "$1" in
+    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
+    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
+    *)
+	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+	exit 1
+esac
+exit 0
+# append the patch here and adjust the -p? flag in the patch calls.
+--- include/features.h.orig	2005-02-18 01:08:56.000000000 +0100
++++ include/features.h	2005-07-17 22:18:23.000000000 +0200
+@@ -288,6 +288,7 @@
+ 
+ /* Major and minor version number of the GNU C library package.  Use
+    these macros to test for features in specific releases.  */
++#undef __GLIBC__
+ #define	__GLIBC__	2
+ #define	__GLIBC_MINOR__	3
+ 
+--- misc/sys/queue.h.orig	1999-06-08 23:03:17.000000000 +0200
++++ misc/sys/queue.h	2005-04-28 22:29:17.000000000 +0200
+@@ -26,50 +26,296 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  *
+- *	@(#)queue.h	8.3 (Berkeley) 12/13/93
++ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
++ * $FreeBSD: src/sys/sys/queue.h,v 1.58 2004/04/07 04:19:49 imp Exp $
+  */
+ 
+-#ifndef	_SYS_QUEUE_H
+-#define	_SYS_QUEUE_H 1
++#ifndef _SYS_QUEUE_H_
++#define	_SYS_QUEUE_H_
++
++#include <sys/cdefs.h>
+ 
+ /*
+- * This file defines three types of data structures: lists, tail queues,
+- * and circular queues.
++ * This file defines four types of data structures: singly-linked lists,
++ * singly-linked tail queues, lists and tail queues.
++ *
++ * A singly-linked list is headed by a single forward pointer. The elements
++ * are singly linked for minimum space and pointer manipulation overhead at
++ * the expense of O(n) removal for arbitrary elements. New elements can be
++ * added to the list after an existing element or at the head of the list.
++ * Elements being removed from the head of the list should use the explicit
++ * macro for this purpose for optimum efficiency. A singly-linked list may
++ * only be traversed in the forward direction.  Singly-linked lists are ideal
++ * for applications with large datasets and few or no removals or for
++ * implementing a LIFO queue.
++ *
++ * A singly-linked tail queue is headed by a pair of pointers, one to the
++ * head of the list and the other to the tail of the list. The elements are
++ * singly linked for minimum space and pointer manipulation overhead at the
++ * expense of O(n) removal for arbitrary elements. New elements can be added
++ * to the list after an existing element, at the head of the list, or at the
++ * end of the list. Elements being removed from the head of the tail queue
++ * should use the explicit macro for this purpose for optimum efficiency.
++ * A singly-linked tail queue may only be traversed in the forward direction.
++ * Singly-linked tail queues are ideal for applications with large datasets
++ * and few or no removals or for implementing a FIFO queue.
+  *
+  * A list is headed by a single forward pointer (or an array of forward
+  * pointers for a hash table header). The elements are doubly linked
+  * so that an arbitrary element can be removed without a need to
+- * traverse the list. New elements can be added to the list after
+- * an existing element or at the head of the list. A list may only be
+- * traversed in the forward direction.
++ * traverse the list. New elements can be added to the list before
++ * or after an existing element or at the head of the list. A list
++ * may only be traversed in the forward direction.
+  *
+  * A tail queue is headed by a pair of pointers, one to the head of the
+  * list and the other to the tail of the list. The elements are doubly
+  * linked so that an arbitrary element can be removed without a need to
+- * traverse the list. New elements can be added to the list after
+- * an existing element, at the head of the list, or at the end of the
+- * list. A tail queue may only be traversed in the forward direction.
+- *
+- * A circle queue is headed by a pair of pointers, one to the head of the
+- * list and the other to the tail of the list. The elements are doubly
+- * linked so that an arbitrary element can be removed without a need to
+- * traverse the list. New elements can be added to the list before or after
+- * an existing element, at the head of the list, or at the end of the list.
+- * A circle queue may be traversed in either direction, but has a more
+- * complex end of list detection.
++ * traverse the list. New elements can be added to the list before or
++ * after an existing element, at the head of the list, or at the end of
++ * the list. A tail queue may be traversed in either direction.
+  *
+  * For details on the use of these macros, see the queue(3) manual page.
++ *
++ *
++ *				SLIST	LIST	STAILQ	TAILQ
++ * _HEAD			+	+	+	+
++ * _HEAD_INITIALIZER		+	+	+	+
++ * _ENTRY			+	+	+	+
++ * _INIT			+	+	+	+
++ * _EMPTY			+	+	+	+
++ * _FIRST			+	+	+	+
++ * _NEXT			+	+	+	+
++ * _PREV			-	-	-	+
++ * _LAST			-	-	+	+
++ * _FOREACH			+	+	+	+
++ * _FOREACH_SAFE		+	+	+	+
++ * _FOREACH_REVERSE		-	-	-	+
++ * _FOREACH_REVERSE_SAFE	-	-	-	+
++ * _INSERT_HEAD			+	+	+	+
++ * _INSERT_BEFORE		-	+	-	+
++ * _INSERT_AFTER		+	+	+	+
++ * _INSERT_TAIL			-	-	+	+
++ * _CONCAT			-	-	+	+
++ * _REMOVE_HEAD			+	-	+	-
++ * _REMOVE			+	+	+	+
++ *
+  */
++#define	QUEUE_MACRO_DEBUG 0
++#if QUEUE_MACRO_DEBUG
++/* Store the last 2 places the queue element or head was altered */
++struct qm_trace {
++	char * lastfile;
++	int lastline;
++	char * prevfile;
++	int prevline;
++};
++
++#define	TRACEBUF	struct qm_trace trace;
++#define	TRASHIT(x)	do {(x) = (void *)-1;} while (0)
++
++#define	QMD_TRACE_HEAD(head) do {					\
++	(head)->trace.prevline = (head)->trace.lastline;		\
++	(head)->trace.prevfile = (head)->trace.lastfile;		\
++	(head)->trace.lastline = __LINE__;				\
++	(head)->trace.lastfile = __FILE__;				\
++} while (0)
++
++#define	QMD_TRACE_ELEM(elem) do {					\
++	(elem)->trace.prevline = (elem)->trace.lastline;		\
++	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
++	(elem)->trace.lastline = __LINE__;				\
++	(elem)->trace.lastfile = __FILE__;				\
++} while (0)
++
++#else
++#define	QMD_TRACE_ELEM(elem)
++#define	QMD_TRACE_HEAD(head)
++#define	TRACEBUF
++#define	TRASHIT(x)
++#endif	/* QUEUE_MACRO_DEBUG */
+ 
+ /*
+- * List definitions.
++ * Singly-linked List declarations.
+  */
+-#define LIST_HEAD(name, type)						\
++#define	SLIST_HEAD(name, type)						\
++struct name {								\
++	struct type *slh_first;	/* first element */			\
++}
++
++#define	SLIST_HEAD_INITIALIZER(head)					\
++	{ NULL }
++
++#define	SLIST_ENTRY(type)						\
++struct {								\
++	struct type *sle_next;	/* next element */			\
++}
++
++/*
++ * Singly-linked List functions.
++ */
++#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
++
++#define	SLIST_FIRST(head)	((head)->slh_first)
++
++#define	SLIST_FOREACH(var, head, field)					\
++	for ((var) = SLIST_FIRST((head));				\
++	    (var);							\
++	    (var) = SLIST_NEXT((var), field))
++
++#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
++	for ((var) = SLIST_FIRST((head));				\
++	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
++	    (var) = (tvar))
++
++#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
++	for ((varp) = &SLIST_FIRST((head));				\
++	    ((var) = *(varp)) != NULL;					\
++	    (varp) = &SLIST_NEXT((var), field))
++
++#define	SLIST_INIT(head) do {						\
++	SLIST_FIRST((head)) = NULL;					\
++} while (0)
++
++#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
++	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
++	SLIST_NEXT((slistelm), field) = (elm);				\
++} while (0)
++
++#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
++	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
++	SLIST_FIRST((head)) = (elm);					\
++} while (0)
++
++#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
++
++#define	SLIST_REMOVE(head, elm, type, field) do {			\
++	if (SLIST_FIRST((head)) == (elm)) {				\
++		SLIST_REMOVE_HEAD((head), field);			\
++	}								\
++	else {								\
++		struct type *curelm = SLIST_FIRST((head));		\
++		while (SLIST_NEXT(curelm, field) != (elm))		\
++			curelm = SLIST_NEXT(curelm, field);		\
++		SLIST_NEXT(curelm, field) =				\
++		    SLIST_NEXT(SLIST_NEXT(curelm, field), field);	\
++	}								\
++} while (0)
++
++#define	SLIST_REMOVE_HEAD(head, field) do {				\
++	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
++} while (0)
++
++/*
++ * Singly-linked Tail queue declarations.
++ */
++#define	STAILQ_HEAD(name, type)						\
++struct name {								\
++	struct type *stqh_first;/* first element */			\
++	struct type **stqh_last;/* addr of last next element */		\
++}
++
++#define	STAILQ_HEAD_INITIALIZER(head)					\
++	{ NULL, &(head).stqh_first }
++
++#define	STAILQ_ENTRY(type)						\
++struct {								\
++	struct type *stqe_next;	/* next element */			\
++}
++
++/*
++ * Singly-linked Tail queue functions.
++ */
++#define	STAILQ_CONCAT(head1, head2) do {				\
++	if (!STAILQ_EMPTY((head2))) {					\
++		*(head1)->stqh_last = (head2)->stqh_first;		\
++		(head1)->stqh_last = (head2)->stqh_last;		\
++		STAILQ_INIT((head2));					\
++	}								\
++} while (0)
++
++#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
++
++#define	STAILQ_FIRST(head)	((head)->stqh_first)
++
++#define	STAILQ_FOREACH(var, head, field)				\
++	for((var) = STAILQ_FIRST((head));				\
++	   (var);							\
++	   (var) = STAILQ_NEXT((var), field))
++
++
++#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
++	for ((var) = STAILQ_FIRST((head));				\
++	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
++	    (var) = (tvar))
++
++#define	STAILQ_INIT(head) do {						\
++	STAILQ_FIRST((head)) = NULL;					\
++	(head)->stqh_last = &STAILQ_FIRST((head));			\
++} while (0)
++
++#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
++	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
++		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
++	STAILQ_NEXT((tqelm), field) = (elm);				\
++} while (0)
++
++#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
++	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
++		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
++	STAILQ_FIRST((head)) = (elm);					\
++} while (0)
++
++#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
++	STAILQ_NEXT((elm), field) = NULL;				\
++	*(head)->stqh_last = (elm);					\
++	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
++} while (0)
++
++#define	STAILQ_LAST(head, type, field)					\
++	(STAILQ_EMPTY((head)) ?						\
++		NULL :							\
++	        ((struct type *)					\
++		((char *)((head)->stqh_last) - __offsetof(struct type, field))))
++
++#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
++
++#define	STAILQ_REMOVE(head, elm, type, field) do {			\
++	if (STAILQ_FIRST((head)) == (elm)) {				\
++		STAILQ_REMOVE_HEAD((head), field);			\
++	}								\
++	else {								\
++		struct type *curelm = STAILQ_FIRST((head));		\
++		while (STAILQ_NEXT(curelm, field) != (elm))		\
++			curelm = STAILQ_NEXT(curelm, field);		\
++		if ((STAILQ_NEXT(curelm, field) =			\
++		     STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL)\
++			(head)->stqh_last = &STAILQ_NEXT((curelm), field);\
++	}								\
++} while (0)
++
++#define	STAILQ_REMOVE_HEAD(head, field) do {				\
++	if ((STAILQ_FIRST((head)) =					\
++	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
++		(head)->stqh_last = &STAILQ_FIRST((head));		\
++} while (0)
++
++#define	STAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {			\
++	if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)	\
++		(head)->stqh_last = &STAILQ_FIRST((head));		\
++} while (0)
++
++/*
++ * List declarations.
++ */
++#define	LIST_HEAD(name, type)						\
+ struct name {								\
+ 	struct type *lh_first;	/* first element */			\
+ }
+ 
+-#define LIST_ENTRY(type)						\
++#define	LIST_HEAD_INITIALIZER(head)					\
++	{ NULL }
++
++#define	LIST_ENTRY(type)						\
+ struct {								\
+ 	struct type *le_next;	/* next element */			\
+ 	struct type **le_prev;	/* address of previous next element */	\
+@@ -78,164 +324,230 @@
+ /*
+  * List functions.
+  */
+-#define	LIST_INIT(head) {						\
+-	(head)->lh_first = NULL;					\
+-}
+ 
+-#define LIST_INSERT_AFTER(listelm, elm, field) {			\
+-	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+-		(listelm)->field.le_next->field.le_prev =		\
+-		    &(elm)->field.le_next;				\
+-	(listelm)->field.le_next = (elm);				\
+-	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+-}
++#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+ 
+-#define LIST_INSERT_HEAD(head, elm, field) {				\
+-	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+-		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+-	(head)->lh_first = (elm);					\
+-	(elm)->field.le_prev = &(head)->lh_first;			\
+-}
++#define	LIST_FIRST(head)	((head)->lh_first)
+ 
+-#define LIST_REMOVE(elm, field) {					\
+-	if ((elm)->field.le_next != NULL)				\
+-		(elm)->field.le_next->field.le_prev = 			\
++#define	LIST_FOREACH(var, head, field)					\
++	for ((var) = LIST_FIRST((head));				\
++	    (var);							\
++	    (var) = LIST_NEXT((var), field))
++
++#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
++	for ((var) = LIST_FIRST((head));				\
++	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
++	    (var) = (tvar))
++
++#define	LIST_INIT(head) do {						\
++	LIST_FIRST((head)) = NULL;					\
++} while (0)
++
++#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
++	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
++		LIST_NEXT((listelm), field)->field.le_prev =		\
++		    &LIST_NEXT((elm), field);				\
++	LIST_NEXT((listelm), field) = (elm);				\
++	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
++} while (0)
++
++#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
++	(elm)->field.le_prev = (listelm)->field.le_prev;		\
++	LIST_NEXT((elm), field) = (listelm);				\
++	*(listelm)->field.le_prev = (elm);				\
++	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
++} while (0)
++
++#define	LIST_INSERT_HEAD(head, elm, field) do {				\
++	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
++		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
++	LIST_FIRST((head)) = (elm);					\
++	(elm)->field.le_prev = &LIST_FIRST((head));			\
++} while (0)
++
++#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
++
++#define	LIST_REMOVE(elm, field) do {					\
++	if (LIST_NEXT((elm), field) != NULL)				\
++		LIST_NEXT((elm), field)->field.le_prev = 		\
+ 		    (elm)->field.le_prev;				\
+-	*(elm)->field.le_prev = (elm)->field.le_next;			\
+-}
++	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
++} while (0)
+ 
+ /*
+- * Tail queue definitions.
++ * Tail queue declarations.
+  */
+-#define TAILQ_HEAD(name, type)						\
++#define	TAILQ_HEAD(name, type)						\
+ struct name {								\
+ 	struct type *tqh_first;	/* first element */			\
+ 	struct type **tqh_last;	/* addr of last next element */		\
++	TRACEBUF							\
+ }
+ 
+-#define TAILQ_ENTRY(type)						\
++#define	TAILQ_HEAD_INITIALIZER(head)					\
++	{ NULL, &(head).tqh_first }
++
++#define	TAILQ_ENTRY(type)						\
+ struct {								\
+ 	struct type *tqe_next;	/* next element */			\
+ 	struct type **tqe_prev;	/* address of previous next element */	\
++	TRACEBUF							\
+ }
+ 
+ /*
+  * Tail queue functions.
+  */
+-#define	TAILQ_INIT(head) {						\
+-	(head)->tqh_first = NULL;					\
+-	(head)->tqh_last = &(head)->tqh_first;				\
+-}
+-
+-#define TAILQ_INSERT_HEAD(head, elm, field) {				\
+-	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+-		(elm)->field.tqe_next->field.tqe_prev =			\
+-		    &(elm)->field.tqe_next;				\
++#define	TAILQ_CONCAT(head1, head2, field) do {				\
++	if (!TAILQ_EMPTY(head2)) {					\
++		*(head1)->tqh_last = (head2)->tqh_first;		\
++		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
++		(head1)->tqh_last = (head2)->tqh_last;			\
++		TAILQ_INIT((head2));					\
++		QMD_TRACE_HEAD(head);					\
++		QMD_TRACE_HEAD(head2);					\
++	}								\
++} while (0)
++
++#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
++
++#define	TAILQ_FIRST(head)	((head)->tqh_first)
++
++#define	TAILQ_FOREACH(var, head, field)					\
++	for ((var) = TAILQ_FIRST((head));				\
++	    (var);							\
++	    (var) = TAILQ_NEXT((var), field))
++
++#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
++	for ((var) = TAILQ_FIRST((head));				\
++	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
++	    (var) = (tvar))
++
++#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
++	for ((var) = TAILQ_LAST((head), headname);			\
++	    (var);							\
++	    (var) = TAILQ_PREV((var), headname, field))
++
++#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
++	for ((var) = TAILQ_LAST((head), headname);			\
++	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
++	    (var) = (tvar))
++
++#define	TAILQ_INIT(head) do {						\
++	TAILQ_FIRST((head)) = NULL;					\
++	(head)->tqh_last = &TAILQ_FIRST((head));			\
++	QMD_TRACE_HEAD(head);						\
++} while (0)
++
++#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
++	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
++		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
++		    &TAILQ_NEXT((elm), field);				\
++	else {								\
++		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
++		QMD_TRACE_HEAD(head);					\
++	}								\
++	TAILQ_NEXT((listelm), field) = (elm);				\
++	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
++	QMD_TRACE_ELEM(&(elm)->field);					\
++	QMD_TRACE_ELEM(&listelm->field);				\
++} while (0)
++
++#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
++	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
++	TAILQ_NEXT((elm), field) = (listelm);				\
++	*(listelm)->field.tqe_prev = (elm);				\
++	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
++	QMD_TRACE_ELEM(&(elm)->field);					\
++	QMD_TRACE_ELEM(&listelm->field);				\
++} while (0)
++
++#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
++	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
++		TAILQ_FIRST((head))->field.tqe_prev =			\
++		    &TAILQ_NEXT((elm), field);				\
+ 	else								\
+-		(head)->tqh_last = &(elm)->field.tqe_next;		\
+-	(head)->tqh_first = (elm);					\
+-	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+-}
++		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
++	TAILQ_FIRST((head)) = (elm);					\
++	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
++	QMD_TRACE_HEAD(head);						\
++	QMD_TRACE_ELEM(&(elm)->field);					\
++} while (0)
+ 
+-#define TAILQ_INSERT_TAIL(head, elm, field) {				\
+-	(elm)->field.tqe_next = NULL;					\
++#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
++	TAILQ_NEXT((elm), field) = NULL;				\
+ 	(elm)->field.tqe_prev = (head)->tqh_last;			\
+ 	*(head)->tqh_last = (elm);					\
+-	(head)->tqh_last = &(elm)->field.tqe_next;			\
+-}
+-
+-#define TAILQ_INSERT_AFTER(head, listelm, elm, field) {			\
+-	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+-		(elm)->field.tqe_next->field.tqe_prev = 		\
+-		    &(elm)->field.tqe_next;				\
+-	else								\
+-		(head)->tqh_last = &(elm)->field.tqe_next;		\
+-	(listelm)->field.tqe_next = (elm);				\
+-	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+-}
+-
+-#define TAILQ_REMOVE(head, elm, field) {				\
+-	if (((elm)->field.tqe_next) != NULL)				\
+-		(elm)->field.tqe_next->field.tqe_prev = 		\
++	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
++	QMD_TRACE_HEAD(head);						\
++	QMD_TRACE_ELEM(&(elm)->field);					\
++} while (0)
++
++#define	TAILQ_LAST(head, headname)					\
++	(*(((struct headname *)((head)->tqh_last))->tqh_last))
++
++#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
++
++#define	TAILQ_PREV(elm, headname, field)				\
++	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
++
++#define	TAILQ_REMOVE(head, elm, field) do {				\
++	if ((TAILQ_NEXT((elm), field)) != NULL)				\
++		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+ 		    (elm)->field.tqe_prev;				\
+-	else								\
++	else {								\
+ 		(head)->tqh_last = (elm)->field.tqe_prev;		\
+-	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+-}
++		QMD_TRACE_HEAD(head);					\
++	}								\
++	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
++	TRASHIT((elm)->field.tqe_next);					\
++	TRASHIT((elm)->field.tqe_prev);					\
++	QMD_TRACE_ELEM(&(elm)->field);					\
++} while (0)
+ 
+-/*
+- * Circular queue definitions.
+- */
+-#define CIRCLEQ_HEAD(name, type)					\
+-struct name {								\
+-	struct type *cqh_first;		/* first element */		\
+-	struct type *cqh_last;		/* last element */		\
+-}
+ 
+-#define CIRCLEQ_ENTRY(type)						\
+-struct {								\
+-	struct type *cqe_next;		/* next element */		\
+-	struct type *cqe_prev;		/* previous element */		\
+-}
++#ifdef _KERNEL
+ 
+ /*
+- * Circular queue functions.
++ * XXX insque() and remque() are an old way of handling certain queues.
++ * They bogusly assumes that all queue heads look alike.
+  */
+-#define	CIRCLEQ_INIT(head) {						\
+-	(head)->cqh_first = (void *)(head);				\
+-	(head)->cqh_last = (void *)(head);				\
+-}
+ 
+-#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
+-	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
+-	(elm)->field.cqe_prev = (listelm);				\
+-	if ((listelm)->field.cqe_next == (void *)(head))		\
+-		(head)->cqh_last = (elm);				\
+-	else								\
+-		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
+-	(listelm)->field.cqe_next = (elm);				\
+-}
++struct quehead {
++	struct quehead *qh_link;
++	struct quehead *qh_rlink;
++};
+ 
+-#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) {		\
+-	(elm)->field.cqe_next = (listelm);				\
+-	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
+-	if ((listelm)->field.cqe_prev == (void *)(head))		\
+-		(head)->cqh_first = (elm);				\
+-	else								\
+-		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
+-	(listelm)->field.cqe_prev = (elm);				\
+-}
++#if defined(__GNUC__) || defined(__INTEL_COMPILER)
+ 
+-#define CIRCLEQ_INSERT_HEAD(head, elm, field) {				\
+-	(elm)->field.cqe_next = (head)->cqh_first;			\
+-	(elm)->field.cqe_prev = (void *)(head);				\
+-	if ((head)->cqh_last == (void *)(head))				\
+-		(head)->cqh_last = (elm);				\
+-	else								\
+-		(head)->cqh_first->field.cqe_prev = (elm);		\
+-	(head)->cqh_first = (elm);					\
+-}
++static __inline void
++insque(void *a, void *b)
++{
++	struct quehead *element = (struct quehead *)a,
++		 *head = (struct quehead *)b;
+ 
+-#define CIRCLEQ_INSERT_TAIL(head, elm, field) {				\
+-	(elm)->field.cqe_next = (void *)(head);				\
+-	(elm)->field.cqe_prev = (head)->cqh_last;			\
+-	if ((head)->cqh_first == (void *)(head))			\
+-		(head)->cqh_first = (elm);				\
+-	else								\
+-		(head)->cqh_last->field.cqe_next = (elm);		\
+-	(head)->cqh_last = (elm);					\
++	element->qh_link = head->qh_link;
++	element->qh_rlink = head;
++	head->qh_link = element;
++	element->qh_link->qh_rlink = element;
+ }
+ 
+-#define	CIRCLEQ_REMOVE(head, elm, field) {				\
+-	if ((elm)->field.cqe_next == (void *)(head))			\
+-		(head)->cqh_last = (elm)->field.cqe_prev;		\
+-	else								\
+-		(elm)->field.cqe_next->field.cqe_prev =			\
+-		    (elm)->field.cqe_prev;				\
+-	if ((elm)->field.cqe_prev == (void *)(head))			\
+-		(head)->cqh_first = (elm)->field.cqe_next;		\
+-	else								\
+-		(elm)->field.cqe_prev->field.cqe_next =			\
+-		    (elm)->field.cqe_next;				\
++static __inline void
++remque(void *a)
++{
++	struct quehead *element = (struct quehead *)a;
++
++	element->qh_link->qh_rlink = element->qh_rlink;
++	element->qh_rlink->qh_link = element->qh_link;
++	element->qh_rlink = 0;
+ }
+-#endif	/* sys/queue.h */
++
++#else /* !(__GNUC__ || __INTEL_COMPILER) */
++
++void	insque(void *a, void *b);
++void	remque(void *a);
++
++#endif /* __GNUC__ || __INTEL_COMPILER */
++
++#endif /* _KERNEL */
++
++#endif /* !_SYS_QUEUE_H_ */
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/patches/kfreebsd-scripts.dpatch
+++ glibc-2.3.5/debian/patches/kfreebsd-scripts.dpatch
@@ -0,0 +1,152 @@
+#! /bin/sh -e
+
+# All lines beginning with `# DP:' are a description of the patch.
+# DP: Description: Scripts modification to support GNU/kFreeBSD
+# DP: Related bugs: 
+# DP: Dpatch author: Aurelien Jarno <aurel32@debian.org>
+# DP: Patch author: Robert Millan <rmh@debian.org>
+# DP: Upstream status: Not submitted
+# DP: Status Details: 
+# DP: Date: 2005-06-12
+
+if [ $# -ne 2 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+case "$1" in
+    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
+    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
+    *)
+	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+	exit 1
+esac
+exit 0
+
+# append the patch here and adjust the -p? flag in the patch calls.
+diff -urN glibc-2.3.2.orig/abi-tags glibc-2.3.2/abi-tags
+--- abi-tags	2002-09-21 02:28:19.000000000 +0200
++++ abi-tags	2005-06-12 17:58:26.000000000 +0200
+@@ -22,7 +22,7 @@
+ 
+ .*-sun-solaris2.*	2	2.0.0	# just an arbitrary value
+ 
+-.*-.*-freebsd.*-gnu.*	3	4.0.0	# earliest compatible kernel version
++.*-.*-kfreebsd.*-gnu.*	3	5.0.0	# earliest compatible kernel version
+ 
+ # There is no catch-all default here because every supported OS that uses
+ # ELF must have its own unique ABI tag.
+diff -urN glibc-2.3.2.orig/configure glibc-2.3.2/configure
+--- configure	2005-06-12 17:39:18.000000000 +0200
++++ configure	2005-06-12 18:02:40.000000000 +0200
+@@ -1734,7 +1734,7 @@
+ 
+ # Some configurations imply other options.
+ case "$host_os" in
+-gnu* | linux* | bsd4.4* | netbsd* | freebsd*)
++gnu* | linux* | bsd4.4* | netbsd* | freebsd* | k*bsd*-gnu)
+   # These systems always use GNU tools.
+   gnu_ld=yes gnu_as=yes ;;
+ esac
+@@ -1742,7 +1742,7 @@
+ # i586-linuxaout is mangled into i586-pc-linux-gnuaout
+ linux*ecoff* | linux*aout* | gnu*aout* | gnu*ecoff*)
+   ;;
+-gnu* | linux* | freebsd* | netbsd* | sysv4* | solaris2* | irix6*)
++gnu* | linux* | freebsd* | netbsd* | k*bsd*-gnu | sysv4* | solaris2* | irix6*)
+   # These systems (almost) always use the ELF format.
+   elf=yes
+   ;;
+@@ -1785,7 +1785,7 @@
+ ###
+ if test -z "$enable_hacker_mode"; then
+   case "$machine-$host_os" in
+-  *-linux* | *-gnu* | arm*-none* | powerpc-aix4.3.*)
++  *-linux* | *-gnu* | *-kfreebsd*-gnu | arm*-none* | powerpc-aix4.3.*)
+     ;;
+   *)
+     echo "*** The GNU C library is currently not available for this platform."
+@@ -1883,7 +1883,7 @@
+ case "$os" in
+ gnu*)
+   base_os=mach/hurd ;;
+-netbsd* | 386bsd* | freebsd* | bsdi*)
++netbsd* | 386bsd* | freebsd* | bsdi* | k*bsd*-gnu)
+   base_os=unix/bsd/bsd4.4 ;;
+ osf* | sunos* | ultrix* | newsos* | dynix* | *bsd*)
+   base_os=unix/bsd ;;
+diff -urN glibc-2.3.2.orig/configure.in glibc-2.3.2/configure.in
+--- configure.in	2005-06-12 17:39:21.000000000 +0200
++++ configure.in	2005-06-12 18:01:28.000000000 +0200
+@@ -308,7 +308,7 @@
+ 
+ # Some configurations imply other options.
+ case "$host_os" in
+-gnu* | linux* | bsd4.4* | netbsd* | freebsd*)
++gnu* | linux* | bsd4.4* | netbsd* | freebsd* | k*bsd*-gnu)
+   # These systems always use GNU tools.
+   gnu_ld=yes gnu_as=yes ;;
+ esac
+@@ -316,7 +316,7 @@
+ # i586-linuxaout is mangled into i586-pc-linux-gnuaout
+ linux*ecoff* | linux*aout* | gnu*aout* | gnu*ecoff*)
+   ;;
+-gnu* | linux* | freebsd* | netbsd* | sysv4* | solaris2* | irix6*)
++gnu* | linux* | freebsd* | netbsd* | | k*bsd*-gnu | sysv4* | solaris2* | irix6*)
+   # These systems (almost) always use the ELF format.
+   elf=yes
+   ;;
+@@ -359,7 +359,7 @@
+ ###
+ if test -z "$enable_hacker_mode"; then
+   case "$machine-$host_os" in
+-  *-linux* | *-gnu* | arm*-none* | powerpc-aix4.3.*)
++  *-linux* | *-gnu* | *-kfreebsd*-gnu | arm*-none* | powerpc-aix4.3.*)
+     ;;
+   *)
+     echo "*** The GNU C library is currently not available for this platform."
+@@ -458,7 +458,7 @@
+ case "$os" in
+ gnu*)
+   base_os=mach/hurd ;;
+-netbsd* | 386bsd* | freebsd* | bsdi*)
++netbsd* | 386bsd* | freebsd* | bsdi* k*bsd*-gnu)
+   base_os=unix/bsd/bsd4.4 ;;
+ osf* | sunos* | ultrix* | newsos* | dynix* | *bsd*)
+   base_os=unix/bsd ;;
+diff -urN glibc-2.3.2.orig/shlib-versions glibc-2.3.2/shlib-versions
+--- shlib-versions	2002-09-05 11:31:49.000000000 +0200
++++ shlib-versions	2005-06-12 18:06:19.000000000 +0200
+@@ -26,6 +26,7 @@
+ x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
+ powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
+ .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
++.*-.*-kfreebsd.*-gnu	DEFAULT			GLIBC_2.3
+ 
+ # Configuration		Library=version		Earliest symbol set (optional)
+ # -------------		---------------		------------------------------
+@@ -39,6 +40,7 @@
+ hppa.*-.*-.*		libm=6			GLIBC_2.2
+ .*-.*-linux.*		libm=6
+ .*-.*-gnu-gnu.*		libm=6
++.*-.*-kfreebsd.*-gnu	libm=1
+ 
+ # We provide libc.so.6 for Linux kernel versions 2.0 and later.
+ alpha.*-.*-linux.*	libc=6.1
+@@ -49,6 +51,7 @@
+ sparc64-.*-linux.*	libc=6			GLIBC_2.2
+ hppa.*-.*-.*		libc=6			GLIBC_2.2
+ .*-.*-linux.*		libc=6
++.*-.*-kfreebsd.*-gnu	libc=0.1
+ 
+ # libmachuser.so.1 corresponds to mach/*.defs as of Utah's UK22 release.
+ .*-.*-gnu-gnu.*		libmachuser=1
+diff -urN glibc-2.3.2.orig/linuxthreads/shlib-versions glibc-2.3.2/linuxthreads/shlib-versions
+--- linuxthreads/shlib-versions	2002-09-05 12:14:21.000000000 +0200
++++ linuxthreads/shlib-versions	2005-06-15 01:40:37.000000000 +0200
+@@ -8,4 +8,5 @@
+ cris-.*-linux.*		libpthread=0		GLIBC_2.2
+ x86_64-.*-linux.*	libpthread=0		GLIBC_2.2.5
+ powerpc64-.*-linux.*	libpthread=0		GLIBC_2.3
+-.*-.*-linux.*		libpthread=0
+++.*-.*-kfreebsd.*-gnu.*	libpthread=0		GLIBC_2.3
+++.*-.*-.*		libpthread=0
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/patches/kfreebsd-sysdeps.dpatch
+++ glibc-2.3.5/debian/patches/kfreebsd-sysdeps.dpatch
@@ -0,0 +1,18494 @@
+#! /bin/sh -e
+
+# All lines beginning with `# DP:' are a description of the patch.
+# DP: Description: sysdeps for GNU/kFreeBSD
+# DP: Related bugs: 
+# DP: Dpatch author: Aurelien Jarno <aurel32@debian.org>
+# DP: Patch author: Bruno Haible <bruno@clisp.org>
+# DP: Upstream status: Not submitted
+# DP: Status Details: 
+# DP: Date: 2005-06-10
+
+if [ $# -ne 2 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+case "$1" in
+    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
+    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
+    *)
+	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+	exit 1
+esac
+exit 0
+
+# append the patch here and adjust the -p? flag in the patch calls.
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,48 @@
++/* Minimum guaranteed maximum values for system limits.  FreeBSD version.
++   Copyright (C) 1993-1998, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/syslimits.h>
++
++/* The number of data keys per process.  */
++#define _POSIX_THREAD_KEYS_MAX	128
++/* This is the value this implementation supports.  */
++#define PTHREAD_KEYS_MAX	1024
++
++/* Controlling the iterations of destructors for thread-specific data.  */
++#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
++/* Number of iterations this implementation does.  */
++#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
++
++/* The number of threads per process.  */
++#define _POSIX_THREAD_THREADS_MAX	64
++/* This is the value this implementation supports.  */
++#define PTHREAD_THREADS_MAX	1024
++
++/* Maximum amount by which a process can descrease its asynchronous I/O
++   priority level.  */
++#define AIO_PRIO_DELTA_MAX	20
++
++/* Minimum size for a thread.  We are free to choose a reasonable value.  */
++#define PTHREAD_STACK_MIN	16384
++
++/* Maximum number of POSIX timers available.  */
++#define TIMER_MAX	256
++
++/* Maximum number of timer expiration overruns.  */
++#define DELAYTIMER_MAX	2147483647
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,133 @@
++/* Define POSIX options for FreeBSD.
++   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Never include this file directly; use <unistd.h> instead.
++ */
++
++#ifndef	_BITS_POSIX_OPT_H
++#define	_BITS_POSIX_OPT_H	1
++
++/* Job control is supported.  */
++#define	_POSIX_JOB_CONTROL	1
++
++/* Processes have a saved set-user-ID and a saved set-group-ID.  */
++#define	_POSIX_SAVED_IDS	1
++
++/* Priority scheduling is supported.  */
++#define	_POSIX_PRIORITY_SCHEDULING	1
++
++/* Synchronizing file data is supported.  */
++#define	_POSIX_SYNCHRONIZED_IO	1
++
++/* The fsync function is present.  */
++#define	_POSIX_FSYNC	1
++
++/* Mapping of files to memory is supported.  */
++#define	_POSIX_MAPPED_FILES	1
++
++/* Locking of all memory is supported.  */
++#define	_POSIX_MEMLOCK	1
++
++/* Locking of ranges of memory is supported.  */
++#define	_POSIX_MEMLOCK_RANGE	1
++
++/* Setting of memory protections is supported.  */
++#define	_POSIX_MEMORY_PROTECTION	1
++
++/* Implementation supports `poll' function.  */
++#define	_POSIX_POLL	1
++
++/* Implementation supports `select' and `pselect' functions.  */
++#define	_POSIX_SELECT	1
++
++/* XPG4.2 shared memory is supported.  */
++#define	_XOPEN_SHM	1
++
++/* Tell we have POSIX threads.  */
++#define _POSIX_THREADS	1
++
++/* We have the reentrant functions described in POSIX.  */
++#define _POSIX_REENTRANT_FUNCTIONS	1
++#define _POSIX_THREAD_SAFE_FUNCTIONS	1
++
++/* We provide priority scheduling for threads.  */
++#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
++
++/* We support user-defined stack sizes.  */
++#define _POSIX_THREAD_ATTR_STACKSIZE	1
++
++/* We support user-defined stacks.  */
++#define _POSIX_THREAD_ATTR_STACKADDR	1
++
++/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
++#define _POSIX_SEMAPHORES	1
++
++/* We support asynchronous I/O.  */
++#define _POSIX_ASYNCHRONOUS_IO	1
++#define _POSIX_ASYNC_IO		1
++/* Alternative name for Unix98.  */
++#define _LFS_ASYNCHRONOUS_IO	1
++
++/* The LFS support in asynchronous I/O is also available.  */
++#define _LFS64_ASYNCHRONOUS_IO	1
++
++/* The rest of the LFS is also available.  */
++#define _LFS_LARGEFILE		1
++#define _LFS64_LARGEFILE	1
++#define _LFS64_STDIO		1
++
++/* X/Open realtime support is available.  */
++#define _XOPEN_REALTIME	1
++
++/* X/Open realtime thread support is available.  */
++#define _XOPEN_REALTIME_THREADS	1
++
++/* Only root can change owner of file.  */
++#define	_POSIX_CHOWN_RESTRICTED	1
++
++/* `c_cc' member of 'struct termios' structure can be disabled by
++   using the value _POSIX_VDISABLE.  */
++#define	_POSIX_VDISABLE	'\0'
++
++/* POSIX timers are available.  */
++#define _POSIX_TIMERS 1
++
++/* Reader/Writer locks are available.  */
++#define _POSIX_READER_WRITER_LOCKS	200912L
++
++/* GNU libc provides regular expression handling.  */
++#define _POSIX_REGEXP	1
++
++/* We have a POSIX shell.  */
++#define _POSIX_SHELL	1
++
++/* We support the Timeouts option.  */
++#define _POSIX_TIMEOUTS	200912L
++
++/* We support spinlocks.  */
++#define _POSIX_SPIN_LOCKS	200912L
++
++/* The `spawn' function family is supported.  */
++#define _POSIX_SPAWN	200912L
++
++/* The barrier functions are available.  */
++#define _POSIX_BARRIERS	200912L
++
++#endif /* bits/posix_opt.h */
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigthread.h linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigthread.h
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigthread.h	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigthread.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,38 @@
++/* Signal handling function for threaded programs.
++   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _BITS_SIGTHREAD_H
++#define _BITS_SIGTHREAD_H	1
++
++#if !defined _SIGNAL_H && !defined _PTHREAD_H
++# error "Never include this file directly.  Use <pthread.h> instead"
++#endif
++
++/* Functions for handling signals. */
++
++/* Modify the signal mask for the calling thread.  The arguments have
++   the same meaning as for sigprocmask(2). */
++extern int pthread_sigmask (int __how,
++			    __const __sigset_t *__restrict __newmask,
++			    __sigset_t *__restrict __oldmask) __THROW;
++
++/* Send signal SIGNO to the given thread. */
++extern int pthread_kill (pthread_t __threadid, int __signo) __THROW;
++
++#endif	/* bits/sigthread.h */
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/posix_opt.h linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/posix_opt.h
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/posix_opt.h	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/posix_opt.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,139 @@
++/* Define POSIX options for FreeBSD.
++   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Never include this file directly; use <unistd.h> instead.
++ */
++
++#ifndef	_BITS_POSIX_OPT_H
++#define	_BITS_POSIX_OPT_H	1
++
++/* Job control is supported.  */
++#define	_POSIX_JOB_CONTROL	1
++
++/* Processes have a saved set-user-ID and a saved set-group-ID.  */
++#define	_POSIX_SAVED_IDS	1
++
++/* Priority scheduling is supported.  */
++#define	_POSIX_PRIORITY_SCHEDULING	1
++
++/* Synchronizing file data is supported.  */
++#define	_POSIX_SYNCHRONIZED_IO	1
++
++/* The fsync function is present.  */
++#define	_POSIX_FSYNC	1
++
++/* Mapping of files to memory is supported.  */
++#define	_POSIX_MAPPED_FILES	1
++
++/* Locking of all memory is supported.  */
++#define	_POSIX_MEMLOCK	1
++
++/* Locking of ranges of memory is supported.  */
++#define	_POSIX_MEMLOCK_RANGE	1
++
++/* Setting of memory protections is supported.  */
++#define	_POSIX_MEMORY_PROTECTION	1
++
++/* Implementation supports `poll' function.  */
++#define	_POSIX_POLL	1
++
++/* Implementation supports `select' and `pselect' functions.  */
++#define	_POSIX_SELECT	1
++
++/* XPG4.2 shared memory is supported.  */
++#define	_XOPEN_SHM	1
++
++/* Tell we have POSIX threads.  */
++#define _POSIX_THREADS	1
++
++/* We have the reentrant functions described in POSIX.  */
++#define _POSIX_REENTRANT_FUNCTIONS	1
++#define _POSIX_THREAD_SAFE_FUNCTIONS	1
++
++/* We provide priority scheduling for threads.  */
++#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
++
++/* We support user-defined stack sizes.  */
++#define _POSIX_THREAD_ATTR_STACKSIZE	1
++
++/* We support user-defined stacks.  */
++#define _POSIX_THREAD_ATTR_STACKADDR	1
++
++/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
++#define _POSIX_SEMAPHORES	1
++
++/* We support asynchronous I/O.  */
++#define _POSIX_ASYNCHRONOUS_IO	1
++#define _POSIX_ASYNC_IO		1
++/* Alternative name for Unix98.  */
++#define _LFS_ASYNCHRONOUS_IO	1
++
++/* The LFS support in asynchronous I/O is also available.  */
++#define _LFS64_ASYNCHRONOUS_IO	1
++
++/* The rest of the LFS is also available.  */
++#define _LFS_LARGEFILE		1
++#define _LFS64_LARGEFILE	1
++#define _LFS64_STDIO		1
++
++/* X/Open realtime support is available.  */
++#define _XOPEN_REALTIME	1
++
++/* X/Open realtime thread support is available.  */
++#define _XOPEN_REALTIME_THREADS	1
++
++/* Only root can change owner of file.  */
++#define	_POSIX_CHOWN_RESTRICTED	1
++
++/* `c_cc' member of 'struct termios' structure can be disabled by
++   using the value _POSIX_VDISABLE.  */
++#define	_POSIX_VDISABLE	'\0'
++
++/* POSIX timers are available.  */
++#define _POSIX_TIMERS 1
++
++/* CPU-time clocks supported.  */
++#define _POSIX_CPUTIME	200912L
++
++/* We support the clock also in threads.  */
++#define _POSIX_THREAD_CPUTIME	200912L
++
++/* Reader/Writer locks are available.  */
++#define _POSIX_READER_WRITER_LOCKS	200912L
++
++/* GNU libc provides regular expression handling.  */
++#define _POSIX_REGEXP	1
++
++/* We have a POSIX shell.  */
++#define _POSIX_SHELL	1
++
++/* We support the Timeouts option.  */
++#define _POSIX_TIMEOUTS	200912L
++
++/* We support spinlocks.  */
++#define _POSIX_SPIN_LOCKS	200912L
++
++/* The `spawn' function family is supported.  */
++#define _POSIX_SPAWN	200912L
++
++/* The barrier functions are available.  */
++#define _POSIX_BARRIERS	200912L
++
++#endif /* bits/posix_opt.h */
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1 @@
++pthread
+diff -Nur linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/smp.h linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/smp.h
+--- linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/smp.h	1970-01-01 01:00:00.000000000 +0100
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/smp.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Determine whether the host has multiple processors.  FreeBSD version.
++   Copyright (C) 1996, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Library General Public License as
++   published by the Free Software Foundation; either version 2 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Library General Public License for more details.
++
++   You should have received a copy of the GNU Library General Public
++   License along with the GNU C Library; see the file COPYING.LIB.  If not,
++   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
++   Boston, MA 02111-1307, USA.  */
++
++#include <sys/sysctl.h>
++
++/* Test whether the machine has more than one processor.  */
++static inline int
++is_smp_system (void)
++{
++  /* Fetch sysctl value of "hw.ncpu".  */
++  int request[] = { CTL_HW, HW_NCPU };
++  int result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    /* Dummy result.  */
++    return 0;
++
++  return (result > 1);
++}
+diff -Nur sysdeps/generic/bits/types.h sysdeps/generic/bits/types.h
+--- sysdeps/generic/bits/types.h	2004-09-26 10:47:37.000000000 +0200
++++ sysdeps/generic/bits/types.h	2005-08-23 17:35:07.000000000 +0200
+@@ -145,6 +145,7 @@
+ __STD_TYPE __PID_T_TYPE __pid_t;	/* Type of process identifications.  */
+ __STD_TYPE __FSID_T_TYPE __fsid_t;	/* Type of file system IDs.  */
+ __STD_TYPE __CLOCK_T_TYPE __clock_t;	/* Type of CPU usage counts.  */
++__STD_TYPE __CLOCK_T_TYPE __kernel_time_t; /* Type of CPU usage counts.  */
+ __STD_TYPE __RLIM_T_TYPE __rlim_t;	/* Type for resource measurement.  */
+ __STD_TYPE __RLIM64_T_TYPE __rlim64_t;	/* Type for resource measurement (LFS).  */
+ __STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
+diff -Nur sysdeps/posix/Dist sysdeps/posix/Dist
+--- sysdeps/posix/Dist	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/posix/Dist	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++show-prof-freq.c
+diff -Nur sysdeps/posix/show-prof-freq.c sysdeps/posix/show-prof-freq.c
+--- sysdeps/posix/show-prof-freq.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/posix/show-prof-freq.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,87 @@
++/* Show the profiler frequency.  Use for porting __profile_frequency().
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This program shows the profiler frequency.  Its purpose it to port
++   __profile_frequency().  Note that you should avoid to put immediate
++   constants into the implementation of __profile_frequency() if the
++   information is also available through a kernel API; but this program
++   can at least help you choosing the right API.  */
++
++#include <signal.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <time.h>
++#include <unistd.h>
++#include <sys/time.h>
++
++struct timeval start_time;
++struct timeval end_time;
++
++int counter;
++
++static void prof_handler ()
++{
++  counter++;
++}
++
++static void int_handler ()
++{
++  /* Take end time.  */
++  gettimeofday (&end_time, NULL);
++
++  printf ("\n");
++  printf ("Number of ITIMER_PROF ticks: %d\n", counter);
++  printf ("Frequency of ITIMER_PROF ticks: %g / sec\n",
++	  (double) counter
++	  / ((end_time.tv_sec + 1e-6 * end_time.tv_usec)
++	     - (start_time. tv_sec + 1e-6 * start_time.tv_usec)));
++  printf ("For comparison: CLK_TCK = %d\n", CLK_TCK);
++  exit (0);
++}
++
++int main ()
++{
++  struct sigaction act;
++  struct itimerval timer;
++
++  printf ("Calibrating...\n");
++
++  signal (SIGINT, int_handler);
++  signal (SIGALRM, int_handler);
++
++  /* Set up the profiling action.  */
++  act.sa_handler = prof_handler;
++  act.sa_flags = SA_RESTART;
++  sigfillset (&act.sa_mask);
++  sigaction (SIGPROF, &act, NULL);
++
++  /* Take start time.  */
++  gettimeofday (&start_time, NULL);
++
++  /* Start profiling timer.  */
++  timer.it_value.tv_sec  = 0;
++  timer.it_value.tv_usec = 1;
++  timer.it_interval.tv_sec  = 0;
++  timer.it_interval.tv_usec = 1;
++  setitimer (ITIMER_PROF, &timer, NULL);
++
++  alarm (10);
++
++  for (;;);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/bits/errno.h sysdeps/unix/bsd/bsd4.4/bits/errno.h
+--- sysdeps/unix/bsd/bsd4.4/bits/errno.h	2002-07-20 03:02:00.000000000 +0200
++++ sysdeps/unix/bsd/bsd4.4/bits/errno.h	2005-08-23 17:35:06.000000000 +0200
+@@ -32,9 +32,11 @@
+  * SUCH DAMAGE.
+  *
+  *	@(#)errno.h	8.5 (Berkeley) 1/21/94
++ * $FreeBSD: src/sys/sys/errno.h,v 1.26 2004/04/07 04:19:49 imp Exp $
+  */
+ 
+-#ifdef	_ERRNO_H
++#ifndef _ERRNO_H_
++#define _ERRNO_H_
+ 
+ #define	EPERM		1		/* Operation not permitted */
+ #define	ENOENT		2		/* No such file or directory */
+@@ -51,9 +53,7 @@
+ #define	ENOMEM		12		/* Cannot allocate memory */
+ #define	EACCES		13		/* Permission denied */
+ #define	EFAULT		14		/* Bad address */
+-#ifdef	__USE_BSD
+ #define	ENOTBLK		15		/* Block device required */
+-#endif
+ #define	EBUSY		16		/* Device busy */
+ #define	EEXIST		17		/* File exists */
+ #define	EXDEV		18		/* Cross-device link */
+@@ -64,13 +64,11 @@
+ #define	ENFILE		23		/* Too many open files in system */
+ #define	EMFILE		24		/* Too many open files */
+ #define	ENOTTY		25		/* Inappropriate ioctl for device */
+-#ifdef	__USE_BSD
+ #define	ETXTBSY		26		/* Text file busy */
+-#endif
+ #define	EFBIG		27		/* File too large */
+ #define	ENOSPC		28		/* No space left on device */
+ #define	ESPIPE		29		/* Illegal seek */
+-#define	EROFS		30		/* Read-only file system */
++#define	EROFS		30		/* Read-only filesystem */
+ #define	EMLINK		31		/* Too many links */
+ #define	EPIPE		32		/* Broken pipe */
+ 
+@@ -89,7 +87,6 @@
+ 
+ /* non-blocking and interrupt i/o */
+ #define	EAGAIN		35		/* Resource temporarily unavailable */
+-#ifdef	__USE_BSD
+ #define	EWOULDBLOCK	EAGAIN		/* Operation would block */
+ #define	EINPROGRESS	36		/* Operation now in progress */
+ #define	EALREADY	37		/* Operation already in progress */
+@@ -103,6 +100,7 @@
+ #define	EPROTONOSUPPORT	43		/* Protocol not supported */
+ #define	ESOCKTNOSUPPORT	44		/* Socket type not supported */
+ #define	EOPNOTSUPP	45		/* Operation not supported */
++#define	ENOTSUP		EOPNOTSUPP	/* Operation not supported */
+ #define	EPFNOSUPPORT	46		/* Protocol family not supported */
+ #define	EAFNOSUPPORT	47		/* Address family not supported by protocol family */
+ #define	EADDRINUSE	48		/* Address already in use */
+@@ -123,18 +121,14 @@
+ #define	ECONNREFUSED	61		/* Connection refused */
+ 
+ #define	ELOOP		62		/* Too many levels of symbolic links */
+-#endif /* __USE_BSD */
+ #define	ENAMETOOLONG	63		/* File name too long */
+ 
+ /* should be rearranged */
+-#ifdef	__USE_BSD
+ #define	EHOSTDOWN	64		/* Host is down */
+ #define	EHOSTUNREACH	65		/* No route to host */
+-#endif /* __USE_BSD */
+ #define	ENOTEMPTY	66		/* Directory not empty */
+ 
+ /* quotas & mush */
+-#ifdef	__USE_BSD
+ #define	EPROCLIM	67		/* Too many processes */
+ #define	EUSERS		68		/* Too many users */
+ #define	EDQUOT		69		/* Disc quota exceeded */
+@@ -147,18 +141,51 @@
+ #define	EPROGUNAVAIL	74		/* RPC prog. not avail */
+ #define	EPROGMISMATCH	75		/* Program version wrong */
+ #define	EPROCUNAVAIL	76		/* Bad procedure for program */
+-#endif /* __USE_BSD */
+ 
+ #define	ENOLCK		77		/* No locks available */
+ #define	ENOSYS		78		/* Function not implemented */
+-
+ #define	EFTYPE		79		/* Inappropriate file type or format */
+ 
+-#ifdef	__USE_BSD
+ #define	EAUTH		80		/* Authentication error */
+ #define	ENEEDAUTH	81		/* Need authenticator */
+-#define	ELAST		81		/* Must be equal largest errno */
+-#endif /* __USE_BSD */
++#define	EIDRM		82		/* Identifier removed */
++#define	ENOMSG		83		/* No message of desired type */
++#define	EOVERFLOW	84		/* Value too large to be stored in data type */
++#define	ECANCELED	85		/* Operation canceled */
++
++#endif /* <errno.h> included.  */
++
++#if !defined(__Emath_defined) &&  (defined(_ERRNO_H) || defined(__need_Emath))
++#define	EILSEQ		86		/* Illegal byte sequence */
++#endif /* Emath not defined and <errno.h> included or need Emath.  */
++
++#ifdef _ERRNO_H
++
++#define	ENOATTR		87		/* Attribute not found */
++
++#define EDOOFUS		88		/* Programming error */
++
++#define	ELAST		88		/* Must be equal largest errno */
++
++#ifdef _KERNEL
++/* pseudo-errors returned inside kernel to modify return to process */
++#define	ERESTART	(-1)		/* restart syscall */
++#define	EJUSTRETURN	(-2)		/* don't modify regs, just return */
++#define	ENOIOCTL	(-3)		/* ioctl not handled by this layer */
++#define	EDIRIOCTL	(-4)		/* do direct ioctl in GEOM */
++#endif
+ 
++#ifndef __ASSEMBLER__
++/* We now need a declaration of the `errno' variable.  */
++extern int errno;
++
++/* Function to get address of global `errno' variable.  */
++extern int *__errno_location (void) __THROW __attribute__ ((__const__));
++
++# if !defined _LIBC || defined _LIBC_REENTRANT
++/* When using threads, errno is a per-thread value.  */
++#  define errno (*__errno_location ())
++# endif
++#endif /* !__ASSEMBLER__ */
+ 
+ #endif /* <errno.h> included.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/mcontext.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/mcontext.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/mcontext.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/mcontext.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Machine-dependent processor state structure for FreeBSD.  alpha version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SYS_UCONTEXT_H
++# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
++#endif
++
++/* Whole processor state.  */
++typedef struct
++  {
++    long mc_onstack;		/* Nonzero if running on sigstack.  */
++
++    /* General registers.  */
++    unsigned long mc_regs[32];
++    long mc_ps;
++    long mc_pc;			/* Process counter.  */
++
++    /* Trap arguments.  */
++    unsigned long mc_traparg_a0;
++    unsigned long mc_traparg_a1;
++    unsigned long mc_traparg_a2;
++
++    /* Floating-point registers.  */
++    unsigned long mc_fpregs[32];
++    unsigned long mc_fpcr;
++    unsigned long mc_fp_control;
++    long mc_ownedfp;
++
++    unsigned long mc_ssize;
++    char *mc_sbase;
++
++    unsigned long mc_fp_trap_pc;
++    unsigned long mc_fp_trigger_sum;
++    unsigned long mc_fp_trigger_inst;
++
++    long mc_spare[2];
++  } mcontext_t;
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/sigcontext.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/sigcontext.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/sigcontext.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,91 @@
++/* Machine-dependent signal context structure for FreeBSD.  alpha version.
++   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
++# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
++#endif
++
++#ifndef _BITS_SIGCONTEXT_H
++#define _BITS_SIGCONTEXT_H  1
++
++/* State of this thread when the signal was taken.  */
++struct sigcontext
++  {
++    __sigset_t sc_mask;		/* Blocked signals to restore.  */
++    long sc_onstack;		/* Nonzero if running on sigstack.  */
++
++    /* General registers.  */
++    unsigned long sc_regs[32];
++    long sc_ps;
++    long sc_pc;			/* Process counter.  */
++
++    /* Trap arguments.  */
++    unsigned long sc_traparg_a0;
++    unsigned long sc_traparg_a1;
++    unsigned long sc_traparg_a2;
++
++    /* Floating-point registers.  */
++    unsigned long sc_fpregs[32];
++    unsigned long sc_fpcr;
++    unsigned long sc_fp_control;
++    long sc_ownedfp;
++
++    unsigned long sc_ssize;
++    char *sc_sbase;
++
++    unsigned long sc_fp_trap_pc;
++    unsigned long sc_fp_trigger_sum;
++    unsigned long sc_fp_trigger_inst;
++
++    long sc_spare[2];
++  };
++
++/* Traditional BSD names for some members.  */
++#define sc_sp		sc_regs[30]	/* Stack pointer.  */
++#define sc_fp		sc_regs[15]	/* Frame pointer.  */
++
++
++#if 0 /* XXX These need verification.  */
++
++/* Codes for SIGFPE.  */
++#define FPE_INTDIV	1 /* integer divide by zero */
++#define FPE_INTOVF	2 /* integer overflow */
++#define FPE_FLTDIV	3 /* floating divide by zero */
++#define FPE_FLTOVF	4 /* floating overflow */
++#define FPE_FLTUND	5 /* floating underflow */
++#define FPE_FLTINX	6 /* floating loss of precision */
++#define FPE_SUBRNG_FAULT	0x7 /* BOUNDS instruction failed */
++#define FPE_FLTDNR_FAULT	0x8 /* denormalized operand */
++#define FPE_EMERR_FAULT		0xa /* mysterious emulation error 33 */
++#define FPE_EMBND_FAULT		0xb /* emulation BOUNDS instruction failed */
++
++/* Codes for SIGILL.  */
++#define ILL_PRIVIN_FAULT	1
++#define ILL_ALIGN_FAULT		14
++#define ILL_FPOP_FAULT		24
++
++/* Codes for SIGBUS.  */
++#define BUS_PAGE_FAULT		12
++#define BUS_SEGNP_FAULT		26
++#define BUS_STK_FAULT		27
++#define BUS_SEGM_FAULT		29
++
++#endif
++
++#endif /* _BITS_SIGCONTEXT_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/time.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/time.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/time.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/time.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,97 @@
++/* System-dependent timing definitions.  FreeBSD version.
++   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Never include this file directly; use <time.h> instead.
++ */
++
++#ifndef __need_timeval
++# ifndef _BITS_TIME_H
++#  define _BITS_TIME_H	1
++
++/* ISO/IEC 9899:1990 7.12.1: <time.h>
++   The macro `CLOCKS_PER_SEC' is the number per second of the value
++   returned by the `clock' function. */
++/* CAE XSH, Issue 4, Version 2: <time.h>
++   The value of CLOCKS_PER_SEC is required to be 1 million on all
++   XSI-conformant systems. */
++#  define CLOCKS_PER_SEC  1000000l
++
++#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
++/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
++   presents the real value for clock ticks per second for the system.  */
++#   define CLK_TCK 100
++#  endif
++
++#  ifdef __USE_POSIX199309
++/* Identifier for system-wide realtime clock.  */
++#   define CLOCK_REALTIME	0
++/* These are declared in FreeBSD, but not implemented.  */
++#   ifdef __USE_BSD
++#    define CLOCK_VIRTUAL	1
++#    define CLOCK_PROF		2
++#   endif
++
++/* Flag to indicate time is absolute.  */
++#   define TIMER_ABSTIME	1
++#  endif
++
++#  include <bits/types.h>
++
++struct __kernel_timespec
++  {
++    __kernel_time_t tv_sec;	/* Seconds.  */
++    long int tv_nsec;		/* Nanoseconds.  */
++  };
++
++# endif	/* bits/time.h */
++#endif
++
++
++#ifdef __need_timeval
++# undef __need_timeval
++# ifndef _STRUCT_TIMEVAL
++#  define _STRUCT_TIMEVAL	1
++
++#  include <bits/types.h>
++
++/* A time value that is accurate to the nearest
++   microsecond but also has a range of years.  */
++struct timeval
++  {
++    __time_t tv_sec;		/* Seconds.  */
++    __suseconds_t tv_usec;	/* Microseconds.  */
++  };
++
++struct __kernel_timeval
++  {
++    __kernel_time_t tv_sec;	/* Seconds.  */
++    __suseconds_t tv_usec;	/* Microseconds.  */
++  };
++
++struct __kernel_itimerval
++  {
++    /* Value to put into `it_value' when the timer expires.  */
++    struct __kernel_timeval it_interval;
++    /* Time to the next timer expiration.  */
++    struct __kernel_timeval it_value;
++  };
++
++# endif	/* struct timeval */
++#endif	/* need timeval */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/brk.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/brk.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/brk.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/brk.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,73 @@
++/* Copyright (C) 1993, 1995-1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* Traditional name for the 'brk' system call.  */
++#define SYS_brk SYS_obreak
++
++#include <sysdep.h>
++
++#ifdef PIC
++.section .bss
++	.align 3
++	.globl __curbrk
++__curbrk: .skip 8
++	.type __curbrk,@object
++	.size __curbrk,8
++#else
++.comm __curbrk, 8
++#endif
++
++	.text
++LEAF(__brk, 8)
++	ldgp	gp, 0(t12)
++	subq	sp, 8, sp
++#ifdef PROF
++	.set noat
++	lda	AT, _mcount
++	jsr	AT, (AT), _mcount
++	.set at
++#endif
++	.prologue 1
++
++	/* Save the requested brk across the system call.  */
++	stq	a0, 0(sp)
++
++	ldiq	v0, SYS_brk
++	call_pal PAL_callsys
++
++	ldq	a0, 0(sp)
++
++	/* Test for error.  */
++	bne	a3, $error
++
++	/* Don't need to handle brk(0) specially, because the kernel doesn't
++	   support this way of calling brk anyway.  */
++
++	/* Update __curbrk and return cleanly.  */
++	stq	a0, __curbrk
++	mov	zero, v0
++	addq	sp, 8, sp
++	ret
++
++	/* What a horrible way to die.  */
++$error:	addq	sp, 8, sp
++	jmp	zero, __syscall_error
++
++	END(__brk)
++
++weak_alias (__brk, brk)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-brk.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-brk.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-brk.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-brk.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++#include <brk.S>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-machine.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-machine.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-machine.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-machine.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,35 @@
++/* Dynamic linker magic for glibc on FreeBSD.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* FreeBSD on alpha can emulate two ABIs (= sets of system calls):
++   The native FreeBSD ABI and OSF/1.  Without additional kernel
++   modules, only the FreeBSD ABI is supported.  For this reason, we use
++   this ABI, and we have to label every executable as using this ABI,
++   by writing the string "FreeBSD" at byte offset 8 (= EI_ABIVERSION)
++   of every executable.  Strictly speaking, only ld.so and the
++   executables would need this labelling.  But it's easiest to mark
++   every executable and every shared object the same way.  */
++#define VALID_ELF_HEADER(e_ident, expected, size) \
++  (memcmp (e_ident, expected, EI_ABIVERSION) == 0			      \
++   && memcmp ((const char *) (e_ident) + EI_ABIVERSION, "FreeBSD", 8) == 0)
++#define VALID_ELF_OSABI(osabi) ((osabi) == ELFOSABI_SYSV)
++#define VALID_ELF_ABIVERSION(abi) (memcmp (&(abi), "FreeBSD", 8) == 0)
++
++#include_next "dl-machine.h"
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fhstatfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fhstatfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fhstatfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fhstatfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'fhstatfs64' is the same as 'fhstatfs', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,30 @@
++/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++PSEUDO (__libc_fork, fork, 0)
++	/* In the parent process, a4 == 0, v0 == child pid.  */
++	/* In the child process, a4 == 1, v0 == parent pid.  */
++	cmovne a4, zero, v0
++	ret
++
++PSEUDO_END (__libc_fork)
++
++weak_alias (__libc_fork, __fork)
++weak_alias (__fork, fork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fpu.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fpu.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fpu.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fpu.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,128 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _FPU_H
++#define _FPU_H	1
++
++
++/* Usage of the fpcr register.
++   The rounding mode bits (in FPCR_DYN_MASK) can be modified in user mode
++   and will be preserved by the kernel when a software assisted floating-
++   point operation or an exception occurs.  All other bits will be set by
++   the kernel when a software assisted floating-point operation or an
++   exception occurs.  */
++
++#if 0 /* Only Linux, not FreeBSD */
++#define FPCR_DNOD	(1UL<<47)	/* denorm INV trap disable */
++#define FPCR_DNZ	(1UL<<48)	/* denorms to zero */
++#endif
++#define FPCR_INVD	(1UL<<49)	/* invalid op disable (opt.) */
++#define FPCR_DZED	(1UL<<50)	/* division by zero disable (opt.) */
++#define FPCR_OVFD	(1UL<<51)	/* overflow disable (optional) */
++#define FPCR_INV	(1UL<<52)	/* invalid operation */
++#define FPCR_DZE	(1UL<<53)	/* division by zero */
++#define FPCR_OVF	(1UL<<54)	/* overflow */
++#define FPCR_UNF	(1UL<<55)	/* underflow */
++#define FPCR_INE	(1UL<<56)	/* inexact */
++#define FPCR_IOV	(1UL<<57)	/* integer overflow */
++#define FPCR_UNDZ	(1UL<<60)	/* underflow to zero (opt.) */
++#define FPCR_UNFD	(1UL<<61)	/* underflow disable (opt.) */
++#define FPCR_INED	(1UL<<62)	/* inexact disable (opt.) */
++#define FPCR_SUM	(1UL<<63)	/* summary bit, an OR of bits 52..56 */
++
++#define FPCR_DYN_SHIFT	58		/* first dynamic rounding mode bit */
++#define FPCR_DYN_CHOPPED (0x0UL << FPCR_DYN_SHIFT)	/* towards 0 */
++#define FPCR_DYN_MINUS	 (0x1UL << FPCR_DYN_SHIFT)	/* towards -INF */
++#define FPCR_DYN_NORMAL	 (0x2UL << FPCR_DYN_SHIFT)	/* towards nearest */
++#define FPCR_DYN_PLUS	 (0x3UL << FPCR_DYN_SHIFT)	/* towards +INF */
++#define FPCR_DYN_MASK	 (0x3UL << FPCR_DYN_SHIFT)
++
++#define FPCR_MASK	0xffff800000000000
++
++
++/* IEEE traps are enabled depending on a control word (not to be confused
++   with fpcr!) which can be read using __ieee_get_fp_control() and written
++   using __ieee_set_fp_control().  The bits in these control word are
++   as follows (compatible with Linux and OSF/1).  */
++
++/* Trap enable bits.  Get copied (inverted) to bits 49,50,51,61,62,47
++   of fpcr in the kernel.  */
++#define IEEE_TRAP_ENABLE_INV	(1UL<<1)	/* invalid op */
++#define IEEE_TRAP_ENABLE_DZE	(1UL<<2)	/* division by zero */
++#define IEEE_TRAP_ENABLE_OVF	(1UL<<3)	/* overflow */
++#define IEEE_TRAP_ENABLE_UNF	(1UL<<4)	/* underflow */
++#define IEEE_TRAP_ENABLE_INE	(1UL<<5)	/* inexact */
++#if 0 /* Only Linux, not FreeBSD */
++#define IEEE_TRAP_ENABLE_DNO	(1UL<<6)	/* denorm */
++#endif
++#define IEEE_TRAP_ENABLE_MASK	(IEEE_TRAP_ENABLE_INV | IEEE_TRAP_ENABLE_DZE |\
++				 IEEE_TRAP_ENABLE_OVF | IEEE_TRAP_ENABLE_UNF |\
++				 IEEE_TRAP_ENABLE_INE/*| IEEE_TRAP_ENABLE_DNO*/)
++
++#if 0 /* Only Linux, not FreeBSD */
++
++/* Denorm and Underflow flushing. */
++/* Get copied to bits 48,60 of fpcr in the kernel.  */
++#define IEEE_MAP_DMZ		(1UL<<12)	/* Map denorm inputs to zero */
++#define IEEE_MAP_UMZ		(1UL<<13)	/* Map underflowed outputs to zero */
++
++#define IEEE_MAP_MASK		(IEEE_MAP_DMZ | IEEE_MAP_UMZ)
++
++#endif
++
++/* Status bits.  Get copied to bits 52,53,54,55,56 of fpcr in the kernel.  */
++#define IEEE_STATUS_INV		(1UL<<17)	/* invalid op */
++#define IEEE_STATUS_DZE		(1UL<<18)	/* division by zero */
++#define IEEE_STATUS_OVF		(1UL<<19)	/* overflow */
++#define IEEE_STATUS_UNF		(1UL<<20)	/* underflow */
++#define IEEE_STATUS_INE		(1UL<<21)	/* inexact */
++#if 0 /* Only Linux, not FreeBSD */
++#define IEEE_STATUS_DNO		(1UL<<22)	/* denorm */
++#endif
++
++#define IEEE_STATUS_MASK	(IEEE_STATUS_INV | IEEE_STATUS_DZE |	\
++				 IEEE_STATUS_OVF | IEEE_STATUS_UNF |	\
++				 IEEE_STATUS_INE /* | IEEE_STATUS_DNO */)
++
++#define IEEE_SW_MASK		(IEEE_TRAP_ENABLE_MASK |		\
++				 IEEE_STATUS_MASK /* | IEEE_MAP_MASK */)
++
++#if 0 /* Only Linux, not FreeBSD */
++
++#define IEEE_CURRENT_RM_SHIFT	32
++#define IEEE_CURRENT_RM_MASK	(3UL<<IEEE_CURRENT_RM_SHIFT)
++
++#endif
++
++#define IEEE_INHERIT    (1UL<<63)	/* inherit on thread create? */
++
++
++#if 0 /* Unused.  */
++
++/* Exception summary bits.  */
++#define EXCSUM_SWC	(1LL << 0)	/* Software completion */
++#define EXCSUM_INV	(1LL << 1)	/* Invalid operation */
++#define EXCSUM_DZE	(1LL << 2)	/* Division by zero */
++#define EXCSUM_OVF	(1LL << 3)	/* Overflow */
++#define EXCSUM_UNF	(1LL << 4)	/* Underflow */
++#define EXCSUM_INE	(1LL << 5)	/* Inexact result */
++#define EXCSUM_IOV	(1LL << 6)	/* Integer overflow */
++
++#endif
++
++#endif /* _FPU_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fstatfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fstatfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fstatfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'fstatfs64' is the same as 'fstatfs', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getfsstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getfsstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getfsstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getfsstat64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'getfsstat64' is the same as 'getfsstat', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'getmntinfo64' is the same as 'getmntinfo', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,8 @@
++/* 'getmntinfo64' is the same as 'getmntinfo', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
++
++#define getmntinfo64 __no_getmntinfo64_decl
++#include <sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c>
++#undef getmntinfo64
++
++weak_alias (__getmntinfo, getmntinfo64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_get_fp_control.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_get_fp_control.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_get_fp_control.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_get_fp_control.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,35 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysarch.h>
++#include <stdlib.h>
++
++unsigned long
++__ieee_get_fp_control (void)
++{
++  /* The Alpha hardware requires this to be a system call.  */
++  unsigned long word;
++
++  if (__sysarch (ALPHA_GET_FPMASK, &word) < 0)
++    abort ();
++
++  return word;
++}
++
++weak_alias (__ieee_get_fp_control, ieee_get_fp_control)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_set_fp_control.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_set_fp_control.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_set_fp_control.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_set_fp_control.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,33 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysarch.h>
++#include <stdlib.h>
++
++void
++__ieee_set_fp_control (unsigned long trap_enable_mask)
++{
++  /* The Alpha hardware requires this to be a system call.  */
++  unsigned long word = trap_enable_mask;
++
++  if (__sysarch (ALPHA_SET_FPMASK, &word) < 0)
++    abort ();
++}
++
++weak_alias (__ieee_set_fp_control, ieee_set_fp_control)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Implies sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Implies
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Implies	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Implies	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,6 @@
++# The kernel include files come from the 'kernel-include' add-on.
++# This is actually added by configure.in.
++#/usr/src/kfreebsd-headers/alpha
++
++# Turn 32-bit __kernel_time_t into 64-bit __time_t.
++unix/bsd/bsd4.4/kfreebsd/time-64
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ldsodefs.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ldsodefs.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ldsodefs.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Run-time dynamic linker definitions for FreeBSD/alpha.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_LDSODEFS_H
++
++/* Get the real definitions.  */
++#include_next <ldsodefs.h>
++
++/* Now define our stuff.  */
++
++/* The value of the floating-point control word, at the moment the kernel
++   passes control to the program.  Cf. <fpu_control.h> for the meaning of
++   each bit.  */
++#define _FPU_INITIAL 0x1340	/* FIXME: Not sure about bits 5..0 */
++
++#endif /* ldsodefs.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/machine/pal.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/machine/pal.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/machine/pal.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/machine/pal.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,57 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* Unprivileged PAL function codes.  (The PAL codes which require
++   privileges are useful in the kernel only.)  */
++
++/* Common PAL codes.  */
++#define PAL_bpt		128
++#define PAL_bugchk	129
++#define PAL_callsys	131
++#define PAL_imb		134
++#define PAL_rduniq	158
++#define PAL_wruniq	159
++#define PAL_gentrap	170
++#define PAL_nphalt	190
++
++/* gentrap causes.  */
++#define GEN_INTOVF	-1	/* integer overflow */
++#define GEN_INTDIV	-2	/* integer division by zero */
++#define GEN_FLTOVF	-3	/* fp overflow */
++#define GEN_FLTDIV	-4	/* fp division by zero */
++#define GEN_FLTUND	-5	/* fp underflow */
++#define GEN_FLTINV	-6	/* invalid fp operand */
++#define GEN_FLTINE	-7	/* inexact fp operand */
++#define GEN_DECOVF	-8	/* decimal overflow (for COBOL??) */
++#define GEN_DECDIV	-9	/* decimal division by zero */
++#define GEN_DECINV	-10	/* invalid decimal operand */
++#define GEN_ROPRAND	-11	/* reserved operand */
++#define GEN_ASSERTERR	-12	/* assertion error */
++#define GEN_NULPTRERR	-13	/* null pointer error */
++#define GEN_STKOVF	-14	/* stack overflow */
++#define GEN_STRLENERR	-15	/* string length error */
++#define GEN_SUBSTRERR	-16	/* substring error */
++#define GEN_RANGERR	-17	/* range error */
++#define GEN_SUBRNG	-18
++#define GEN_SUBRNG1	-19	 
++#define GEN_SUBRNG2	-20
++#define GEN_SUBRNG3	-21	/* these report range errors for */
++#define GEN_SUBRNG4	-22	/* subscripting (indexing) at levels 0..7 */
++#define GEN_SUBRNG5	-23
++#define GEN_SUBRNG6	-24
++#define GEN_SUBRNG7	-25
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Makefile sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Makefile
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Makefile	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,16 @@
++# Additional header files to be installed in $prefix/include:
++
++ifeq ($(subdir),misc)
++sysdep_headers += \
++ machine/pal.h
++endif
++
++# Additional functions, and particular system calls:
++
++ifeq ($(subdir),io)
++sysdep_routines += sys_poll
++endif
++
++ifeq ($(subdir),math)
++sysdep_routines += ieee_get_fp_control ieee_set_fp_control
++endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/poll.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/poll.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/poll.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/poll.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,46 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/poll.h>
++#include <sysdep.h>
++#include <errno.h>
++
++/* nfds_t is defined as 'unsigned long int' in <sys/poll.h>, but the poll
++   system call expects an 'unsigned int' as second argument.  */
++
++extern int __syscall_poll (struct pollfd *fds, unsigned int nfds, int timeout);
++
++int
++__poll (struct pollfd *fds, nfds_t nfds, int timeout)
++{
++  unsigned int infds = nfds;
++
++  if (infds == nfds)
++    return INLINE_SYSCALL (poll, 3, fds, infds, timeout);
++  else
++    {
++      /* NFDS doesn't fit into an unsigned int.  FDS cannot point to such
++	 a big chunk of valid memory.  */
++      __set_errno (EFAULT);
++      return -1;
++    }
++}
++libc_hidden_def (__poll)
++
++weak_alias (__poll, poll)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/README sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/README
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/README	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/README	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++Note that even on 64-bit platforms, because __ino64_t != __ino_t, we have
++stat64 != stat, fstat64 != fstat, lstat64 != lstat, fhstat64 != fhstat,
++glob64 != glob.
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/regdef.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/regdef.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/regdef.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/regdef.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,62 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _REGDEF_H
++#define _REGDEF_H
++
++/* Common symbolic names for Alpha registers.
++   Names taken from binutils/opcodes/alpha-dis.c.
++   Register usage info taken from gcc-3.1/gcc/config/alpha/alpha.h.
++   NB: "saved" = "call-saved", "nonsaved" = "call-used".  */
++
++#define v0	$0	/* nonsaved, first return value */
++#define t0	$1	/* nonsaved, second return value, lexical closure reg */
++#define t1	$2	/* nonsaved */
++#define t2	$3	/* nonsaved */
++#define t3	$4	/* nonsaved */
++#define t4	$5	/* nonsaved */
++#define t5	$6	/* nonsaved */
++#define t6	$7	/* nonsaved */
++#define t7	$8	/* nonsaved */
++#define s0	$9	/* saved */
++#define s1	$10	/* saved */
++#define s2	$11	/* saved */
++#define s3	$12	/* saved */
++#define s4	$13	/* saved */
++#define s5	$14	/* saved */
++#define s6	$15	/* use only in leaf functions without frame pointer */
++#define fp	$15	/* frame pointer */
++#define a0	$16	/* nonsaved, argument 1 */
++#define a1	$17	/* nonsaved, argument 2 */
++#define a2	$18	/* nonsaved, argument 3 */
++#define a3	$19	/* nonsaved, argument 4 */
++#define a4	$20	/* nonsaved, argument 5 */
++#define a5	$21	/* nonsaved, argument 6 */
++#define t8	$22	/* nonsaved */
++#define t9	$23	/* nonsaved */
++#define t10	$24	/* nonsaved */
++#define t11	$25	/* nonsaved */
++#define ra	$26	/* return address */
++#define t12	$27	/* current function's address */
++#define pv	$27	/* current function's address */
++#define AT	$28	/* nonsaved, assembler temporary */
++#define gp	$29	/* global pointer */
++#define sp	$30	/* stack pointer */
++#define zero	$31	/* reads as zero, writes go to /dev/null */
++
++#endif /* _REGDEF_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/rfork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/rfork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/rfork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/rfork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,29 @@
++/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++SYSCALL__ (rfork, 0)
++	/* In the parent process, a4 == 0, v0 == child pid.  */
++	/* In the child process, a4 == 1, v0 == parent pid.  */
++	cmovne a4, zero, v0
++	ret
++
++PSEUDO_END (__rfork)
++
++weak_alias (__rfork, rfork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setfpucw.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setfpucw.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setfpucw.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setfpucw.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,88 @@
++/* Set FP exception mask and rounding mode.
++   Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <fpu_control.h>
++#include <fpu.h>
++
++extern unsigned long __ieee_get_fp_control (void);
++extern void __ieee_set_fp_control (unsigned long);
++
++
++static inline unsigned long
++rdfpcr (void)
++{
++  unsigned long fpcr;
++  asm ("excb; mf_fpcr %0" : "=f"(fpcr));
++  return fpcr;
++}
++
++static inline void
++wrfpcr (unsigned long fpcr)
++{
++  asm volatile ("mt_fpcr %0; excb" : : "f"(fpcr));
++}
++
++
++void
++__setfpucw (fpu_control_t fpu_control)
++{
++  if (!fpu_control)
++    fpu_control = _FPU_DEFAULT;
++
++  /* Note that the fpu_control argument, as defined in <fpu_control.h>,
++     consists of bits that are not directly related to the bits of the
++     fpcr and fp_control registers.  In particular, the precision control
++     (_FPU_EXTENDED, _FPU_DOUBLE, _FPU_SINGLE) and the interrupt mask
++     _FPU_MASK_UM are without effect.  */
++
++  /* First, set dynamic rounding mode: */
++  {
++    unsigned long fpcr;
++
++    fpcr = rdfpcr();
++    fpcr &= ~FPCR_DYN_MASK;
++    switch (fpu_control & 0xc00)
++      {
++      case _FPU_RC_NEAREST:	fpcr |= FPCR_DYN_NORMAL; break;
++      case _FPU_RC_DOWN:	fpcr |= FPCR_DYN_MINUS; break;
++      case _FPU_RC_UP:		fpcr |= FPCR_DYN_PLUS; break;
++      case _FPU_RC_ZERO:	fpcr |= FPCR_DYN_CHOPPED; break;
++      }
++    wrfpcr(fpcr);
++  }
++
++  /* Now tell kernel about traps that we like to hear about: */
++  {
++    unsigned long old_fpcw, fpcw;
++
++    old_fpcw = fpcw = __ieee_get_fp_control ();
++    fpcw &= ~IEEE_TRAP_ENABLE_MASK;
++
++    if (!(fpu_control & _FPU_MASK_IM)) fpcw |= IEEE_TRAP_ENABLE_INV;
++    if (!(fpu_control & _FPU_MASK_DM)) fpcw |= IEEE_TRAP_ENABLE_UNF;
++    if (!(fpu_control & _FPU_MASK_ZM)) fpcw |= IEEE_TRAP_ENABLE_DZE;
++    if (!(fpu_control & _FPU_MASK_OM)) fpcw |= IEEE_TRAP_ENABLE_OVF;
++    if (!(fpu_control & _FPU_MASK_PM)) fpcw |= IEEE_TRAP_ENABLE_INE;
++
++    if (fpcw != old_fpcw)
++      __ieee_set_fp_control (fpcw);
++  }
++
++  __fpu_control = fpu_control;	/* update global copy */
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sigcontextinfo.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sigcontextinfo.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sigcontextinfo.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sigcontextinfo.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,25 @@
++/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#define SIGCONTEXT int _code, struct sigcontext *
++#define SIGCONTEXT_EXTRA_ARGS _code,
++#define GET_PC(ctx)	((void *) (ctx)->sc_pc)
++#define GET_FRAME(ctx)	((void *) (ctx)->sc_regs[15])
++#define GET_STACK(ctx)	((void *) (ctx)->sc_regs[30])
++#define CALL_SIGHANDLER(handler, signo, ctx) \
++  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/start_thread.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/start_thread.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/start_thread.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/start_thread.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,172 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* __start_thread (flags, stack, func, arg)
++   calls __rfork (flags), and in the child sets the stack pointer and then
++   calls _exit (func (arg)).
++   It cannot be done in portable C.  */
++
++#include <sysdep.h>
++#define SIG_SETMASK	3
++
++	.text
++ENTRY (__start_thread)
++	/* There is a window of a few instructions, right after the rfork
++	   system call, where the handling of a signal would write garbage
++	   into the stack shared by the parent and the child (assuming
++	   RFMEM is set in flags).  To solve this: 1. We block all signals
++	   around the rfork system call and unblock them afterwards in
++	   the parent and in the child (but only after changing the stack
++	   pointer).  2. The child accesses only values passed in registers
++	   and on its own stack.  This way, if the parent is scheduled to
++	   run first, and handles a signal, it will not affect the child;
++	   and if the child runs first, and handles a signal, it will use
++	   the child's stack and not affect the parent.
++	   We need to pass 7 words of info to the child: stack, func, arg,
++	   and the signal mask to restore.  Since we have only 4 call-saved
++	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
++	   stack pointer in a register, and the rest through the child's
++	   stack.  */
++	lda	sp,-56(sp)
++	stq	ra,0(sp)
++	stq	s0,8(sp)
++	stq	s1,16(sp)
++	stq	s2,24(sp)
++	stq	s3,32(sp)
++	.prologue 1
++
++	/* Save arguments.  */
++	mov	a0,s1		/* flags */
++	mov	a1,s0		/* stack */
++	mov	a2,s2		/* func */
++	mov	a3,s3		/* arg */
++
++	and	a0,32,t0	/* flags & RFMEM */
++	beq	t0,$simple
++
++	/* Block all signals.  */
++	lda	t0,-1
++	stq	t0,40(sp)
++	stq	t0,48(sp)
++	lda	a0,SIG_SETMASK
++	lda	a1,40(sp)
++	mov	a1,a2
++	lda	v0,SYS_sigprocmask
++	call_pal PAL_callsys
++	bne	a3,$error
++
++	/* Copy all info to the child's stack.  */
++	lda	s0,-32(s0)	/* room for func, arg, sigset_t */
++	andnot	s0,7,s0		/* make it 8-bytes aligned */
++	stq	s2,8(s0)	/* func */
++	stq	s3,0(s0)	/* arg */
++	ldq	t0,40(sp)	/* sigset_t word 0 */
++	ldq	t1,48(sp)	/* sigset_t word 1 */
++	stq	t0,16(s0)
++	stq	t1,24(s0)
++
++	/* Perform the rfork system call.  */
++	mov	s1,a0		/* flags */
++	lda	v0,SYS_rfork
++	call_pal PAL_callsys
++	bne	a3,$error
++
++	/* a4 is now 0 for the parent and 1 for the child.  */
++	bne	a4,$child
++
++	/* Save the child pid, currently in v0.  */
++	mov	v0,s1
++
++	/* Restore the previous signal mask.  */
++	lda	a0,SIG_SETMASK
++	lda	a1,40(sp)
++	mov	zero,a2
++	lda	v0,SYS_sigprocmask
++	call_pal PAL_callsys
++
++	/* Return the child pid, currently in s1.  */
++	mov	s1,v0
++$retv0:	ldq	ra,0(sp)
++	ldq	s0,8(sp)
++	ldq	s1,16(sp)
++	ldq	s2,24(sp)
++	ldq	s3,32(sp)
++	lda	sp,56(sp)
++	ret	zero,(ra),1
++
++$child:	/* Here we are in the child thread.  */
++
++	/* Set the stack pointer.  */
++	mov	s0,sp
++
++	/* Restore the previous signal mask.  */
++	lda	a0,SIG_SETMASK
++	lda	a1,16(sp)
++	mov	zero,a2
++	lda	v0,SYS_sigprocmask
++	call_pal PAL_callsys
++
++$child1:
++	/* Call func (arg).  */
++	ldq	a0,0(sp)
++	ldq	pv,8(sp)
++	jsr	ra,(pv),0
++
++	/* Tail-call _exit.  */
++	br	gp,$here
++$here:	ldgp	gp,0(gp)
++	mov	v0,a0
++	jmp	zero,_exit
++
++$simple:/* Simple case without signal mask handling.  */
++
++	/* Copy all info to the child's stack.  */
++	lda	s0,-16(s0)	/* room for func, arg */
++	andnot	s0,7,s0		/* make it 8-bytes aligned */
++	stq	s2,8(s0)	/* func */
++	stq	s3,0(s0)	/* arg */
++
++	/* Perform the rfork system call.  */
++	mov	s1,a0		/* flags */
++	lda	v0,SYS_rfork
++	call_pal PAL_callsys
++	bne	a3,$error
++
++	/* a4 is now 0 for the parent and 1 for the child.  */
++	/* If in the parent, return the child pid, currently in v0.  */
++	beq	a4,$retv0
++
++$simple_child:/* Here we are in the child thread.  */
++
++	/* Set the stack pointer.  */
++	mov	s0,sp
++
++	br	zero,$child1
++
++$error:	ldq	ra,0(sp)
++	ldq	s0,8(sp)
++	ldq	s1,16(sp)
++	ldq	s2,24(sp)
++	ldq	s3,32(sp)
++	lda	sp,56(sp)
++#if 0 /* Not needed: The PSEUDO_END expansion starts with this label.  */
++	br	zero,1996f
++#endif
++
++PSEUDO_END (__start_thread)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/statfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/statfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/statfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/statfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'statfs64' is the same as 'statfs', because
++   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysarch.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysarch.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysarch.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysarch.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Parameters for the architecture specific system call.  alpha version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYSARCH_H
++#define _SYSARCH_H	1
++
++#include <features.h>
++
++/* Function that can be used as first argument to 'sysarch'.  */
++enum
++  {
++    ALPHA_SETHAE = 0,
++#define ALPHA_SETHAE ALPHA_SETHAE
++    /* Arg is 'unsigned long *'.  Returns the current pcb_fp_control.  */
++    ALPHA_GET_FPMASK = 1,
++#define ALPHA_GET_FPMASK ALPHA_GET_FPMASK
++    /* Arg is 'unsigned long *'.  Sets the pcb_fp_control and returns its
++       old value in the same memory location.  */
++    ALPHA_SET_FPMASK = 2,
++#define ALPHA_SET_FPMASK ALPHA_SET_FPMASK
++    ALPHA_GET_UAC = 3,
++#define ALPHA_GET_UAC ALPHA_GET_UAC
++    ALPHA_SET_UAC = 4
++#define ALPHA_SET_UAC ALPHA_SET_UAC
++  };
++
++__BEGIN_DECLS
++
++extern int sysarch (int __cmd, void *__arg);
++
++#ifdef _LIBC
++extern int __sysarch (int __cmd, void *__arg);
++#endif
++
++__END_DECLS
++
++#endif /* _SYSARCH_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscall.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscall.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscall.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscall.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++#include <sysdeps/unix/sysv/linux/alpha/syscall.S>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscalls.list sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscalls.list
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscalls.list	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscalls.list	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,7 @@
++# File name	Caller	Syscall name	# args	Strong name	Weak names
++
++fhstatfs	-	fhstatfs	i:pp	__fhstatfs	fhstatfs fhstatfs64
++fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs __fstatfs64 fstatfs64
++getfsstat	-	getfsstat	i:pii	__getfsstat	getfsstat __getfsstat64 getfsstat64
++sys_poll	-	poll		i:pii	__syscall_poll
++statfs		-	statfs		i:sp	__statfs	statfs statfs64
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysdep.h sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysdep.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysdep.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysdep.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _FREEBSD_ALPHA_SYSDEP_H
++#define _FREEBSD_ALPHA_SYSDEP_H 1
++
++#ifdef __ASSEMBLER__
++#include <machine/pal.h>		/* get PAL_callsys */
++#endif
++
++#include <sysdeps/unix/alpha/sysdep.h>
++
++/* FIXME: Is this necessary?  */
++#undef INLINE_SYSCALL
++#define INLINE_SYSCALL(name, nr, args...) __syscall_##name(args)
++
++#endif /* freebsd/alpha/sysdep.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/vfork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/vfork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/vfork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/vfork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,29 @@
++/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++SYSCALL__ (vfork, 0)
++	/* In the parent process, a4 == 0, v0 == child pid.  */
++	/* In the child process, a4 == 1, v0 == parent pid.  */
++	cmovne a4, zero, v0
++	ret
++
++PSEUDO_END (__vfork)
++
++weak_alias (__vfork, vfork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,50 @@
++/* Directory entry structure `struct dirent'.  FreeBSD version.
++   Copyright (C) 1996-1998,2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _DIRENT_H
++# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
++#endif
++
++struct dirent
++  {
++    unsigned int d_fileno;	/* File serial number.  */
++    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
++    unsigned char d_type;	/* File type, possibly unknown.  */
++    unsigned char d_namlen;	/* Length of the file name.  */
++
++    /* Only this member is in the POSIX standard.  */
++    char d_name[1];		/* File name (actually longer).  */
++  };
++
++#ifdef __USE_LARGEFILE64
++struct dirent64
++  {
++    unsigned int d_fileno;	/* File serial number.  */
++    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
++    unsigned char d_type;	/* File type, possibly unknown.  */
++    unsigned char d_namlen;	/* Length of the file name.  */
++
++    /* Only this member is in the POSIX standard.  */
++    char d_name[1];		/* File name (actually longer).  */
++  };
++#endif
++
++#define _DIRENT_HAVE_D_RECLEN 1
++#define _DIRENT_HAVE_D_NAMLEN 1
++#define _DIRENT_HAVE_D_TYPE 1
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,142 @@
++/* O_*, F_*, FD_* bit values for FreeBSD.
++   Copyright (C) 1991-1992, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_FCNTL_H
++#error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
++#endif
++
++#include <sys/types.h>
++
++/* File access modes for `open' and `fcntl'.  */
++#define	O_RDONLY	0	/* Open read-only.  */
++#define	O_WRONLY	1	/* Open write-only.  */
++#define	O_RDWR		2	/* Open read/write.  */
++
++
++/* Bits OR'd into the second argument to open.  */
++#define	O_CREAT		0x0200	/* Create file if it doesn't exist.  */
++#define	O_EXCL		0x0800	/* Fail if file already exists.  */
++#define	O_TRUNC		0x0400	/* Truncate file to zero length.  */
++#define	O_NOCTTY	0x8000	/* Don't assign a controlling terminal.  */
++#ifdef	__USE_MISC
++#define	O_ASYNC		0x0040	/* Send SIGIO to owner when data is ready.  */
++#define	O_FSYNC		0x0080	/* Synchronous writes.  */
++#define	O_SYNC		O_FSYNC
++#define	O_SHLOCK	0x0010	/* Open with shared file lock.  */
++#define	O_EXLOCK	0x0020	/* Open with shared exclusive lock.  */
++#define O_NOFOLLOW	0x0100	/* Don't follow symlinks.  */
++#endif
++
++/* File status flags for `open' and `fcntl'.  */
++#define	O_APPEND	0x0008	/* Writes append to the file.  */
++#define	O_NONBLOCK	0x0004	/* Non-blocking I/O.  */
++
++#ifdef __USE_BSD
++#define	O_NDELAY	O_NONBLOCK
++#endif
++
++/* Since 'off_t' is 64-bit, O_LARGEFILE is a no-op.  */
++#define O_LARGEFILE	0
++
++/* FreeBSD doesn't have smaller grained synchronicity control than per file.
++   fdatasync() is equivalent to fsync(), so we define O_DSYNC == O_SYNC.  */
++#if defined __USE_POSIX199309 || defined __USE_UNIX98
++# define O_DSYNC	O_SYNC	/* Synchronize data.  */
++# define O_RSYNC	O_SYNC	/* Synchronize read operations.  */
++#endif
++
++#ifdef __USE_BSD
++/* Bits in the file status flags returned by F_GETFL.
++   These are all the O_* flags, plus FREAD and FWRITE, which are
++   independent bits set by which of O_RDONLY, O_WRONLY, and O_RDWR, was
++   given to `open'.  */
++#define FREAD		1
++#define	FWRITE		2
++
++/* Traditional BSD names the O_* bits.  */
++#define FASYNC		O_ASYNC
++#define FCREAT		O_CREAT
++#define FEXCL		O_EXCL
++#define FTRUNC		O_TRUNC
++#define FNOCTTY		O_NOCTTY
++#define FFSYNC		O_FSYNC
++#define FSYNC		O_SYNC
++#define FAPPEND		O_APPEND
++#define FNONBLOCK	O_NONBLOCK
++#define FNDELAY		O_NDELAY
++#endif
++
++/* Mask for file access modes.  This is system-dependent in case
++   some system ever wants to define some other flavor of access.  */
++#define	O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
++
++/* Values for the second argument to `fcntl'.  */
++#define	F_DUPFD	  	0	/* Duplicate file descriptor.  */
++#define	F_GETFD		1	/* Get file descriptor flags.  */
++#define	F_SETFD		2	/* Set file descriptor flags.  */
++#define	F_GETFL		3	/* Get file status flags.  */
++#define	F_SETFL		4	/* Set file status flags.  */
++#ifdef __USE_BSD
++#define	F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
++#define	F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
++#endif
++#define	F_GETLK		7	/* Get record locking info.  */
++#define	F_SETLK		8	/* Set record locking info (non-blocking).  */
++#define	F_SETLKW	9	/* Set record locking info (blocking).  */
++
++/* File descriptor flags used with F_GETFD and F_SETFD.  */
++#define	FD_CLOEXEC	1	/* Close on exec.  */
++
++
++#include <bits/types.h>
++
++/* The structure describing an advisory lock.  This is the type of the third
++   argument to `fcntl' for the F_GETLK, F_SETLK, and F_SETLKW requests.  */
++struct flock
++  {
++    __off_t l_start;	/* Offset where the lock begins.  */
++    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
++    __pid_t l_pid;	/* Process holding the lock.  */
++    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
++    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
++  };
++
++#ifdef __USE_LARGEFILE64
++struct flock64
++  {
++    __off64_t l_start;	/* Offset where the lock begins.  */
++    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
++    __pid_t l_pid;	/* Process holding the lock.  */
++    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
++    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
++  };
++#endif
++
++/* Values for the `l_type' field of a `struct flock'.  */
++#define	F_RDLCK	1	/* Read lock.  */
++#define	F_WRLCK	3	/* Write lock.  */
++#define	F_UNLCK	2	/* Remove lock.  */
++
++#ifdef __USE_BSD
++/* Operations for flock().  */
++# define LOCK_SH 1	/* shared lock */
++# define LOCK_EX 2	/* exclusive lock */
++# define LOCK_NB 4	/* or'd with one of the above to prevent blocking */
++# define LOCK_UN 8	/* remove lock */
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,149 @@
++/* Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* FreeBSD version.  */
++
++#ifndef _NETINET_IN_H
++# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
++#endif
++
++
++/* Link numbers.  */
++#define	IMPLINK_IP		155
++#define	IMPLINK_LOWEXPER	156
++#define	IMPLINK_HIGHEXPER	158
++
++
++/* Options for use with `getsockopt' and `setsockopt' at the IP level.
++   The first word in the comment at the right is the data type used;
++   "bool" means a boolean value stored in an `int'.  */
++#define	IP_OPTIONS	1	/* ip_opts; IP per-packet options.  */
++#define	IP_HDRINCL	2	/* int; Header is included with data.  */
++#define	IP_TOS		3	/* int; IP type of service and precedence.  */
++#define	IP_TTL		4	/* int; IP time to live.  */
++#define	IP_RECVOPTS	5	/* bool; Receive all IP options w/datagram.  */
++#define	IP_RECVRETOPTS	6	/* bool; Receive IP options for response.  */
++#define	IP_RECVDSTADDR	7	/* bool; Receive IP dst addr w/datagram.  */
++#define	IP_RETOPTS	8	/* ip_opts; Set/get IP per-packet options.  */
++#define IP_MULTICAST_IF 9	/* in_addr; set/get IP multicast i/f */
++#define IP_MULTICAST_TTL 10	/* u_char; set/get IP multicast ttl */
++#define IP_MULTICAST_LOOP 11	/* i_char; set/get IP multicast loopback */
++#define IP_ADD_MEMBERSHIP 12	/* ip_mreq; add an IP group membership */
++#define IP_DROP_MEMBERSHIP 13	/* ip_mreq; drop an IP group membership */
++#define IP_MULTICAST_VIF 14	/* set/get IP mcast virt. iface */
++#define IP_RSVP_ON	15	/* enable RSVP in kernel */
++#define IP_RSVP_OFF	16	/* disable RSVP in kernel */
++#define IP_RSVP_VIF_ON	17	/* set RSVP per-vif socket */
++#define IP_RSVP_VIF_OFF	18	/* unset RSVP per-vif socket */
++#define IP_PORTRANGE	19	/* int; range to choose for unspec port */
++#define	IP_RECVIF	20	/* bool; receive reception if w/dgram */
++/* for IPSEC */
++#define	IP_IPSEC_POLICY	21	/* int; set/get security policy */
++#define	IP_FAITH	22	/* bool; accept FAITH'ed connections */
++
++#define	IP_FW_ADD    	50	/* add a firewall rule to chain */
++#define	IP_FW_DEL    	51	/* delete a firewall rule from chain */
++#define	IP_FW_FLUSH   	52	/* flush firewall rule chain */
++#define	IP_FW_ZERO    	53	/* clear single/all firewall counter(s) */
++#define	IP_FW_GET     	54	/* get entire firewall rule chain */
++#define	IP_FW_RESETLOG	55	/* reset logging counters */
++
++#define	IP_DUMMYNET_CONFIGURE	60	/* add/configure a dummynet pipe */
++#define	IP_DUMMYNET_DEL		61	/* delete a dummynet pipe from chain */
++#define	IP_DUMMYNET_FLUSH	62	/* flush dummynet */
++#define	IP_DUMMYNET_GET		64	/* get entire dummynet pipes */
++
++/*
++ * Defaults and limits for options
++ */
++#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
++#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
++#define	IP_MAX_MEMBERSHIPS	20	/* per socket */
++
++/*
++ * Argument for IP_PORTRANGE:
++ * - which range to search when port is unspecified at bind() or connect()
++ */
++#define	IP_PORTRANGE_DEFAULT	0	/* default range */
++#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
++#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
++
++/*
++ * Names for IP sysctl objects
++ */
++#define	IPCTL_FORWARDING	1	/* act as router */
++#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
++#define	IPCTL_DEFTTL		3	/* default TTL */
++#ifdef notyet
++#define	IPCTL_DEFMTU		4	/* default MTU */
++#endif
++#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
++#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
++#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
++#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
++#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
++#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
++#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
++#define	IPCTL_STATS		12	/* ipstat structure */
++#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
++#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
++#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
++#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
++#define	IPCTL_MAXID		17
++
++/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
++   The `ip_dst' field is used for the first-hop gateway when using a
++   source route (this gets put into the header proper).  */
++struct ip_opts
++  {
++    struct in_addr ip_dst;	/* First hop; zero without source route.  */
++    char ip_opts[40];		/* Actually variable in size.  */
++  };
++
++/* IPV6 socket options.  */
++#define IPV6_ADDRFORM		1
++#define IPV6_RXINFO		2
++#define IPV6_HOPOPTS		3
++#define IPV6_DSTOPTS		4
++#define IPV6_RTHDR		5
++#define IPV6_PKTOPTIONS		6
++#define IPV6_CHECKSUM		7
++#define IPV6_HOPLIMIT		8
++
++#define IPV6_TXINFO		IPV6_RXINFO
++#define SCM_SRCINFO		IPV6_TXINFO
++#define SCM_SRCRT		IPV6_RXSRCRT
++
++#define IPV6_UNICAST_HOPS	16
++#define IPV6_MULTICAST_IF	17
++#define IPV6_MULTICAST_HOPS	18
++#define IPV6_MULTICAST_LOOP	19
++#define IPV6_JOIN_GROUP		20
++#define IPV6_LEAVE_GROUP	21
++
++/* Obsolete synonyms for the above.  */
++#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
++#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
++#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
++#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
++
++/* Routing header options for IPv6.  */
++#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
++#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
++
++#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,365 @@
++/*-
++ * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
++ */
++
++#ifndef	_IOCTLS_H_
++#define	_IOCTLS_H_
++
++/*
++ *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
++ */
++
++/*
++ * Ioctl's have the command encoded in the lower word, and the size of
++ * any in or out parameters in the upper word.  The high 3 bits of the
++ * upper word are used to encode the in/out status of the parameter.
++ */
++#define	IOCPARM_MASK	0x1fff		/* parameter length, at most 13 bits */
++#define	IOCPARM_LEN(x)	(((x) >> 16) & IOCPARM_MASK)
++#define	IOCBASECMD(x)	((x) & ~(IOCPARM_MASK << 16))
++#define	IOCGROUP(x)	(((x) >> 8) & 0xff)
++
++#define	IOCPARM_MAX	NBPG		/* max size of ioctl, mult. of NBPG */
++#define	IOC_VOID	0x20000000	/* no parameters */
++#define	IOC_OUT		0x40000000	/* copy out parameters */
++#define	IOC_IN		0x80000000	/* copy in parameters */
++#define	IOC_INOUT	(IOC_IN|IOC_OUT)
++#define	IOC_DIRMASK	0xe0000000	/* mask for IN/OUT/VOID */
++
++#define	_IOC(inout,group,num,len) \
++	((unsigned long)(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num)))
++#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
++#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
++#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
++/* this should be _IORW, but stdio got there first */
++#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
++
++/*
++ *	@(#)ttycom.h	8.1 (Berkeley) 3/28/94
++ */
++
++#define	TIOCMODG	_IOR('t', 3, int)	/* get modem control state */
++#define	TIOCMODS	_IOW('t', 4, int)	/* set modem control state */
++#define		TIOCM_LE	0001		/* line enable */
++#define		TIOCM_DTR	0002		/* data terminal ready */
++#define		TIOCM_RTS	0004		/* request to send */
++#define		TIOCM_ST	0010		/* secondary transmit */
++#define		TIOCM_SR	0020		/* secondary receive */
++#define		TIOCM_CTS	0040		/* clear to send */
++#define		TIOCM_CAR	0100		/* carrier detect */
++#define		TIOCM_CD	TIOCM_CAR
++#define		TIOCM_RNG	0200		/* ring */
++#define		TIOCM_RI	TIOCM_RNG
++#define		TIOCM_DSR	0400		/* data set ready */
++						/* 8-10 compat */
++#define	TIOCEXCL	 _IO('t', 13)		/* set exclusive use of tty */
++#define	TIOCNXCL	 _IO('t', 14)		/* reset exclusive use of tty */
++						/* 15 unused */
++#define	TIOCFLUSH	_IOW('t', 16, int)	/* flush buffers */
++						/* 17-18 compat */
++#define	TIOCGETA	_IOR('t', 19, struct termios) /* get termios struct */
++#define	TIOCSETA	_IOW('t', 20, struct termios) /* set termios struct */
++#define	TIOCSETAW	_IOW('t', 21, struct termios) /* drain output, set */
++#define	TIOCSETAF	_IOW('t', 22, struct termios) /* drn out, fls in, set */
++#define	TIOCGETD	_IOR('t', 26, int)	/* get line discipline */
++#define	TIOCSETD	_IOW('t', 27, int)	/* set line discipline */
++						/* 127-124 compat */
++#define	TIOCSBRK	 _IO('t', 123)		/* set break bit */
++#define	TIOCCBRK	 _IO('t', 122)		/* clear break bit */
++#define	TIOCSDTR	 _IO('t', 121)		/* set data terminal ready */
++#define	TIOCCDTR	 _IO('t', 120)		/* clear data terminal ready */
++#define	TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
++#define	TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
++						/* 117-116 compat */
++#define	TIOCOUTQ	_IOR('t', 115, int)	/* output queue size */
++#define	TIOCSTI		_IOW('t', 114, char)	/* simulate terminal input */
++#define	TIOCNOTTY	 _IO('t', 113)		/* void tty association */
++#define	TIOCPKT		_IOW('t', 112, int)	/* pty: set/clear packet mode */
++#define		TIOCPKT_DATA		0x00	/* data packet */
++#define		TIOCPKT_FLUSHREAD	0x01	/* flush packet */
++#define		TIOCPKT_FLUSHWRITE	0x02	/* flush packet */
++#define		TIOCPKT_STOP		0x04	/* stop output */
++#define		TIOCPKT_START		0x08	/* start output */
++#define		TIOCPKT_NOSTOP		0x10	/* no more ^S, ^Q */
++#define		TIOCPKT_DOSTOP		0x20	/* now do ^S ^Q */
++#define		TIOCPKT_IOCTL		0x40	/* state change of pty driver */
++#define	TIOCSTOP	 _IO('t', 111)		/* stop output, like ^S */
++#define	TIOCSTART	 _IO('t', 110)		/* start output, like ^Q */
++#define	TIOCMSET	_IOW('t', 109, int)	/* set all modem bits */
++#define	TIOCMBIS	_IOW('t', 108, int)	/* bis modem bits */
++#define	TIOCMBIC	_IOW('t', 107, int)	/* bic modem bits */
++#define	TIOCMGET	_IOR('t', 106, int)	/* get all modem bits */
++#define	TIOCREMOTE	_IOW('t', 105, int)	/* remote input editing */
++#define	TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
++#define	TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
++#define	TIOCUCNTL	_IOW('t', 102, int)	/* pty: set/clr usr cntl mode */
++#define	TIOCSTAT	 _IO('t', 101)		/* simulate ^T status message */
++#define		UIOCCMD(n)	_IO('u', n)	/* usr cntl op "n" */
++#define	TIOCCONS	_IOW('t', 98, int)	/* become virtual console */
++#define	TIOCSCTTY	 _IO('t', 97)		/* become controlling tty */
++#define	TIOCEXT		_IOW('t', 96, int)	/* pty: external processing */
++#define	TIOCSIG		 _IO('t', 95)		/* pty: generate signal */
++#define	TIOCDRAIN	 _IO('t', 94)		/* wait till output drained */
++#define	TIOCMSDTRWAIT	_IOW('t', 91, int)	/* modem: set wait on close */
++#define	TIOCMGDTRWAIT	_IOR('t', 90, int)	/* modem: get wait on close */
++#define	TIOCTIMESTAMP	_IOR('t', 89, struct timeval)	/* enable/get timestamp
++						 * of last input event */
++#define	TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)	/* enable/get timestamp
++						 * of last DCd rise */
++#define	TIOCSDRAINWAIT	_IOW('t', 87, int)	/* set ttywait timeout */
++#define	TIOCGDRAINWAIT	_IOR('t', 86, int)	/* get ttywait timeout */
++
++#define	TTYDISC		0		/* termios tty line discipline */
++#define	SLIPDISC	4		/* serial IP discipline */
++#define	PPPDISC		5		/* PPP discipline */
++#define	NETGRAPHDISC	6		/* Netgraph tty node discipline */
++
++/*
++ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
++ */
++
++#define	TIOCGSIZE	TIOCGWINSZ
++#define	TIOCSSIZE	TIOCSWINSZ
++
++/*
++ *	@(#)filio.h	8.1 (Berkeley) 3/28/94
++ */
++
++/* Generic file-descriptor ioctl's. */
++#define	FIOCLEX		 _IO('f', 1)		/* set close on exec on fd */
++#define	FIONCLEX	 _IO('f', 2)		/* remove close on exec */
++#define	FIONREAD	_IOR('f', 127, int)	/* get # bytes to read */
++#define	FIONBIO		_IOW('f', 126, int)	/* set/clear non-blocking i/o */
++#define	FIOASYNC	_IOW('f', 125, int)	/* set/clear async i/o */
++#define	FIOSETOWN	_IOW('f', 124, int)	/* set owner */
++#define	FIOGETOWN	_IOR('f', 123, int)	/* get owner */
++#define	FIODTYPE	_IOR('f', 122, int)	/* get d_flags type part */
++#define	FIOGETLBA	_IOR('f', 121, int)	/* get start blk # */
++
++/*
++ *	@(#)sockio.h	8.1 (Berkeley) 3/28/94
++ */
++
++/* Socket ioctl's. */
++#define	SIOCSHIWAT	 _IOW('s',  0, int)		/* set high watermark */
++#define	SIOCGHIWAT	 _IOR('s',  1, int)		/* get high watermark */
++#define	SIOCSLOWAT	 _IOW('s',  2, int)		/* set low watermark */
++#define	SIOCGLOWAT	 _IOR('s',  3, int)		/* get low watermark */
++#define	SIOCATMARK	 _IOR('s',  7, int)		/* at oob mark? */
++#define	SIOCSPGRP	 _IOW('s',  8, int)		/* set process group */
++#define	SIOCGPGRP	 _IOR('s',  9, int)		/* get process group */
++
++#define	SIOCADDRT	 _IOW('r', 10, struct ortentry)	/* add route */
++#define	SIOCDELRT	 _IOW('r', 11, struct ortentry)	/* delete route */
++#define	SIOCGETVIFCNT	_IOWR('r', 15, struct sioc_vif_req)/* get vif pkt cnt */
++#define	SIOCGETSGCNT	_IOWR('r', 16, struct sioc_sg_req) /* get s,g pkt cnt */
++
++#define	SIOCSIFADDR	 _IOW('i', 12, struct ifreq)	/* set ifnet address */
++#define	OSIOCGIFADDR	_IOWR('i', 13, struct ifreq)	/* get ifnet address */
++#define	SIOCGIFADDR	_IOWR('i', 33, struct ifreq)	/* get ifnet address */
++#define	SIOCSIFDSTADDR	 _IOW('i', 14, struct ifreq)	/* set p-p address */
++#define	OSIOCGIFDSTADDR	_IOWR('i', 15, struct ifreq)	/* get p-p address */
++#define	SIOCGIFDSTADDR	_IOWR('i', 34, struct ifreq)	/* get p-p address */
++#define	SIOCSIFFLAGS	 _IOW('i', 16, struct ifreq)	/* set ifnet flags */
++#define	SIOCGIFFLAGS	_IOWR('i', 17, struct ifreq)	/* get ifnet flags */
++#define	OSIOCGIFBRDADDR	_IOWR('i', 18, struct ifreq)	/* get broadcast addr */
++#define	SIOCGIFBRDADDR	_IOWR('i', 35, struct ifreq)	/* get broadcast addr */
++#define	SIOCSIFBRDADDR	 _IOW('i', 19, struct ifreq)	/* set broadcast addr */
++#define	OSIOCGIFCONF	_IOWR('i', 20, struct ifconf)	/* get ifnet list */
++#define	SIOCGIFCONF	_IOWR('i', 36, struct ifconf)	/* get ifnet list */
++#define	OSIOCGIFNETMASK	_IOWR('i', 21, struct ifreq)	/* get net addr mask */
++#define	SIOCGIFNETMASK	_IOWR('i', 37, struct ifreq)	/* get net addr mask */
++#define	SIOCSIFNETMASK	 _IOW('i', 22, struct ifreq)	/* set net addr mask */
++#define	SIOCGIFMETRIC	_IOWR('i', 23, struct ifreq)	/* get IF metric */
++#define	SIOCSIFMETRIC	 _IOW('i', 24, struct ifreq)	/* set IF metric */
++#define	SIOCDIFADDR	 _IOW('i', 25, struct ifreq)	/* delete IF addr */
++#define	SIOCAIFADDR	 _IOW('i', 26, struct ifaliasreq)/* add/chg IF alias */
++
++#define	SIOCALIFADDR	_IOW('i', 27, struct if_laddrreq) /* add IF addr */
++#define	SIOCGLIFADDR	_IOWR('i', 28, struct if_laddrreq) /* get IF addr */
++#define	SIOCDLIFADDR	_IOW('i', 29, struct if_laddrreq) /* delete IF addr */
++#define	SIOCSIFCAP	 _IOW('i', 30, struct ifreq)	/* set IF features */
++#define	SIOCGIFCAP	_IOWR('i', 31, struct ifreq)	/* get IF features */
++
++#define	SIOCADDMULTI	 _IOW('i', 49, struct ifreq)	/* add m'cast addr */
++#define	SIOCDELMULTI	 _IOW('i', 50, struct ifreq)	/* del m'cast addr */
++#define	SIOCGIFMTU	_IOWR('i', 51, struct ifreq)	/* get IF mtu */
++#define	SIOCSIFMTU	 _IOW('i', 52, struct ifreq)	/* set IF mtu */
++#define	SIOCGIFPHYS	_IOWR('i', 53, struct ifreq)	/* get IF wire */
++#define	SIOCSIFPHYS	 _IOW('i', 54, struct ifreq)	/* set IF wire */
++#define	SIOCSIFMEDIA	_IOWR('i', 55, struct ifreq)	/* set net media */
++#define	SIOCGIFMEDIA	_IOWR('i', 56, struct ifmediareq) /* get net media */
++
++#define	SIOCSIFPHYADDR   _IOW('i', 70, struct ifaliasreq) /* set gif addres */
++#define	SIOCGIFPSRCADDR	_IOWR('i', 71, struct ifreq)	/* get gif psrc addr */
++#define	SIOCGIFPDSTADDR	_IOWR('i', 72, struct ifreq)	/* get gif pdst addr */
++#define	SIOCDIFPHYADDR	 _IOW('i', 73, struct ifreq)	/* delete gif addrs */
++#define	SIOCSLIFPHYADDR	 _IOW('i', 74, struct if_laddrreq) /* set gif addrs */
++#define	SIOCGLIFPHYADDR	_IOWR('i', 75, struct if_laddrreq) /* get gif addrs */
++
++#define	SIOCSIFGENERIC	 _IOW('i', 57, struct ifreq)	/* generic IF set op */
++#define	SIOCGIFGENERIC	_IOWR('i', 58, struct ifreq)	/* generic IF get op */
++
++#define	SIOCGIFSTATUS	_IOWR('i', 59, struct ifstat)	/* get IF status */
++#define	SIOCSIFLLADDR	 _IOW('i', 60, struct ifreq)	/* set linklevel addr */
++
++#define	SIOCGPRIVATE_0	_IOWR('i', 80, struct ifreq)	/* Linux Private + 0 */
++#define	SIOCGPRIVATE_1	_IOWR('i', 81, struct ifreq)	/* Linux Private + 1 */
++
++#define SIOCIFCREATE	_IOWR('i', 122, struct ifreq)	/* create clone if */
++#define SIOCIFDESTROY	 _IOW('i', 121, struct ifreq)	/* destroy clone if */
++#define SIOCIFGCLONERS	_IOWR('i', 120, struct if_clonereq) /* get cloners */
++
++/*
++ * Compatibility with 4.3 BSD terminal driver.
++ *	@(#)ioctl_compat.h	8.4 (Berkeley) 1/21/94
++ */
++
++#ifdef USE_OLD_TTY
++# undef  TIOCGETD
++# define TIOCGETD	_IOR('t', 0, int)	/* get line discipline */
++# undef  TIOCSETD
++# define TIOCSETD	_IOW('t', 1, int)	/* set line discipline */
++#else
++# define OTIOCGETD	_IOR('t', 0, int)	/* get line discipline */
++# define OTIOCSETD	_IOW('t', 1, int)	/* set line discipline */
++#endif
++#define	TIOCHPCL	_IO('t', 2)		/* hang up on last close */
++#define	TIOCGETP	_IOR('t', 8,struct sgttyb)/* get parameters -- gtty */
++#define	TIOCSETP	_IOW('t', 9,struct sgttyb)/* set parameters -- stty */
++#define	TIOCSETN	_IOW('t',10,struct sgttyb)/* as above, but no flushtty*/
++#define	TIOCSETC	_IOW('t',17,struct tchars)/* set special characters */
++#define	TIOCGETC	_IOR('t',18,struct tchars)/* get special characters */
++#define		TANDEM		0x00000001	/* send stopc on out q full */
++#define		CBREAK		0x00000002	/* half-cooked mode */
++#define		LCASE		0x00000004	/* simulate lower case */
++#undef		ECHO				/* see bits/termios.h */
++#define		ECHO		0x00000008	/* echo input */
++#define		CRMOD		0x00000010	/* map \r to \r\n on output */
++#define		RAW		0x00000020	/* no i/o processing */
++#define		ODDP		0x00000040	/* get/send odd parity */
++#define		EVENP		0x00000080	/* get/send even parity */
++#define		ANYP		0x000000c0	/* get any parity/send none */
++#define		NLDELAY		0x00000300	/* \n delay */
++#define			NL0	0x00000000
++#define			NL1	0x00000100	/* tty 37 */
++#define			NL2	0x00000200	/* vt05 */
++#define			NL3	0x00000300
++#define		TBDELAY		0x00000c00	/* horizontal tab delay */
++#define			TAB0	0x00000000
++#define			TAB1	0x00000400	/* tty 37 */
++#define			TAB2	0x00000800
++#define		XTABS		0x00000c00	/* expand tabs on output */
++#define		CRDELAY		0x00003000	/* \r delay */
++#define			CR0	0x00000000
++#define			CR1	0x00001000	/* tn 300 */
++#define			CR2	0x00002000	/* tty 37 */
++#define			CR3	0x00003000	/* concept 100 */
++#define		VTDELAY		0x00004000	/* vertical tab delay */
++#define			FF0	0x00000000
++#define			FF1	0x00004000	/* tty 37 */
++#define		BSDELAY		0x00008000	/* \b delay */
++#define			BS0	0x00000000
++#define			BS1	0x00008000
++#define		ALLDELAY	(NLDELAY|TBDELAY|CRDELAY|VTDELAY|BSDELAY)
++#define		CRTBS		0x00010000	/* do backspacing for crt */
++#define		PRTERA		0x00020000	/* \ ... / erase */
++#define		CRTERA		0x00040000	/* " \b " to wipe out char */
++#define		TILDE		0x00080000	/* hazeltine tilde kludge */
++#undef		MDMBUF				/* see bits/termios.h */
++#define		MDMBUF		0x00100000	/*start/stop output on carrier*/
++#define		LITOUT		0x00200000	/* literal output */
++#undef		TOSTOP				/* see bits/termios.h */
++#define		TOSTOP		0x00400000	/*SIGSTOP on background output*/
++#undef		FLUSHO				/* see bits/termios.h */
++#define		FLUSHO		0x00800000	/* flush output to terminal */
++#define		NOHANG		0x01000000	/* (no-op) was no SIGHUP on carrier drop */
++#define		L001000		0x02000000
++#define		CRTKIL		0x04000000	/* kill line with " \b " */
++#define		PASS8		0x08000000
++#define		CTLECH		0x10000000	/* echo control chars as ^X */
++#undef		PENDIN				/* see bits/termios.h */
++#define		PENDIN		0x20000000	/* tp->t_rawq needs reread */
++#define		DECCTQ		0x40000000	/* only ^Q starts after ^S */
++#undef		NOFLSH				/* see bits/termios.h */
++#define		NOFLSH		0x80000000	/* no output flush on signal */
++#define	TIOCLBIS	_IOW('t', 127, int)	/* bis local mode bits */
++#define	TIOCLBIC	_IOW('t', 126, int)	/* bic local mode bits */
++#define	TIOCLSET	_IOW('t', 125, int)	/* set entire local mode word */
++#define	TIOCLGET	_IOR('t', 124, int)	/* get local modes */
++#define		LCRTBS		(CRTBS>>16)
++#define		LPRTERA		(PRTERA>>16)
++#define		LCRTERA		(CRTERA>>16)
++#define		LTILDE		(TILDE>>16)
++#define		LMDMBUF		(MDMBUF>>16)
++#define		LLITOUT		(LITOUT>>16)
++#define		LTOSTOP		(TOSTOP>>16)
++#define		LFLUSHO		(FLUSHO>>16)
++#define		LNOHANG		(NOHANG>>16)
++#define		LCRTKIL		(CRTKIL>>16)
++#define		LPASS8		(PASS8>>16)
++#define		LCTLECH		(CTLECH>>16)
++#define		LPENDIN		(PENDIN>>16)
++#define		LDECCTQ		(DECCTQ>>16)
++#define		LNOFLSH		(NOFLSH>>16)
++#define	TIOCSLTC	_IOW('t',117,struct ltchars)/* set local special chars*/
++#define	TIOCGLTC	_IOR('t',116,struct ltchars)/* get local special chars*/
++#define OTIOCCONS	_IO('t', 98)	/* for hp300 -- sans int arg */
++#define	OTTYDISC	0
++#define	NETLDISC	1
++#define	NTTYDISC	2
++
++/*
++ * Compatibility with 4.3 BSD terminal driver.
++ *	@(#)ttydev.h	8.2 (Berkeley) 1/4/94
++ */
++
++#ifdef USE_OLD_TTY
++#define B0	0
++#define B50	1
++#define B75	2
++#define B110	3
++#define B134	4
++#define B150	5
++#define B200	6
++#define B300	7
++#define B600	8
++#define B1200	9
++#define	B1800	10
++#define B2400	11
++#define B4800	12
++#define B9600	13
++#define EXTA	14
++#define EXTB	15
++#define B57600  16
++#define B115200 17
++#endif /* USE_OLD_TTY */
++
++#endif /* !_IOCTLS_H_ */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,90 @@
++/* Structure types for pre-termios terminal ioctls.  FreeBSD version.
++   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_IOCTL_H
++# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
++#endif
++
++/* Type of ARG for TIOCGETC and TIOCSETC requests.  */
++struct tchars
++{
++  char t_intrc;			/* Interrupt character.  */
++  char t_quitc;			/* Quit character.  */
++  char t_startc;		/* Start-output character.  */
++  char t_stopc;			/* Stop-output character.  */
++  char t_eofc;			/* End-of-file character.  */
++  char t_brkc;			/* Input delimiter character.  */
++};
++
++#define	_IOT_tchars	/* Hurd ioctl type field.  */ \
++  _IOT (_IOTS (char), 6, 0, 0, 0, 0)
++
++/* Type of ARG for TIOCGLTC and TIOCSLTC requests.  */
++struct ltchars
++{
++  char t_suspc;			/* Suspend character.  */
++  char t_dsuspc;		/* Delayed suspend character.  */
++  char t_rprntc;		/* Reprint-line character.  */
++  char t_flushc;		/* Flush-output character.  */
++  char t_werasc;		/* Word-erase character.  */
++  char t_lnextc;		/* Literal-next character.  */
++};
++
++#define	_IOT_ltchars	/* Hurd ioctl type field.  */ \
++  _IOT (_IOTS (char), 6, 0, 0, 0, 0)
++
++/* Type of ARG for TIOCGETP and TIOCSETP requests (and gtty and stty).  */
++struct sgttyb
++{
++  char sg_ispeed;		/* Input speed.  */
++  char sg_ospeed;		/* Output speed.  */
++  char sg_erase;		/* Erase character.  */
++  char sg_kill;			/* Kill character.  */
++  short int sg_flags;		/* Mode flags.  */
++};
++
++#define	_IOT_sgttyb	/* Hurd ioctl type field.  */ \
++  _IOT (_IOTS (char), 6, _IOTS (short int), 1, 0, 0)
++
++/* Type of ARG for TIOCGWINSZ and TIOCSWINSZ requests.  */
++struct winsize
++{
++  unsigned short int ws_row;	/* Rows, in characters.  */
++  unsigned short int ws_col;	/* Columns, in characters.  */
++
++  /* These are not actually used.  */
++  unsigned short int ws_xpixel;	/* Horizontal pixels.  */
++  unsigned short int ws_ypixel;	/* Vertical pixels.  */
++};
++
++#define	_IOT_winsize	/* Hurd ioctl type field.  */ \
++  _IOT (_IOTS (unsigned short int), 4, 0, 0, 0, 0)
++
++/* Many systems that have TIOCGWINSZ define TIOCGSIZE for source
++   compatibility with Sun; they define `struct ttysize' to have identical
++   layout as `struct winsize' and #define TIOCGSIZE to be TIOCGWINSZ
++   (likewise TIOCSSIZE and TIOCSWINSZ).  */
++struct ttysize
++{
++  unsigned short int ts_lines;
++  unsigned short int ts_cols;
++  unsigned short int ts_xxx;
++  unsigned short int ts_yyy;
++};
++#define	_IOT_ttysize	_IOT_winsize
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,56 @@
++/* Copyright (C) 1995-1997, 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_IPC_H
++# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
++#endif
++
++#include <bits/types.h>
++
++/* Mode bits for `msgget', `semget', and `shmget'.  */
++#define IPC_CREAT	01000		/* create key if key does not exist */
++#define IPC_EXCL	02000		/* fail if key exists */
++#define IPC_NOWAIT	04000		/* return error on wait */
++
++/* Control commands for `msgctl', `semctl', and `shmctl'.  */
++#define IPC_RMID	0		/* remove identifier */
++#define IPC_SET		1		/* set `ipc_perm' options */
++#define IPC_STAT	2		/* get `ipc_perm' options */
++
++/* Special key values.  */
++#define IPC_PRIVATE	((key_t) 0)	/* private key */
++
++#ifdef __USE_BSD
++/* Common mode bits.  */
++# define IPC_R		0400		/* read permission, same as S_IRUSR */
++# define IPC_W		0200		/* write permission, same as S_IWUSR */
++# define IPC_M		0x1000		/* control permission */
++#endif
++
++
++/* Data structure used to pass permission information to IPC operations.  */
++struct ipc_perm
++  {
++    __uint16_t /* yuck! */ cuid;	/* creator's user ID */
++    __uint16_t /* yuck! */ cgid;	/* creator's group ID */
++    __uint16_t /* yuck! */ uid;		/* owner's user ID */
++    __uint16_t /* yuck! */ gid;		/* owner's group ID */
++    __mode_t mode;			/* read/write permission */
++    __uint16_t __seq;
++    __key_t __key;
++  };
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++#include <sys/syslimits.h>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,116 @@
++/* Definitions for POSIX memory map interface.  FreeBSD version.
++   Copyright (C) 1994-1998, 2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_MMAN_H
++# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
++#endif
++
++#include <features.h>
++#include <stddef.h>
++
++/* Protections are chosen from these bits, OR'd together.  The
++   implementation does not necessarily support PROT_EXEC or PROT_WRITE
++   without PROT_READ.  The only guarantees are that no writing will be
++   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
++
++#define	PROT_NONE	 0x00	/* No access.  */
++#define	PROT_READ	 0x01	/* Pages can be read.  */
++#define	PROT_WRITE	 0x02	/* Pages can be written.  */
++#define	PROT_EXEC	 0x04	/* Pages can be executed.  */
++
++/* Flags contain mapping type, sharing type and options.  */
++
++/* Mapping type (must choose one and only one of these).  */
++#ifdef __USE_BSD
++# define MAP_FILE	 0x0000	/* Mapped from a file or device.  */
++# define MAP_ANON	 0x1000	/* Allocated from anonymous virtual memory.  */
++# define MAP_TYPE	 0x1000	/* Mask for type field.  */
++# ifdef __USE_MISC
++#  define MAP_ANONYMOUS  MAP_ANON /* Linux name. */
++# endif
++#endif
++
++/* Sharing types (must choose one and only one of these).  */
++#define	MAP_SHARED	 0x0001	/* Share changes.  */
++#define	MAP_PRIVATE	 0x0002	/* Changes private; copy pages on write.  */
++#ifdef __USE_BSD
++# define MAP_COPY MAP_PRIVATE	/* Virtual copy of region at mapping time.  */
++#endif
++
++/* Other flags.  */
++#define	MAP_FIXED	 0x0010	/* Map address must be exactly as requested. */
++#ifdef __USE_BSD
++# define MAP_INHERIT	 0x0080	/* Region is retained after exec.  */
++# define MAP_NOEXTEND	 0x0100	/* For MAP_FILE, don't change file size.  */
++# define MAP_HASSEMPHORE 0x0200	/* Region may contain semaphores.  */
++# define MAP_STACK	 0x0400	/* Region grows down, like a stack.  */
++# define MAP_NOSYNC	 0x0800	/* Try to avoid flushing to the disk.  */
++# define MAP_NOCORE	0x20000	/* Don't include these pages in a core dump.  */
++#endif
++
++/* Advice to `madvise'.  */
++#ifdef __USE_BSD
++# define MADV_NORMAL	 0	/* No further special treatment.  */
++# define MADV_RANDOM	 1	/* Expect random page references.  */
++# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
++# define MADV_WILLNEED	 3	/* Will need these pages.  */
++# define MADV_DONTNEED	 4	/* Don't need these pages.  */
++# define MADV_FREE	 5	/* Don't need these pages, they contain junk. */
++# define MADV_NOSYNC	 6	/* Try to avoid flushing to the disk.  */
++# define MADV_AUTOSYNC	 7	/* Use the default flushing strategy.  */
++# define MADV_NOCORE	 8	/* Don't include these pages in a core dump.  */
++# define MADV_CORE	 9	/* Include pages in a core dump (default).  */
++#endif
++
++/* The POSIX people had to invent similar names for the same things.  */
++#ifdef __USE_XOPEN2K
++# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
++# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
++# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
++# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
++# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
++#endif
++
++/* Flags to `msync'.  */
++#define MS_ASYNC	1		/* Sync memory asynchronously.  */
++#define MS_SYNC		0		/* Synchronous memory sync.  */
++#define MS_INVALIDATE	2		/* Invalidate the caches.  */
++
++/* Flags for `mlockall' (can be OR'd together).  */
++#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
++#define MCL_FUTURE	2		/* Lock all additions to address
++					   space.  */
++
++/* Flags for 'minherit'.  */
++#ifdef __USE_BSD
++# define INHERIT_SHARE	0
++# define INHERIT_COPY	1
++# define INHERIT_NONE	2
++#endif
++
++
++#ifdef __USE_BSD
++
++__BEGIN_DECLS
++
++extern int minherit (void *__addr, size_t __len, int __inherit);
++
++__END_DECLS
++
++#endif /* Use BSD */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,73 @@
++/* Copyright (C) 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_MSG_H
++#error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
++#endif
++
++#include <bits/types.h>
++
++/* Define options for message queue functions.  */
++#define MSG_NOERROR	010000	/* no error if message is too big */
++
++/* Types used in the structure definition.  */
++typedef unsigned long int msgqnum_t;
++typedef unsigned long int msglen_t;
++
++
++/* Structure of record for one message inside the kernel.
++   The type `struct __msg' is opaque.  */
++struct msqid_ds
++{
++  struct ipc_perm msg_perm;	/* structure describing operation permission */
++  void *__msg_first;
++  void *__msg_last;
++  msglen_t __msg_cbytes;	/* current number of bytes on queue */
++  msgqnum_t msg_qnum;		/* number of messages currently on queue */
++  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
++  __pid_t msg_lspid;		/* pid of last msgsnd() */
++  __pid_t msg_lrpid;		/* pid of last msgrcv() */
++  __kernel_time_t msg_stime;	/* time of last msgsnd command */
++  long __unused1;
++  __kernel_time_t msg_rtime;	/* time of last msgrcv command */
++  long __unused2;
++  __kernel_time_t msg_ctime;	/* time of last change */
++  long __unused3;
++  long __unused4[4];
++};
++
++#ifdef __USE_MISC
++
++# define msg_cbytes	__msg_cbytes
++
++# if 0 /* XXX No way to use this from user space?  */
++
++/* buffer for msgctl calls IPC_INFO, MSG_INFO */
++struct msginfo
++  {
++    int msgmax;
++    int msgmni;
++    int msgmnb;
++    int msgtql;
++    int msgssz;
++    int msgseg;
++  };
++
++# endif
++
++#endif /* __USE_MISC */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,51 @@
++/* Copyright (C) 1997, 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_POLL_H
++# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
++#endif
++
++/* Event types that can be polled for.  These bits may be set in `events'
++   to indicate the interesting event types; they will appear in `revents'
++   to indicate the status of the file descriptor.  */
++#define POLLIN		0x0001		/* There is data to read.  */
++#define POLLPRI		0x0002		/* There is urgent data to read.  */
++#define POLLOUT		0x0004		/* Writing now will not block.  */
++
++#ifdef __USE_XOPEN
++/* These values are defined in XPG4.2.  */
++# define POLLRDNORM	0x0040		/* Normal data may be read.  */
++# define POLLRDBAND	0x0080		/* Priority data may be read.  */
++# define POLLWRNORM	0x0004		/* Writing now will not block.  */
++# define POLLWRBAND	0x0100		/* Priority data may be written.  */
++#endif
++
++#ifdef __USE_BSD
++/* These are extensions for FreeBSD.  */
++# define POLLEXTEND	0x0200		/* File size may have grown.  */
++# define POLLATTRIB	0x0400		/* File attributes may have changed.  */
++# define POLLNLINK	0x0800		/* File may have been moved/removed.  */
++# define POLLWRITE	0x1000		/* File's contents may have changed.  */
++#endif
++
++/* Event types always implicitly polled for.  These bits need not be set in
++   `events', but they will appear in `revents' to indicate the status of
++   the file descriptor.  */
++#define POLLERR		0x0008		/* Error condition.  */
++#define POLLHUP		0x0010		/* Hung up.  */
++#define POLLNVAL	0x0020		/* Invalid polling request.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,90 @@
++/* Define POSIX options for FreeBSD.
++   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Never include this file directly; use <unistd.h> instead.
++ */
++
++#ifndef	_BITS_POSIX_OPT_H
++#define	_BITS_POSIX_OPT_H	1
++
++/* Job control is supported.  */
++#define	_POSIX_JOB_CONTROL	1
++
++/* Processes have a saved set-user-ID and a saved set-group-ID.  */
++#define	_POSIX_SAVED_IDS	1
++
++/* Priority scheduling is supported.  */
++#define	_POSIX_PRIORITY_SCHEDULING	1
++
++/* Synchronizing file data is supported.  */
++#define	_POSIX_SYNCHRONIZED_IO	1
++
++/* The fsync function is present.  */
++#define	_POSIX_FSYNC	1
++
++/* Mapping of files to memory is supported.  */
++#define	_POSIX_MAPPED_FILES	1
++
++/* Locking of all memory is supported.  */
++#define	_POSIX_MEMLOCK	1
++
++/* Locking of ranges of memory is supported.  */
++#define	_POSIX_MEMLOCK_RANGE	1
++
++/* Setting of memory protections is supported.  */
++#define	_POSIX_MEMORY_PROTECTION	1
++
++/* Implementation supports `poll' function.  */
++#define	_POSIX_POLL	1
++
++/* Implementation supports `select' and `pselect' functions.  */
++#define	_POSIX_SELECT	1
++
++/* XPG4.2 shared memory is supported.  */
++#define	_XOPEN_SHM	1
++
++/* X/Open realtime support is available.  */
++#define _XOPEN_REALTIME	1
++
++/* Only root can change owner of file.  */
++#define	_POSIX_CHOWN_RESTRICTED	1
++
++/* `c_cc' member of 'struct termios' structure can be disabled by
++   using the value _POSIX_VDISABLE.  */
++#define	_POSIX_VDISABLE	'\0'
++
++/* The LFS interface is available, except for the asynchronous I/O.  */
++#define _LFS_LARGEFILE		1
++#define _LFS64_LARGEFILE	1
++#define _LFS64_STDIO		1
++
++/* POSIX timers are available.  */
++#define _POSIX_TIMERS 1
++
++/* GNU libc provides regular expression handling.  */
++#define _POSIX_REGEXP	1
++
++/* We have a POSIX shell.  */
++#define _POSIX_SHELL	1
++
++/* The `spawn' function family is supported.  */
++#define _POSIX_SPAWN	200912L
++
++#endif /* bits/posix_opt.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,215 @@
++/* Bit values & structures for resource limits.  FreeBSD version.
++   Copyright (C) 1994, 1996-1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_RESOURCE_H
++# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
++#endif
++
++#include <bits/types.h>
++
++/* These are the values for FreeBSD.  Earlier BSD systems have a subset of
++   these kinds of resource limit.  */
++
++/* Kinds of resource limit.  */
++enum __rlimit_resource
++  {
++    /* Per-process CPU limit, in seconds.  */
++    RLIMIT_CPU,
++#define	RLIMIT_CPU	RLIMIT_CPU
++    /* Largest file that can be created, in bytes.  */
++    RLIMIT_FSIZE,
++#define	RLIMIT_FSIZE	RLIMIT_FSIZE
++    /* Maximum size of data segment, in bytes.  */
++    RLIMIT_DATA,
++#define	RLIMIT_DATA	RLIMIT_DATA
++    /* Maximum size of stack segment, in bytes.  */
++    RLIMIT_STACK,
++#define	RLIMIT_STACK	RLIMIT_STACK
++    /* Largest core file that can be created, in bytes.  */
++    RLIMIT_CORE,
++#define	RLIMIT_CORE	RLIMIT_CORE
++    /* Largest resident set size, in bytes.
++       This affects swapping; processes that are exceeding their
++       resident set size will be more likely to have physical memory
++       taken from them.  */
++    RLIMIT_RSS,
++#define	RLIMIT_RSS	RLIMIT_RSS
++    /* Locked-in-memory address space.  */
++    RLIMIT_MEMLOCK,
++#define	RLIMIT_MEMLOCK	RLIMIT_MEMLOCK
++    /* Number of processes.  */
++    RLIMIT_NPROC,
++#define	RLIMIT_NPROC	RLIMIT_NPROC
++    /* Number of open files.  */
++    RLIMIT_NOFILE,
++#define	RLIMIT_NOFILE	RLIMIT_NOFILE
++    /* Maximum size of all socket buffers.  */
++    RLIMIT_SBSIZE,
++#define RLIMIT_SBSIZE	RLIMIT_SBSIZE
++
++    RLIMIT_NLIMITS,		/* Number of limit flavors.  */
++    RLIM_NLIMITS = RLIMIT_NLIMITS /* Traditional name for same.  */
++  };
++
++/* Value to indicate that there is no limit.  */
++#define RLIM_INFINITY 0x7fffffffffffffffLL
++#ifdef __USE_LARGEFILE64
++# define RLIM64_INFINITY 0x7fffffffffffffffLL
++#endif
++
++
++/* Type for resource quantity measurement.  */
++typedef __rlim_t rlim_t;
++#ifdef __USE_LARGEFILE64
++typedef __rlim64_t rlim64_t;
++#endif
++
++struct rlimit
++  {
++    /* The current (soft) limit.  */
++    rlim_t rlim_cur;
++    /* The hard limit.  */
++    rlim_t rlim_max;
++  };
++
++#ifdef __USE_LARGEFILE64
++struct rlimit64
++  {
++    /* The current (soft) limit.  */
++    rlim64_t rlim_cur;
++    /* The hard limit.  */
++    rlim64_t rlim_max;
++ };
++#endif
++
++/* Whose usage statistics do you want?  */
++enum __rusage_who
++/* The macro definitions are necessary because some programs want
++   to test for operating system features with #ifdef RUSAGE_SELF.
++   In ISO C the reflexive definition is a no-op.  */
++  {
++    /* The calling process.  */
++    RUSAGE_SELF = 0,
++#define RUSAGE_SELF     RUSAGE_SELF
++    /* All of its terminated child processes.  */
++    RUSAGE_CHILDREN = -1
++#define RUSAGE_CHILDREN RUSAGE_CHILDREN
++  };
++
++#define __need_timeval
++#include <bits/time.h>           /* For `struct timeval'.  */
++
++/* Structure which says how much of each resource has been used.  */
++struct rusage
++  {
++    /* Total amount of user time used.  */
++    struct timeval ru_utime;
++    /* Total amount of system time used.  */
++    struct timeval ru_stime;
++    /* Maximum resident set size (in kilobytes).  */
++    long int ru_maxrss;
++    /* Amount of sharing of text segment memory
++       with other processes (kilobyte-seconds).  */
++    long int ru_ixrss;
++    /* Amount of data segment memory used (kilobyte-seconds).  */
++    long int ru_idrss;
++    /* Amount of stack memory used (kilobyte-seconds).  */
++    long int ru_isrss;
++    /* Number of soft page faults (i.e. those serviced by reclaiming
++       a page from the list of pages awaiting reallocation.  */
++    long int ru_minflt;
++    /* Number of hard page faults (i.e. those that required I/O).  */
++    long int ru_majflt;
++    /* Number of times a process was swapped out of physical memory.  */
++    long int ru_nswap;
++    /* Number of input operations via the file system.  Note: This
++       and `ru_oublock' do not include operations with the cache.  */
++    long int ru_inblock;
++    /* Number of output operations via the file system.  */
++    long int ru_oublock;
++    /* Number of IPC messages sent.  */
++    long int ru_msgsnd;
++    /* Number of IPC messages received.  */
++    long int ru_msgrcv;
++    /* Number of signals delivered.  */
++    long int ru_nsignals;
++    /* Number of voluntary context switches, i.e. because the process
++       gave up the process before it had to (usually to wait for some
++       resource to be available).  */
++    long int ru_nvcsw;
++    /* Number of involuntary context switches, i.e. a higher priority process
++       became runnable or the current process used up its time slice.  */
++    long int ru_nivcsw;
++  };
++
++/* Structure which says how much of each resource has been used.  */
++struct __kernel_rusage
++  {
++    /* Total amount of user time used.  */
++    struct __kernel_timeval ru_utime;
++    /* Total amount of system time used.  */
++    struct __kernel_timeval ru_stime;
++    /* Maximum resident set size (in kilobytes).  */
++    long int ru_maxrss;
++    /* Amount of sharing of text segment memory
++       with other processes (kilobyte-seconds).  */
++    long int ru_ixrss;
++    /* Amount of data segment memory used (kilobyte-seconds).  */
++    long int ru_idrss;
++    /* Amount of stack memory used (kilobyte-seconds).  */
++    long int ru_isrss;
++    /* Number of soft page faults (i.e. those serviced by reclaiming
++       a page from the list of pages awaiting reallocation.  */
++    long int ru_minflt;
++    /* Number of hard page faults (i.e. those that required I/O).  */
++    long int ru_majflt;
++    /* Number of times a process was swapped out of physical memory.  */
++    long int ru_nswap;
++    /* Number of input operations via the file system.  Note: This
++       and `ru_oublock' do not include operations with the cache.  */
++    long int ru_inblock;
++    /* Number of output operations via the file system.  */
++    long int ru_oublock;
++    /* Number of IPC messages sent.  */
++    long int ru_msgsnd;
++    /* Number of IPC messages received.  */
++    long int ru_msgrcv;
++    /* Number of signals delivered.  */
++    long int ru_nsignals;
++    /* Number of voluntary context switches, i.e. because the process
++       gave up the process before it had to (usually to wait for some
++       resource to be available).  */
++    long int ru_nvcsw;
++    /* Number of involuntary context switches, i.e. a higher priority process
++       became runnable or the current process used up its time slice.  */
++    long int ru_nivcsw;
++  };
++
++/* Priority limits.  */
++#define PRIO_MIN        -20     /* Minimum priority a process can have.  */
++#define PRIO_MAX        20      /* Maximum priority a process can have.  */
++
++/* The type of the WHICH argument to `getpriority' and `setpriority',
++   indicating what flavor of entity the WHO argument specifies.  */
++enum __priority_which
++  {
++    PRIO_PROCESS = 0,           /* WHO is a process ID.  */
++    PRIO_PGRP = 1,              /* WHO is a process group ID.  */
++    PRIO_USER = 2               /* WHO is a user ID.  */
++  };
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,113 @@
++/* Definitions of constants and data structure for POSIX 1003.1b-1993
++   scheduling interface.
++   Copyright (C) 1996, 1997, 2001, 2003 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef __need_schedparam
++
++#ifndef _SCHED_H
++# error "Never include <bits/sched.h> directly; use <sched.h> instead."
++#endif
++
++
++/* Scheduling algorithms.  */
++#define SCHED_OTHER	2
++#define SCHED_FIFO	1
++#define SCHED_RR	3
++
++/* Data structure to describe a process' schedulability.  */
++struct sched_param
++{
++  int __sched_priority;
++};
++
++
++#ifdef __USE_MISC
++/* Cloning flags.  */
++# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
++# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
++# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
++# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
++# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
++# define CLONE_PID     0x00001000 /* Set if pid shared.  */
++# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
++# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
++				     wake it up on mm_release.  */
++#endif
++
++__BEGIN_DECLS
++
++/* Clone current process.  */
++#ifdef __USE_MISC
++extern int clone (int (*__fn) (void *__arg), void *__child_stack,
++		  int __flags, void *__arg) __THROW;
++#endif
++
++__END_DECLS
++
++#endif	/* need schedparam */
++
++
++#if !defined __defined_schedparam \
++    && (defined __need_schedparam || defined _SCHED_H)
++# define __defined_schedparam	1
++
++/* Data structure to describe a process' schedulability.  */
++struct __sched_param
++  {
++    int __sched_priority;
++  };
++
++# undef __need_schedparam
++#endif
++
++
++#if defined _SCHED_H && !defined __cpu_set_t_defined
++# define __cpu_set_t_defined
++/* Size definition for CPU sets.  */
++# define __CPU_SETSIZE	1024
++# define __NCPUBITS	(8 * sizeof (__cpu_mask))
++
++/* Type for array elements in 'cpu_set'.  */
++typedef unsigned long int __cpu_mask;
++
++/* Basic access functions.  */
++# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
++# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
++
++/* Data structure to describe CPU mask.  */
++typedef struct
++{
++  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
++} cpu_set_t;
++
++/* Access functions for CPU masks.  */
++# define __CPU_ZERO(cpusetp) \
++  do {									      \
++    unsigned int __i;							      \
++    cpu_set *__arr = (cpusetp);						      \
++    for (__i = 0; __i < sizeof (cpu_set) / sizeof (__cpu_mask); ++__i)	      \
++      __arr->__bits[__i] = 0;						      \
++  } while (0)
++# define __CPU_SET(cpu, cpusetp) \
++  ((cpusetp)->__bits[__CPUELT (cpu)] |= __CPUMASK (cpu))
++# define __CPU_CLR(cpu, cpusetp) \
++  ((cpusetp)->__bits[__CPUELT (cpu)] &= ~__CPUMASK (cpu))
++# define __CPU_ISSET(cpu, cpusetp) \
++  (((cpusetp)->__bits[__CPUELT (cpu)] & __CPUMASK (cpu)) != 0)
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,70 @@
++/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_SEM_H
++# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
++#endif
++
++#include <sys/types.h>
++
++/* Flags for `semop'.  */
++#define SEM_UNDO	0x1000		/* undo the operation on exit */
++
++/* Commands for `semctl'.  */
++#define GETPID		4		/* get sempid */
++#define GETVAL		5		/* get semval */
++#define GETALL		6		/* get all semval's */
++#define GETNCNT		3		/* get semncnt */
++#define GETZCNT		7		/* get semzcnt */
++#define SETVAL		8		/* set semval */
++#define SETALL		9		/* set all semval's */
++
++#ifdef __USE_BSD
++# define SEM_R		IPC_R		/* read permission for user */
++# define SEM_A		IPC_W		/* alter permission for user */
++#endif
++
++
++/* Data structure describing a set of semaphores.  */
++struct semid_ds
++{
++  struct ipc_perm sem_perm;		/* operation permission struct */
++  void *__sem_base;
++  unsigned short int sem_nsems;		/* number of semaphores in set */
++  __kernel_time_t sem_otime;		/* last semop() time */
++  long __unused1;
++  __kernel_time_t sem_ctime;		/* last time changed by semctl() */
++  long __unused2;
++  long __unused3[4];
++};
++
++/* The user should define a union like the following to use it for arguments
++   for `semctl'.
++
++   union semun
++   {
++     int val;				<= value for SETVAL
++     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
++     unsigned short int *array;		<= array for GETALL & SETALL
++     struct seminfo *__buf;		<= buffer for IPC_INFO
++   };
++
++   Previous versions of this file used to define this union but this is
++   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
++   one must define the union or not.  */
++#define _SEM_SEMUN_UNDEFINED	1
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,61 @@
++/* Copyright (C) 1995-1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_SHM_H
++# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
++#endif
++
++#include <bits/types.h>
++
++/* Permission flag for shmget.  */
++#ifdef __USE_BSD
++# define SHM_R		IPC_R		/* read permission for user */
++# define SHM_W		IPC_W		/* write permission for user */
++#endif
++
++/* Flags for `shmat'.  */
++#define SHM_RDONLY	010000		/* attach read-only else read-write */
++#define SHM_RND		020000		/* round attach address to SHMLBA */
++
++/* Commands for `shmctl'.  */
++#if 0 /* FreeBSD does not have these yet.  */
++#define SHM_LOCK	11		/* lock segment (root only) */
++#define SHM_UNLOCK	12		/* unlock segment (root only) */
++#endif
++
++/* Segment low boundary address multiple.  */
++#define SHMLBA		(__getpagesize ())
++extern int __getpagesize (void) __THROW __attribute__ ((__const__));
++
++
++/* Type to count number of attaches.  */
++typedef unsigned short int shmatt_t;
++
++/* Data structure describing a set of semaphores.  */
++struct shmid_ds
++  {
++    struct ipc_perm shm_perm;		/* operation permission struct */
++    int shm_segsz;			/* size of segment in bytes */
++    __pid_t shm_lpid;			/* pid of last shmop */
++    __pid_t shm_cpid;			/* pid of creator */
++    shmatt_t shm_nattch;		/* number of current attaches */
++    __kernel_time_t shm_atime;		/* time of last shmat() */
++    __kernel_time_t shm_dtime;		/* time of last shmdt() */
++    __kernel_time_t shm_ctime;		/* time of last change by shmctl() */
++    void *__shm_internal;
++  };
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,76 @@
++/* Copyright (C) 1991-1992,1996-1998,2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SIGNAL_H
++# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
++#endif
++
++/* These definitions match those used by the FreeBSD kernel.  */
++
++/* Structure describing the action to be taken when a signal arrives.  */
++struct sigaction
++  {
++    /* Signal handler.  */
++#ifdef __USE_POSIX199309
++    union
++      {
++	/* Used if SA_SIGINFO is not set.  */
++	__sighandler_t sa_handler;
++	/* Used if SA_SIGINFO is set.  */
++	void (*sa_sigaction) (int, siginfo_t *, void *);
++      }
++    __sigaction_handler;
++# define sa_handler	__sigaction_handler.sa_handler
++# define sa_sigaction	__sigaction_handler.sa_sigaction
++#else
++    __sighandler_t sa_handler;
++#endif
++
++    /* Special flags.  */
++    int sa_flags;
++
++    /* Additional set of signals to be blocked.  */
++    __sigset_t sa_mask;
++  };
++
++/* Bits in `sa_flags'.  */
++#if defined __USE_UNIX98 || defined __USE_MISC
++# define SA_ONSTACK	0x0001	/* Take signal on signal stack.  */
++# define SA_RESTART	0x0002	/* Restart syscall on signal return.  */
++# define SA_RESETHAND	0x0004	/* Reset to SIG_DFL on entry to handler.  */
++# define SA_NODEFER	0x0010	/* Don't automatically block the signal when
++				    its handler is being executed.  */
++# define SA_NOCLDWAIT	0x0020	/* Don't save zombie processes.  */
++# define SA_SIGINFO	0x0040	/* Provide additional info to the handler.  */
++#endif
++#define	SA_NOCLDSTOP	0x0008	/* Don't send SIGCHLD when children stop.  */
++
++#ifdef __USE_MISC
++# define SA_INTERRUPT	0	/* Historical no-op ("not SA_RESTART").  */
++
++/* Some aliases for the SA_ constants.  */
++# define SA_NOMASK    SA_NODEFER
++# define SA_ONESHOT   SA_RESETHAND
++# define SA_STACK     SA_ONSTACK
++#endif
++
++
++/* Values for the HOW argument to `sigprocmask'.  */
++#define	SIG_BLOCK	1	/* Block signals.  */
++#define	SIG_UNBLOCK	2	/* Unblock signals.  */
++#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,222 @@
++/* siginfo_t, sigevent and constants.  FreeBSD version.
++   Copyright (C) 1997-1998, 2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SIGNAL_H && !defined __need_siginfo_t \
++    && !defined __need_sigevent_t
++# error "Never include this file directly.  Use <signal.h> instead"
++#endif
++
++#if (!defined __have_sigval_t \
++     && (defined _SIGNAL_H || defined __need_siginfo_t \
++	 || defined __need_sigevent_t))
++# define __have_sigval_t 1
++
++/* Type for data associated with a signal.  */
++typedef union sigval
++  {
++    int sival_int;
++    void *sival_ptr;
++  } sigval_t;
++#endif
++
++#if (!defined __have_siginfo_t \
++     && (defined _SIGNAL_H || defined __need_siginfo_t))
++# define __have_siginfo_t	1
++
++typedef struct siginfo
++  {
++    int si_signo;		/* Signal number.  */
++    int si_errno;		/* If non-zero, an errno value associated with
++				   this signal, as defined in <errno.h>.  */
++    int si_code;		/* Signal code.  */
++    int si_pid;			/* Sending process ID.  */
++    unsigned int si_uid;	/* Real user ID of sending process.  */
++    int si_status;		/* Exit value or signal.  */
++    void *si_addr;		/* Address of faulting instruction.  */
++    union sigval si_value;	/* Signal value.  */
++    long int si_band;		/* Band event for SIGPOLL.  */
++    int __si_spare[7];
++  } siginfo_t;
++
++
++/* Values for `si_code'.  Positive values are reserved for kernel-generated
++   signals.  */
++enum
++{
++  SI_ASYNCIO = 0x10004,		/* Sent by AIO completion.  */
++# define SI_ASYNCIO	SI_ASYNCIO
++  SI_MESGQ = 0x10005,		/* Sent by real time mesq state change.  */
++# define SI_MESGQ	SI_MESGQ
++  SI_TIMER = 0x10003,		/* Sent by timer expiration.  */
++# define SI_TIMER	SI_TIMER
++  SI_QUEUE = 0x10002,		/* Sent by sigqueue.  */
++# define SI_QUEUE	SI_QUEUE
++  SI_USER = 0x10001,		/* Sent by kill, sigsend, raise.  */
++# define SI_USER	SI_USER
++  SI_UNDEFINED = 0
++# define SI_UNDEFINED	SI_UNDEFINED
++};
++
++#if 0 /* XXX These need verification.  See <bits/sigcontext.h>.  */
++
++/* `si_code' values for SIGILL signal.  */
++enum
++{
++  ILL_ILLOPC = 1,		/* Illegal opcode.  */
++# define ILL_ILLOPC	ILL_ILLOPC
++  ILL_ILL_OPN,			/* Illegal operand.  */
++# define ILL_ILLOPN	ILL_ILLOPN
++  ILL_ILLADR,			/* Illegal addressing mode.  */
++# define ILL_ILLADR	ILL_ILLADR
++  ILL_ILLTRP,			/* Illegal trap. */
++# define ILL_ILLTRP	ILL_ILLTRP
++  ILL_PRVOPC,			/* Privileged opcode.  */
++# define ILL_PRVOPC	ILL_PRVOPC
++  ILL_PRVREG,			/* Privileged register.  */
++# define ILL_PRVREG	ILL_PRVREG
++  ILL_COPROC,			/* Coprocessor error.  */
++# define ILL_COPROC	ILL_COPROC
++  ILL_BADSTK			/* Internal stack error.  */
++# define ILL_BADSTK	ILL_BADSTK
++};
++
++/* `si_code' values for SIGFPE signal.  */
++enum
++{
++  FPE_INTDIV = 1,		/* Integer divide by zero.  */
++# define FPE_INTDIV	FPE_INTDIV
++  FPE_INTOVF,			/* Integer overflow.  */
++# define FPE_INTOVF	FPE_INTOVF
++  FPE_FLTDIV,			/* Floating point divide by zero.  */
++# define FPE_FLTDIV	FPE_FLTDIV
++  FPE_FLTOVF,			/* Floating point overflow.  */
++# define FPE_FLTOVF	FPE_FLTOVF
++  FPE_FLTUND,			/* Floating point underflow.  */
++# define FPE_FLTUND	FPE_FLTUND
++  FPE_FLTRES,			/* Floating point inexact result.  */
++# define FPE_FLTRES	FPE_FLTRES
++  FPE_FLTINV,			/* Floating point invalid operation.  */
++# define FPE_FLTINV	FPE_FLTINV
++  FPE_FLTSUB			/* Subscript out of range.  */
++# define FPE_FLTSUB	FPE_FLTSUB
++};
++
++/* `si_code' values for SIGSEGV signal.  */
++enum
++{
++  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
++# define SEGV_MAPERR	SEGV_MAPERR
++  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
++# define SEGV_ACCERR	SEGV_ACCERR
++};
++
++/* `si_code' values for SIGBUS signal.  */
++enum
++{
++  BUS_ADRALN = 1,		/* Invalid address alignment.  */
++# define BUS_ADRALN	BUS_ADRALN
++  BUS_ADRERR,			/* Non-existant physical address.  */
++# define BUS_ADRERR	BUS_ADRERR
++  BUS_OBJERR			/* Object specific hardware error.  */
++# define BUS_OBJERR	BUS_OBJERR
++};
++
++/* `si_code' values for SIGTRAP signal.  */
++enum
++{
++  TRAP_BRKPT = 1,		/* Process breakpoint.  */
++# define TRAP_BRKPT	TRAP_BRKPT
++  TRAP_TRACE			/* Process trace trap.  */
++# define TRAP_TRACE	TRAP_TRACE
++};
++
++#endif
++
++/* `si_code' values for SIGCHLD signal.  */
++/* XXX These are only used by the waitid() function, not by the kernel.  */
++enum
++{
++  CLD_EXITED = 1,		/* Child has exited.  */
++# define CLD_EXITED	CLD_EXITED
++  CLD_KILLED,			/* Child was killed.  */
++# define CLD_KILLED	CLD_KILLED
++  CLD_DUMPED,			/* Child terminated abnormally.  */
++# define CLD_DUMPED	CLD_DUMPED
++  CLD_TRAPPED,			/* Traced child has trapped.  */
++# define CLD_TRAPPED	CLD_TRAPPED
++  CLD_STOPPED,			/* Child has stopped.  */
++# define CLD_STOPPED	CLD_STOPPED
++  CLD_CONTINUED			/* Stopped child has continued.  */
++# define CLD_CONTINUED	CLD_CONTINUED
++};
++
++#if 0 /* XXX These need verification.  See <bits/sigcontext.h>.  */
++
++/* `si_code' values for SIGPOLL signal.  */
++enum
++{
++  POLL_IN = 1,			/* Data input available.  */
++# define POLL_IN	POLL_IN
++  POLL_OUT,			/* Output buffers available.  */
++# define POLL_OUT	POLL_OUT
++  POLL_MSG,			/* Input message available.   */
++# define POLL_MSG	POLL_MSG
++  POLL_ERR,			/* I/O error.  */
++# define POLL_ERR	POLL_ERR
++  POLL_PRI,			/* High priority input available.  */
++# define POLL_PRI	POLL_PRI
++  POLL_HUP			/* Device disconnected.  */
++# define POLL_HUP	POLL_HUP
++};
++
++#endif
++
++# undef __need_siginfo_t
++#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
++
++
++#if (defined _SIGNAL_H || defined __need_sigevent_t) \
++    && !defined __have_sigevent_t
++# define __have_sigevent_t	1
++
++/* Structure to transport application-defined values with signals.  */
++
++typedef struct sigevent
++  {
++    int sigev_notify;
++    int sigev_signo;
++    sigval_t sigev_value;
++    /* Not yet supported by the kernel.  */
++    void (*sigev_notify_function) (sigval_t);	/* Function to start.  */
++    void *sigev_notify_attributes;		/* Really pthread_attr_t.  */
++  } sigevent_t;
++
++/* `sigev_notify' values.  */
++enum
++{
++  SIGEV_SIGNAL = 1,		/* Notify via signal.  */
++# define SIGEV_SIGNAL	SIGEV_SIGNAL
++  SIGEV_NONE = 0,		/* Other notification: meaningless.  */
++# define SIGEV_NONE	SIGEV_NONE
++  /* Not yet supported by the kernel.  */
++  SIGEV_THREAD = 2		/* Deliver via thread creation.  */
++# define SIGEV_THREAD	SIGEV_THREAD
++};
++
++#endif	/* have _SIGNAL_H.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,68 @@
++/* Signal number definitions.  FreeBSD version.
++   Copyright (C) 1991-1993, 1996, 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifdef	_SIGNAL_H
++
++/* This file defines the fake signal functions and signal
++   number constants for 4.2 or 4.3 BSD-derived Unix system.  */
++
++/* Fake signal functions.  */
++#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
++#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
++#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
++
++
++/* Signals.  */
++#define	SIGHUP		1	/* Hangup (POSIX).  */
++#define	SIGINT		2	/* Interrupt (ANSI).  */
++#define	SIGQUIT		3	/* Quit (POSIX).  */
++#define	SIGILL		4	/* Illegal instruction (ANSI).  */
++#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
++#define	SIGTRAP		5	/* Trace trap (POSIX).  */
++#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
++#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
++#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
++#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
++#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
++#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
++#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD).  */
++#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
++#define	SIGALRM		14	/* Alarm clock (POSIX).  */
++#define	SIGTERM		15	/* Termination (ANSI).  */
++#define	SIGURG		16	/* Urgent condition on socket (4.2 BSD).  */
++#define	SIGSTOP		17	/* Stop, unblockable (POSIX).  */
++#define	SIGTSTP		18	/* Keyboard stop (POSIX).  */
++#define	SIGCONT		19	/* Continue (POSIX).  */
++#define	SIGCHLD		20	/* Child status has changed (POSIX).  */
++#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
++#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
++#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
++#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
++#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
++#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
++#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
++#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
++#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
++#define SIGINFO		29	/* Information request (4.4 BSD).  */
++#define	SIGUSR1		30	/* User-defined signal 1 (POSIX).  */
++#define	SIGUSR2		31	/* User-defined signal 2 (POSIX).  */
++
++#endif	/* <signal.h> included.  */
++
++#define	_NSIG		129	/* Biggest signal number + 1.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,135 @@
++/* __sig_atomic_t, __sigset_t, and related definitions.  FreeBSD version.
++   Copyright (C) 1994-1996, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SIGSET_H_types
++#define _SIGSET_H_types	1
++
++typedef int __sig_atomic_t;
++
++/* A `sigset_t' has a bit for each signal.  */
++typedef struct
++  {
++    unsigned int __sigbits[4];
++  } __sigset_t;
++
++#endif	/* ! _SIGSET_H_types */
++
++/* We only want to define these functions if <signal.h> was actually
++   included; otherwise we were included just to define the types.  Since we
++   are namespace-clean, it wouldn't hurt to define extra macros.  But
++   trouble can be caused by functions being defined (e.g., any global
++   register vars declared later will cause compilation errors).  */
++
++#if !defined (_SIGSET_H_fns) && defined (_SIGNAL_H)
++#define _SIGSET_H_fns 1
++
++# ifndef _EXTERN_INLINE
++#  define _EXTERN_INLINE extern __inline
++# endif
++
++/* Return a mask that includes SIG only.  */
++# define __sigmask(sig)	((unsigned int) 1 << ((sig) - 1))
++
++/* Return the word index for SIG.  */
++# define __sigword(sig)	(((sig) - 1) >> 5)
++
++# if defined __GNUC__ && __GNUC__ >= 2
++#  define __sigemptyset(set) \
++  (__extension__ ({ sigset_t *__set = (set);				      \
++		    __set->__sigbits[0] = 0; __set->__sigbits[1] = 0;	      \
++		    __set->__sigbits[2] = 0; __set->__sigbits[3] = 0;	      \
++		    0; }))
++#  define __sigfillset(set) \
++  (__extension__ ({ sigset_t *__set = (set);				      \
++		    __set->__sigbits[0] = ~0; __set->__sigbits[1] = ~0;	      \
++		    __set->__sigbits[2] = ~0; __set->__sigbits[3] = ~0;	      \
++		    0; }))
++
++#  ifdef __USE_GNU
++/* The POSIX does not specify for handling the whole signal set in one
++   command.  This is often wanted and so we define three more functions
++   here.  */
++#   define __sigisemptyset(set) \
++  (__extension__ ({ const sigset_t *__set = (set);			      \
++		    __set->__sigbits[0] == 0				      \
++		    && __set->__sigbits[1] == 0				      \
++		    && __set->__sigbits[2] == 0				      \
++		    && __set->__sigbits[3] == 0; }))
++#   define __sigandset(dest, left, right) \
++  (__extension__ ({ sigset_t *__dest = (dest);				      \
++		    const sigset_t *__left = (left);			      \
++		    const sigset_t *__right = (right);			      \
++		    __dest->__sigbits[0] =				      \
++		      __left->__sigbits[0] & __right->__sigbits[0];	      \
++		    __dest->__sigbits[1] =				      \
++		      __left->__sigbits[1] & __right->__sigbits[1];	      \
++		    __dest->__sigbits[2] =				      \
++		      __left->__sigbits[2] & __right->__sigbits[2];	      \
++		    __dest->__sigbits[3] =				      \
++		      __left->__sigbits[3] & __right->__sigbits[3];	      \
++		    0; }))
++#   define __sigorset(dest, left, right) \
++  (__extension__ ({ sigset_t *__dest = (dest);				      \
++		    const sigset_t *__left = (left);			      \
++		    const sigset_t *__right = (right);			      \
++		    __dest->__sigbits[0] =				      \
++		      __left->__sigbits[0] | __right->__sigbits[0];	      \
++		    __dest->__sigbits[1] =				      \
++		      __left->__sigbits[1] | __right->__sigbits[1];	      \
++		    __dest->__sigbits[2] =				      \
++		      __left->__sigbits[2] | __right->__sigbits[2];	      \
++		    __dest->__sigbits[3] =				      \
++		      __left->__sigbits[3] | __right->__sigbits[3];	      \
++		    0; }))
++#  endif
++# endif
++
++/* These functions needn't check for a bogus signal number -- error
++   checking is done in the non __ versions.  */
++
++extern int __sigismember (__const __sigset_t *, int);
++extern int __sigaddset (__sigset_t *, int);
++extern int __sigdelset (__sigset_t *, int);
++
++# ifdef __USE_EXTERN_INLINES
++
++_EXTERN_INLINE int
++__sigismember (__const __sigset_t *__set, int __sig)
++{
++  return (__set->__sigbits[__sigword (__sig)] & __sigmask (__sig) ? 1 : 0);
++}
++
++_EXTERN_INLINE int
++__sigaddset (__sigset_t *__set, int __sig)
++{
++  __set->__sigbits[__sigword (__sig)] |= __sigmask (__sig);
++  return 0;
++}
++
++_EXTERN_INLINE int
++__sigdelset (__sigset_t *__set, int __sig)
++{
++  __set->__sigbits[__sigword (__sig)] &= ~__sigmask (__sig);
++  return 0;
++}
++
++# endif
++
++
++#endif /* ! _SIGSET_H_fns */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,377 @@
++/* System-specific socket constants and types.  FreeBSD version.
++   Copyright (C) 1991-1992,1994-1999,2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Library General Public License as
++   published by the Free Software Foundation; either version 2 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Library General Public License for more details.
++
++   You should have received a copy of the GNU Library General Public
++   License along with the GNU C Library; see the file COPYING.LIB.  If not,
++   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
++   Boston, MA 02111-1307, USA.  */
++
++#ifndef __BITS_SOCKET_H
++#define __BITS_SOCKET_H	1
++
++#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
++# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
++#endif
++
++#define	__need_size_t
++#define __need_NULL
++#include <stddef.h>
++
++#include <limits.h>		/* XXX Is this allowed?  */
++#include <bits/types.h>
++
++/* Type for length arguments in socket calls.  */
++#ifndef __socklen_t_defined
++typedef __socklen_t socklen_t;
++# define __socklen_t_defined
++#endif
++
++
++/* Types of sockets.  */
++enum __socket_type
++{
++  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
++				   byte streams.  */
++#define SOCK_STREAM SOCK_STREAM
++  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
++				   of fixed maximum length.  */
++#define SOCK_DGRAM SOCK_DGRAM
++  SOCK_RAW = 3,			/* Raw protocol interface.  */
++#define SOCK_RAW SOCK_RAW
++  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
++#define SOCK_RDM SOCK_RDM
++  SOCK_SEQPACKET = 5		/* Sequenced, reliable, connection-based,
++				   datagrams of fixed maximum length.  */
++#define SOCK_SEQPACKET SOCK_SEQPACKET
++};
++
++/* Protocol families.  */
++#define	PF_UNSPEC	0	/* Unspecified.  */
++#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
++#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
++#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
++#define	PF_INET		2	/* IP protocol family.  */
++#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
++#define	PF_PUP		4	/* PUP protocols.  */
++#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
++#define	PF_NS		6	/* Xerox NS protocols.  */
++#define	PF_ISO		7	/* ISO protocols.  */
++#define	PF_OSI		PF_ISO
++#define	PF_ECMA		8	/* ECMA protocols.  */
++#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
++#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
++#define	PF_SNA		11	/* IBM SNA protocol.  */
++#define	PF_DECnet	12	/* DECnet protocols.  */
++#define	PF_DLI		13	/* Direct data link interface.  */
++#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
++#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
++#define	PF_APPLETALK	16	/* Don't use this.  */
++#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
++#define	PF_LINK		18	/* Link layer interface.  */
++#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
++#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
++#define	PF_CNT		21	/* Computer Network Technology.  */
++#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
++#define	PF_IPX		23	/* Novell Internet Protocol.  */
++#define	PF_SIP		24	/* Simple Internet Protocol.  */
++#define PF_PIP		25	/* Help Identify PIP packets.  */
++#define PF_ISDN		26	/* Integrated Services Digital Network.  */
++#define PF_KEY		27	/* Internal key-management function.  */
++#define PF_INET6	28	/* IP version 6.  */
++#define PF_NATM		29	/* Native ATM access.  */
++#define PF_ATM		30	/* ATM.  */
++#define PF_HDRCMPLT	31	/* Used by BPF to not rewrite headers in
++				   interface output routine.  */
++#define PF_NETGRAPH	32	/* Netgraph sockets.  */
++#define	PF_MAX		33
++
++/* Address families.  */
++#define	AF_UNSPEC	PF_UNSPEC
++#define	AF_LOCAL	PF_LOCAL
++#define	AF_UNIX		PF_UNIX
++#define	AF_FILE		PF_FILE
++#define	AF_INET		PF_INET
++#define	AF_IMPLINK	PF_IMPLINK
++#define	AF_PUP		PF_PUP
++#define	AF_CHAOS	PF_CHAOS
++#define	AF_NS		PF_NS
++#define	AF_ISO		PF_ISO
++#define	AF_OSI		PF_OSI
++#define	AF_ECMA		PF_ECMA
++#define	AF_DATAKIT	PF_DATAKIT
++#define	AF_CCITT	PF_CCITT
++#define	AF_SNA		PF_SNA
++#define	AF_DECnet	PF_DECnet
++#define	AF_DLI		PF_DLI
++#define	AF_LAT		PF_LAT
++#define	AF_HYLINK	PF_HYLINK
++#define	AF_APPLETALK	PF_APPLETALK
++#define	AF_ROUTE	PF_ROUTE
++#define	AF_LINK		PF_LINK
++#define	pseudo_AF_XTP	PF_XTP
++#define	AF_COIP		PF_COIP
++#define	AF_CNT		PF_CNT
++#define pseudo_AF_RTIP	PF_RTIP
++#define	AF_IPX		PF_IPX
++#define	AF_SIP		PF_SIP
++#define pseudo_AF_PIP	PF_PIP
++#define AF_ISDN		PF_ISDN
++#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation.  */
++#define pseudo_AF_KEY	PF_KEY
++#define AF_INET6	PF_INET6
++#define AF_NATM		PF_NATM
++#define AF_ATM		PF_ATM
++#define pseudo_AF_HDRCMPLT PF_HDRCMPLT
++#define AF_NETGRAPH	PF_NETGRAPH
++#define	AF_MAX		PF_MAX
++
++/* Maximum queue length specifiable by listen.  */
++#define SOMAXCONN	128	/* 5 on the original 4.4 BSD.  */
++
++/* Get the definition of the macro to define the common sockaddr members.  */
++#include <bits/sockaddr.h>
++
++/* Structure describing a generic socket address.  */
++struct sockaddr
++  {
++    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
++    char sa_data[14];		/* Address data.  */
++  };
++
++
++/* Structure large enough to hold any socket address (with the historical
++   exception of AF_UNIX).  We reserve 128 bytes.  */
++#if ULONG_MAX > 0xffffffff
++# define __ss_aligntype	__uint64_t
++#else
++# define __ss_aligntype	__uint32_t
++#endif
++#define _SS_SIZE	128
++#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
++
++struct sockaddr_storage
++  {
++    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
++    __ss_aligntype __ss_align;	/* Force desired alignment.  */
++    char __ss_padding[_SS_PADSIZE];
++  };
++
++
++/* Bits in the FLAGS argument to `send', `recv', et al.  */
++enum
++  {
++    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
++#define MSG_OOB MSG_OOB
++    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
++#define MSG_PEEK MSG_PEEK
++    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
++#define MSG_DONTROUTE MSG_DONTROUTE
++    MSG_EOR		= 0x08,	/* Data completes record.  */
++#define MSG_EOR MSG_EOR
++    MSG_TRUNC		= 0x10,	/* Data discarded before delivery.  */
++#define MSG_TRUNC MSG_TRUNC
++    MSG_CTRUNC		= 0x20,	/* Control data lost before delivery.  */
++#define MSG_CTRUNC MSG_CTRUNC
++    MSG_WAITALL		= 0x40,	/* Wait for full request or error.  */
++#define MSG_WAITALL MSG_WAITALL
++    MSG_DONTWAIT	= 0x80,	/* This message should be nonblocking.  */
++#define MSG_DONTWAIT MSG_DONTWAIT
++    MSG_EOF		= 0x100, /* Data completes connection.  */
++#define MSG_EOF MSG_EOF
++    MSG_COMPAT		= 0x8000 /* Used in sendit().  */
++#define MSG_COMPAT MSG_COMPAT
++  };
++
++
++/* Structure describing messages sent by
++   `sendmsg' and received by `recvmsg'.  */
++struct msghdr
++  {
++    void *msg_name;		/* Address to send to/receive from.  */
++    socklen_t msg_namelen;	/* Length of address data.  */
++
++    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
++    size_t msg_iovlen;		/* Number of elements in the vector.  */
++
++    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
++    size_t msg_controllen;	/* Ancillary data buffer length.  */
++
++    int msg_flags;		/* Flags in received message.  */
++  };
++
++/* Structure used for storage of ancillary data object information.  */
++struct cmsghdr
++  {
++    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
++				   of cmsghdr structure.  */
++    int cmsg_level;		/* Originating protocol.  */
++    int cmsg_type;		/* Protocol specific type.  */
++#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
++    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
++#endif
++  };
++
++/* Ancillary data object manipulation macros.  */
++#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
++# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
++#else
++# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
++#endif
++
++#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
++
++#define CMSG_FIRSTHDR(mhdr) \
++  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
++   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
++
++#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
++			   & (size_t) ~(sizeof (size_t) - 1))
++#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
++			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
++#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
++
++extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
++				      struct cmsghdr *__cmsg) __THROW;
++#ifdef __USE_EXTERN_INLINES
++# ifndef _EXTERN_INLINE
++#  define _EXTERN_INLINE extern __inline
++# endif
++_EXTERN_INLINE struct cmsghdr *
++__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
++{
++  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
++    /* The kernel header does this so there may be a reason.  */
++    return 0;
++
++  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
++			       + CMSG_ALIGN (__cmsg->cmsg_len));
++  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
++					+ __mhdr->msg_controllen)
++      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
++	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
++    /* No more entries.  */
++    return 0;
++  return __cmsg;
++}
++#endif	/* Use `extern inline'.  */
++
++/* Socket level message types.  */
++enum
++  {
++    SCM_RIGHTS = 0x01,		/* Access rights (array of int).  */
++#define SCM_RIGHTS SCM_RIGHTS
++    SCM_TIMESTAMP = 0x02,	/* Timestamp (struct timeval).  */
++#define SCM_TIMESTAMP SCM_TIMESTAMP
++    SCM_CREDS = 0x03		/* Process creds (struct cmsgcred).  */
++#define SCM_CREDS SCM_CREDS
++  };
++
++/* Unfortunately, BSD practice dictates this structure be of fixed size.
++   If there are more than CMGROUP_MAX groups, the list is truncated.
++   (On GNU systems, the `cmcred_euid' field is just the first in the
++   list of effective UIDs.)  */
++#define CMGROUP_MAX	16
++
++/* Structure delivered by SCM_CREDS.  This describes the identity of the
++   sender of the data simultaneously received on the socket.  By BSD
++   convention, this is included only when a sender on a AF_LOCAL socket
++   sends cmsg data of this type and size; the sender's structure is
++   ignored, and the system fills in the various IDs of the sender process.  */
++struct cmsgcred
++  {
++    __pid_t cmcred_pid;
++    __uid_t cmcred_uid;
++    __uid_t cmcred_euid;
++    __gid_t cmcred_gid;
++    short cmcred_ngroups;
++    __gid_t cmcred_groups[CMGROUP_MAX];
++  };
++
++/* Protocol number used to manipulate socket-level options
++   with `getsockopt' and `setsockopt'.  */
++#define	SOL_SOCKET	0xffff
++
++/* Socket-level options for `getsockopt' and `setsockopt'.  */
++enum
++  {
++    SO_DEBUG = 0x0001,		/* Record debugging information.  */
++#define SO_DEBUG SO_DEBUG
++    SO_ACCEPTCONN = 0x0002,	/* Accept connections on socket.  */
++#define SO_ACCEPTCONN SO_ACCEPTCONN
++    SO_REUSEADDR = 0x0004,	/* Allow reuse of local addresses.  */
++#define SO_REUSEADDR SO_REUSEADDR
++    SO_KEEPALIVE = 0x0008,	/* Keep connections alive and send
++				   SIGPIPE when they die.  */
++#define SO_KEEPALIVE SO_KEEPALIVE
++    SO_DONTROUTE = 0x0010,	/* Don't do local routing.  */
++#define SO_DONTROUTE SO_DONTROUTE
++    SO_BROADCAST = 0x0020,	/* Allow transmission of
++				   broadcast messages.  */
++#define SO_BROADCAST SO_BROADCAST
++    SO_USELOOPBACK = 0x0040,	/* Use the software loopback to avoid
++				   hardware use when possible.  */
++#define SO_USELOOPBACK SO_USELOOPBACK
++    SO_LINGER = 0x0080,		/* Block on close of a reliable
++				   socket to transmit pending data.  */
++#define SO_LINGER SO_LINGER
++    SO_OOBINLINE = 0x0100,	/* Receive out-of-band data in-band.  */
++#define SO_OOBINLINE SO_OOBINLINE
++    SO_REUSEPORT = 0x0200,	/* Allow local address and port reuse.  */
++#define SO_REUSEPORT SO_REUSEPORT
++    SO_TIMESTAMP = 0x0400,	/* Timestamp received dgram traffic.  */
++#define SO_TIMESTAMP SO_TIMESTAMP
++    SO_SNDBUF = 0x1001,		/* Send buffer size.  */
++#define SO_SNDBUF SO_SNDBUF
++    SO_RCVBUF = 0x1002,		/* Receive buffer.  */
++#define SO_RCVBUF SO_RCVBUF
++    SO_SNDLOWAT = 0x1003,	/* Send low-water mark.  */
++#define SO_SNDLOWAT SO_SNDLOWAT
++    SO_RCVLOWAT = 0x1004,	/* Receive low-water mark.  */
++#define SO_RCVLOWAT SO_RCVLOWAT
++    SO_SNDTIMEO = 0x1005,	/* Send timeout.  */
++#define SO_SNDTIMEO SO_SNDTIMEO
++    SO_RCVTIMEO = 0x1006,	/* Receive timeout.  */
++#define SO_RCVTIMEO SO_RCVTIMEO
++    SO_ERROR = 0x1007,		/* Get and clear error status.  */
++#define SO_ERROR SO_ERROR
++    SO_STYLE = 0x1008,		/* Get socket connection style.  */
++#define SO_STYLE SO_STYLE
++    SO_TYPE = SO_STYLE		/* Compatible name for SO_STYLE.  */
++#define SO_TYPE SO_TYPE
++  };
++
++/* Structure used to manipulate the SO_LINGER option.  */
++struct linger
++  {
++    int l_onoff;		/* Nonzero to linger on close.  */
++    int l_linger;		/* Time to linger.  */
++  };
++
++
++#ifdef __USE_BSD
++
++struct sf_hdtr;
++
++__BEGIN_DECLS
++
++extern int bsd_sendfile (int __in_fd, int __out_sock,
++			 __off_t __in_offset, size_t __nbytes,
++			 struct sf_hdtr *__hdtr, __off_t *__sockbytes,
++			 int __flags) __THROW;
++
++__END_DECLS
++
++#endif /* Use BSD */
++
++#endif	/* bits/socket.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This structure corresponds to the original FreeBSD 'struct stat'
++   (i.e. _STAT_VER_stat), and is used by the fhstat() system call.  */
++struct stat16
++  {
++    __dev_t st_dev;		/* Device containing the file.  */
++    __ino_t st_ino;		/* File serial number.  */
++
++    __uint16_t st_mode;		/* File mode.  */
++    __uint16_t st_nlink;	/* Link count.  */
++
++    __uid_t st_uid;		/* User ID of the file's owner.  */
++    __gid_t st_gid;		/* Group ID of the file's group.  */
++
++    __dev_t st_rdev;		/* Device number, if device.  */
++
++    __kernel_time_t st_atime;	/* Time of last access.  */
++    long int st_atimensec;	/* Nanoseconds of last access.  */
++    __kernel_time_t st_mtime;	/* Time of last modification.  */
++    long int st_mtimensec;	/* Nanoseconds of last modification.  */
++    __kernel_time_t st_ctime;	/* Time of last status change.  */
++    long int st_ctimensec;	/* Nanoseconds of last status change.  */
++
++    __off_t st_size;		/* Size of file, in bytes.  */
++
++    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
++
++    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
++
++    __uint32_t st_flags;	/* User defined flags.  */
++
++    __uint32_t st_gen;		/* Generation number.  */
++
++    __uint32_t __unused1;
++    __quad_t __unused2[2];
++  };
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat32.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat32.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat32.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat32.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,52 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This structure corresponds to the newer FreeBSD 'struct nstat'
++   (i.e. _STAT_VER_nstat).  */
++struct stat32
++  {
++    __dev_t st_dev;		/* Device containing the file.  */
++    __ino_t st_ino;		/* File serial number.  */
++
++    __uint32_t st_mode;		/* File mode.  */
++    __uint32_t st_nlink;	/* Link count.  */
++
++    __uid_t st_uid;		/* User ID of the file's owner.  */
++    __gid_t st_gid;		/* Group ID of the file's group.  */
++
++    __dev_t st_rdev;		/* Device number, if device.  */
++
++    __kernel_time_t st_atime;	/* Time of last access.  */
++    long int st_atimensec;	/* Nanoseconds of last access.  */
++    __kernel_time_t st_mtime;	/* Time of last modification.  */
++    long int st_mtimensec;	/* Nanoseconds of last modification.  */
++    __kernel_time_t st_ctime;	/* Time of last status change.  */
++    long int st_ctimensec;	/* Nanoseconds of last status change.  */
++
++    __off_t st_size;		/* Size of file, in bytes.  */
++
++    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
++
++    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
++
++    __uint32_t st_flags;	/* User defined flags.  */
++
++    __uint32_t st_gen;		/* Generation number.  */
++
++    __quad_t __unused1[2];
++  };
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,91 @@
++/* Definition of `struct statfs', information about a filesystem.
++   Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _BITS_STATFS_H
++#define _BITS_STATFS_H	1
++
++#if !defined _SYS_STATFS_H && !defined _SYS_MOUNT_H
++# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
++#endif
++
++#include <bits/types.h>
++
++struct statfs
++  {
++    unsigned long __unused1;
++    unsigned long f_bsize;
++    unsigned long f_iosize;
++#ifndef __USE_FILE_OFFSET64
++    __fsblkcnt_t f_blocks;
++    __fsblkcnt_t f_bfree;
++    __fsblkcnt_t f_bavail;
++    __fsfilcnt_t f_files;
++    __fsfilcnt_t f_ffree;
++#else
++    __fsblkcnt64_t f_blocks;
++    __fsblkcnt64_t f_bfree;
++    __fsblkcnt64_t f_bavail;
++    __fsfilcnt64_t f_files;
++    __fsfilcnt64_t f_ffree;
++#endif
++    __fsid_t f_fsid;
++    __uid_t f_owner;
++    int f_type;
++    int f_flags;
++    unsigned long int f_syncwrites;
++    unsigned long int f_asyncwrites;
++    char f_fstypename[16];
++    char f_mntonname[sizeof(long) == 8 ? 72 : 80];
++    unsigned long int f_syncreads;
++    unsigned long int f_asyncreads;
++    short __unused2;
++    char f_mntfromname[sizeof(long) == 8 ? 72 : 80];
++    short __unused3;
++    long __unused4[2];
++  };
++
++#ifdef __USE_LARGEFILE64
++struct statfs64
++  {
++    unsigned long __unused1;
++    unsigned long f_bsize;
++    unsigned long f_iosize;
++    __fsblkcnt64_t f_blocks;
++    __fsblkcnt64_t f_bfree;
++    __fsblkcnt64_t f_bavail;
++    __fsfilcnt64_t f_files;
++    __fsfilcnt64_t f_ffree;
++    __fsid_t f_fsid;
++    __uid_t f_owner;
++    int f_type;
++    int f_flags;
++    unsigned long int f_syncwrites;
++    unsigned long int f_asyncwrites;
++    char f_fstypename[16];
++    char f_mntonname[sizeof(long) == 8 ? 72 : 80];
++    unsigned long int f_syncreads;
++    unsigned long int f_asyncreads;
++    short __unused2;
++    char f_mntfromname[sizeof(long) == 8 ? 72 : 80];
++    short __unused3;
++    long __unused4[2];
++  };
++#endif
++
++#endif /* _BITS_STATFS_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,180 @@
++/* Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_STAT_H
++# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
++#endif
++
++/* This structure needs to be defined in accordance with the
++   implementation of __stat, __fstat, and __lstat.  */
++
++#include <bits/types.h>
++
++/* Versions of the 'struct stat' data structure.  */
++#define _STAT_VER_ostat	0	/* 'struct ostat' in /usr/src/sys/sys/stat.h */
++#define _STAT_VER_stat	1	/* 'struct stat' in /usr/src/sys/sys/stat.h */
++#define _STAT_VER_nstat	2	/* 'struct nstat' in /usr/src/sys/sys/stat.h */
++#define _STAT_VER_gstat 3	/* glibc's 'struct stat' without LFS */
++/* By default we use _STAT_VER_gstat, but we support also _STAT_VER_stat and
++   _STAT_VER_nstat.  */
++#define _STAT_VER	_STAT_VER_gstat
++
++/* Structure describing file characteristics.  */
++struct stat
++  {
++    __dev_t st_dev;		/* Device containing the file.  */
++#ifndef __USE_FILE_OFFSET64
++    __ino_t st_ino;		/* File serial number.  */
++#else
++    __ino64_t st_ino;		/* File serial number.	*/
++#endif
++
++    __uint32_t st_mode;		/* File mode.  */
++    __uint32_t st_nlink;	/* Link count.  */
++
++    __uid_t st_uid;		/* User ID of the file's owner.  */
++    __gid_t st_gid;		/* Group ID of the file's group.  */
++
++    __dev_t st_rdev;		/* Device number, if device.  */
++
++    __time_t st_atime;		/* Time of last access.  */
++    long int st_atimensec;	/* Nanoseconds of last access.  */
++    __time_t st_mtime;		/* Time of last modification.  */
++    long int st_mtimensec;	/* Nanoseconds of last modification.  */
++    __time_t st_ctime;		/* Time of last status change.  */
++    long int st_ctimensec;	/* Nanoseconds of last status change.  */
++
++    __off_t st_size;		/* Size of file, in bytes.  */
++
++    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
++
++    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
++#define _STATBUF_ST_BLKSIZE	/* Tell code we have this member.  */
++
++    __uint32_t st_flags;	/* User defined flags.  */
++
++    __uint32_t st_gen;		/* Generation number.  */
++
++    __quad_t __unused1[2];
++  };
++
++#ifdef __USE_LARGEFILE64
++struct stat64
++  {
++    __dev_t st_dev;		/* Device containing the file.  */
++    __ino64_t st_ino;		/* File serial number.	*/
++
++    __uint32_t st_mode;		/* File mode.  */
++    __uint32_t st_nlink;	/* Link count.  */
++
++    __uid_t st_uid;		/* User ID of the file's owner.  */
++    __gid_t st_gid;		/* Group ID of the file's group.  */
++
++    __dev_t st_rdev;		/* Device number, if device.  */
++
++    __time_t st_atime;		/* Time of last access.  */
++    long int st_atimensec;	/* Nanoseconds of last access.  */
++    __time_t st_mtime;		/* Time of last modification.  */
++    long int st_mtimensec;	/* Nanoseconds of last modification.  */
++    __time_t st_ctime;		/* Time of last status change.  */
++    long int st_ctimensec;	/* Nanoseconds of last status change.  */
++
++    __off_t st_size;		/* Size of file, in bytes.  */
++
++    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
++
++    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
++
++    __uint32_t st_flags;	/* User defined flags.  */
++
++    __uint32_t st_gen;		/* Generation number.  */
++
++    __quad_t __unused1[2];
++  };
++#endif
++
++/* Encoding of the file mode.  These are the standard Unix values,
++   but POSIX.1 does not specify what values should be used.  */
++
++#define __S_IFMT	0170000	/* These bits determine file type.  */
++
++/* File types.  */
++#define __S_IFDIR	0040000	/* Directory.  */
++#define __S_IFCHR	0020000	/* Character device.  */
++#define __S_IFBLK	0060000	/* Block device.  */
++#define __S_IFREG	0100000	/* Regular file.  */
++#define __S_IFLNK	0120000	/* Symbolic link.  */
++#define __S_IFSOCK	0140000	/* Socket.  */
++#define __S_IFWHT	0160000	/* Whiteout.  */
++#define __S_IFIFO	0010000	/* FIFO.  */
++
++/* POSIX.1b objects.  */
++#define __S_TYPEISMQ(buf) 0
++#define __S_TYPEISSEM(buf) 0
++#define __S_TYPEISSHM(buf) 0
++
++/* Protection bits.  */
++
++#define __S_ISUID	04000	/* Set user ID on execution.  */
++#define __S_ISGID	02000	/* Set group ID on execution.  */
++#define __S_ISVTX	01000	/* Save swapped text after use (sticky).  */
++#define __S_IREAD	0400	/* Read by owner.  */
++#define __S_IWRITE	0200	/* Write by owner.  */
++#define __S_IEXEC	0100	/* Execute by owner.  */
++
++#ifdef __USE_BSD
++
++__BEGIN_DECLS
++
++/* Set file access permissions for FILE to MODE.
++   Doesn't follow symbolic links if FILE is a symbolic link.
++   This takes an `int' MODE argument because that
++   is what `mode_t's get widened to.  */
++extern int lchmod (__const char *__file, __mode_t __mode) __THROW;
++
++__END_DECLS
++
++
++/* Definitions of flags stored in file flags word.  */
++
++/* Super-user and owner changeable flags.  */
++# define UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
++# define UF_NODUMP	0x00000001	/* do not dump file */
++# define UF_IMMUTABLE	0x00000002	/* file may not be changed */
++# define UF_APPEND	0x00000004	/* writes to file may only append */
++# define UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
++# define UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
++
++/* Super-user changeable flags.  */
++# define SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
++# define SF_ARCHIVED	0x00010000	/* file is archived */
++# define SF_IMMUTABLE	0x00020000	/* file may not be changed */
++# define SF_APPEND	0x00040000	/* writes to file may only append */
++# define SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
++
++__BEGIN_DECLS
++
++/* Set file flags for FILE to FLAGS.  */
++extern int chflags (__const char *__file, unsigned long int __flags) __THROW;
++
++/* Set file flags of the file referred to by FD to FLAGS.  */
++extern int fchflags (int __fd, unsigned long int __flags) __THROW;
++
++__END_DECLS
++
++#endif /* __USE_BSD */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,85 @@
++/* Definition of `struct statvfs', information about a filesystem.
++   Copyright (C) 1998, 2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_STATVFS_H
++# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
++#endif
++
++#include <bits/types.h>
++
++struct statvfs
++  {
++    unsigned long int f_bsize;
++    unsigned long int f_frsize;
++#ifndef __USE_FILE_OFFSET64
++    __fsblkcnt_t f_blocks;
++    __fsblkcnt_t f_bfree;
++    __fsblkcnt_t f_bavail;
++    __fsfilcnt_t f_files;
++    __fsfilcnt_t f_ffree;
++    __fsfilcnt_t f_favail;
++#else
++    __fsblkcnt64_t f_blocks;
++    __fsblkcnt64_t f_bfree;
++    __fsblkcnt64_t f_bavail;
++    __fsfilcnt64_t f_files;
++    __fsfilcnt64_t f_ffree;
++    __fsfilcnt64_t f_favail;
++#endif
++    __fsid_t f_fsid;
++    unsigned long int f_flag;
++    unsigned long int f_namemax;
++    unsigned int f_spare[6];
++  };
++
++#ifdef __USE_LARGEFILE64
++struct statvfs64
++  {
++    unsigned long int f_bsize;
++    unsigned long int f_frsize;
++    __fsblkcnt64_t f_blocks;
++    __fsblkcnt64_t f_bfree;
++    __fsblkcnt64_t f_bavail;
++    __fsfilcnt64_t f_files;
++    __fsfilcnt64_t f_ffree;
++    __fsfilcnt64_t f_favail;
++    __fsid_t f_fsid;
++    unsigned long int f_flag;
++    unsigned long int f_namemax;
++    unsigned int f_spare[6];
++  };
++#endif
++
++/* Definitions for the flag in `f_flag'.  */
++enum
++{
++  ST_RDONLY = 1,		/* Mount read-only.  */
++#define ST_RDONLY	ST_RDONLY
++  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
++#define ST_NOSUID	ST_NOSUID
++#ifdef __USE_GNU
++  ,
++  ST_NODEV = 4,			/* Disallow access to device special files.  */
++# define ST_NODEV	ST_NODEV
++  ST_NOEXEC = 8,		/* Disallow program execution.  */
++# define ST_NOEXEC	ST_NOEXEC
++  ST_SYNCHRONOUS = 16		/* Writes are synced at once.  */
++# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
++#endif	/* Use GNU.  */
++};
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,258 @@
++/* termios type and macro definitions.  FreeBSD version.
++   Copyright (C) 1993-1994,1996-1997,1999,2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _TERMIOS_H
++# error "Never include <bits/termios.h> directly; use <termios.h> instead."
++#endif
++
++/* These macros are also defined in some <bits/ioctls.h> files (with
++   numerically identical values), but this serves to shut up cpp's
++   complaining. */
++#ifdef __USE_BSD
++
++# ifdef MDMBUF
++#  undef MDMBUF
++# endif
++# ifdef FLUSHO
++#  undef FLUSHO
++# endif
++# ifdef PENDIN
++#  undef PENDIN
++# endif
++
++#endif /* __USE_BSD */
++
++#ifdef ECHO
++# undef ECHO
++#endif
++#ifdef TOSTOP
++# undef TOSTOP
++#endif
++#ifdef NOFLSH
++# undef NOFLSH
++#endif
++
++
++/* Type of terminal control flag masks.  */
++typedef unsigned int tcflag_t;
++
++/* Type of control characters.  */
++typedef unsigned char cc_t;
++
++/* Type of baud rate specifiers.  */
++typedef unsigned int speed_t;
++
++/* Terminal control structure.  */
++struct termios
++{
++  /* Input modes.  */
++  tcflag_t c_iflag;
++#define	IGNBRK	(1 << 0)	/* Ignore break condition.  */
++#define	BRKINT	(1 << 1)	/* Signal interrupt on break.  */
++#define	IGNPAR	(1 << 2)	/* Ignore characters with parity errors.  */
++#define	PARMRK	(1 << 3)	/* Mark parity and framing errors.  */
++#define	INPCK	(1 << 4)	/* Enable input parity check.  */
++#define	ISTRIP	(1 << 5)	/* Strip 8th bit off characters.  */
++#define	INLCR	(1 << 6)	/* Map NL to CR on input.  */
++#define	IGNCR	(1 << 7)	/* Ignore CR.  */
++#define	ICRNL	(1 << 8)	/* Map CR to NL on input.  */
++#define	IXON	(1 << 9)	/* Enable start/stop output control.  */
++#define	IXOFF	(1 << 10)	/* Enable start/stop input control.  */
++#ifdef	__USE_BSD
++# define IXANY	(1 << 11)	/* Any character will restart after stop.  */
++# define IMAXBEL (1 << 13)	/* Ring bell when input queue is full.  */
++#endif
++
++  /* Output modes.  */
++  tcflag_t c_oflag;
++#define	OPOST	(1 << 0)	/* Perform output processing.  */
++#ifdef	__USE_BSD
++# define ONLCR	(1 << 1)	/* Map NL to CR-NL on output.  */
++# define OXTABS	(1 << 2)	/* Expand tabs to spaces.  */
++# define ONOEOT	(1 << 3)	/* Discard EOT (^D) on output.  */
++#endif
++
++  /* Control modes.  */
++  tcflag_t c_cflag;
++#ifdef	__USE_BSD
++# define CIGNORE	(1 << 0)	/* Ignore these control flags.  */
++#endif
++#define	CSIZE	(CS5|CS6|CS7|CS8)	/* Number of bits per byte (mask).  */
++#define	CS5	(0 << 8)	/* 5 bits per byte.  */
++#define	CS6	(1 << 8)	/* 6 bits per byte.  */
++#define	CS7	(2 << 8)	/* 7 bits per byte.  */
++#define	CS8	(3 << 8)	/* 8 bits per byte.  */
++#define	CSTOPB	(1 << 10)	/* Two stop bits instead of one.  */
++#define	CREAD	(1 << 11)	/* Enable receiver.  */
++#define	PARENB	(1 << 12)	/* Parity enable.  */
++#define	PARODD	(1 << 13)	/* Odd parity instead of even.  */
++#define	HUPCL	(1 << 14)	/* Hang up on last close.  */
++#define	CLOCAL	(1 << 15)	/* Ignore modem status lines.  */
++#ifdef	__USE_BSD
++# define CCTS_OFLOW	(1 << 16)	/* CTS flow control of output.  */
++# define CRTS_IFLOW	(1 << 17)	/* RTS flow control of input.  */
++# define CRTSCTS	(CCTS_OFLOW|CRTS_IFLOW)	/* CTS/RTS flow control.  */
++# define CDTR_IFLOW	(1 << 18)	/* DTR flow control of input.  */
++# define CDSR_OFLOW	(1 << 19)	/* DSR flow control of output.  */
++# define CCAR_OFLOW	(1 << 20)	/* DCD flow control of output.  */
++# define MDMBUF		(1 << 20)	/* Carrier flow control of output.  */
++#endif
++
++  /* Local modes.  */
++  tcflag_t c_lflag;
++#ifdef	__USE_BSD
++# define ECHOKE	(1 << 0)	/* Visual erase for KILL.  */
++#endif
++#define	_ECHOE	(1 << 1)	/* Visual erase for ERASE.  */
++#define	ECHOE	_ECHOE
++#define	_ECHOK	(1 << 2)	/* Echo NL after KILL.  */
++#define	ECHOK	_ECHOK
++#define	_ECHO	(1 << 3)	/* Enable echo.  */
++#define	ECHO	_ECHO
++#define	_ECHONL	(1 << 4)	/* Echo NL even if ECHO is off.  */
++#define	ECHONL	_ECHONL
++#ifdef	__USE_BSD
++# define ECHOPRT	(1 << 5)	/* Hardcopy visual erase.  */
++# define ECHOCTL	(1 << 6)	/* Echo control characters as ^X.  */
++#endif
++#define	_ISIG	(1 << 7)	/* Enable signals.  */
++#define	ISIG	_ISIG
++#define	_ICANON	(1 << 8)	/* Do erase and kill processing.  */
++#define	ICANON	_ICANON
++#ifdef	__USE_BSD
++# define ALTWERASE (1 << 9)	/* Alternate WERASE algorithm.  */
++#endif
++#define	_IEXTEN	(1 << 10)	/* Enable DISCARD and LNEXT.  */
++#define	IEXTEN	_IEXTEN
++#define	_EXTPROC (1 << 11)	/* External processing.  */
++#define EXTPROC	_EXTPROC
++#define	_TOSTOP	(1 << 22)	/* Send SIGTTOU for background output.  */
++#define	TOSTOP	_TOSTOP
++#ifdef	__USE_BSD
++# define FLUSHO	(1 << 23)	/* Output being flushed (state).  */
++# define NOKERNINFO (1 << 25)	/* Disable VSTATUS.  */
++# define PENDIN	(1 << 29)	/* Retype pending input (state).  */
++#endif
++#define	_NOFLSH	(1 << 31)	/* Disable flush after interrupt.  */
++#define	NOFLSH	_NOFLSH
++
++  /* Control characters.  */
++#define	VEOF	0		/* End-of-file character [ICANON].  */
++#define	VEOL	1		/* End-of-line character [ICANON].  */
++#ifdef	__USE_BSD
++# define VEOL2	2		/* Second EOL character [ICANON].  */
++#endif
++#define	VERASE	3		/* Erase character [ICANON].  */
++#ifdef	__USE_BSD
++# define VWERASE 4		/* Word-erase character [ICANON].  */
++#endif
++#define	VKILL	5		/* Kill-line character [ICANON].  */
++#ifdef	__USE_BSD
++# define VREPRINT 6		/* Reprint-line character [ICANON].  */
++#endif
++#define	VINTR	8		/* Interrupt character [ISIG].  */
++#define	VQUIT	9		/* Quit character [ISIG].  */
++#define	VSUSP	10		/* Suspend character [ISIG].  */
++#ifdef	__USE_BSD
++# define VDSUSP	11		/* Delayed suspend character [ISIG].  */
++#endif
++#define	VSTART	12		/* Start (X-ON) character [IXON, IXOFF].  */
++#define	VSTOP	13		/* Stop (X-OFF) character [IXON, IXOFF].  */
++#ifdef	__USE_BSD
++# define VLNEXT	14		/* Literal-next character [IEXTEN].  */
++# define VDISCARD 15		/* Discard character [IEXTEN].  */
++#endif
++#define	VMIN	16		/* Minimum number of bytes read at once [!ICANON].  */
++#define	VTIME	17		/* Time-out value (tenths of a second) [!ICANON].  */
++#ifdef	__USE_BSD
++# define VSTATUS 18		/* Status character [ICANON].  */
++#endif
++#define	NCCS	20
++  cc_t c_cc[NCCS];
++
++  /* Input and output baud rates.  */
++#ifdef __USE_BSD
++  speed_t c_ispeed, c_ospeed;
++# define __ispeed c_ispeed
++# define __ospeed c_ospeed
++#else
++  speed_t __ispeed, __ospeed;
++#endif
++#define	B0	0		/* Hang up.  */
++#define	B50	50		/* 50 baud.  */
++#define	B75	75		/* 75 baud.  */
++#define	B110	110		/* 110 baud.  */
++#define	B134	134		/* 134.5 baud.  */
++#define	B150	150		/* 150 baud.  */
++#define	B200	200		/* 200 baud.  */
++#define	B300	300		/* 300 baud.  */
++#define	B600	600		/* 600 baud.  */
++#define	B1200	1200		/* 1200 baud.  */
++#define	B1800	1800		/* 1800 baud.  */
++#define	B2400	2400		/* 2400 baud.  */
++#define	B4800	4800		/* 4800 baud.  */
++#define	B9600	9600		/* 9600 baud.  */
++#define	B19200	19200		/* 19200 baud.  */
++#define	B38400	38400		/* 38400 baud.  */
++#define B76800	76800
++#ifdef	__USE_MISC
++# define EXTA	19200
++# define EXTB	38400
++#endif
++#define B7200	7200
++#define B14400	14400
++#define B28800	28800
++#define	B57600	57600
++#define	B115200	115200
++#define	B230400	230400
++#define	B460800	460800
++#define	B500000	500000
++#define	B576000	576000
++#define	B921600	921600
++#define	B1000000 1000000
++#define	B1152000 1152000
++#define	B1500000 1500000
++#define	B2000000 2000000
++#define	B2500000 2500000
++#define	B3000000 3000000
++#define	B3500000 3500000
++#define	B4000000 4000000
++};
++
++#define _IOT_termios /* Hurd ioctl type field.  */ \
++  _IOT (_IOTS (tcflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)
++
++/* Values for the OPTIONAL_ACTIONS argument to `tcsetattr'.  */
++#define	TCSANOW		0	/* Change immediately.  */
++#define	TCSADRAIN	1	/* Change when pending output is written.  */
++#define	TCSAFLUSH	2	/* Flush pending input before changing.  */
++#ifdef	__USE_BSD
++# define TCSASOFT	0x10	/* Flag: Don't alter hardware state.  */
++#endif
++
++/* Values for the QUEUE_SELECTOR argument to `tcflush'.  */
++#define	TCIFLUSH	1	/* Discard data received but not yet read.  */
++#define	TCOFLUSH	2	/* Discard data written but not yet sent.  */
++#define	TCIOFLUSH	3	/* Discard all pending data.  */
++
++/* Values for the ACTION argument to `tcflow'.  */
++#define	TCOOFF	1		/* Suspend output.  */
++#define	TCOON	2		/* Restart suspended output.  */
++#define	TCIOFF	3		/* Send a STOP character.  */
++#define	TCION	4		/* Send a START character.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,66 @@
++/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
++   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _BITS_TYPES_H
++# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
++#endif
++
++#ifndef	_BITS_TYPESIZES_H
++#define	_BITS_TYPESIZES_H	1
++
++/* See <bits/types.h> for the meaning of these macros.  This file exists so
++   that <bits/types.h> need not vary across different GNU platforms.  */
++
++#define __DEV_T_TYPE		__U32_TYPE
++#define __UID_T_TYPE		__U32_TYPE
++#define __GID_T_TYPE		__U32_TYPE
++#define __INO_T_TYPE		__U32_TYPE
++#define __INO64_T_TYPE		__UQUAD_TYPE
++#define __MODE_T_TYPE		__U16_TYPE
++#define __NLINK_T_TYPE		__U16_TYPE
++#define __OFF_T_TYPE		__SQUAD_TYPE
++#define __OFF64_T_TYPE		__SQUAD_TYPE
++#define __PID_T_TYPE		__S32_TYPE
++#define __RLIM_T_TYPE		__SQUAD_TYPE
++#define __RLIM64_T_TYPE		__SQUAD_TYPE
++#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
++#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
++#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
++#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
++#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
++#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
++#define	__ID_T_TYPE		__U32_TYPE
++#define __CLOCK_T_TYPE		__S32_TYPE
++#define __TIME_T_TYPE		__SLONGWORD_TYPE
++#define __USECONDS_T_TYPE	__U32_TYPE
++#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
++#define __DADDR_T_TYPE		__S32_TYPE
++#define __SWBLK_T_TYPE		__S32_TYPE
++#define __KEY_T_TYPE		__S32_TYPE
++#define __CLOCKID_T_TYPE	__S32_TYPE
++#define __TIMER_T_TYPE		__S32_TYPE
++#define __BLKSIZE_T_TYPE	__U32_TYPE
++#define __FSID_T_TYPE		struct { int __val[2]; }
++#define __SSIZE_T_TYPE		__SWORD_TYPE
++
++/* Number of descriptors that can fit in an `fd_set'.  */
++#define	__FD_SETSIZE		1024
++
++
++#endif /* bits/typesizes.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_UIO_H
++# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
++#endif
++
++
++/* `struct iovec' -- Structure describing a section of memory.  */
++
++struct iovec
++{
++  /* Starting address.  */
++  __ptr_t iov_base;
++  /* Length in bytes.  */
++  size_t iov_len;
++};
++
++/* Maximum number of 'struct iovec's that can be passed to a readv() or
++   writev() system call.  For larger arrays of 'struct iovec', the libc
++   uses a single read() or write() call to guarantee atomicity.  */
++#define UIO_MAXIOV	1024
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,27 @@
++/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_UTSNAME_H
++# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
++#endif
++
++/* Length of the entries in 'struct utsname' is 32.  */
++#define _UTSNAME_LENGTH 32
++
++/* But the version entry is longer.  */
++#define _UTSNAME_VERSION_LENGTH 256
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Definitions of flag bits for `waitpid' et al.
++   Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SYS_WAIT_H && !defined _STDLIB_H
++# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
++#endif
++
++
++/* Bits in the third argument to `waitpid'.  */
++#define	WNOHANG		1	/* Don't block waiting.  */
++#define	WUNTRACED	2	/* Report status of stopped children.  */
++
++#define __WCLONE	0x80000000	/* Wait for cloned process.  */
++#ifdef __USE_BSD
++# define WLINUXCLONE	__WCLONE	/* FreeBSD name for __WCLONE.  */
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,54 @@
++/* Copyright (C) 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Robert Millan <robertmh@gnu.org>
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <unistd.h>
++#include <sys/syscall.h>
++
++#ifndef SYS_break
++#define SYS_break SYS_obreak
++#endif
++
++extern void _end;
++
++/* sbrk.c expects this.  */
++void *__curbrk = &_end;
++
++/* Set the end of the process's data space to ADDR.
++   Return 0 if successful, -1 if not.  */
++int
++__brk (addr)
++     void *addr;
++{
++  if (addr < &_end)
++    return 0;
++
++  if (syscall (SYS_break, addr) == -1)
++    {
++      __set_errno (ENOMEM);
++      return -1;
++    }
++
++  __curbrk = addr;
++  return 0;
++}
++stub_warning (brk)
++
++weak_alias (__brk, brk)
++#include <stub-tag.h>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,102 @@
++/* Create a thread.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#define __clone __no_broken_clone_decl
++#include <sched.h>
++#include <sys/rfork.h>
++#include <errno.h>
++#include <signal.h>
++#include <stddef.h>
++#undef __clone
++
++/* __start_thread (flags, child_stack, fn, arg)
++   is roughly equivalent to
++
++     int retval = __rfork (flags);
++     if (retval == 0)
++       {
++         // Here we are in the child thread.
++         %stackpointer = child_stack;
++         _exit (fn (arg));
++       }
++     return retval;
++
++   but it cannot be done in portable C because it must access fn and arg
++   after having replaced the stack pointer.  */
++
++extern int __start_thread (int flags, void *child_stack,
++			   int (*fn) (void *), void *arg);
++
++int __clone (int (*fn) (void *), void *child_stack, int flags, void *arg)
++{
++  int rfork_flags = RFPROC;
++
++  if (fn == NULL || child_stack == NULL)
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++
++  /* This implementation of clone() does not support all Linux flags.  */
++  if (flags & ~(CSIGNAL | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
++		| CLONE_VFORK))
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++
++  if ((flags & CSIGNAL) != 0 && (flags & CSIGNAL) != SIGCHLD)
++    {
++      /* This implementation of clone() supports only the SIGUSR1 signal.  */
++      if ((flags & CSIGNAL) != SIGUSR1)
++	{
++	  __set_errno (EINVAL);
++	  return -1;
++	}
++      rfork_flags |= RFLINUXTHPN;
++    }
++
++  if (flags & CLONE_VM)
++    rfork_flags |= RFMEM;
++
++  if (flags & CLONE_FS)
++    /* Sharing the filesystem related info (umask, cwd, root dir)
++       is not supported by rfork.  Ignore this; let's hope programs
++       will set their umask and cwd before spawning threads.  */
++    ;
++
++  if (!(flags & CLONE_FILES))
++    rfork_flags |= RFFDG;
++
++  if (flags & CLONE_SIGHAND)
++    {
++      rfork_flags |= RFSIGSHARE;
++      /* Also set the undocumented flag RFTHREAD.  It has the effect that when
++	 the thread leader exits, all threads belonging to it are killed.  */
++      rfork_flags |= RFTHREAD;
++    }
++
++  if (flags & CLONE_VFORK)
++    rfork_flags |= RFPPWAIT;
++
++  return __start_thread (rfork_flags, child_stack, fn, arg);
++}
++
++weak_alias (__clone, clone)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/configure sysdeps/unix/bsd/bsd4.4/kfreebsd/configure
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/configure	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/configure	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,292 @@
++# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
++ # Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
++
++# The kFreeBSD headers can be found in
++#   /usr/src/sys/
++# Check whether this directory is available.
++if test -z "$sysheaders" &&
++   test "x$cross_compiling" = xno &&
++   test -d /usr/src/sys/ ; then
++  sysheaders="/usr/src/sys/"
++  ccheaders=`$CC -print-file-name=include`
++      SYSINCLUDES="-I $sysheaders"
++fi
++
++# Don't bother trying to generate any glue code to be compatible with the
++# existing system library, because we are the only system library.
++inhibit_glue=yes
++
++if test -n "$sysheaders"; then
++  OLD_CPPFLAGS=$CPPFLAGS
++  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
++fi
++
++
++echo "$as_me:$LINENO: checking for egrep" >&5
++echo $ECHO_N "checking for egrep... $ECHO_C" >&6
++if test "${ac_cv_prog_egrep+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
++    then ac_cv_prog_egrep='grep -E'
++    else ac_cv_prog_egrep='egrep'
++    fi
++fi
++echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
++echo "${ECHO_T}$ac_cv_prog_egrep" >&6
++ EGREP=$ac_cv_prog_egrep
++
++
++echo "$as_me:$LINENO: checking installed kFreeBSD kernel header files" >&5
++echo $ECHO_N "checking installed kFreeBSD kernel header files... $ECHO_C" >&6
++if test "${libc_cv_kfreebsdVER+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <osreldate.h>
++#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version <  (5 *10000+ 2 *100+ 0) /* 5.2.0 */
++eat flaming death
++#endif
++_ACEOF
++if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
++  $EGREP "eat flaming death" >/dev/null 2>&1; then
++  libc_cv_kfreebsdVER='TOO OLD!'
++else
++  libc_cv_kfreebsdVER='5.2.0 or later'
++fi
++rm -f conftest*
++
++fi
++echo "$as_me:$LINENO: result: $libc_cv_kfreebsdVER" >&5
++echo "${ECHO_T}$libc_cv_kfreebsdVER" >&6
++if test "$libc_cv_kfreebsdVER" != '5.2.0 or later'; then
++  { { echo "$as_me:$LINENO: error: GNU libc requires kernel header files from
++kFreeBSD 5.2.0 or later to be installed before configuring.
++The kernel header files are found usually in /usr/src/sys/; make sure
++these directories use files from kFreeBSD 5.2.0 or later.
++This check uses <osreldate.h>, so
++make sure that file was built correctly when installing the kernel header
++files.  To use kernel headers not from /usr/src/sys/, use the
++configure option --with-headers." >&5
++echo "$as_me: error: GNU libc requires kernel header files from
++kFreeBSD 5.2.0 or later to be installed before configuring.
++The kernel header files are found usually in /usr/src/sys/; make sure
++these directories use files from kFreeBSD 5.2.0 or later.
++This check uses <osreldate.h>, so
++make sure that file was built correctly when installing the kernel header
++files.  To use kernel headers not from /usr/src/sys/, use the
++configure option --with-headers." >&2;}
++   { (exit 1); exit 1; }; }
++fi
++
++# Check whether --enable-compatible-utmp or --disable-compatible-utmp was given.
++if test "${enable_compatible_utmp+set}" = set; then
++  enableval="$enable_compatible_utmp"
++  enable_utmp_compat=$enableval
++else
++  enable_utmp_compat=no
++fi;
++if test "$enable_utmp_compat" = no; then
++  utmp_subdir=utmp-utmpx
++else
++  utmp_subdir=utmp-compat
++fi
++
++# If the user gave a minimal version number test whether the available
++# kernel headers are young enough.  Additionally we have minimal
++# kernel versions for some architectures.  If a previous configure fragment
++# set arch_minimum_kernel already, let that override our defaults here.
++# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
++# if appropriate too.
++test -n "$arch_minimum_kernel" ||
++case "$machine" in
++  i386*)
++    libc_cv_gcc_unwind_find_fde=yes
++    arch_minimum_kernel=5.2.0
++    ;;
++esac
++if test -n "$minimum_kernel"; then
++
++  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
++  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
++
++  if test $user_version -lt $arch_version; then
++    { echo "$as_me:$LINENO: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&5
++echo "$as_me: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&2;}
++    minimum_kernel=$arch_minimum_kernel
++  fi
++else
++  if test $arch_minimum_kernel != '5.2.0'; then
++    minimum_kernel=$arch_minimum_kernel
++  fi
++fi
++
++if test -n "$minimum_kernel"; then
++  echo "$as_me:$LINENO: checking for kernel header at least $minimum_kernel" >&5
++echo $ECHO_N "checking for kernel header at least $minimum_kernel... $ECHO_C" >&6
++  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 10000 + \2 * 100 + \3)/'`;
++  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
++  cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <osreldate.h>
++#if __FreeBSD_kernel_version < $decnum
++eat flaming death
++#endif
++_ACEOF
++if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
++  $EGREP "eat flaming death" >/dev/null 2>&1; then
++  libc_minimum_kernel='too old!'
++else
++  libc_minimum_kernel=ok
++fi
++rm -f conftest*
++
++  echo "$as_me:$LINENO: result: $libc_minimum_kernel" >&5
++echo "${ECHO_T}$libc_minimum_kernel" >&6
++  if test "$libc_minimum_kernel" = ok; then
++    cat >>confdefs.h <<_ACEOF
++#define __KFREEBSD_KERNEL_VERSION $decnum
++_ACEOF
++
++    cat >>confdefs.h <<_ACEOF
++#define __ABI_TAG_VERSION $abinum
++_ACEOF
++
++  else
++    { { echo "$as_me:$LINENO: error: *** The available kernel headers are older than the requested
++*** compatible kernel version" >&5
++echo "$as_me: error: *** The available kernel headers are older than the requested
++*** compatible kernel version" >&2;}
++   { (exit 1); exit 1; }; }
++  fi
++fi
++
++if test -n "$sysheaders"; then
++  CPPFLAGS=$OLD_CPPFLAGS
++fi
++# The Linux filesystem standard prescribes where to place "essential"
++# files.  I.e., when the installation prefix is "/usr" we have to place
++# shared library objects and the configuration files on the root partition
++# in /lib and /etc.
++case "$prefix" in
++/usr | /usr/)
++  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
++  case $machine in
++  sparc/sparc64 | powerpc/powerpc64 | s390/s390-64 | \
++  mips/mips64/n64/* )
++    libc_cv_slibdir="/lib64"
++    if test "$libdir" = '${exec_prefix}/lib'; then
++      libdir='${exec_prefix}/lib64';
++      # Locale data can be shared between 32bit and 64bit libraries
++      libc_cv_localedir='${exec_prefix}/lib/locale'
++    fi
++    ;;
++  mips/mips64/n32/* )
++    libc_cv_slibdir="/lib32"
++    if test "$libdir" = '${exec_prefix}/lib'; then
++      libdir='${exec_prefix}/lib32';
++      # Locale data can be shared between 32bit and 64bit libraries
++      libc_cv_localedir='${exec_prefix}/lib/locale'
++    fi
++    ;;
++  *)
++    libc_cv_slibdir="/lib"
++    ;;
++  esac
++  # Allow the user to override the path with --sysconfdir
++  if test $sysconfdir = '${prefix}/etc'; then
++    libc_cv_sysconfdir=/etc
++  else
++    libc_cv_sysconfdir=$sysconfdir
++   fi
++  libc_cv_rootsbindir="/sbin"
++  ;;
++esac
++
++
++# Put exception handling support into libc, so that not every shared
++# library needs to include it.
++# FIXME: Does not work yet.
++#libc_cv_gcc_unwind_find_fde=yes
++
++if test "$linuxthreads_missing"; then
++  if test $enable_sanity = yes; then
++    echo "\
++*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
++*** \`linuxthreads' add-on.  Without that, the library will be
++*** incompatible with normal GNU/kFreeBSD systems.
++*** If you really mean to not use this add-on, run configure again
++*** using the extra parameter \`--disable-sanity-checks'."
++    exit 1
++  else
++    echo "\
++*** WARNING: Are you sure you do not want to use the \`linuxthreads'
++*** add-on?"
++  fi
++fi
++
++if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
++  if test $enable_sanity = yes; then
++    echo "\
++*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
++*** /usr/local since this might make your system totally unusable.
++*** We strongly advise to use a different prefix.  For details read the FAQ.
++*** If you really mean to do this, run configure again using the extra
++*** parameter \`--disable-sanity-checks'."
++    exit 1
++  else
++    echo "\
++*** WARNING: Do you really want to install the GNU C Library into /usr/local?
++*** This might make your system totally unusable, for details read the FAQ."
++  fi
++fi
++
++
++# One kFreeBSD we use ldconfig.
++use_ldconfig=yes
++
++if test $host = $build; then
++  # If $prefix/include/{net,scsi} are symlinks, make install will
++  # clobber what they're linked to (probably a kernel tree).
++  # test -L ought to work on all Linux boxes.
++  if test "x$prefix" != xNONE; then
++    ac_prefix=$prefix
++  else
++    ac_prefix=$ac_default_prefix
++  fi
++  echo "$as_me:$LINENO: checking for symlinks in ${ac_prefix}/include" >&5
++echo $ECHO_N "checking for symlinks in ${ac_prefix}/include... $ECHO_C" >&6
++  ac_message=
++  if test -L ${ac_prefix}/include/net; then
++    ac_message="$ac_message
++   ${ac_prefix}/include/net is a symlink"
++  fi
++  if test -L ${ac_prefix}/include/scsi; then
++    ac_message="$ac_message
++   ${ac_prefix}/include/scsi is a symlink"
++  fi
++  if test -n "$ac_message"; then
++    { { echo "$as_me:$LINENO: error: $ac_message
++\`make install' will destroy the target of the link(s).
++Delete the links and re-run configure, or better still, move the entire
++${ac_prefix}/include directory out of the way." >&5
++echo "$as_me: error: $ac_message
++\`make install' will destroy the target of the link(s).
++Delete the links and re-run configure, or better still, move the entire
++${ac_prefix}/include directory out of the way." >&2;}
++   { (exit 1); exit 1; }; }
++  else
++    echo "$as_me:$LINENO: result: ok" >&5
++echo "${ECHO_T}ok" >&6
++  fi
++fi
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,217 @@
++GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
++# Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
++
++# The kFreeBSD headers can be found in
++#   /usr/src/sys/
++# Check whether this directory is available.
++if test -z "$sysheaders" && 
++   test "x$cross_compiling" = xno &&
++   test -d /usr/src/sys/ ; then
++  sysheaders="/usr/src/sys/"
++  ccheaders=`$CC -print-file-name=include`
++  dnl We don't have to use -nostdinc.  We just want one more directory
++  dnl to be used.
++  SYSINCLUDES="-I $sysheaders"
++fi
++
++# Don't bother trying to generate any glue code to be compatible with the
++# existing system library, because we are the only system library.
++inhibit_glue=yes
++
++define([LIBC_KFREEBSD_VERSION],[5.2.0])dnl
++if test -n "$sysheaders"; then
++  OLD_CPPFLAGS=$CPPFLAGS
++  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
++fi
++define([libc_cv_linuxVER], [libc_cv_linux]patsubst(LIBC_KFREEBSD_VERSION,[\.]))dnl
++AC_CACHE_CHECK(installed kFreeBSD kernel header files, libc_cv_kfreebsdVER, [dnl
++AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
++#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version < ]dnl
++patsubst(LIBC_KFREEBSD_VERSION,[^\([^.]*\)\.\([^.]*\)\.\([^.]*\)$],dnl
++[ (\1 *10000+ \2 *100+ \3) /* \1.\2.\3 */])[
++eat flaming death
++#endif],
++	     libc_cv_kfreebsdVER='TOO OLD!',
++	     libc_cv_kfreebsdVER='LIBC_KFREEBSD_VERSION or later')])
++if test "$libc_cv_kfreebsdVER" != 'LIBC_KFREEBSD_VERSION or later'; then
++  AC_MSG_ERROR([GNU libc requires kernel header files from
++kFreeBSD LIBC_KFREEBSD_VERSION or later to be installed before configuring.
++The kernel header files are found usually in /usr/src/sys/; make sure
++these directories use files from kFreeBSD LIBC_KFREEBSD_VERSION or later.  
++This check uses <osreldate.h>, so
++make sure that file was built correctly when installing the kernel header
++files.  To use kernel headers not from /usr/src/sys/, use the
++configure option --with-headers.])
++fi
++
++AC_ARG_ENABLE(compatible-utmp, dnl
++[  --disable-compatible-utmp  use a struct utmp which is the same as struct
++                          utmpx, as on kFreeBSD, but incompatible with FreeBSD],
++              enable_utmp_compat=$enableval, enable_utmp_compat=no)
++if test "$enable_utmp_compat" = no; then
++  utmp_subdir=utmp-utmpx
++else
++  utmp_subdir=utmp-compat
++fi
++
++# If the user gave a minimal version number test whether the available
++# kernel headers are young enough.  Additionally we have minimal
++# kernel versions for some architectures.  If a previous configure fragment
++# set arch_minimum_kernel already, let that override our defaults here.
++# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
++# if appropriate too.
++test -n "$arch_minimum_kernel" ||
++case "$machine" in
++  i386*)
++    libc_cv_gcc_unwind_find_fde=yes
++    arch_minimum_kernel=5.2.0
++    ;;
++esac
++if test -n "$minimum_kernel"; then
++  changequote(,)
++  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
++  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
++  changequote([,])
++  if test $user_version -lt $arch_version; then
++    AC_MSG_WARN([minimum kernel version reset to $arch_minimum_kernel])
++    minimum_kernel=$arch_minimum_kernel
++  fi
++else
++  if test $arch_minimum_kernel != '5.2.0'; then
++    minimum_kernel=$arch_minimum_kernel
++  fi
++fi
++
++if test -n "$minimum_kernel"; then
++  AC_MSG_CHECKING(for kernel header at least $minimum_kernel)
++changequote(,)dnl
++  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 10000 + \2 * 100 + \3)/'`;
++  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
++changequote([,])dnl
++  AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
++#if __FreeBSD_kernel_version < $decnum
++eat flaming death
++#endif], libc_minimum_kernel='too old!', libc_minimum_kernel=ok)
++  AC_MSG_RESULT($libc_minimum_kernel)
++  if test "$libc_minimum_kernel" = ok; then
++    AC_DEFINE_UNQUOTED(__KFREEBSD_KERNEL_VERSION, $decnum)
++    AC_DEFINE_UNQUOTED(__ABI_TAG_VERSION, $abinum)
++  else
++    AC_MSG_ERROR([*** The available kernel headers are older than the requested
++*** compatible kernel version])
++  fi
++fi
++
++if test -n "$sysheaders"; then
++  CPPFLAGS=$OLD_CPPFLAGS
++fi
++# The Linux filesystem standard prescribes where to place "essential"
++# files.  I.e., when the installation prefix is "/usr" we have to place
++# shared library objects and the configuration files on the root partition
++# in /lib and /etc.
++case "$prefix" in
++/usr | /usr/)
++  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
++  case $machine in
++  sparc/sparc64 | powerpc/powerpc64 | s390/s390-64 | \
++  mips/mips64/n64/* )
++    libc_cv_slibdir="/lib64"
++    if test "$libdir" = '${exec_prefix}/lib'; then
++      libdir='${exec_prefix}/lib64';
++      # Locale data can be shared between 32bit and 64bit libraries
++      libc_cv_localedir='${exec_prefix}/lib/locale'
++    fi
++    ;;
++  mips/mips64/n32/* )
++    libc_cv_slibdir="/lib32"
++    if test "$libdir" = '${exec_prefix}/lib'; then
++      libdir='${exec_prefix}/lib32';
++      # Locale data can be shared between 32bit and 64bit libraries
++      libc_cv_localedir='${exec_prefix}/lib/locale'
++    fi
++    ;;
++  *)
++    libc_cv_slibdir="/lib"
++    ;;
++  esac
++  # Allow the user to override the path with --sysconfdir
++  if test $sysconfdir = '${prefix}/etc'; then
++    libc_cv_sysconfdir=/etc
++  else
++    libc_cv_sysconfdir=$sysconfdir
++   fi
++  libc_cv_rootsbindir="/sbin"
++  ;;
++esac
++
++
++# Put exception handling support into libc, so that not every shared
++# library needs to include it.
++# FIXME: Does not work yet.
++#libc_cv_gcc_unwind_find_fde=yes
++
++if test "$linuxthreads_missing"; then
++  if test $enable_sanity = yes; then
++    echo "\
++*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
++*** \`linuxthreads' add-on.  Without that, the library will be
++*** incompatible with normal GNU/kFreeBSD systems.
++*** If you really mean to not use this add-on, run configure again
++*** using the extra parameter \`--disable-sanity-checks'."
++    exit 1
++  else
++    echo "\
++*** WARNING: Are you sure you do not want to use the \`linuxthreads'
++*** add-on?"
++  fi
++fi
++
++if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
++  if test $enable_sanity = yes; then
++    echo "\
++*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
++*** /usr/local since this might make your system totally unusable.
++*** We strongly advise to use a different prefix.  For details read the FAQ.
++*** If you really mean to do this, run configure again using the extra
++*** parameter \`--disable-sanity-checks'."
++    exit 1
++  else
++    echo "\
++*** WARNING: Do you really want to install the GNU C Library into /usr/local?
++*** This might make your system totally unusable, for details read the FAQ."
++  fi
++fi
++
++
++# One kFreeBSD we use ldconfig.
++use_ldconfig=yes
++
++if test $host = $build; then
++  # If $prefix/include/{net,scsi} are symlinks, make install will
++  # clobber what they're linked to (probably a kernel tree).
++  # test -L ought to work on all Linux boxes.
++  if test "x$prefix" != xNONE; then
++    ac_prefix=$prefix
++  else
++    ac_prefix=$ac_default_prefix
++  fi
++  AC_MSG_CHECKING([for symlinks in ${ac_prefix}/include])
++  ac_message=
++  if test -L ${ac_prefix}/include/net; then
++    ac_message="$ac_message
++   ${ac_prefix}/include/net is a symlink"
++  fi
++  if test -L ${ac_prefix}/include/scsi; then
++    ac_message="$ac_message
++   ${ac_prefix}/include/scsi is a symlink"
++  fi
++  if test -n "$ac_message"; then
++    AC_MSG_ERROR([$ac_message
++\`make install' will destroy the target of the link(s).
++Delete the links and re-run configure, or better still, move the entire
++${ac_prefix}/include directory out of the way.])
++  else
++    AC_MSG_RESULT(ok)
++  fi
++fi
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,30 @@
++bits/mcontext.h
++bits/stat16.h
++fpu.h
++machine/pal.h
++net/ethernet.h
++net/if_arp.h
++net/if_dl.h
++net/route.h
++nfs/nfs.h
++regdef.h
++stat16conv.c
++statconv.c
++statfsconv.c
++statvfsconv.c
++sys/acl.h
++sys/extattr.h
++sys/io.h
++sys/jail.h
++sys/ktrace.h
++sys/linker.h
++sys/mount.h
++sys/perm.h
++sys/rfork.h
++sys/rtprio.h
++sys/syslimits.h
++sys/timex.h
++sys/vm86.h
++sys_lseek.S
++sysarch.h
++ucontext_i.h
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,41 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++#include <sys/stat.h>
++#include <bits/stat16.h>
++#include <sysdep.h>
++
++#include "stat16conv.c"
++
++extern int __syscall_fhstat (const fhandle_t *fhp, struct stat16 *buf);
++
++int
++fhstat64 (const fhandle_t *fhp, struct stat64 *buf)
++{
++  struct stat16 buf16;
++
++  if (__syscall_fhstat (fhp, &buf16) < 0)
++    return -1;
++
++  /* Convert a 'struct stat16' to 'struct stat64'.  */
++  stat16_to_stat64 (&buf16, buf);
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,43 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++#include <sys/stat.h>
++#include <bits/stat16.h>
++#include <sysdep.h>
++
++#include "stat16conv.c"
++
++extern int __syscall_fhstat (const fhandle_t *fhp, struct stat16 *buf);
++
++int
++__fhstat (const fhandle_t *fhp, struct stat *buf)
++{
++  struct stat16 buf16;
++
++  if (__syscall_fhstat (fhp, &buf16) < 0)
++    return -1;
++
++  /* Convert a 'struct stat16' to 'struct stat'.  */
++  stat16_to_stat (&buf16, buf);
++
++  return 0;
++}
++
++weak_alias (__fhstat, fhstat)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,38 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++
++#include "statfsconv.c"
++
++extern int __fhstatfs (const fhandle_t *fhp, struct statfs *buf);
++
++int
++fhstatfs64 (const fhandle_t *fhp, struct statfs64 *buf)
++{
++  struct statfs buf32;
++
++  if (__fhstatfs (fhp, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statfs64'.  */
++  statfs_to_statfs64 (&buf32, buf);
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,40 @@
++/* Return information about the filesystem on which FD resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statfs.h>
++
++#include "statfsconv.c"
++
++/* Return information about the filesystem on which FD resides.  */
++int
++__fstatfs64 (int fd, struct statfs64 *buf)
++{
++  struct statfs buf32;
++
++  if (__fstatfs (fd, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statfs64'.  */
++  statfs_to_statfs64 (&buf32, buf);
++
++  return 0;
++}
++
++weak_alias (__fstatfs64, fstatfs64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,41 @@
++/* Return information about the filesystem on which FD resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statvfs.h>
++#include <sys/statfs.h>
++
++#include "statvfsconv.c"
++
++/* Return information about the filesystem on which FD resides.  */
++int
++__fstatvfs64 (int fd, struct statvfs64 *buf)
++{
++  struct statfs buf32;
++
++  if (__fstatfs (fd, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
++  statfs_to_statvfs64 (&buf32, buf);
++
++  return 0;
++}
++
++weak_alias (__fstatvfs64, fstatvfs64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,40 @@
++/* Return information about the filesystem on which FD resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statvfs.h>
++#include <sys/statfs.h>
++
++#include "statvfsconv.c"
++
++/* Return information about the filesystem on which FD resides.  */
++int
++fstatvfs (int fd, struct statvfs *buf)
++{
++  struct statfs buf32;
++
++  if (__fstatfs (fd, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statvfs'.  */
++  statfs_to_statvfs (&buf32, buf);
++
++  return 0;
++}
++libc_hidden_def (fstatvfs)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c	2005-08-23 17:49:51.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++int
++__ftruncate64 (int fd, __off64_t length)
++{
++  /* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
++  return __ftruncate (fd, (__off_t) length);
++}
++
++weak_alias (__ftruncate64, ftruncate64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c	2005-08-23 17:39:42.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern int __syscall_ftruncate (int __fd, int __unused1,
++				__off_t __length) __THROW;
++
++int
++__ftruncate (int fd, __off_t length)
++{
++  /* We pass 2 arguments in 4 words.  */
++  return INLINE_SYSCALL (ftruncate, 2, fd, 0, length);
++}
++
++weak_alias (__ftruncate, ftruncate)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,47 @@
++/* fxstat using FreeBSD fstat, nfstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_nfstat (int, struct stat32 *__unbounded);
++
++int
++__fxstat64 (int vers, int fd, struct stat64 *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nfstat (fd, __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat64 (&buf32, buf);
++      return result;
++    }
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__fxstat64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,55 @@
++/* fxstat using FreeBSD fstat, nfstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat16.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_fstat (int, struct stat16 *__unbounded);
++extern int __syscall_nfstat (int, struct stat32 *__unbounded);
++
++int
++__fxstat (int vers, int fd, struct stat *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nfstat (fd, __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat (&buf32, buf);
++      return result;
++    }
++  else if (__builtin_expect (vers == _STAT_VER_nstat, 1))
++    return __syscall_nfstat (fd, CHECK_1 ((struct stat32 *) buf));
++  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
++    return __syscall_fstat (fd, CHECK_1 ((struct stat16 *) buf));
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__fxstat)
++
++weak_alias (__fxstat, _fxstat)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,90 @@
++/* Determine current working directory.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <limits.h>
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++
++#include <sysdep.h>
++#include <bp-checks.h>
++
++/* The system calls only makes a lookup in the VFS cache, which can easily
++   fail.  Therefore we use the generic version as a fallback.  */
++extern int __syscall_getcwd (char *__unbounded buf, unsigned int size);
++static char *generic_getcwd (char *buf, size_t size) internal_function;
++
++char *
++__getcwd (char *buf, size_t size)
++{
++  char tmpbuf[PATH_MAX];
++
++  if (INLINE_SYSCALL (getcwd, 2, tmpbuf, PATH_MAX) >= 0)
++    {
++      size_t len = strlen (tmpbuf) + 1;
++
++      if (size == 0)
++	{
++	  if (__builtin_expect (buf != NULL, 0))
++	    {
++	      __set_errno (EINVAL);
++	      return NULL;
++	    }
++
++	  buf = (char *) malloc (len);
++	  if (__builtin_expect (buf == NULL, 0))
++	    {
++	      __set_errno (ENOMEM);
++	      return NULL;
++	    }
++	}
++      else
++	{
++	  if (size < len)
++	    {
++	      __set_errno (ERANGE);
++	      return NULL;
++	    }
++
++	  if (buf == NULL)
++	    {
++	      buf = (char *) malloc (size);
++	      if (__builtin_expect (buf == NULL, 0))
++		{
++		  __set_errno (ENOMEM);
++		  return NULL;
++		}
++	    }
++	}
++
++      memcpy (buf, tmpbuf, len);
++      return buf;
++    }
++
++  return generic_getcwd (buf, size);
++}
++
++weak_alias (__getcwd, getcwd)
++
++/* Get the code for the generic version.  */
++#define GETCWD_RETURN_TYPE	static char * internal_function
++#define __getcwd		generic_getcwd
++#include <sysdeps/posix/getcwd.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++/* We have the function getdirentries64 in file getdirentries64.c.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,89 @@
++/* Read directory entries, 3 argument function.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <dirent.h>
++#include <sys/types.h>
++#include <errno.h>
++#include <sysdep.h>
++
++#if 1
++
++/* Use the 3-argument system call.  */
++
++extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
++
++/* Read directory entries from FD into BUF, reading at most NBYTES.
++   Returns the number of bytes read; zero when at end of directory; or
++   -1 for errors.  */
++ssize_t
++internal_function
++__getdents (int fd, char *buf, size_t nbytes)
++{
++  return __syscall_getdents (fd, buf, nbytes);
++}
++
++/* Export getdents().  Not an internal_function.  */
++ssize_t
++getdents (int fd, char *buf, size_t nbytes)
++{
++  return __syscall_getdents (fd, buf, nbytes);
++}
++
++#else
++
++/* Use the 4-argument system call.  */
++
++extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
++				    long *basep);
++
++/* Read directory entries from FD into BUF, reading at most NBYTES.
++   Returns the number of bytes read; zero when at end of directory; or
++   -1 for errors.  */
++ssize_t
++internal_function
++__getdents (int fd, char *buf, size_t nbytes)
++{
++  /* On 64-bit platforms, the system call differs from this function
++     because it takes an 'unsigned int', not a 'size_t'.  */
++  unsigned int nbytes32;
++
++  nbytes32 = nbytes;
++  if (nbytes32 == nbytes)
++    return __syscall_getdirentries (fd, buf, nbytes32, NULL);
++  else
++    {
++      /* NBYTES is too large.  */
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++
++/* Export getdents().  Not an internal_function.  */
++ssize_t
++getdents (int fd, char *buf, size_t nbytes)
++{
++  return __getdents (fd, buf, nbytes);
++}
++
++#endif
++
++/* Since 'struct dirent64' == 'struct dirent', the functions '__getdents64'
++   and '__getdents' are equal.  */
++strong_alias (__getdents, __getdents64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,5 @@
++/* Since 'struct dirent64' == 'struct dirent', the functions 'getdirentries64'
++   and 'getdirentries' differ only in the type of the BASEP argument.  */
++#define GETDIRENTRIES getdirentries64
++#define OFF_T off64_t
++#include <sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,100 @@
++/* Read directory entries, 4 argument function.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef GETDIRENTRIES
++# define GETDIRENTRIES getdirentries
++# define OFF_T off_t
++#endif
++
++#include <dirent.h>
++#include <sys/types.h>
++#include <unistd.h>
++#include <errno.h>
++#include <sysdep.h>
++
++#if 1
++
++/* Use the 4-argument system call.  */
++
++extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
++				    long *basep);
++
++/* Read directory entries from FD into BUF, reading at most NBYTES.
++   Reading starts at offset *BASEP, and *BASEP is updated with the new
++   position after reading.  Returns the number of bytes read; zero when at
++   end of directory; or -1 for errors.  */
++/* FIXME: This is not what this function does.  It starts reading at the
++   current position of FD, not at *BASEP.  */
++ssize_t
++GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
++{
++  /* On 32-bit platforms, the system call differs from this function because
++     it takes a 'long *', not an 'OFF_T *'.  On 64-bit platforms, the system
++     call differs from this function because it takes an 'unsigned int', not
++     a 'size_t'.  */
++  unsigned int nbytes32;
++
++  nbytes32 = nbytes;
++  if (nbytes32 == nbytes)
++    {
++      long base;
++      int result = __syscall_getdirentries (fd, buf, nbytes32, &base);
++
++      if (result >= 0 && basep != NULL)
++	*basep = base;
++      return result;
++    }
++  else
++    {
++      /* NBYTES is too large.  */
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++
++#else
++
++/* Use the 3-argument system call.  */
++
++extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
++
++/* Read directory entries from FD into BUF, reading at most NBYTES.
++   Reading starts at offset *BASEP, and *BASEP is updated with the new
++   position after reading.  Returns the number of bytes read; zero when at
++   end of directory; or -1 for errors.  */
++/* FIXME: This is not what this function does.  It starts reading at the
++   current position of FD, not at *BASEP.  */
++ssize_t
++GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
++{
++  OFF_T base = 0;
++  ssize_t result;
++
++  if (basep)
++    base = __lseek (fd, (off_t) 0, SEEK_CUR);
++
++  result = __syscall_getdents (fd, buf, nbytes);
++
++  if (basep && result >= 0)
++    *basep = base;
++  return result;
++}
++
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,103 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++#include <sys/param.h>
++#include <errno.h>
++#include <string.h>
++
++/* Put the name of the current NIS domain in no more than LEN bytes of NAME.
++   The result is null-terminated if LEN is large enough for the full
++   name and the terminator.  */
++
++int
++getdomainname (char *name, size_t len)
++{
++  /* Fetch the "kern.domainname" sysctl value.  */
++  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
++#if 1
++  size_t result_len = len;
++
++  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
++    {
++      if (errno == ENOMEM)
++	__set_errno (ENAMETOOLONG);
++      return -1;
++    }
++
++  if (result_len == len)
++    {
++      __set_errno (ENAMETOOLONG);
++      return -1;
++    }
++
++  name[result_len] = '\0';
++  return 0;
++#else
++  char buf[MAXHOSTNAMELEN + 1];
++  char *result;
++  size_t result_len;
++  char *bufend;
++  size_t buflen;
++
++  if (len >= MAXHOSTNAMELEN)
++    {
++      result = name;
++      result_len = len - 1;
++    }
++  else
++    {
++      /* Use a temporary buffer, so that we can detect the ENAMETOOLONG
++	 condition.  (Well, we could also rely on the ENOMEM error code.)  */
++      result = buf;
++      result_len = MAXHOSTNAMELEN;
++    }
++
++  if (__sysctl (request, 2, result, &result_len, NULL, 0) < 0)
++    return -1;
++
++  /* If we used no temporary buffer, we are done.  */
++  if (result == name)
++    {
++      result[resultlen] = '\0';
++      return 0;
++    }
++
++  /* See if the result fits in the caller's buffer.  */
++  bufend = memchr (buf, '\0', result_len);
++  if (bufend == NULL)
++    {
++      bufend = buf + result_len;
++      *bufend = '\0';
++    }
++  buflen = bufend - buf + 1;
++
++  /* Copy into the caller's buffer.  */
++  memcpy (name, buf, len < buflen ? len : buflen);
++
++  if (len < buflen)
++    {
++      __set_errno (ENAMETOOLONG);
++      return -1;
++    }
++  return 0;
++#endif
++}
++libc_hidden_def (getdomainname)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,48 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++
++#include "statfsconv.c"
++
++int
++__getfsstat64 (struct statfs64 *buf, long bufsize, int flags)
++{
++  long bufcount;
++  struct statfs *smallbuf;
++  int count, i;
++
++  if (bufsize < 0)
++    bufsize = 0;
++  bufcount = bufsize / sizeof (struct statfs64);
++
++  /* Since sizeof (struct statfs) <= sizeof (struct statfs64), we can use
++     buf as temporary buffer.  */
++  smallbuf = (struct statfs *) buf;
++
++  count = __getfsstat (smallbuf, bufcount * sizeof (struct statfs), flags);
++  if (count > 0)
++    for (i = count - 1; i >= 0; i--)
++      /* Convert a 'struct statfs' to 'struct statfs64'.  */
++      statfs_to_statfs64 (&smallbuf[i], &buf[i]);
++
++  return count;
++}
++
++weak_alias (__getfsstat64, getfsstat64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++
++/* Return the current machine's Internet number.  */
++long int
++gethostid (void)
++{
++  /* Fetch sysctl value of "kern.hostid".  */
++  int request[2] = { CTL_KERN, KERN_HOSTID };
++  int result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    /* Dummy result.  */
++    return 0;
++
++  return result;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,52 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++#include <errno.h>
++
++/* Put the name of the current host in no more than LEN bytes of NAME. 
++   The result is null-terminated if LEN is large enough for the full
++   name and the terminator.  */
++
++int
++__gethostname (char *name, size_t len)
++{
++  /* Fetch the "kern.hostname" sysctl value.  */
++  int request[2] = { CTL_KERN, KERN_HOSTNAME };
++  size_t result_len = len;
++
++  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
++    {
++      if (errno == ENOMEM)
++	__set_errno (ENAMETOOLONG);
++      return -1;
++    }
++
++  if (result_len >= len)
++    {
++      __set_errno (ENAMETOOLONG);
++      return -1;
++    }
++
++  name[result_len] = '\0';
++  return 0;
++}
++
++weak_alias (__gethostname, gethostname)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Get system load averages.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stdlib.h>
++#include <sys/sysctl.h>
++
++struct loadavg
++  {
++    unsigned int ldavg[3];
++    long fscale;
++  };
++
++/* Put the 1 minute, 5 minute and 15 minute load averages into the first
++   NELEM elements of LOADAVG.  Return the number written (never more than
++   three, but may be less than NELEM), or -1 if an error occurred.  */
++int
++getloadavg (double loadavg[], int nelem)
++{
++  if (nelem > 3)
++    nelem = 3;
++  if (nelem > 0)
++    {
++      /* Fetch the "vm.loadavg" sysctl value.  */
++      int request[2] = { CTL_VM, VM_LOADAVG };
++      struct loadavg result;
++      size_t result_len = sizeof (result);
++      int i;
++
++      if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++	return -1;
++
++      for (i = 0; i < nelem; i++)
++	loadavg[i] = (double) result.ldavg[i] / (double) result.fscale;
++    }
++  return nelem;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,49 @@
++/* Non-reentrant function to return the current login name.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++#include <sys/param.h>
++#include <sysdep.h>
++
++/* Defined in getlogin_r.c.  */
++extern char *__getlogin_cache;
++extern char __getlogin_cache_room[MAXLOGNAME];
++
++extern int __syscall_getlogin (char *__name, size_t __name_len);
++
++/* Return the login name of the user, or NULL if it can't be determined.
++   The returned pointer, if not NULL, is good only until the next call.  */
++
++char *
++getlogin (void)
++{
++  if (__getlogin_cache == NULL)
++    {
++      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
++	return NULL;
++      /* The system call should return a NULL terminated name.  */
++      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
++	abort ();
++      __getlogin_cache = __getlogin_cache_room;
++    }
++  return (__getlogin_cache[0] ? __getlogin_cache : NULL);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,69 @@
++/* Reentrant function to return the current login name.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++#include <sys/param.h>
++#include <sysdep.h>
++
++/* Cache the system call's return value.  */
++char *__getlogin_cache;
++/* The kernel never returns more than MAXLOGNAME bytes, therefore we don't
++   need more than that either.  */
++char __getlogin_cache_room[MAXLOGNAME];
++
++extern int __syscall_getlogin (char *__name, size_t __name_len);
++
++/* Return at most NAME_LEN characters of the login name of the user in NAME.
++   If it cannot be determined or some other error occurred, return the error
++   code.  Otherwise return 0.
++   Note that the getlogin_r function in FreeBSD libc returns a 'char *',
++   but SUSV2 wants a return type of 'int'.  */
++
++int
++getlogin_r (char *name, size_t name_len)
++{
++  size_t len;
++
++  if (__getlogin_cache == NULL)
++    {
++      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
++	return -1;
++      /* The system call should return a NULL terminated name.  */
++      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
++	abort ();
++      __getlogin_cache = __getlogin_cache_room;
++    }
++
++  len = strlen (__getlogin_cache);
++  if (__builtin_expect (len < name_len, 1))
++    {
++      memcpy (name, __getlogin_cache, len + 1);
++      return 0;
++    }
++  else
++    {
++      __set_errno (ERANGE);
++      return -1;
++    }
++}
++libc_hidden_def (getlogin_r)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,78 @@
++/* Return list of mounted filesystems.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++#include <stdlib.h>
++#include <errno.h>
++
++static int mntbufsize;
++static struct statfs64 *mntbuf;
++
++/* Return list of mounted filesystems.
++   Inherently not multithread-safe.  */
++int
++getmntinfo64 (struct statfs64 **mntbufp, int flags)
++{
++  for (;;)
++    {
++      int count = __getfsstat64 (NULL, 0, flags);
++      int count2;
++
++      if (count < 0)
++	return 0;
++
++      if (count == 0)
++	{
++	  __set_errno (0);
++	  return 0;
++	}
++
++      if (count > mntbufsize)
++	{
++	  if (mntbuf != NULL)
++	    free (mntbuf);
++	  mntbufsize = 0;
++	  mntbuf = (struct statfs64 *) malloc (count * sizeof (struct statfs64));
++	  if (mntbuf == NULL)
++	    {
++	      __set_errno (ENOMEM);
++	      return 0;
++	    }
++	  mntbufsize = count;
++	}
++
++      count2 = __getfsstat64 (mntbuf, count * sizeof (struct statfs64), flags);
++
++      if (count2 < 0)
++	return 0;
++
++      if (count2 == 0)
++	{
++	  __set_errno (0);
++	  return 0;
++	}
++
++      if (count2 <= count)
++	{
++	  *mntbufp = mntbuf;
++	  return count2;
++	}
++    }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,80 @@
++/* Return list of mounted filesystems.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/mount.h>
++#include <stdlib.h>
++#include <errno.h>
++
++static int mntbufsize;
++static struct statfs *mntbuf;
++
++/* Return list of mounted filesystems.
++   Inherently not multithread-safe.  */
++int
++__getmntinfo (struct statfs **mntbufp, int flags)
++{
++  for (;;)
++    {
++      int count = __getfsstat (NULL, 0, flags);
++      int count2;
++
++      if (count < 0)
++	return 0;
++
++      if (count == 0)
++	{
++	  __set_errno (0);
++	  return 0;
++	}
++
++      if (count > mntbufsize)
++	{
++	  if (mntbuf != NULL)
++	    free (mntbuf);
++	  mntbufsize = 0;
++	  mntbuf = (struct statfs *) malloc (count * sizeof (struct statfs));
++	  if (mntbuf == NULL)
++	    {
++	      __set_errno (ENOMEM);
++	      return 0;
++	    }
++	  mntbufsize = count;
++	}
++
++      count2 = __getfsstat (mntbuf, count * sizeof (struct statfs), flags);
++
++      if (count2 < 0)
++	return 0;
++
++      if (count2 == 0)
++	{
++	  __set_errno (0);
++	  return 0;
++	}
++
++      if (count2 <= count)
++	{
++	  *mntbufp = mntbuf;
++	  return count2;
++	}
++    }
++}
++
++weak_alias (__getmntinfo, getmntinfo)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,42 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++
++/* Return the system page size.  */
++int
++__getpagesize (void)
++{
++  static int cached_pagesize /* = 0 */;
++
++  if (cached_pagesize == 0)
++    {
++      /* Fetch sysctl value of "hw.pagesize".  */
++      int request[2] = { CTL_HW, HW_PAGESIZE };
++      size_t result_len = sizeof (cached_pagesize);
++
++      if (__sysctl (request, 2, &cached_pagesize, &result_len, NULL, 0) < 0)
++	return -1;
++    }
++  return cached_pagesize;
++}
++libc_hidden_def (__getpagesize)
++
++weak_alias (__getpagesize, getpagesize)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,92 @@
++/* Copyright (C) 1998-1999, 2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <fcntl.h>
++#include <string.h>
++#include <unistd.h>
++#include <sys/ioctl.h>
++
++
++/* Prefix for master pseudo terminal nodes.  */
++#define _PATH_PTY "/dev/pty"
++
++
++/* Letters indicating a series of pseudo terminals.  */
++#ifndef PTYNAME1
++#define PTYNAME1 "pqrs"
++#endif
++const char __libc_ptyname1[] attribute_hidden = PTYNAME1;
++
++/* Letters indicating the position within a series.  */
++#ifndef PTYNAME2
++#define PTYNAME2 "0123456789abcdefghijklmnopqrstuv";
++#endif
++const char __libc_ptyname2[] attribute_hidden = PTYNAME2;
++
++
++/* Open a master pseudo terminal and return its file descriptor.  */
++int
++__posix_openpt (int oflag)
++{
++  char buf[sizeof (_PATH_PTY) + 2];
++  const char *p, *q;
++  char *s;
++
++  s = __mempcpy (buf, _PATH_PTY, sizeof (_PATH_PTY) - 1);
++  /* s[0] and s[1] will be filled in the loop.  */
++  s[2] = '\0';
++
++  for (p = __libc_ptyname1; *p != '\0'; ++p)
++    {
++      s[0] = *p;
++
++      for (q = __libc_ptyname2; *q != '\0'; ++q)
++	{
++	  int fd;
++
++	  s[1] = *q;
++
++	  fd = __open (buf, oflag);
++	  if (fd >= 0)
++	    {
++	      if (!(oflag & O_NOCTTY))
++		__ioctl (fd, TIOCSCTTY, NULL);
++
++	      return fd;
++	    }
++
++	  if (errno == ENOENT)
++	    return -1;
++	}
++    }
++
++  __set_errno (ENOENT);
++  return -1;
++}
++
++weak_alias (__posix_openpt, posix_openpt)
++
++
++int
++__getpt (void)
++{
++  return __posix_openpt (O_RDWR);
++}
++
++weak_alias (__getpt, getpt)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++/* 'getrlimit64' is the same as 'getrlimit', because __rlim64_t == __rlim_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,108 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/sysctl.h>
++#include <stddef.h>
++
++
++int
++__get_nprocs (void)
++{
++  /* Fetch sysctl value of "hw.ncpu".  */
++  int request[2] = { CTL_HW, HW_NCPU };
++  int result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    /* Dummy result.  */
++    return 1;
++
++  return result;
++}
++
++weak_alias (__get_nprocs, get_nprocs)
++
++
++int
++__get_nprocs_conf (void)
++{
++  /* We don't know how to distinguish between configured and active CPUs.  */
++  return __get_nprocs ();
++}
++
++weak_alias (__get_nprocs_conf, get_nprocs_conf)
++
++
++long int
++__get_phys_pages (void)
++{
++  /* Fetch sysctl value of "hw.physmem".  This is a little smaller than
++     the real installed memory size, but so what.  */
++  int request[2] = { CTL_HW, HW_PHYSMEM };
++  int result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    return -1;
++
++  return result;
++}
++
++weak_alias (__get_phys_pages, get_phys_pages)
++
++
++long int
++__get_avphys_pages (void)
++{
++#if 1
++  int result1;
++  int result2;
++  {
++    /* Fetch sysctl value of "vm.stats.vm.v_inactive_count".  */
++    size_t result_len = sizeof (result1);
++
++    if (__sysctlbyname ("vm.stats.vm.v_inactive_count", &result1, &result_len,
++			NULL, 0) < 0)
++      return -1;
++  }
++  {
++    /* Fetch sysctl value of "vm.stats.vm.v_free_count".  */
++    size_t result_len = sizeof (result2);
++
++    if (__sysctlbyname ("vm.stats.vm.v_free_count", &result2, &result_len,
++			NULL, 0) < 0)
++      return -1;
++  }
++
++  return result1 + result2;
++#else
++  /* This does not appear to work.  */
++  /* Fetch v_inactive_count field of sysctl value of "vm.vmmeter".  */
++  int request[2] = { CTL_VM, VM_METER };
++  struct vmmeter result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    return -1;
++
++  return result.v_inactive_count;
++#endif
++}
++
++weak_alias (__get_avphys_pages, get_avphys_pages)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++/* 'glob64' is different from 'glob', because
++   'struct stat64' != 'struct stat'.  */
++#include <sysdeps/gnu/glob64.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++/* 'glob64' is different from 'glob', because
++   'struct stat64' != 'struct stat'.  */
++#include <sysdeps/generic/glob.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,62 @@
++/* Machine-dependent processor state structure for FreeBSD.  i386 version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SYS_UCONTEXT_H
++# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
++#endif
++
++/* Whole processor state.  */
++typedef struct
++  {
++    int mc_onstack;		/* Nonzero if running on sigstack.  */
++
++    /* Segment registers.  */
++    int mc_gs;
++    int mc_fs;
++    int mc_es;
++    int mc_ds;
++
++    /* "General" registers.  These members are in the order that the i386
++       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
++    int mc_edi;
++    int mc_esi;
++    int mc_ebp;
++    int mc_isp;			/* Not used; sc_esp is used instead.  */
++    int mc_ebx;
++    int mc_edx;
++    int mc_ecx;
++    int mc_eax;
++
++    int mc_trapno;
++    int mc_err;
++
++    int mc_eip;			/* Instruction pointer.  */
++    int mc_cs;			/* Code segment register.  */
++
++    int mc_efl;			/* Processor flags.  */
++
++    int mc_esp;			/* This stack pointer is used.  */
++    int mc_ss;			/* Stack segment register.  */
++
++    int mc_fpregs[28];
++    int mc_spare[17];
++  } mcontext_t;
++
++/* Traditional BSD names for some members.  */
++#define mc_eflags	mc_efl
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,104 @@
++/* Machine-dependent signal context structure for FreeBSD.  i386 version.
++   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
++# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
++#endif
++
++#ifndef _BITS_SIGCONTEXT_H
++#define _BITS_SIGCONTEXT_H  1
++
++/* State of this thread when the signal was taken.
++   The unions below are for compatibility with Linux (whose sigcontext
++   components don't have sc_ prefix) */
++struct sigcontext
++  {
++    __sigset_t sc_mask;		/* Blocked signals to restore.  */
++    int sc_onstack;		/* Nonzero if running on sigstack.  */
++
++    /* Segment registers.  */
++    union { int sc_gs; int gs; };
++    union { int sc_fs; int fs; };
++    union { int sc_es; int es; };
++    union { int sc_ds; int ds; };
++
++    /* "General" registers.  These members are in the order that the i386
++       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
++    union { int sc_edi; int edi; };
++    union { int sc_esi; int esi; };
++    union { int sc_ebp; int ebp; };
++    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
++    union { int sc_ebx; int ebx; };
++    union { int sc_edx; int edx; };
++    union { int sc_ecx; int ecx; };
++    union { int sc_eax; int eax; };
++
++    union { int sc_trapno; int trapno; };
++    union { int sc_err; int err; };
++
++    union { int sc_eip; int eip; };		/* Instruction pointer.  */
++    union { int sc_cs; int cs; };		/* Code segment register.  */
++
++    int sc_efl;					/* Processor flags.  */
++
++    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
++    union { int sc_ss; int ss; };		/* Stack segment register.  */
++
++    int sc_fpregs[28];
++    int sc_spare[17];
++  };
++
++/* Traditional BSD names for some members.  */
++#define sc_sp		sc_esp		/* Stack pointer.  */
++#define sc_fp		sc_ebp		/* Frame pointer.  */
++#define sc_pc		sc_eip		/* Process counter.  */
++#define sc_ps		sc_efl
++#define sc_eflags	sc_efl
++#define eflags		sc_efl		/* Linux-style name. */
++
++
++/* Codes for SIGFPE.  */
++#define FPE_INTDIV	1 /* integer divide by zero */
++#define FPE_INTOVF	2 /* integer overflow */
++
++#if 1 /* FIXME: These need verification.  */
++
++#define FPE_FLTDIV	3 /* floating divide by zero */
++#define FPE_FLTOVF	4 /* floating overflow */
++#define FPE_FLTUND	5 /* floating underflow */
++#define FPE_FLTINX	6 /* floating loss of precision */
++#define FPE_SUBRNG_FAULT	0x7 /* BOUNDS instruction failed */
++#define FPE_FLTDNR_FAULT	0x8 /* denormalized operand */
++#define FPE_EMERR_FAULT		0xa /* mysterious emulation error 33 */
++#define FPE_EMBND_FAULT		0xb /* emulation BOUNDS instruction failed */
++
++/* Codes for SIGILL.  */
++#define ILL_PRIVIN_FAULT	1
++#define ILL_ALIGN_FAULT		14
++#define ILL_FPOP_FAULT		24
++
++/* Codes for SIGBUS.  */
++#define BUS_PAGE_FAULT		12
++#define BUS_SEGNP_FAULT		26
++#define BUS_STK_FAULT		27
++#define BUS_SEGM_FAULT		29
++
++#endif
++
++#endif /* _BITS_SIGCONTEXT_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/time.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/time.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/time.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/time.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,101 @@
++/* System-dependent timing definitions.  FreeBSD version.
++   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Never include this file directly; use <time.h> instead.
++ */
++
++#ifndef __need_timeval
++# ifndef _BITS_TIME_H
++#  define _BITS_TIME_H	1
++
++/* ISO/IEC 9899:1990 7.12.1: <time.h>
++   The macro `CLOCKS_PER_SEC' is the number per second of the value
++   returned by the `clock' function. */
++/* CAE XSH, Issue 4, Version 2: <time.h>
++   The value of CLOCKS_PER_SEC is required to be 1 million on all
++   XSI-conformant systems. */
++#  define CLOCKS_PER_SEC  1000000l
++
++#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
++/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
++   presents the real value for clock ticks per second for the system.  */
++#   define CLK_TCK 128
++#  endif
++
++#  ifdef __USE_POSIX199309
++/* Identifier for system-wide realtime clock.  */
++#   define CLOCK_REALTIME	0
++/* High-resolution timer from the CPU.  */
++#   define CLOCK_PROCESS_CPUTIME_ID	4
++/* Thread-specific CPU-time clock.  */
++#   define CLOCK_THREAD_CPUTIME_ID	5
++/* These are declared in FreeBSD, but not implemented.  */
++#   ifdef __USE_BSD
++#    define CLOCK_VIRTUAL	1
++#    define CLOCK_PROF		2
++#   endif
++
++/* Flag to indicate time is absolute.  */
++#   define TIMER_ABSTIME	1
++#  endif
++
++#  include <bits/types.h>
++
++struct __kernel_timespec
++  {
++    __kernel_time_t tv_sec;	/* Seconds.  */
++    long int tv_nsec;		/* Nanoseconds.  */
++  };
++
++# endif	/* bits/time.h */
++#endif
++
++
++#ifdef __need_timeval
++# undef __need_timeval
++# ifndef _STRUCT_TIMEVAL
++#  define _STRUCT_TIMEVAL	1
++
++#  include <bits/types.h>
++
++/* A time value that is accurate to the nearest
++   microsecond but also has a range of years.  */
++struct timeval
++  {
++    __time_t tv_sec;		/* Seconds.  */
++    __suseconds_t tv_usec;	/* Microseconds.  */
++  };
++
++struct __kernel_timeval
++  {
++    __kernel_time_t tv_sec;	/* Seconds.  */
++    __suseconds_t tv_usec;	/* Microseconds.  */
++  };
++
++struct __kernel_itimerval
++  {
++    /* Value to put into `it_value' when the timer expires.  */
++    struct __kernel_timeval it_interval;
++    /* Time to the next timer expiration.  */
++    struct __kernel_timeval it_value;
++  };
++
++# endif	/* struct timeval */
++#endif	/* need timeval */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,33 @@
++/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++PSEUDO (__libc_fork, fork, 0)
++	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
++	   make it -1 (all bits set) for the parent, and 0 (no bits set)
++	   for the child.  Then AND it with R0, so the parent gets
++	   R0&-1==R0, and the child gets R0&0==0.  */
++	decl r1
++	andl r1, r0
++	ret
++PSEUDO_END (__libc_fork)
++
++weak_alias (__libc_fork, __fork)
++libc_hidden_def (__fork)
++weak_alias (__libc_fork, fork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,76 @@
++/* Save current context.
++   Copyright (C) 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++#include "ucontext_i.h"
++
++
++ENTRY(__getcontext)
++	/* Load address of the context data structure.  */
++	movl	4(%esp), %eax
++
++	/* Return value of getcontext.  EAX is the only register whose
++	   value is not preserved.  */
++	movl	$0, oEAX(%eax)
++
++	/* Save the 32-bit register values and the return address.  */
++	movl	%ecx, oECX(%eax)
++	movl	%edx, oEDX(%eax)
++	movl	%edi, oEDI(%eax)
++	movl	%esi, oESI(%eax)
++	movl	%ebp, oEBP(%eax)
++	movl	(%esp), %ecx
++	movl	%ecx, oEIP(%eax)
++	leal	4(%esp), %ecx		/* Exclude the return address.  */
++	movl	%ecx, oESP(%eax)
++	movl	%ebx, oEBX(%eax)
++
++	/* Save the FS segment register.  We don't touch the GS register
++	   since it is used for threads.  */
++	xorl	%edx, %edx
++	movw	%fs, %dx
++	movl	%edx, oFS(%eax)
++
++	/* Save the floating-point registers.  */
++	leal	oFPREGSMEM(%eax), %ecx
++	/* Save the floating-point context.  */
++	fnstenv	(%ecx)
++
++	/* Save the current signal mask.  */
++	pushl	%ebx
++	leal	oSIGMASK(%eax), %eax
++	pushl	%eax
++	pushl	$0
++	pushl	$SIG_BLOCK
++	pushl	$0			/* Dummy return address.  */
++	movl	$SYS_sigprocmask, %eax
++	int	$0x80
++	addl	$16, %esp
++	popl	%ebx
++	jb	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
++
++	/* All done, return 0 for success.  */
++	xorl	%eax, %eax
++	ret
++
++PSEUDO_END(__getcontext)
++
++weak_alias(__getcontext, getcontext)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/perm.h>
++#include <sysarch.h>
++
++int
++i386_get_ioperm (unsigned int from, unsigned int *num, int *turned_on)
++{
++  struct i386_ioperm_args args;
++
++  args.start = from;
++
++  if (__sysarch (I386_GET_IOPERM, &args) < 0)
++    return -1;
++
++  *num = args.length;
++  *turned_on = args.enable;
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,34 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/perm.h>
++#include <sysarch.h>
++
++int
++i386_set_ioperm (unsigned int from, unsigned int num, int turn_on)
++{
++  struct i386_ioperm_args args;
++
++  args.start = from;
++  args.length = num;
++  args.enable = turn_on;
++
++  return __sysarch (I386_SET_IOPERM, &args);
++}
++
++strong_alias (i386_set_ioperm, ioperm)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/vm86.h>
++#include <sysarch.h>
++
++int
++i386_vm86 (int cmd, void *arg)
++{
++  struct i386_vm86_args args;
++
++  args.sub_op = cmd;
++  args.sub_args = arg;
++
++  return __sysarch (I386_VM86, &args);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Implies sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Implies
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Implies	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Implies	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++# The kernel include files come from the 'kernel-include' add-on.
++# This is actually added by configure.in.
++#/usr/src/kfreebsd-headers/i386
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,54 @@
++/* Copyright (C) 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Robert Millan <robertmh@gnu.org>
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <fcntl.h>	/* open */
++#include <unistd.h>	/* close */
++
++static int __iopl_fd = -1;
++
++int
++iopl (int level)
++  {
++    switch (level)
++      {
++        case 3:
++          if (__iopl_fd != -1)
++            return 0;
++
++          __iopl_fd = open ("/dev/io", O_RDWR);
++          if (__iopl_fd == -1)
++            {
++              if (errno == EACCES)
++                __set_errno (EPERM);
++              return -1;
++            }
++          return 0;
++
++        case 0:
++          if (__iopl_fd != -1)
++            if (close (__iopl_fd) == -1)
++              return 1;
++          return 0;
++
++        default:
++          __set_errno (EINVAL);
++          return -1;
++      }
++  }
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldsodefs.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldsodefs.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldsodefs.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Run-time dynamic linker definitions for FreeBSD/i386.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_LDSODEFS_H
++
++/* Get the real definitions.  */
++#include_next <ldsodefs.h>
++
++/* Now define our stuff.  */
++
++/* The value of the floating-point control word, at the moment the kernel
++   passes control to the program.  Cf. <fpu_control.h> for the meaning of
++   each bit.  */
++#define _FPU_INITIAL 0x127f
++
++#endif /* ldsodefs.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,113 @@
++/* Create new context.
++   Copyright (C) 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++#include "ucontext_i.h"
++
++
++ENTRY(__makecontext)
++	movl	4(%esp), %eax
++
++	/* Load the address of the function we are supposed to run.  */
++	movl	8(%esp), %ecx
++
++	/* Compute the address of the stack.  The information comes from
++	   to us_stack element.  */
++	movl	oSS_SP(%eax), %edx
++	movl	%ecx, oEIP(%eax)
++	addl	oSS_SIZE(%eax), %edx
++
++	/* Put the next context on the new stack (from the uc_link
++	   element).  */
++	movl	oLINK(%eax), %ecx
++	movl	%ecx, -4(%edx)
++
++	/* Remember the number of parameters for the exit handler since
++	   it has to remove them.  We store the number in the EBX register
++	   which the function we will call must preserve.  */
++	movl	12(%esp), %ecx
++	movl	%ecx, oEBX(%eax)
++
++	/* Make room on the new stack for the parameters.  */
++	negl	%ecx
++	leal	-8(%edx,%ecx,4), %edx
++	negl	%ecx
++	/* Store the future stack pointer.  */
++	movl	%edx, oESP(%eax)
++
++	/* Copy all the parameters.  */
++	jecxz	2f
++1:	movl	12(%esp,%ecx,4), %eax
++	movl	%eax, (%edx,%ecx,4)
++	decl	%ecx
++	jnz	1b
++2:
++
++	/* If the function we call returns we must continue with the
++	   context which is given in the uc_link element.  To do this
++	   set the return address for the function the user provides
++	   to a little bit of helper code which does the magic (see
++	   below).  */
++#ifdef PIC
++	call	1f
++1:	popl	%ecx
++	addl	$L(exitcode)-1b, %ecx
++	movl	%ecx, (%edx)
++#else
++	movl	$L(exitcode), (%edx)
++#endif
++	/* 'makecontext' returns no value.  */
++	ret
++
++	/* This is the helper code which gets called if a function which
++	   is registered with 'makecontext' returns.  In this case we
++	   have to install the context listed in the uc_link element of
++	   the context 'makecontext' manipulated at the time of the
++	   'makecontext' call.  If the pointer is NULL the process must
++	   terminate.  */
++L(exitcode):
++	/* This removes the parameters passed to the function given to
++	   'makecontext' from the stack.  EBX contains the number of
++	   parameters (see above).  */
++	leal	(%esp,%ebx,4), %esp
++
++#ifdef	PIC
++	call	1f
++1:	popl	%ebx
++	addl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %ebx
++#endif
++	popl	%eax			/* This is the next context.  */
++	testl	%eax, %eax
++	je	2f			/* If it is zero exit.  */
++
++	pushl	%eax
++	call	JUMPTARGET(__setcontext)
++	/* If this returns (which can happen if the syscall fails) we'll
++	   exit the program with the return error value (-1).  */
++
++2:	pushl	%eax
++	call	JUMPTARGET(exit)
++	/* The 'exit' call should never return.  In case it does cause
++	   the process to terminate.  */
++	hlt
++END(__makecontext)
++
++weak_alias(__makecontext, makecontext)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,17 @@
++# Additional header files to be installed in $prefix/include:
++
++ifeq ($(subdir),misc)
++sysdep_headers += \
++ sys/io.h \
++ sys/perm.h \
++ sys/vm86.h
++endif
++
++# Additional functions, and particular system calls:
++
++ifeq ($(subdir),misc)
++# For <sys/io.h> and <sys/perm.h>.
++sysdep_routines += i386_get_ioperm i386_set_ioperm iopl
++# For <sys/vm86.h>.
++sysdep_routines += i386_vm86
++endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++SYSCALL__ (rfork, 1)
++	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
++	   make it -1 (all bits set) for the parent, and 0 (no bits set)
++	   for the child.  Then AND it with R0, so the parent gets
++	   R0&-1==R0, and the child gets R0&0==0.  */
++	decl r1
++	andl r1, r0
++	ret
++PSEUDO_END (__rfork)
++
++weak_alias (__rfork, rfork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/setcontext.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/setcontext.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/setcontext.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/setcontext.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,96 @@
++/* Install given context.
++   Copyright (C) 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++#include "ucontext_i.h"
++
++
++ENTRY(__setcontext)
++	/* Load address of the context data structure.  */
++	movl	4(%esp), %eax
++
++	/* Get the current signal mask.  Note that we preserve EBX in case
++	   the system call fails and we return from the function with an
++	   error.  */
++	pushl	%ebx
++	leal	oSIGMASK(%eax), %eax
++	pushl	%eax
++	pushl	$0
++	pushl	$SIG_SETMASK
++	pushl	$0			/* Dummy return address.  */
++	movl	$SYS_sigprocmask, %eax
++	int	$0x80
++	addl	$16, %esp
++	popl	%ebx
++	jb	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
++
++	/* EAX was modified, reload it.  */
++	movl	4(%esp), %eax
++
++	/* Restore the floating-point context.  Not the registers, only the
++	   rest.  */
++	leal	oFPREGSMEM(%eax), %ecx
++	fldenv	(%ecx)
++
++	/* Restore the FS segment register.  We don't touch the GS register
++	   since it is used for threads.  */
++	movl	oFS(%eax), %ecx
++	movw	%cx, %fs
++
++	/* Load the new stack pointer.  */
++	movl	oESP(%eax), %ecx
++	/* Make room for 8 registers and the return address.  We will load
++	   the values from the stack.  */
++	subl	$36, %ecx
++
++	/* Move the values of all the 32-bit registers (except ESP) on
++	   the stack.  This happens in the form the 'popa' instruction
++	   expects it.  Before this block put the address of the code
++	   to execute.  */
++	movl	oEDI(%eax), %ebx
++	movl	oESI(%eax), %edx
++	movl	oEBP(%eax), %esi
++	movl	oEBX(%eax), %edi
++	movl	%ebx, (%ecx)
++	movl	%edx, 4(%ecx)
++	movl	%esi, 8(%ecx)
++	movl	%edi, 16(%ecx)
++	movl	oEDX(%eax), %ebx
++	movl	oECX(%eax), %edx
++	movl	oEAX(%eax), %esi
++	movl	oEIP(%eax), %edi
++	movl	%ebx, 20(%ecx)
++	movl	%edx, 24(%ecx)
++	movl	%esi, 28(%ecx)
++	movl	%edi, 32(%ecx)
++
++	/* Set the new stack address.  The stack points now to the block
++	   we put the register content in.  */
++	movl	%ecx, %esp
++	/* Restore the register content.  */
++	popa
++	/* The following 'ret' will pop the addres of the code and jump
++	   to it.  */
++	ret
++
++PSEUDO_END(__setcontext)
++
++weak_alias(__setcontext, setcontext)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,25 @@
++/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#define SIGCONTEXT int _code, struct sigcontext *
++#define SIGCONTEXT_EXTRA_ARGS _code,
++#define GET_PC(ctx)	((void *) (ctx)->sc_eip)
++#define GET_FRAME(ctx)	((void *) (ctx)->sc_ebp)
++#define GET_STACK(ctx)	((void *) (ctx)->sc_esp)
++#define CALL_SIGHANDLER(handler, signo, ctx) \
++  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,187 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* __start_thread (flags, stack, func, arg)
++   calls __rfork (flags), and in the child sets the stack pointer and then
++   calls _exit (func (arg)).
++   It cannot be done in portable C.  */
++
++#include <sysdep.h>
++#include <asm-syntax.h>
++#define SIG_SETMASK	3
++
++	.text
++ENTRY (__start_thread)
++	/* There is a window of a few instructions, right after the rfork
++	   system call, where the handling of a signal would write garbage
++	   into the stack shared by the parent and the child (assuming
++	   RFMEM is set in flags).  To solve this: 1. We block all signals
++	   around the rfork system call and unblock them afterwards in
++	   the parent and in the child (but only after changing the stack
++	   pointer).  2. The child accesses only values passed in registers
++	   and on its own stack.  This way, if the parent is scheduled to
++	   run first, and handles a signal, it will not affect the child;
++	   and if the child runs first, and handles a signal, it will use
++	   the child's stack and not affect the parent.
++	   We need to pass 7 words of info to the child: stack, func, arg,
++	   and the signal mask to restore.  Since we have only 4 call-saved
++	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
++	   stack pointer in a register, and the rest through the child's
++	   stack.  */
++	pushl	%ebp
++	movl	%esp, %ebp
++	subl	$36, %esp
++	movl	%ebx, 32(%esp)
++
++	movl	8(%ebp), %eax	/* flags */
++	testl	$32, %eax	/* flags & RFMEM */
++	jz	L(simple)
++
++	/* Block all signals.  */
++	movl	$-1, %eax
++	movl	%eax, 16(%esp)
++	movl	%eax, 20(%esp)
++	movl	%eax, 24(%esp)
++	movl	%eax, 28(%esp)
++	leal	16(%esp), %eax
++	movl	$SIG_SETMASK, 4(%esp)
++	movl	%eax, 8(%esp)
++	movl	%eax, 12(%esp)
++	DO_CALL (sigprocmask, 3)
++	jb	L(error)
++
++	/* Copy all info to the child's stack.  */
++	movl	12(%ebp), %ebx	/* stack */
++	subl	$32, %ebx	/* room for func, arg, sigset_t */
++	andl	$-16, %ebx	/* make it 16-bytes aligned */
++	movl	16(%ebp), %eax	/* func */
++	movl	20(%ebp), %edx	/* arg */
++	movl	%eax, 4(%ebx)
++	movl	%edx, (%ebx)
++	movl	16(%esp), %eax	/* sigset_t word 0 */
++	movl	20(%esp), %edx	/* sigset_t word 1 */
++	movl	%eax, 16(%ebx)
++	movl	%edx, 20(%ebx)
++	movl	24(%esp), %eax	/* sigset_t word 2 */
++	movl	28(%esp), %edx	/* sigset_t word 3 */
++	movl	%eax, 24(%ebx)
++	movl	%edx, 28(%ebx)
++
++	/* Perform the rfork system call.  */
++	movl	8(%ebp), %eax	/* flags */
++	movl	%eax, 4(%esp)
++	DO_CALL (rfork, 1)
++	jb	L(error)
++
++	/* %edx is now 0 for the parent and 1 for the child.  */
++	testl	%edx, %edx
++	jnz	L(child)
++
++	/* Save the child pid, currently in %eax.  */
++	movl	%eax, %ebx
++
++	/* Restore the previous signal mask.  */
++	leal	16(%esp), %eax
++	movl	$SIG_SETMASK, 4(%esp)
++	movl	%eax, 8(%esp)
++	movl	$0, 12(%esp)
++	DO_CALL (sigprocmask, 3)
++
++	/* Return the child pid, currently in %ebx.  */
++	movl	%ebx, %eax
++	addl	$32, %esp
++	popl	%ebx
++	popl	%ebp
++	ret
++
++L(child):/* Here we are in the child thread.  */
++
++	/* Set the stack pointer.  */
++	movl	%ebx, %esp
++	/* Terminate the stack frame.  */
++	subl	%ebp, %ebp
++
++	movl	4(%esp), %edi
++
++	/* Restore the previous signal mask.  */
++	leal	16(%esp), %eax
++	movl	$SIG_SETMASK, 4(%esp)
++	movl	%eax, 8(%esp)
++	movl	$0, 12(%esp)
++	DO_CALL (sigprocmask, 3)
++
++L(child1):
++	/* Call func (arg).  */
++	call	*%edi
++
++	/* Call _exit.  */
++#ifdef PIC
++	call	L(here)
++L(here):
++	popl	%ebx
++	addl	$_GLOBAL_OFFSET_TABLE_+[.-L(here)], %ebx
++#endif
++	pushl	%eax
++	call	JUMPTARGET (_exit)
++
++L(simple):/* Simple case without signal mask handling.  */
++
++	/* Copy all info to the child's stack.  */
++	movl	12(%ebp), %ebx	/* stack */
++	subl	$8, %ebx	/* room for func, arg */
++	andl	$-16, %ebx	/* make it 16-bytes aligned */
++	movl	16(%ebp), %eax	/* func */
++	movl	20(%ebp), %edx	/* arg */
++	movl	%eax, 4(%ebx)
++	movl	%edx, (%ebx)
++
++	/* Perform the rfork system call.  */
++	movl	8(%ebp), %eax	/* flags */
++	movl	%eax, 4(%esp)
++	DO_CALL (rfork, 1)
++	jb	L(error)
++
++	/* %edx is now 0 for the parent and 1 for the child.  */
++	testl	%edx, %edx
++	jnz	L(simple_child)
++
++	/* Return the child pid, currently in %eax.  */
++	addl	$32, %esp
++	popl	%ebx
++	popl	%ebp
++	ret
++
++L(simple_child):/* Here we are in the child thread.  */
++
++	/* Set the stack pointer.  */
++	movl	%ebx, %esp
++	/* Terminate the stack frame.  */
++	subl	%ebp, %ebp
++
++	movl	4(%esp), %edi
++
++	jmp	L(child1)
++
++L(error):
++	addl	$32, %esp
++	popl	%ebx
++	popl	%ebp
++	jmp	SYSCALL_ERROR_LABEL
++
++PSEUDO_END (__start_thread)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,123 @@
++/* Save current context and install the given one.
++   Copyright (C) 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++#include "ucontext_i.h"
++
++
++ENTRY(__swapcontext)
++	/* Load address of the context data structure we save in.  */
++	movl	4(%esp), %eax
++
++	/* Return value of swapcontext.  EAX is the only register whose
++	   value is not preserved.  */
++	movl	$0, oEAX(%eax)
++
++	/* Save the 32-bit register values and the return address.  */
++	movl	%ecx, oECX(%eax)
++	movl	%edx, oEDX(%eax)
++	movl	%edi, oEDI(%eax)
++	movl	%esi, oESI(%eax)
++	movl	%ebp, oEBP(%eax)
++	movl	(%esp), %ecx
++	movl	%ecx, oEIP(%eax)
++	leal	4(%esp), %ecx
++	movl	%ecx, oESP(%eax)
++	movl	%ebx, oEBX(%eax)
++
++	/* Save the FS segment register.  */
++	xorl	%edx, %edx
++	movw	%fs, %dx
++	movl	%edx, oFS(%eax)
++
++	/* Save the floating-point registers.  */
++	leal	oFPREGSMEM(%eax), %ecx
++	/* Save the floating-point context.  */
++	fnstenv	(%ecx)
++
++	/* Load address of the context data structure we have to load.  */
++	movl	8(%esp), %ecx
++
++	/* Save the current signal mask and install the new one.  */
++	pushl	%ebx
++	leal	oSIGMASK(%eax), %eax
++	leal	oSIGMASK(%ecx), %ecx
++	pushl	%eax
++	pushl	%ecx
++	pushl	$SIG_SETMASK
++	pushl	$0			/* Dummy return address.  */
++	movl	$SYS_sigprocmask, %eax
++	int	$0x80
++	addl	$16, %esp
++	popl	%ebx
++	jb	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
++
++	/* EAX was modified, reload it.  */
++	movl	8(%esp), %eax
++
++	/* Restore the floating-point context.  Not the registers, only the
++	   rest.  */
++	leal	oFPREGSMEM(%eax), %ecx
++	fldenv	(%ecx)
++
++	/* Restore the FS segment registers.  */
++	movl	oFS(%eax), %edx
++	movw	%dx, %fs
++
++	/* Load the new stack pointer.  */
++	movl	oESP(%eax), %ecx
++	/* Make room for 8 registers and the return address.  We will load
++	   the values from the stack.  */
++	subl	$36, %ecx
++
++	/* Move the values of all the 32-bit registers (except ESP) on
++	   the stack.  This happens in the form the 'popa' instruction
++	   expects it.  Before this block put the address of the code
++	   to execute.  */
++	movl	oEDI(%eax), %ebx
++	movl	oESI(%eax), %edx
++	movl	oEBP(%eax), %esi
++	movl	oEBX(%eax), %edi
++	movl	%ebx, (%ecx)
++	movl	%edx, 4(%ecx)
++	movl	%esi, 8(%ecx)
++	movl	%edi, 16(%ecx)
++	movl	oEDX(%eax), %ebx
++	movl	oECX(%eax), %edx
++	movl	oEAX(%eax), %esi
++	movl	oEIP(%eax), %edi
++	movl	%ebx, 20(%ecx)
++	movl	%edx, 24(%ecx)
++	movl	%esi, 28(%ecx)
++	movl	%edi, 32(%ecx)
++
++	/* Set the new stack address.  The stack points now to the block
++	   we put the register content in.  */
++	movl	%ecx, %esp
++	/* Restore the register content.  */
++	popa
++	/* The following 'ret' will pop the addres of the code and jump
++	   to it.  */
++	ret
++
++PSEUDO_END(__swapcontext)
++
++weak_alias(__swapcontext, swapcontext)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,180 @@
++/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_SYS_IO_H
++#define	_SYS_IO_H	1
++
++#include <features.h>
++
++__BEGIN_DECLS
++
++/* If TURN_ON is TRUE, request for permission to do direct i/o on the
++   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
++   permission off for that range.  This call requires root privileges.
++
++   Portability note: not all kFreeBSD platforms support this call.  Most
++   platforms based on the PC I/O architecture probably will, however. */
++extern int ioperm (unsigned int __from, unsigned int __num, int __turn_on)
++     __THROW;
++
++/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
++   access any I/O port is granted.  This call requires root
++   privileges. */
++extern int iopl (int __level) __THROW;
++
++#if defined __GNUC__ && __GNUC__ >= 2
++
++static __inline unsigned char
++inb (unsigned short int port)
++{
++  unsigned char _v;
++
++  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline unsigned char
++inb_p (unsigned short int port)
++{
++  unsigned char _v;
++
++  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline unsigned short int
++inw (unsigned short int port)
++{
++  unsigned short _v;
++
++  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline unsigned short int
++inw_p (unsigned short int port)
++{
++  unsigned short int _v;
++
++  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline unsigned int
++inl (unsigned short int port)
++{
++  unsigned int _v;
++
++  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline unsigned int
++inl_p (unsigned short int port)
++{
++  unsigned int _v;
++  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
++  return _v;
++}
++
++static __inline void
++outb (unsigned char value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
++}
++
++static __inline void
++outb_p (unsigned char value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
++			"Nd" (port));
++}
++
++static __inline void
++outw (unsigned short int value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
++
++}
++
++static __inline void
++outw_p (unsigned short int value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
++			"Nd" (port));
++}
++
++static __inline void
++outl (unsigned int value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
++}
++
++static __inline void
++outl_p (unsigned int value, unsigned short int port)
++{
++  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
++			"Nd" (port));
++}
++
++static __inline void
++insb (unsigned short int port, void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++static __inline void
++insw (unsigned short int port, void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++static __inline void
++insl (unsigned short int port, void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++static __inline void
++outsb (unsigned short int port, const void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++static __inline void
++outsw (unsigned short int port, const void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++static __inline void
++outsl (unsigned short int port, const void *addr, unsigned long int count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
++			"=c" (count):"d" (port), "0" (addr), "1" (count));
++}
++
++#endif	/* GNU C */
++
++__END_DECLS
++#endif /* _SYS_IO_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,38 @@
++/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_PERM_H
++#define _SYS_PERM_H	1
++
++#include <features.h>
++
++__BEGIN_DECLS
++
++/* Set port input/output permissions.  */
++extern int ioperm (unsigned int __from, unsigned int __num, int __turn_on)
++     __THROW;
++extern int i386_set_ioperm (unsigned int __from, unsigned int __num,
++			    int __turn_on) __THROW;
++
++/* Retrieve a contiguous range of port input/output permissions.  */
++extern int i386_get_ioperm (unsigned int __from, unsigned int *__num,
++			    int *__turned_on) __THROW;
++
++__END_DECLS
++
++#endif	/* _SYS_PERM_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_VM86_H
++#define _SYS_VM86_H	1
++
++#include <features.h>
++
++/* Possible values for the 'cmd' argument to i386_vm86.  */
++enum
++  {
++    VM86_INIT = 1,
++#define VM86_INIT VM86_INIT
++    VM86_GET_VME = 3
++#define VM86_GET_VME VM86_GET_VME
++  };
++
++/* Argument structure for VM86_INIT.  */
++struct vm86_init_args
++  {
++    int debug;
++    int cpu_type;
++    unsigned char int_map[32];
++  };
++
++/* Argument structure for VM86_GET_VME.  */
++struct vm86_vme_args
++  {
++    int state;
++  };
++
++__BEGIN_DECLS
++
++extern int i386_vm86 (int __cmd, void *__arg);
++
++__END_DECLS
++
++#endif	/* _SYS_VM86_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,73 @@
++/* Parameters for the architecture specific system call.  i386 version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYSARCH_H
++#define _SYSARCH_H	1
++
++#include <features.h>
++
++/* Function that can be used as first argument to 'sysarch'.  */
++enum
++  {
++    I386_GET_LDT = 0,
++#define I386_GET_LDT I386_GET_LDT
++    I386_SET_LDT = 1,
++#define I386_SET_LDT I386_SET_LDT
++    I386_GET_IOPERM = 3,
++#define I386_GET_IOPERM I386_GET_IOPERM
++    I386_SET_IOPERM = 4,
++#define I386_SET_IOPERM I386_SET_IOPERM
++    I386_VM86 = 6
++#define I386_VM86 I386_VM86
++  };
++
++/* Argument struct for I386_GET_LDT and I386_SET_LDT.  */
++struct i386_ldt_args
++  {
++    int start;
++    union descriptor *descs;
++    int num;
++  };
++
++/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
++struct i386_ioperm_args
++  {
++    unsigned int start;
++    unsigned int length;
++    int enable;
++  };
++
++/* Argument struct for I386_VM86.  */
++struct i386_vm86_args
++  {
++    int sub_op;
++    void *sub_args;
++  };
++
++__BEGIN_DECLS
++
++extern int sysarch (int __cmd, void *__arg);
++
++#ifdef _LIBC
++extern int __sysarch (int __cmd, void *__arg);
++#endif
++
++__END_DECLS
++
++#endif /* _SYSARCH_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,29 @@
++/* Copyright (C) 1993, 1995-1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++ENTRY (syscall)
++	popl %ecx		/* Pop return address into %ecx.  */
++	popl %eax		/* Pop syscall number into %eax.  */
++	pushl %ecx		/* Push back return address.  */
++	int $0x80		/* Do the system call.  */
++	jb SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
++	ret			/* Return to caller.  */
++
++PSEUDO_END (syscall)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls.list sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls.list
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls.list	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls.list	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++# File name	Caller	Syscall name	# args	Strong name	Weak names
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,108 @@
++/* Copyright (C) 1991-1993, 1995-2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _FREEBSD_I386_SYSDEP_H
++#define _FREEBSD_I386_SYSDEP_H 1
++
++/* There is some commonality.  */
++#include <sysdeps/unix/i386/sysdep.h>
++#include <bp-sym.h>
++#include <bp-asm.h>
++
++#ifdef __ASSEMBLER__
++
++/* We don't want the label for the error handler to be global when we define
++   it here.  */
++#ifdef PIC
++# define SYSCALL_ERROR_LABEL 0f
++#else
++# define SYSCALL_ERROR_LABEL syscall_error
++#endif
++
++#undef	PSEUDO
++#define	PSEUDO(name, syscall_name, args)				      \
++  .text;								      \
++  ENTRY (name)								      \
++    DO_CALL (syscall_name, args);					      \
++    jb SYSCALL_ERROR_LABEL;
++
++#undef	PSEUDO_END
++#define	PSEUDO_END(name)						      \
++  SYSCALL_ERROR_HANDLER							      \
++  END (name)
++
++#undef  PSEUDO_NOERRNO
++#define PSEUDO_NOERRNO(name, syscall_name, args)			      \
++  .text;								      \
++  ENTRY (name)								      \
++    DO_CALL (syscall_name, args)
++
++#undef  PSEUDO_END_NOERRNO
++#define PSEUDO_END_NOERRNO(name)					      \
++  END (name)
++
++#define ret_NOERRNO ret
++
++#ifndef PIC
++#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
++#else
++/* Store %eax into errno through the GOT.  */
++#ifdef _LIBC_REENTRANT
++#define SYSCALL_ERROR_HANDLER						      \
++0:pushl %ebx;								      \
++  call 1f;								      \
++  .subsection 1;							      \
++1:movl (%esp), %ebx;							      \
++  ret;									      \
++  .previous;								      \
++  addl $_GLOBAL_OFFSET_TABLE_, %ebx;					      \
++  pushl %eax;								      \
++  PUSH_ERRNO_LOCATION_RETURN;						      \
++  call BP_SYM (__errno_location)@PLT;					      \
++  POP_ERRNO_LOCATION_RETURN;						      \
++  popl %ecx;								      \
++  popl %ebx;								      \
++  movl %ecx, (%eax);							      \
++  movl $-1, %eax;							      \
++  ret;
++/* A quick note: it is assumed that the call to `__errno_location' does
++   not modify the stack!  */
++#else
++#define SYSCALL_ERROR_HANDLER						      \
++0:call 1f;								      \
++  .subsection 1;							      \
++1:movl (%esp), %ecx;							      \
++  ret;									      \
++  .previous;								      \
++  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
++  movl errno@GOT(%ecx), %ecx;						      \
++  movl %eax, (%ecx);							      \
++  movl $-1, %eax;							      \
++  ret;
++#endif	/* _LIBC_REENTRANT */
++#endif	/* PIC */
++
++/* FreeBSD expects the system call arguments on the stack.  */
++#undef DO_CALL
++#define DO_CALL(syscall_name, args)					      \
++  movl $SYS_ify (syscall_name), %eax;					      \
++  int $0x80
++
++#endif	/* __ASSEMBLER__ */
++
++#endif /* freebsd/i386/sysdep.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,38 @@
++/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++/* The following code is only used in the shared library when we
++   compile the reentrant version.  Otherwise each system call defines
++   its own version.  */
++
++#ifndef PIC
++
++/* The syscall stubs jump here when they detect an error.
++   The code for FreeBSD is identical to the canonical Unix/i386 code.  */
++
++#undef CALL_MCOUNT
++#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %eax.  */
++
++	.text
++ENTRY (__syscall_error)
++#define __syscall_error __syscall_error_1
++#include <sysdeps/unix/i386/sysdep.S>
++
++#endif	/* !PIC */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,90 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++/* lseek returns a 64-bit result in %eax, %edx.  This means that in the
++   error case we have to set both %eax and %edx to -1.  */
++
++#undef SYSCALL_ERROR_LABEL
++#define SYSCALL_ERROR_LABEL 0f
++
++#undef SYSCALL_ERROR_HANDLER
++#ifndef PIC
++#ifdef _LIBC_REENTRANT
++#define SYSCALL_ERROR_HANDLER						      \
++0:pushl %eax;								      \
++  PUSH_ERRNO_LOCATION_RETURN;						      \
++  call BP_SYM (__errno_location);					      \
++  POP_ERRNO_LOCATION_RETURN;						      \
++  popl %ecx;								      \
++  movl $-1, %edx;							      \
++  movl %ecx, (%eax);							      \
++  movl %edx, %eax;							      \
++  ret;
++/* A quick note: it is assumed that the call to `__errno_location' does
++   not modify the stack!  */
++#else
++#define SYSCALL_ERROR_HANDLER						      \
++0:movl $-1, %edx;							      \
++  movl %eax, errno;							      \
++  movl %edx, %eax;							      \
++  ret;
++#endif	/* _LIBC_REENTRANT */
++#else
++/* Store %eax into errno through the GOT.  */
++#ifdef _LIBC_REENTRANT
++#define SYSCALL_ERROR_HANDLER						      \
++0:pushl %ebx;								      \
++  call 1f;								      \
++  .subsection 1;							      \
++1:movl (%esp), %ebx;							      \
++  ret;									      \
++  .previous;								      \
++  addl $_GLOBAL_OFFSET_TABLE_, %ebx;					      \
++  pushl %eax;								      \
++  PUSH_ERRNO_LOCATION_RETURN;						      \
++  call BP_SYM (__errno_location)@PLT;					      \
++  POP_ERRNO_LOCATION_RETURN;						      \
++  popl %ecx;								      \
++  popl %ebx;								      \
++  movl $-1, %edx;							      \
++  movl %ecx, (%eax);							      \
++  movl %edx, %eax;							      \
++  ret;
++/* A quick note: it is assumed that the call to `__errno_location' does
++   not modify the stack!  */
++#else
++#define SYSCALL_ERROR_HANDLER						      \
++0:call 1f;								      \
++  .subsection 1;							      \
++1:movl (%esp), %ecx;							      \
++  ret;									      \
++  .previous;								      \
++  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
++  movl errno@GOT(%ecx), %ecx;						      \
++  movl $-1, %edx;							      \
++  movl %eax, (%ecx);							      \
++  movl %edx, %eax;							      \
++  ret;
++#endif	/* _LIBC_REENTRANT */
++#endif	/* PIC */
++
++PSEUDO (__syscall_lseek, lseek, 4)
++	ret
++PSEUDO_END(__syscall_lseek)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,40 @@
++/* Offsets and other constants needed in the *context() function
++   implementation.
++   Copyright (C) 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#define SIG_BLOCK	1
++#define SIG_SETMASK	3
++
++/* Offsets of the fields in the ucontext_t structure.  */
++#define oSIGMASK	0
++#define oGS		20
++#define oFS		24
++#define oEDI		36
++#define oESI		40
++#define oEBP		44
++#define oESP		48
++#define oEBX		52
++#define oEDX		56
++#define oECX		60
++#define oEAX		64
++#define oEIP		76
++#define oFPREGSMEM	96	/* FIXME: not sure */
++#define oLINK		276
++#define oSS_SP		280
++#define oSS_SIZE	284
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,6 @@
++libc {
++  GLIBC_2.2.6 {
++    i386_get_ioperm; i386_set_ioperm; i386_vm86;
++    ioperm; iopl;
++  }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,55 @@
++/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++
++/* Clone the calling process, but without copying the whole address space.
++   The calling process is suspended until the new process exits or is
++   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
++   and the process ID of the new process to the old process.  */
++
++ENTRY (__vfork)
++
++	/* Pop the return PC value into ECX.  */
++	popl	%ecx
++
++	/* Perform the system call.  */
++	DO_CALL (vfork, 0)
++	jb	L(error)	/* Branch forward if it failed.  */
++
++	/* In the parent process, %edx == 0, %eax == child pid.  */
++	/* In the child process, %edx == 1, %eax == parent pid.  */
++
++	/* Change %eax to be 0 in the child process.  */
++	decl	%edx
++	andl	%edx, %eax
++
++	/* Jump to the return PC.  */
++	jmp	*%ecx
++
++L(error):
++	/* Push back the return PC.  */
++	pushl	%ecx
++
++	/* Branch to the error handler, hidden in PSEUDO_END.  */
++	jmp	SYSCALL_ERROR_LABEL
++
++PSEUDO_END (__vfork)
++libc_hidden_def (__vfork)
++
++weak_alias (__vfork, vfork)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,300 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <net/if.h>
++#include <sys/sysctl.h>
++#include <sys/socket.h>
++#include <net/route.h>
++#include <net/if_dl.h>
++#include <alloca.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <string.h>
++
++
++typedef int (*if_fn) (void *private, unsigned int index, const char *name);
++
++/* Iterate through all present interfaces.
++   Call FN once for every interface, returning immediately if FN returns
++   a nonzero value.  */
++static void
++if_iterate (if_fn fn, void *private)
++{
++  int request[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
++  char *buf;
++  size_t bufsize = 512;
++  char *bufend;
++  char *p;
++
++  /* Call the kernel function sysctl_iflist() in /usr/src/sys/net/rtsock.c.  */
++  for (;;)
++    {
++      buf = alloca (bufsize);
++      if (__sysctl (request, 6, buf, &bufsize, NULL, 0) >= 0)
++	break;
++      if (errno != ENOMEM)
++	return;
++      bufsize *= 2;
++    }
++
++  bufend = buf + bufsize;
++  for (p = buf; p < bufend; )
++    {
++      struct if_msghdr *msg = (struct if_msghdr *) p;
++
++      if (msg->ifm_version != RTM_VERSION)
++	abort ();
++
++      switch (msg->ifm_type)
++	{
++	case RTM_IFINFO:
++	  if (msg->ifm_flags & IFF_UP)
++	    {
++	      unsigned int index;
++	      struct sockaddr_dl *sdl;
++	      char namebuf[IFNAMSIZ + 1];
++	      size_t namelen;
++
++	      index = msg->ifm_index;
++	      if (index == 0)
++		abort ();
++
++	      sdl = (struct sockaddr_dl *) (msg + 1);
++	      namelen = sdl->sdl_nlen;
++	      /* Avoid overflowing namebuf[].  */
++	      if (namelen > IFNAMSIZ)
++		namelen = IFNAMSIZ;
++	      memcpy (namebuf, sdl->sdl_data, namelen);
++	      namebuf[namelen] = '\0';
++
++	      /* Call FN now.  */
++	      if (fn (private, index, namebuf))
++		return;
++	    }
++	  break;
++
++	case RTM_NEWADDR:
++	  break;
++
++	default:
++	  abort ();
++	}
++
++      p += msg->ifm_msglen;
++    }
++}
++
++/* ------------------------------------------------------------------------- */
++
++struct nametoindex_locals
++  {
++    const char *name;
++    unsigned int index;
++  };
++
++static int
++nametoindex_aux (void *private, unsigned int index, const char *name)
++{
++  struct nametoindex_locals *l = (struct nametoindex_locals *) private;
++  if (strcmp (name, l->name) == 0)
++    {
++      l->index = index;
++      return 1;
++    }
++  return 0;
++}
++
++/* Return the index of an interface given by name.  */
++unsigned int
++if_nametoindex (const char *ifname)
++{
++  struct nametoindex_locals l;
++
++  l.name = ifname;
++  l.index = 0;
++  if_iterate (nametoindex_aux, &l);
++
++  return l.index;
++}
++libc_hidden_def (if_nametoindex)
++
++/* ------------------------------------------------------------------------- */
++
++struct indextoname_locals
++  {
++    unsigned int index;
++    char *name;
++    char *retval;
++  };
++
++static int
++indextoname_aux (void *private, unsigned int index, const char *name)
++{
++  struct indextoname_locals *l = (struct indextoname_locals *) private;
++  if (index == l->index)
++    {
++      strncpy (l->name, name, IF_NAMESIZE);
++      l->retval = l->name;
++      return 1;
++    }
++  return 0;
++}
++
++/* Return the name of an interface given by name.  */
++char *
++if_indextoname (unsigned int ifindex, char *ifname)
++{
++  struct indextoname_locals l;
++
++  l.index = ifindex;
++  l.name = ifname;
++  l.retval = NULL;
++  if_iterate (indextoname_aux, &l);
++  return l.retval;
++}
++libc_hidden_def (if_indextoname)
++
++/* ------------------------------------------------------------------------- */
++
++struct nameindex_locals
++  {
++    /* Resizable array of 'struct if_nameindex'.  */
++    struct if_nameindex *s_array;
++    size_t s_len;
++    size_t s_allocated;
++    /* Resizable array of char.  */
++    char *c_array;
++    size_t c_len;
++    size_t c_allocated;
++    /* Out-of-memory indicator.  */
++    int oom;
++  };
++
++static void
++add_s (struct nameindex_locals *l, unsigned int index, char *name)
++{
++  if (l->s_len == l->s_allocated)
++    {
++      size_t new_allocated = 2 * l->s_allocated + 1;
++      struct if_nameindex *new_array =
++	(struct if_nameindex *)
++	realloc (l->s_array, new_allocated * sizeof (struct if_nameindex));
++      if (new_array == NULL)
++	{
++	  l->oom = 1;
++	  return;
++	}
++      l->s_array = new_array;
++      l->s_allocated = new_allocated;
++    }
++  /* Now l->s_len < l->s_allocated.  */
++  l->s_array[l->s_len].if_index = index;
++  l->s_array[l->s_len].if_name = name;
++  l->s_len++;
++}
++
++static __inline size_t
++add_c (struct nameindex_locals *l, const char *name)
++{
++  size_t n = strlen (name) + 1;
++  size_t result_offset;
++  if (l->c_len + n > l->c_allocated)
++    {
++      size_t new_allocated =
++	(l->c_len + n < 2 * l->c_allocated + 1
++	 ? l->c_len + n
++	 : 2 * l->c_allocated + 1);
++      char *new_array = (char *) realloc (l->c_array, new_allocated);
++      if (new_array == NULL)
++	{
++	  l->oom = 1;
++	  return 0;
++	}
++      l->c_array = new_array;
++      l->c_allocated = new_allocated;
++    }
++  /* Now l->c_len + n <= l->c_allocated.  */
++  result_offset = l->c_len;
++  memcpy (l->c_array + l->c_len, name, n);
++  l->c_len += n;
++  return result_offset;
++}
++
++static int
++nameindex_aux (void *private, unsigned int index, const char *name)
++{
++  struct nameindex_locals *l = (struct nameindex_locals *) private;
++
++  size_t name_offset = add_c (l, name);
++  if (!l->oom)
++    {
++      add_s (l, index, (char *) NULL + name_offset);
++      if (!l->oom)
++	return 0;
++    }
++  return 1;
++}
++
++/* Return an array of 'struct if_nameindex', one for each present
++   interface.  */
++struct if_nameindex *
++if_nameindex (void)
++{
++  struct nameindex_locals l;
++
++  l.s_array = NULL; l.s_len = 0; l.s_allocated = 0;
++  l.c_array = NULL; l.c_len = 0; l.c_allocated = 0;
++  l.oom = 0;
++  if_iterate (nameindex_aux, &l);
++  if (!l.oom)
++    {
++      /* Convert all offsets to real pointers.  */
++      struct if_nameindex *p;
++      struct if_nameindex *p_end;
++
++      for (p = l.s_array, p_end = p + l.s_len; p < p_end; p++)
++	p->if_name = l.c_array + (p->if_name - (char *) NULL);
++
++      /* Add a terminating entry.  */
++      add_s (&l, 0, NULL);
++    }
++  if (l.oom)
++    {
++      free (l.s_array);
++      free (l.c_array);
++      __set_errno (ENOMEM);
++      return NULL;
++    }
++  return l.s_array;
++}
++
++/* ------------------------------------------------------------------------- */
++
++/* Free an array returned by if_nameindex().  */
++void
++if_freenameindex (struct if_nameindex *ifn)
++{
++  if (ifn != NULL)
++    {
++      /* Free c_array.  */
++      free (ifn[0].if_name);
++      /* Free s_array.  */
++      free (ifn);
++    }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.h sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,107 @@
++/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <net/if.h>
++#include <sys/socket.h>
++#include <sys/ioctl.h>
++
++
++/* The FreeBSD ioctl SIOCGIFCONF returns the list if interfaces as a
++   concatenation of records of different size, each having at least
++   sizeof (struct ifreq) bytes.  */
++
++static inline struct ifreq *
++__if_nextreq (struct ifreq *ifr)
++{
++  return (struct ifreq *)
++	 ((char *) ifr + (ifr->ifr_addr.sa_len <= sizeof (ifr->ifr_addr)
++			  ? sizeof (struct ifreq)
++			  : sizeof (struct ifreq) - sizeof (ifr->ifr_addr)
++			    + ifr->ifr_addr.sa_len));
++}
++
++static inline void
++__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
++{
++  int fd = sockfd;
++  struct ifconf ifc;
++  int rq_len;
++  int nifs;
++  char *ifstart;
++  char *ifend;
++  struct ifreq *ifr;
++  /* FreeBSD has many interfaces, many of them are usually down.  */
++# define RQ_IFS	16
++  /* We have to assume all records are of limited size, so that we know
++     when we can stop enlarging the buffer.  */
++# define RQ_MAXSIZE 256
++
++  if (fd < 0)
++    fd = __opensock ();
++  if (fd < 0)
++    {
++      *num_ifs = 0;
++      *ifreqs = NULL;
++      return;
++    }
++
++  ifc.ifc_buf = NULL;
++  rq_len = RQ_IFS * sizeof (struct ifreq) + RQ_MAXSIZE;
++  for (;;)
++    {
++      ifc.ifc_len = rq_len;
++      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
++      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
++	{
++	  if (ifc.ifc_buf)
++	    free (ifc.ifc_buf);
++
++	  if (fd != sockfd)
++	    __close (fd);
++	  *num_ifs = 0;
++	  *ifreqs = NULL;
++	  return;
++	}
++      if (ifc.ifc_len + RQ_MAXSIZE <= rq_len)
++	break;
++      rq_len *= 2;
++    }
++
++  nifs = 0;
++  ifstart = (char *) ifc.ifc_buf;
++  ifend = ifstart + ifc.ifc_len;
++  for (ifr = (struct ifreq *) ifstart;
++       (char *) ifr < ifend;
++       ifr = __if_nextreq (ifr))
++    nifs++;
++
++  if (fd != sockfd)
++    __close (fd);
++
++  *num_ifs = nifs;
++  *ifreqs = realloc (ifc.ifc_buf, ifc.ifc_len);
++}
++
++static inline void
++__if_freereq (struct ifreq *ifreqs, int num_ifs)
++{
++  free (ifreqs);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,11 @@
++# The kernel include files come from the 'kernel-include' add-on.
++# This is actually added by configure.in.
++#/usr/src/kfreebsd-headers/
++
++# One of two possible utmp file formats.
++# This is actually added by configure.in.
++#unix/bsd/bsd4.4/kfreebsd/utmp-xyz
++
++# The gnu subdirectory exists for things common to Linux-based, Hurd-based
++# and kFreeBSD-based GNU systems.
++gnu
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,145 @@
++/* Initialization code run first thing by the ELF startup code.  Linux version.
++   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <fcntl.h>
++#include <unistd.h>
++#include <sysdep.h>
++#include <fpu_control.h>
++#include <sys/param.h>
++#include <sys/types.h>
++#include <libc-internal.h>
++
++#include <ldsodefs.h>
++#ifndef SHARED
++# include "dl-osinfo.h"
++#endif
++
++/* _FPU_INITIAL is the value of the floating-point control word, at
++   the moment the kernel passes control to the program.  _FPU_DEFAULT
++   is the default value of the floating-point control word, at the
++   moment when control gets passed to the main() function.  */
++#ifndef _FPU_INITIAL
++# define _FPU_INITIAL _FPU_DEFAULT
++#endif
++
++/* The function is called from assembly stubs the compiler can't see.  */
++static void init (int, char **, char **) __attribute__ ((unused));
++
++extern int _dl_starting_up;
++weak_extern (_dl_starting_up)
++
++/* Set nonzero if we have to be prepared for more then one libc being
++   used in the process.  Safe assumption if initializer never runs.  */
++int __libc_multiple_libcs attribute_hidden = 1;
++
++/* Remember the command line argument and enviroment contents for
++   later calls of initializers for dynamic libraries.  */
++int __libc_argc attribute_hidden;
++char **__libc_argv attribute_hidden;
++
++
++static void
++init (int argc, char **argv, char **envp)
++{
++#ifdef USE_NONOPTION_FLAGS
++  extern void __getopt_clean_environment (char **);
++#endif
++  /* The next variable is only here to work around a bug in gcc <= 2.7.2.2.
++     If the address would be taken inside the expression the optimizer
++     would try to be too smart and throws it away.  Grrr.  */
++  int *dummy_addr = &_dl_starting_up;
++
++  __libc_multiple_libcs = dummy_addr && !_dl_starting_up;
++
++  /* Make sure we don't initialize twice.  */
++  if (!__libc_multiple_libcs)
++    {
++#ifndef SHARED
++# ifdef DL_SYSDEP_OSCHECK
++      DL_SYSDEP_OSCHECK (__libc_fatal);
++# endif
++#endif
++
++      /* Set the FPU control word to the proper default value if the
++	 kernel would use a different value.  */
++      if (__fpu_control != _FPU_INITIAL)
++	__setfpucw (__fpu_control);
++    }
++
++  /* Save the command-line arguments.  */
++  __libc_argc = argc;
++  __libc_argv = argv;
++  __environ = envp;
++
++#ifndef SHARED
++  __libc_init_secure ();
++
++  /* First the initialization which normally would be done by the
++     dynamic linker.  */
++  _dl_non_dynamic_init ();
++#endif
++
++  __init_misc (argc, argv, envp);
++
++#ifdef USE_NONOPTION_FLAGS
++  /* This is a hack to make the special getopt in GNU libc working.  */
++  __getopt_clean_environment (envp);
++#endif
++
++#ifdef SHARED
++  __libc_global_ctors ();
++#endif
++}
++
++#ifdef SHARED
++
++strong_alias (init, _init);
++
++extern void __libc_init_first (void);
++
++void
++__libc_init_first (void)
++{
++}
++
++#else
++extern void __libc_init_first (int argc, char **argv, char **envp);
++
++void
++__libc_init_first (int argc, char **argv, char **envp)
++{
++  init (argc, argv, envp);
++}
++#endif
++
++
++/* This function is defined here so that if this file ever gets into
++   ld.so we will get a link error.  Having this file silently included
++   in ld.so causes disaster, because the _init definition above will
++   cause ld.so to gain an init function, which is not a cool thing. */
++
++extern void _dl_start (void) __attribute__ ((noreturn));
++
++void
++_dl_start (void)
++{
++  abort ();
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,26 @@
++/* Set flags signalling availability of kernel features based on given
++   kernel version number.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* No real-time signals in FreeBSD 4.0.  */
++#define __ASSUME_REALTIME_SIGNALS	0
++
++/* LDT manipulation function of sysarch is by default not compiled into
++   the FreeBSD 4.0 kernel.  */
++#define __ASSUME_LDT_WORKS		0
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ldconfig.h sysdeps/unix/bsd/bsd4.4/kfreebsd/ldconfig.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ldconfig.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdeps/generic/ldconfig.h>
++
++#define SYSDEP_KNOWN_INTERPRETER_NAMES \
++  { "/usr/lib/ld.so.1", FLAG_ELF_LIBC6 },			\
++  { "/gnu/usr/lib/ld.so.1", FLAG_ELF_LIBC6 },	/* temporary */	\
++  { "/usr/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
++
++#define SYSDEP_KNOWN_LIBRARY_NAMES \
++  { "libc.so.6", FLAG_ELF_LIBC6 },		/* temporary */	\
++  { "libm.so.6", FLAG_ELF_LIBC6 },		/* temporary */	\
++  { "libc.so.4", FLAG_ELF_LIBC5 },				\
++  { "libm.so.4", FLAG_ELF_LIBC5 },				\
++  { "libc.so.5", FLAG_ELF_LIBC5 },				\
++  { "libm.so.5", FLAG_ELF_LIBC5 },
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,39 @@
++/* Run-time dynamic linker data structures for loaded ELF shared objects.
++   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_LDSODEFS_H
++
++/* Get the real definitions.  */
++#include_next <ldsodefs.h>
++
++/* Now define our stuff.  */
++
++/* FreeBSD puts some extra information into an auxiliary vector when it
++   execs ELF executables.  Note that it uses AT_* values of 10 and 11
++   to denote something different than AT_NOTELF and AT_UID, but this is
++   not a problem since elf/dl-support.c ignores these AT_* values.  */
++#define HAVE_AUX_VECTOR
++
++/* Used by static binaries to check the auxiliary vector.  */
++extern void _dl_aux_init (ElfW(auxv_t) *av) internal_function;
++
++/* Initialization which is normally done by the dynamic linker.  */
++extern void _dl_non_dynamic_init (void) internal_function;
++
++#endif /* ldsodefs.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c	2005-08-23 17:42:39.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++__off64_t
++__libc_lseek64 (int fd, __off64_t offset, int whence)
++{
++  /* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
++  return (__off64_t) __libc_lseek(fd, (__off_t) offset, whence);
++}
++
++weak_alias (__libc_lseek64, __lseek64)
++weak_alias (__libc_lseek64, lseek64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c	2005-08-23 17:42:06.000000000 +0200
+@@ -0,0 +1,76 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++#include <errno.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern __off_t __syscall_lseek (int __fd, int __unused1, __off_t __offset,
++				int __whence) __THROW;
++
++__off_t
++__libc_lseek (int fd, __off_t offset, int whence)
++{
++#if 0 /* If the kernel would work right... */
++  /* We pass 3 arguments in 5 words.  */
++  return INLINE_SYSCALL (lseek, 3, fd, 0, offset, whence);
++#else
++  /* According to POSIX:2001, if the resulting file offset would become
++     negative, this function has to return an EINVAL error and leave the
++     file offset unchanged.  But the FreeBSD 4.0 kernel doesn't do this,
++     so we emulate it.  */
++  if (offset >= 0)
++    /* No risk that the file offset could become negative.  */
++    return INLINE_SYSCALL (lseek, 3, fd, 0, offset, whence);
++  else
++    {
++      /* Test whether the file offset becomes negative.  */
++      __off_t old_position;
++      __off_t new_position;
++      int saved_errno;
++
++      saved_errno = errno;
++      old_position = INLINE_SYSCALL (lseek, 3, fd, 0, 0, SEEK_CUR);
++      errno = 0;
++      new_position = INLINE_SYSCALL (lseek, 3, fd, 0, offset, whence);
++      if (new_position < 0)
++	{
++	  if (errno == 0)
++	    {
++	      /* The file offset became negative, and the kernel didn't
++		 notice it.  */
++	      if (old_position >= 0)
++		INLINE_SYSCALL (lseek, 3, fd, 0, old_position, SEEK_SET);
++	      new_position = -1;
++	      errno = EINVAL;
++	    }
++	}
++      else
++	errno = saved_errno;
++      return new_position;
++    }
++#endif
++}
++
++weak_alias (__libc_lseek, __lseek)
++libc_hidden_def (__lseek)
++weak_alias (__libc_lseek, lseek)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,47 @@
++/* lxstat using FreeBSD lstat, nlstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_nlstat (const char *__unbounded, struct stat32 *__unbounded);
++
++int
++__lxstat64 (int vers, const char *file, struct stat64 *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nlstat (CHECK_STRING (file), __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat64 (&buf32, buf);
++      return result;
++    }
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__lxstat64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,57 @@
++/* lxstat using FreeBSD lstat, nlstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat16.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_lstat (const char *__unbounded, struct stat16 *__unbounded);
++extern int __syscall_nlstat (const char *__unbounded, struct stat32 *__unbounded);
++
++int
++__lxstat (int vers, const char *file, struct stat *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nlstat (CHECK_STRING (file), __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat (&buf32, buf);
++      return result;
++    }
++  else if (__builtin_expect (vers == _STAT_VER_nstat, 1))
++    return __syscall_nlstat (CHECK_STRING (file),
++			     CHECK_1 ((struct stat32 *) buf));
++  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
++    return __syscall_lstat (CHECK_STRING (file),
++			    CHECK_1 ((struct stat16 *) buf));
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__lxstat)
++
++weak_alias (__lxstat, _lxstat)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c	2005-08-23 17:43:50.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/types.h>
++#include <unistd.h>
++#include <sysdep.h>
++
++void *
++__mmap64 (void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
++{
++  /* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
++  return __mmap(addr, len, prot, flags, fd, (__off64_t) offset);  
++}
++
++weak_alias (__mmap64, mmap64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c	2005-08-23 17:42:13.000000000 +0200
+@@ -0,0 +1,75 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/types.h>
++#include <sys/mman.h>
++#include <unistd.h>
++#include <errno.h>
++#include <sysdep.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern void *__syscall_mmap (void *__addr, size_t __len, int __prot,
++			     int __flags, int __fd, int __unused1,
++			     __off_t __offset) __THROW;
++extern ssize_t __syscall_pread (int __fd, void *__buf, size_t __nbytes,
++                                int __unused1, __off_t __offset) __THROW;
++
++void *
++__mmap (void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
++{
++  void *result;
++
++  /* Validity checks not done by the kernel.  */
++  if ((flags & MAP_FIXED) || (offset != 0))
++    {
++      int pagesize = __getpagesize ();
++
++      if (((flags & MAP_FIXED)
++	   && (__builtin_expect (pagesize & (pagesize - 1), 0)
++	       ? (unsigned long) addr % pagesize
++	       : (unsigned long) addr & (pagesize - 1)))
++	  || (__builtin_expect (pagesize & (pagesize - 1), 0)
++	      ? offset % pagesize
++	      : offset & (pagesize - 1)))
++	{
++	  __set_errno (EINVAL);
++	  return (void *) (-1);
++	}
++    }
++
++  /* We pass 7 arguments in 8 words.  */
++  result = INLINE_SYSCALL (mmap, 7, addr, len, prot, flags, fd, 0, offset);
++
++  if (result != (void *) (-1) && fd >= 0 && len > 0)
++    {
++      /* Force an update of the atime.  POSIX:2001 mandates that this happens
++	 at some time between the mmap() call and the first page-in.  Since
++	 the FreeBSD 4.0 kernel doesn't update the atime upon a page-in, we
++	 do it here.  */
++      char dummy;
++
++      INLINE_SYSCALL (pread, 5, fd, &dummy, 1, 0, offset);
++    }
++
++  return result;
++}
++
++weak_alias (__mmap, mmap)
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,328 @@
++/*
++ * Copyright (c) 1982, 1986, 1989, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)if.h	8.1 (Berkeley) 6/10/93
++ * $FreeBSD: src/sys/net/if.h,v 1.88.2.2 2004/09/13 05:11:40 brooks Exp $
++ */
++
++#ifndef _NET_IF_H_
++#define	_NET_IF_H_
++
++#include <sys/cdefs.h>
++
++#include <features.h>
++
++#include <sys/types.h>
++#include <sys/socket.h>
++
++struct ifnet;
++
++/*
++ * Length of interface external name, including terminating '\0'.
++ * Note: this is the same size as a generic device's external name.
++ */
++#define		IF_NAMESIZE	16
++#define		IFNAMSIZ	IF_NAMESIZE
++#define		IF_MAXUNIT	0x7fff	/* historical value */
++
++/*
++ * Structure used to query names of interface cloners.
++ */
++
++struct if_clonereq {
++	int	ifcr_total;		/* total cloners (out) */
++	int	ifcr_count;		/* room for this many in user buffer */
++	char	*ifcr_buffer;		/* buffer for cloner names */
++};
++
++/*
++ * Structure describing information about an interface
++ * which may be of interest to management entities.
++ */
++struct if_data {
++	/* generic interface information */
++	unsigned char	ifi_type;		/* ethernet, tokenring, etc */
++	unsigned char	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
++	unsigned char	ifi_addrlen;		/* media address length */
++	unsigned char	ifi_hdrlen;		/* media header length */
++	unsigned char	ifi_link_state;		/* current link state */
++	unsigned char	ifi_recvquota;		/* polling quota for receive intrs */
++	unsigned char	ifi_xmitquota;		/* polling quota for xmit intrs */
++	unsigned char	ifi_datalen;		/* length of this data struct */
++	unsigned long	ifi_mtu;		/* maximum transmission unit */
++	unsigned long	ifi_metric;		/* routing metric (external only) */
++	unsigned long	ifi_baudrate;		/* linespeed */
++	/* volatile statistics */
++	unsigned long	ifi_ipackets;		/* packets received on interface */
++	unsigned long	ifi_ierrors;		/* input errors on interface */
++	unsigned long	ifi_opackets;		/* packets sent on interface */
++	unsigned long	ifi_oerrors;		/* output errors on interface */
++	unsigned long	ifi_collisions;		/* collisions on csma interfaces */
++	unsigned long	ifi_ibytes;		/* total number of octets received */
++	unsigned long	ifi_obytes;		/* total number of octets sent */
++	unsigned long	ifi_imcasts;		/* packets received via multicast */
++	unsigned long	ifi_omcasts;		/* packets sent via multicast */
++	unsigned long	ifi_iqdrops;		/* dropped on input, this interface */
++	unsigned long	ifi_noproto;		/* destined for unsupported protocol */
++	unsigned long	ifi_hwassist;		/* HW offload capabilities */
++	time_t	ifi_epoch;		/* time of attach or stat reset */
++#ifdef __alpha__
++	u_int	ifi_timepad;		/* time_t is int, not long on alpha */
++#endif
++	struct	timeval ifi_lastchange;	/* time of last administrative change */
++};
++
++#define	IFF_UP		0x1		/* interface is up */
++#define	IFF_BROADCAST	0x2		/* broadcast address valid */
++#define	IFF_DEBUG	0x4		/* turn on debugging */
++#define	IFF_LOOPBACK	0x8		/* is a loopback net */
++#define	IFF_POINTOPOINT	0x10		/* interface is point-to-point link */
++#define	IFF_SMART	0x20		/* interface manages own routes */
++#define	IFF_RUNNING	0x40		/* resources allocated */
++#define	IFF_NOARP	0x80		/* no address resolution protocol */
++#define	IFF_PROMISC	0x100		/* receive all packets */
++#define	IFF_ALLMULTI	0x200		/* receive all multicast packets */
++#define	IFF_OACTIVE	0x400		/* transmission in progress */
++#define	IFF_SIMPLEX	0x800		/* can't hear own transmissions */
++#define	IFF_LINK0	0x1000		/* per link layer defined bit */
++#define	IFF_LINK1	0x2000		/* per link layer defined bit */
++#define	IFF_LINK2	0x4000		/* per link layer defined bit */
++#define	IFF_ALTPHYS	IFF_LINK2	/* use alternate physical connection */
++#define	IFF_MULTICAST	0x8000		/* supports multicast */
++#define	IFF_POLLING	0x10000		/* Interface is in polling mode. */
++#define	IFF_PPROMISC	0x20000		/* user-requested promisc mode */
++#define	IFF_MONITOR	0x40000		/* user-requested monitor mode */
++#define	IFF_STATICARP	0x80000		/* static ARP */
++#define	IFF_NEEDSGIANT	0x100000	/* hold Giant over if_start calls */
++
++/* flags set internally only: */
++#define	IFF_CANTCHANGE \
++	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE|\
++	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|IFF_PROMISC|\
++	    IFF_POLLING)
++
++/*
++ * Values for if_link_state.
++ */
++#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
++#define	LINK_STATE_DOWN		1	/* link is down */
++#define	LINK_STATE_UP		2	/* link is up */
++
++/*
++ * Some convenience macros used for setting ifi_baudrate.
++ * XXX 1000 vs. 1024? --thorpej@netbsd.org
++ */
++#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
++#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
++#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
++
++/* Capabilities that interfaces can advertise. */
++#define IFCAP_RXCSUM		0x0001  /* can offload checksum on RX */
++#define IFCAP_TXCSUM		0x0002  /* can offload checksum on TX */
++#define IFCAP_NETCONS		0x0004  /* can be a network console */
++#define	IFCAP_VLAN_MTU		0x0008	/* VLAN-compatible MTU */
++#define	IFCAP_VLAN_HWTAGGING	0x0010	/* hardware VLAN tag support */
++#define	IFCAP_JUMBO_MTU		0x0020	/* 9000 byte MTU supported */
++#define	IFCAP_POLLING		0x0040	/* driver supports polling */
++
++#define IFCAP_HWCSUM		(IFCAP_RXCSUM | IFCAP_TXCSUM)
++
++#define	IFQ_MAXLEN	50
++#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
++
++/*
++ * Message format for use in obtaining information about interfaces
++ * from getkerninfo and the routing socket
++ */
++struct if_msghdr {
++	unsigned short	ifm_msglen;	/* to skip over non-understood messages */
++	unsigned char	ifm_version;	/* future binary compatibility */
++	unsigned char	ifm_type;	/* message type */
++	int	ifm_addrs;	/* like rtm_addrs */
++	int	ifm_flags;	/* value of if_flags */
++	unsigned short	ifm_index;	/* index for associated ifp */
++	struct	if_data ifm_data;/* statistics and other data about if */
++};
++
++/*
++ * Message format for use in obtaining information about interface addresses
++ * from getkerninfo and the routing socket
++ */
++struct ifa_msghdr {
++	unsigned short	ifam_msglen;	/* to skip over non-understood messages */
++	unsigned char	ifam_version;	/* future binary compatibility */
++	unsigned char	ifam_type;	/* message type */
++	int	ifam_addrs;	/* like rtm_addrs */
++	int	ifam_flags;	/* value of ifa_flags */
++	unsigned short	ifam_index;	/* index for associated ifp */
++	int	ifam_metric;	/* value of ifa_metric */
++};
++
++/*
++ * Message format for use in obtaining information about multicast addresses
++ * from the routing socket
++ */
++struct ifma_msghdr {
++	unsigned short	ifmam_msglen;	/* to skip over non-understood messages */
++	unsigned char	ifmam_version;	/* future binary compatibility */
++	unsigned char	ifmam_type;	/* message type */
++	int	ifmam_addrs;	/* like rtm_addrs */
++	int	ifmam_flags;	/* value of ifa_flags */
++	unsigned short	ifmam_index;	/* index for associated ifp */
++};
++
++/*
++ * Message format announcing the arrival or departure of a network interface.
++ */
++struct if_announcemsghdr {
++	unsigned short	ifan_msglen;	/* to skip over non-understood messages */
++	unsigned char	ifan_version;	/* future binary compatibility */
++	unsigned char	ifan_type;	/* message type */
++	unsigned short	ifan_index;	/* index for associated ifp */
++	char	ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
++	unsigned short	ifan_what;	/* what type of announcement */
++};
++
++#define	IFAN_ARRIVAL	0	/* interface arrival */
++#define	IFAN_DEPARTURE	1	/* interface departure */
++
++/*
++ * Interface request structure used for socket
++ * ioctl's.  All interface ioctl's must have parameter
++ * definitions which begin with ifr_name.  The
++ * remainder may be interface specific.
++ */
++struct	ifreq {
++	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
++	union {
++		struct	sockaddr ifru_addr;
++		struct	sockaddr ifru_dstaddr;
++		struct	sockaddr ifru_broadaddr;
++		struct	sockaddr ifru_netmask;
++		short	ifru_flags[2];
++		short	ifru_index;
++		int	ifru_metric;
++		int	ifru_mtu;
++		int	ifru_phys;
++		int	ifru_media;
++		char	*ifru_data;
++		int	ifru_cap[2];
++	} ifr_ifru;
++#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
++#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
++#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
++#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
++#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags (low 16 bits) */
++#define	ifr_flagshigh	ifr_ifru.ifru_flags[1]	/* flags (high 16 bits) */
++#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
++#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
++#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
++#define ifr_media	ifr_ifru.ifru_media	/* physical media */
++#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
++#define	ifr_reqcap	ifr_ifru.ifru_cap[0]	/* requested capabilities */
++#define	ifr_curcap	ifr_ifru.ifru_cap[1]	/* current capabilities */
++#define	ifr_index	ifr_ifru.ifru_index	/* interface index */
++};
++
++#define	_SIZEOF_ADDR_IFREQ(ifr) \
++	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
++	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
++	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))
++
++struct ifaliasreq {
++	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
++	struct	sockaddr ifra_addr;
++	struct	sockaddr ifra_broadaddr;
++	struct	sockaddr ifra_mask;
++};
++
++struct ifmediareq {
++	char	ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
++	int	ifm_current;		/* current media options */
++	int	ifm_mask;		/* don't care mask */
++	int	ifm_status;		/* media status */
++	int	ifm_active;		/* active options */
++	int	ifm_count;		/* # entries in ifm_ulist array */
++	int	*ifm_ulist;		/* media words */
++};
++
++/* 
++ * Structure used to retrieve aux status data from interfaces.
++ * Kernel suppliers to this interface should respect the formatting
++ * needed by ifconfig(8): each line starts with a TAB and ends with
++ * a newline.  The canonical example to copy and paste is in if_tun.c.
++ */
++
++#define	IFSTATMAX	800		/* 10 lines of text */
++struct ifstat {
++	char	ifs_name[IFNAMSIZ];	/* if name, e.g. "en0" */
++	char	ascii[IFSTATMAX + 1];
++};
++
++/*
++ * Structure used in SIOCGIFCONF request.
++ * Used to retrieve interface configuration
++ * for machine (useful for programs which
++ * must know all networks accessible).
++ */
++struct	ifconf {
++	int	ifc_len;		/* size of associated buffer */
++	union {
++		char	*ifcu_buf;
++		struct	ifreq *ifcu_req;
++	} ifc_ifcu;
++#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
++#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
++};
++
++
++/*
++ * Structure for SIOC[AGD]LIFADDR
++ */
++struct if_laddrreq {
++	char	iflr_name[IFNAMSIZ];
++	unsigned int	flags;
++#define	IFLR_PREFIX	0x8000  /* in: prefix given  out: kernel fills id */
++	unsigned int	prefixlen;         /* in/out */
++	struct	sockaddr_storage addr;   /* in/out */
++	struct	sockaddr_storage dstaddr; /* out */
++};
++
++struct if_nameindex {
++	unsigned int	if_index;	/* 1, 2, ... */
++	char		*if_name;	/* null terminated name: "le0", ... */
++};
++
++__BEGIN_DECLS
++void			 if_freenameindex(struct if_nameindex *);
++char			*if_indextoname(unsigned int, char *);
++struct if_nameindex	*if_nameindex(void);
++unsigned int		 if_nametoindex(const char *);
++__END_DECLS
++
++#endif /* !_NET_IF_H_ */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,288 @@
++/* Copyright (C) 1991-1993, 1995-1997, 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef __NETINET_IP_ICMP_H
++#define __NETINET_IP_ICMP_H    1
++
++#include <sys/cdefs.h>
++#include <sys/types.h>
++
++__BEGIN_DECLS
++
++struct icmphdr
++{
++  u_int8_t type;		/* message type */
++  u_int8_t code;		/* type sub-code */
++  u_int16_t checksum;
++  union
++  {
++    struct
++    {
++      u_int16_t	id;
++      u_int16_t	sequence;
++    } echo;			/* echo datagram */
++    u_int32_t	gateway;	/* gateway address */
++    struct
++    {
++      u_int16_t	__unused;
++      u_int16_t	mtu;
++    } frag;			/* path mtu discovery */
++  } un;
++};
++
++#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
++#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
++#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
++#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
++#define ICMP_ECHO		8	/* Echo Request			*/
++#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
++#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
++#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
++#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
++#define ICMP_INFO_REQUEST	15	/* Information Request		*/
++#define ICMP_INFO_REPLY		16	/* Information Reply		*/
++#define ICMP_ADDRESS		17	/* Address Mask Request		*/
++#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
++#define NR_ICMP_TYPES		18
++
++
++/* Codes for UNREACH. */
++#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
++#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
++#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
++#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
++#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
++#define ICMP_SR_FAILED		5	/* Source Route failed		*/
++#define ICMP_NET_UNKNOWN	6
++#define ICMP_HOST_UNKNOWN	7
++#define ICMP_HOST_ISOLATED	8
++#define ICMP_NET_ANO		9
++#define ICMP_HOST_ANO		10
++#define ICMP_NET_UNR_TOS	11
++#define ICMP_HOST_UNR_TOS	12
++#define ICMP_PKT_FILTERED	13	/* Packet filtered */
++#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
++#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
++#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
++
++/* Codes for REDIRECT. */
++#define ICMP_REDIR_NET		0	/* Redirect Net			*/
++#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
++#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
++#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
++
++/* Codes for TIME_EXCEEDED. */
++#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
++#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
++
++
++#ifdef __USE_BSD
++/*
++ * Copyright (c) 1982, 1986, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
++ */
++
++#include <netinet/in.h>
++#include <netinet/ip.h>
++
++/*
++ * Internal of an ICMP Router Advertisement
++ */
++struct icmp_ra_addr
++{
++  u_int32_t ira_addr;
++  u_int32_t ira_preference;
++};
++
++struct icmp
++{
++  u_int8_t  icmp_type;	/* type of message, see below */
++  u_int8_t  icmp_code;	/* type sub code */
++  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
++  union
++  {
++    u_char ih_pptr;		/* ICMP_PARAMPROB */
++    struct in_addr ih_gwaddr;	/* gateway address */
++    struct ih_idseq		/* echo datagram */
++    {
++      u_int16_t icd_id;
++      u_int16_t icd_seq;
++    } ih_idseq;
++    u_int32_t ih_void;
++
++    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
++    struct ih_pmtu
++    {
++      u_int16_t ipm_void;
++      u_int16_t ipm_nextmtu;
++    } ih_pmtu;
++
++    struct ih_rtradv
++    {
++      u_int8_t irt_num_addrs;
++      u_int8_t irt_wpa;
++      u_int16_t irt_lifetime;
++    } ih_rtradv;
++  } icmp_hun;
++#define	icmp_pptr	icmp_hun.ih_pptr
++#define	icmp_gwaddr	icmp_hun.ih_gwaddr
++#define	icmp_id		icmp_hun.ih_idseq.icd_id
++#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
++#define	icmp_void	icmp_hun.ih_void
++#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
++#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
++#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
++#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
++#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
++  union
++  {
++    struct
++    {
++      u_int32_t its_otime;
++      u_int32_t its_rtime;
++      u_int32_t its_ttime;
++    } id_ts;
++    struct
++    {
++      struct ip idi_ip;
++      /* options and then 64 bits of data */
++    } id_ip;
++    struct icmp_ra_addr id_radv;
++    u_int32_t   id_mask;
++    u_int8_t    id_data[1];
++  } icmp_dun;
++#define	icmp_otime	icmp_dun.id_ts.its_otime
++#define	icmp_rtime	icmp_dun.id_ts.its_rtime
++#define	icmp_ttime	icmp_dun.id_ts.its_ttime
++#define	icmp_ip		icmp_dun.id_ip.idi_ip
++#define	icmp_radv	icmp_dun.id_radv
++#define	icmp_mask	icmp_dun.id_mask
++#define	icmp_data	icmp_dun.id_data
++};
++
++/*
++ * Lower bounds on packet lengths for various types.
++ * For the error advice packets must first insure that the
++ * packet is large enough to contain the returned ip header.
++ * Only then can we do the check to see if 64 bits of packet
++ * data have been returned, since we need to check the returned
++ * ip header length.
++ */
++#define	ICMP_MINLEN	8				/* abs minimum */
++#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
++#define	ICMP_MASKLEN	12				/* address mask */
++#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
++#ifndef _IP_VHL
++#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
++	/* N.B.: must separately check that ip_hl >= 5 */
++#else
++#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
++	/* N.B.: must separately check that header length >= 5 */
++#endif
++
++/* Definition of type and code fields. */
++/* defined above: ICMP_ECHOREPLY, ICMP_REDIRECT, ICMP_ECHO */
++#define	ICMP_ECHOREPLY		0		/* echo reply */
++#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
++#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
++#define	ICMP_REDIRECT		5		/* shorter route, codes: */
++#define	ICMP_ECHO		8		/* echo service */
++#define	ICMP_ROUTERADVERT	9		/* router advertisement */
++#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
++#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
++#define	ICMP_PARAMPROB		12		/* ip header bad */
++#define	ICMP_TSTAMP		13		/* timestamp request */
++#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
++#define	ICMP_IREQ		15		/* information request */
++#define	ICMP_IREQREPLY		16		/* information reply */
++#define	ICMP_MASKREQ		17		/* address mask request */
++#define	ICMP_MASKREPLY		18		/* address mask reply */
++
++#define	ICMP_MAXTYPE		18
++
++/* UNREACH codes */
++#define	ICMP_UNREACH_NET	        0	/* bad net */
++#define	ICMP_UNREACH_HOST	        1	/* bad host */
++#define	ICMP_UNREACH_PROTOCOL	        2	/* bad protocol */
++#define	ICMP_UNREACH_PORT	        3	/* bad port */
++#define	ICMP_UNREACH_NEEDFRAG	        4	/* IP_DF caused drop */
++#define	ICMP_UNREACH_SRCFAIL	        5	/* src route failed */
++#define	ICMP_UNREACH_NET_UNKNOWN        6	/* unknown net */
++#define	ICMP_UNREACH_HOST_UNKNOWN       7	/* unknown host */
++#define	ICMP_UNREACH_ISOLATED	        8	/* src host isolated */
++#define	ICMP_UNREACH_NET_PROHIB	        9	/* net denied */
++#define	ICMP_UNREACH_HOST_PROHIB        10	/* host denied */
++#define	ICMP_UNREACH_TOSNET	        11	/* bad tos for net */
++#define	ICMP_UNREACH_TOSHOST	        12	/* bad tos for host */
++#define	ICMP_UNREACH_FILTER_PROHIB      13	/* admin prohib */
++#define	ICMP_UNREACH_HOST_PRECEDENCE    14	/* host prec vio. */
++#define	ICMP_UNREACH_PRECEDENCE_CUTOFF  15	/* prec cutoff */
++
++/* REDIRECT codes */
++#define	ICMP_REDIRECT_NET	0		/* for network */
++#define	ICMP_REDIRECT_HOST	1		/* for host */
++#define	ICMP_REDIRECT_TOSNET	2		/* for tos and net */
++#define	ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
++
++/* TIMEXCEED codes */
++#define	ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
++#define	ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
++
++/* PARAMPROB code */
++#define	ICMP_PARAMPROB_ERRATPTR 0		/* error at param ptr */
++#define	ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
++#define	ICMP_PARAMPROB_LENGTH 2			/* bad length */
++
++#define	ICMP_INFOTYPE(type) \
++	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
++	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
++	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
++	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
++	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
++
++#endif /* __USE_BSD */
++
++__END_DECLS
++
++#endif /* netinet/ip_icmp.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,258 @@
++/* netinet/tcp.h
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Copyright (c) 1982, 1986, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
++ */
++
++#ifndef _NETINET_TCP_H
++#define _NETINET_TCP_H	1
++
++#include <features.h>
++
++/*
++ * User-settable options (used with setsockopt).
++ */
++#define	TCP_NODELAY	 1	/* Don't delay send to coalesce packets  */
++#define	TCP_MAXSEG	 2	/* Set maximum segment size  */
++#define TCP_NOPUSH	 4	/* Don't push last block of write  */
++#define TCP_NOOPT	 8	/* Don't use TCP options  */
++
++#ifdef __USE_MISC
++# include <sys/types.h>
++
++# ifdef __FAVOR_BSD
++typedef	u_int32_t tcp_seq;
++typedef	u_int32_t tcp_cc;	/* connection count, per RFC 1644 */
++/*
++ * TCP header.
++ * Per RFC 793, September, 1981.
++ */
++struct tcphdr
++  {
++    u_int16_t th_sport;		/* source port */
++    u_int16_t th_dport;		/* destination port */
++    tcp_seq th_seq;		/* sequence number */
++    tcp_seq th_ack;		/* acknowledgement number */
++#  if __BYTE_ORDER == __LITTLE_ENDIAN
++    u_int8_t th_x2:4;		/* (unused) */
++    u_int8_t th_off:4;		/* data offset */
++#  endif
++#  if __BYTE_ORDER == __BIG_ENDIAN
++    u_int8_t th_off:4;		/* data offset */
++    u_int8_t th_x2:4;		/* (unused) */
++#  endif
++    u_int8_t th_flags;
++#  define TH_FIN	0x01
++#  define TH_SYN	0x02
++#  define TH_RST	0x04
++#  define TH_PUSH	0x08
++#  define TH_ACK	0x10
++#  define TH_URG	0x20
++    u_int16_t th_win;		/* window */
++    u_int16_t th_sum;		/* checksum */
++    u_int16_t th_urp;		/* urgent pointer */
++};
++
++# else /* !__FAVOR_BSD */
++struct tcphdr
++  {
++    u_int16_t source;
++    u_int16_t dest;
++    u_int32_t seq;
++    u_int32_t ack_seq;
++#  if __BYTE_ORDER == __LITTLE_ENDIAN
++    u_int16_t res1:4;
++    u_int16_t doff:4;
++    u_int16_t fin:1;
++    u_int16_t syn:1;
++    u_int16_t rst:1;
++    u_int16_t psh:1;
++    u_int16_t ack:1;
++    u_int16_t urg:1;
++    u_int16_t res2:2;
++#  elif __BYTE_ORDER == __BIG_ENDIAN
++    u_int16_t doff:4;
++    u_int16_t res1:4;
++    u_int16_t res2:2;
++    u_int16_t urg:1;
++    u_int16_t ack:1;
++    u_int16_t psh:1;
++    u_int16_t rst:1;
++    u_int16_t syn:1;
++    u_int16_t fin:1;
++#  else
++#   error "Adjust your <bits/endian.h> defines"
++#  endif
++    u_int16_t window;
++    u_int16_t check;
++    u_int16_t urg_ptr;
++};
++# endif /* __FAVOR_BSD */
++
++enum
++{
++  TCP_ESTABLISHED = 1,
++  TCP_SYN_SENT,
++  TCP_SYN_RECV,
++  TCP_FIN_WAIT1,
++  TCP_FIN_WAIT2,
++  TCP_TIME_WAIT,
++  TCP_CLOSE,
++  TCP_CLOSE_WAIT,
++  TCP_LAST_ACK,
++  TCP_LISTEN,
++  TCP_CLOSING   /* now a valid state */
++};
++
++# define TCPOPT_EOL		0
++# define TCPOPT_NOP		1
++# define TCPOPT_MAXSEG		2
++# define    TCPOLEN_MAXSEG		4
++# define TCPOPT_WINDOW		3
++# define    TCPOLEN_WINDOW		3
++# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
++# define    TCPOLEN_SACK_PERMITTED	2
++# define TCPOPT_SACK		5		/* Experimental */
++# define TCPOPT_TIMESTAMP	8
++# define    TCPOLEN_TIMESTAMP	10
++# define    TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */
++# define    TCPOPT_TSTAMP_HDR	\
++    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)
++#define	TCPOPT_CC		11		/* CC options: RFC-1644 */
++#define TCPOPT_CCNEW		12
++#define TCPOPT_CCECHO		13
++#define	   TCPOLEN_CC			6
++#define	   TCPOLEN_CC_APPA		(TCPOLEN_CC+2)
++#define	   TCPOPT_CC_HDR(ccopt)		\
++    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|(ccopt)<<8|TCPOLEN_CC)
++
++/*
++ * Default maximum segment size for TCP.
++ * With an IP MSS of 576, this is 536,
++ * but 512 is probably more convenient.
++ * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
++ */
++# define TCP_MSS	512
++
++/*
++ * Default maximum segment size for TCP6.
++ * With an IP MSS of 1280, this is 1220,
++ * but 1024 is probably more convenient.
++ * This should be defined as MIN(1024, IP6_MSS - sizeof (struct tcpip6hdr)).
++ */
++# define TCP6_MSS	1024
++
++# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */
++# define TTCP_CLIENT_SND_WND 4096 /* default send window for T/TCP client */
++
++# define TCP_MAX_WINSHIFT	14	/* maximum window shift */
++
++#define TCP_MAXBURST		4	/* maximum segments in a burst */
++
++#define TCP_MAXHLEN	(0xf<<2)	/* max length of header in bytes */
++#define TCP_MAXOLEN	(TCP_MAXHLEN - sizeof (struct tcphdr))
++					/* max space left for options */
++
++# define SOL_TCP		6	/* TCP level */
++
++
++# define TCPI_OPT_TIMESTAMPS	1
++# define TCPI_OPT_SACK		2
++# define TCPI_OPT_WSCALE	4
++# define TCPI_OPT_ECN		8
++
++/* Values for tcpi_state.  */
++enum tcp_ca_state
++{
++  TCP_CA_Open = 0,
++  TCP_CA_Disorder = 1,
++  TCP_CA_CWR = 2,
++  TCP_CA_Recovery = 3,
++  TCP_CA_Loss = 4
++};
++
++struct tcp_info
++{
++  u_int8_t	tcpi_state;
++  u_int8_t	tcpi_ca_state;
++  u_int8_t	tcpi_retransmits;
++  u_int8_t	tcpi_probes;
++  u_int8_t	tcpi_backoff;
++  u_int8_t	tcpi_options;
++  u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
++
++  u_int32_t	tcpi_rto;
++  u_int32_t	tcpi_ato;
++  u_int32_t	tcpi_snd_mss;
++  u_int32_t	tcpi_rcv_mss;
++
++  u_int32_t	tcpi_unacked;
++  u_int32_t	tcpi_sacked;
++  u_int32_t	tcpi_lost;
++  u_int32_t	tcpi_retrans;
++  u_int32_t	tcpi_fackets;
++
++  /* Times. */
++  u_int32_t	tcpi_last_data_sent;
++  u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
++  u_int32_t	tcpi_last_data_recv;
++  u_int32_t	tcpi_last_ack_recv;
++
++  /* Metrics. */
++  u_int32_t	tcpi_pmtu;
++  u_int32_t	tcpi_rcv_ssthresh;
++  u_int32_t	tcpi_rtt;
++  u_int32_t	tcpi_rttvar;
++  u_int32_t	tcpi_snd_ssthresh;
++  u_int32_t	tcpi_snd_cwnd;
++  u_int32_t	tcpi_advmss;
++  u_int32_t	tcpi_reordering;
++};
++
++#endif /* Misc.  */
++
++#endif /* netinet/tcp.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,58 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/timex.h>
++#include <sys/sysctl.h>
++#include <stddef.h>
++
++int
++ntp_gettime (struct ntptimeval *ntv)
++{
++  /* Fetch sysctl value of "kern.ntp_pll.gettime".  */
++  /* The 'struct ntptimeval' has grown in size.  */
++  union
++    {
++      struct ntptimeval3 tv3;
++      struct ntptimeval4 tv4;
++    } tv;
++  size_t size = sizeof (tv);
++  int request[2] = { CTL_KERN, KERN_NTP_PLL };
++
++  if (__sysctl (request, 2, &tv, &size, NULL, 0) >= 0)
++    {
++      if (size == sizeof (struct ntptimeval3))
++	{
++	  if (ntv)
++	    {
++	      ntv->time = tv.tv3.time;
++	      ntv->maxerror = tv.tv3.maxerror;
++	      ntv->esterror = tv.tv3.esterror;
++	      ntv->tai = 0;
++	      ntv->time_state = tv.tv3.time_state;
++	    }
++	  return tv.tv3.time_state;
++	}
++      if (size == sizeof (struct ntptimeval4))
++	{
++	  if (ntv)
++	    *ntv = tv.tv4;
++	  return tv.tv4.time_state;
++	}
++    }
++  return TIME_ERROR;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c	2005-08-23 17:38:21.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'open64' is the same as 'open', because __off64_t == __off_t and
++   O_LARGEFILE == 0.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,78 @@
++/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <fcntl.h>
++#include <stdarg.h>
++#include <unistd.h>
++#include <sysdep.h>
++#include <errno.h>
++#include <sys/stat.h>
++#include <sys/time.h>
++
++extern int __syscall_open (const char *file, int oflag, int mode);
++extern int __futimes (int fd, const struct timeval tvp[2]);
++
++int
++__libc_open (const char *file, int oflag, ...)
++{
++  int mode = 0;
++  int fd;
++
++  if (oflag & O_CREAT)
++    {
++      va_list arg;
++      va_start (arg, oflag);
++      mode = va_arg (arg, int);
++      va_end (arg);
++    }
++
++  fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
++
++  if (fd >= 0 && (oflag & O_TRUNC))
++    {
++      /* Set the modification time.  The kernel ought to do this.  */
++      int saved_errno = errno;
++      struct timeval tv[2];
++
++      if (__gettimeofday (&tv[1], NULL) >= 0)
++	{
++	  struct stat statbuf;
++
++	  if (__fxstat (_STAT_VER, fd, &statbuf) >= 0)
++	    {
++	      tv[0].tv_sec = statbuf.st_atime;
++	      tv[0].tv_usec = 0;
++
++	      __futimes (fd, tv);
++	    }
++	}
++      __set_errno (saved_errno);
++    }
++
++  return fd;
++}
++libc_hidden_def (__libc_open)
++
++weak_alias (__libc_open, __open)
++libc_hidden_weak (__open)
++
++weak_alias (__libc_open, open)
++
++strong_alias (__libc_open, __libc_open64)
++weak_alias (__libc_open64, __open64)
++weak_alias (__libc_open64, open64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,73 @@
++/*
++ * Copyright (c) 1989, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
++ */
++
++#ifndef _PATHS_H_
++#define _PATHS_H_
++
++/* Default search path. */
++#define _PATH_DEFPATH	"/usr/bin:/bin"
++/* All standard utilities path. */
++#define _PATH_STDPATH	"/usr/bin:/bin:/usr/sbin:/sbin"
++
++#define _PATH_BSHELL	"/bin/sh"
++#define _PATH_CONSOLE	"/dev/console"
++#define _PATH_CSHELL	"/bin/csh"
++#define _PATH_DEVDB	"/var/run/dev.db"
++#define _PATH_DEVNULL	"/dev/null"
++#define _PATH_DRUM	"/dev/drum"
++#define _PATH_KLOG	"/dev/klog"
++#define _PATH_KMEM	"/dev/kmem"
++#define _PATH_LASTLOG	"/var/log/lastlog"
++#define _PATH_MAILDIR	"/var/mail"
++#define _PATH_MAN	"/usr/share/man"
++#define _PATH_MEM	"/dev/mem"
++#define _PATH_MNTTAB	"/etc/fstab"
++#define _PATH_MOUNTED	"/etc/mtab"
++#define _PATH_NOLOGIN	"/etc/nologin"
++#define _PATH_PRESERVE	"/var/preserve"
++#define _PATH_RWHODIR	"/var/rwho"
++#define _PATH_SENDMAIL	"/usr/sbin/sendmail"
++#define _PATH_SHADOW	"/etc/shadow"
++#define _PATH_SHELLS	"/etc/shells"
++#define _PATH_TTY	"/dev/tty"
++#define _PATH_UNIX	"/kernel"
++#define _PATH_UTMP	"/var/run/utmp"
++#define _PATH_VI	"/usr/bin/vi"
++#define _PATH_WTMP	"/var/log/wtmp"
++
++/* Provide trailing slash, since mostly used for building pathnames. */
++#define _PATH_DEV	"/dev/"
++#define _PATH_TMP	"/tmp/"
++#define _PATH_VARDB	"/var/db/"
++#define _PATH_VARRUN	"/var/run/"
++#define _PATH_VARTMP	"/var/tmp/"
++
++#endif /* !_PATHS_H_ */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,1 @@
++#include <sysdeps/generic/posix_fadvise64.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise.c sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,1 @@
++#include <sysdeps/generic/posix_fadvise.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,1 @@
++#include <sysdeps/posix/posix_fallocate64.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate.c sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,1 @@
++#include <sysdeps/posix/posix_fallocate.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c	2005-08-23 17:55:41.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++ssize_t
++__libc_pread64 (int fd, void *buf, size_t nbytes, __off64_t offset)
++{
++  /* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
++  return __libc_pread(fd, buf, nbytes, (__off_t) offset);
++}
++
++strong_alias (__libc_pread64, __pread64)
++weak_alias (__libc_pread64, pread64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c	2005-08-23 17:55:54.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern ssize_t __syscall_pread (int __fd, void *__buf, size_t __nbytes,
++				int __unused1, __off_t __offset) __THROW;
++
++ssize_t
++__libc_pread (int fd, void *buf, size_t nbytes, __off_t offset)
++{
++  /* We pass 5 arguments in 6 words.  */
++  return INLINE_SYSCALL (pread, 5, fd, buf, nbytes, 0, offset);
++}
++
++strong_alias (__libc_pread, __pread)
++weak_alias (__libc_pread, pread)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,47 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <libc-internal.h>
++#include <stddef.h>
++#include <sys/sysctl.h>
++
++struct clockinfo
++{
++  int hz;		/* Clock frequency.  */
++  int tick;		/* Microseconds per hz tick, = 1000000 / hz.  */
++  int tickadj;		/* Clock skew rate for adjtime().  */
++  int stathz;		/* Statistics clock frequency.  */
++  int profhz;		/* Profiling clock frequency.  */
++};
++
++int
++__profile_frequency (void)
++{
++  /* Fetch the "kern.clockrate" sysctl value.  */
++  int request[2] = { CTL_KERN, KERN_CLOCKRATE };
++  struct clockinfo result;
++  size_t result_len = sizeof (result);
++
++  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
++    /* Dummy result.  */
++    return 1;
++
++  /* Yes, hz, not profhz.  On i386, the value is 100, not 1024.  */
++  return result.hz;
++}
++libc_hidden_def (__profile_frequency)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ptrace.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ptrace.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ptrace.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ptrace.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,68 @@
++/* Copyright (C) 1995-1998, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <sys/types.h>
++#include <sys/ptrace.h>
++#include <stdarg.h>
++
++#include <sysdep.h>
++#include <sys/syscall.h>
++
++extern int __syscall_ptrace (enum __ptrace_request request, pid_t pid,
++			     void *addr, void *data);
++
++int
++ptrace (enum __ptrace_request request, ...)
++{
++  int res, ret;
++  va_list ap;
++  pid_t pid;
++  void *addr, *data;
++
++  /* Usually 4 arguments are given, except when request == PTRACE_TRACEME.
++     But it doesn't harm to peek at the stack in this case as well.  */
++  va_start (ap, request);
++  pid = va_arg (ap, pid_t);
++  addr = va_arg (ap, void *);
++  data = va_arg (ap, void *);
++  va_end (ap);
++
++  switch (request)
++    {
++    case PTRACE_PEEKTEXT:
++    case PTRACE_PEEKDATA:
++#ifdef PTRACE_PEEKUSER
++    case PTRACE_PEEKUSER:
++#endif
++      res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, &ret);
++      if (res >= 0)
++	{
++	  /* ret can be -1 even for successful operation.  */
++	  __set_errno (0);
++	  return ret;
++	}
++      break;
++
++    default:
++      res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, data);
++      break;
++    }
++
++  return res;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,117 @@
++/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <paths.h>
++#include <stdlib.h>
++#include <string.h>
++#include <sys/stat.h>
++#include <sys/sysmacros.h>
++#include <unistd.h>
++
++
++/* Static buffer for `ptsname'.  */
++static char buffer[sizeof (_PATH_TTY) + 2];
++
++
++/* Return the pathname of the pseudo terminal slave associated with
++   the master FD is open on, or NULL on errors.
++   The returned storage is good until the next call to this function.  */
++char *
++ptsname (int fd)
++{
++  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;
++}
++
++
++/* Check if DEV corresponds to a master pseudo terminal device.  */
++#define MASTER_P(dev) (major (dev) == 6)
++
++/* Check if DEV corresponds to a master pseudo terminal device.  */
++#define SLAVE_P(dev) (major (dev) == 5)
++
++/* The are declared in getpt.c.  */
++extern const char __libc_ptyname1[] attribute_hidden;
++extern const char __libc_ptyname2[] attribute_hidden;
++
++
++/* Store at most BUFLEN characters of the pathname of the slave pseudo
++   terminal associated with the master FD is open on in BUF.
++   Return 0 on success, otherwise an error number.  */
++int
++__ptsname_r (int fd, char *buf, size_t buflen)
++{
++  int saved_errno = errno;
++  struct stat64 st;
++  unsigned int ptyno;
++  char *p;
++
++  if (buf == NULL)
++    {
++      __set_errno (EINVAL);
++      return EINVAL;
++    }
++
++  /* Don't call isatty (fd) - it usually fails with errno = EAGAIN.  */
++
++  if (__fxstat64 (_STAT_VER, fd, &st) < 0)
++    return errno;
++
++  /* Check if FD really is a master pseudo terminal.  */
++  if (!(S_ISCHR (st.st_mode) && MASTER_P (st.st_rdev)))
++    {
++      __set_errno (ENOTTY);
++      return ENOTTY;
++    }
++
++  ptyno = (unsigned int) minor (st.st_rdev);
++  if (ptyno / 32 >= strlen (__libc_ptyname1))
++    {
++      __set_errno (ENOTTY);
++      return ENOTTY;
++    }
++
++  if (buflen < sizeof (_PATH_TTY) + 2)
++    {
++      __set_errno (ERANGE);
++      return ERANGE;
++    }
++
++  /* Construct the slave's pathname.  */
++  p = __mempcpy (buf, _PATH_TTY, sizeof (_PATH_TTY) - 1);
++  p[0] = __libc_ptyname1[ptyno / 32];
++  p[1] = __libc_ptyname2[ptyno % 32];
++  p[2] = '\0';
++
++  if (__xstat64 (_STAT_VER, buf, &st) < 0)
++    return errno;
++
++  /* Check if the pathname we're about to return really corresponds to the
++     slave pseudo terminal of the given master pseudo terminal.  */
++  if (!(S_ISCHR (st.st_mode) && SLAVE_P (st.st_rdev)
++	&& (unsigned int) minor (st.st_rdev) == ptyno))
++    {
++      /* This really is a configuration problem.  */
++      __set_errno (ENOTTY);
++      return ENOTTY;
++    }
++
++  __set_errno (saved_errno);
++  return 0;
++}
++weak_alias (__ptsname_r, ptsname_r)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c	2005-08-23 17:54:40.000000000 +0200
+@@ -0,0 +1,33 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++ssize_t
++__libc_pwrite64 (int fd, const void *buf, size_t nbytes, __off64_t offset)
++{
++  /* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
++  return __libc_pwrite(fd, buf, nbytes, (__off_t) offset);
++}
++
++strong_alias (__libc_pwrite64, __pwrite64)
++libc_hidden_weak (__pwrite64)
++weak_alias (__libc_pwrite64, pwrite64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c	2005-08-23 17:55:59.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern ssize_t __syscall_pwrite (int __fd, const void *__buf, size_t __nbytes,
++				 int __unused1, __off_t __offset) __THROW;
++
++ssize_t
++__libc_pwrite (int fd, const void *buf, size_t nbytes, __off_t offset)
++{
++  /* We pass 5 arguments in 6 words.  */
++  return INLINE_SYSCALL (pwrite, 5, fd, buf, nbytes, 0, offset);
++}
++
++strong_alias (__libc_pwrite, __pwrite)
++weak_alias (__libc_pwrite, pwrite)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'readdir64' is the same as 'readdir', because
++   struct dirent64 == struct dirent.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* 'readdir64_r' is the same as 'readdir_r', because
++   struct dirent64 == struct dirent.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,11 @@
++/* 'readdir64' is the same as 'readdir', because
++   struct dirent64 == struct dirent.  */
++
++#define readdir64 __no_readdir64_decl
++#define __readdir64 __no___readdir64_decl
++#include <sysdeps/unix/readdir.c>
++#undef __readdir64
++#undef readdir64
++
++strong_alias (__readdir, __readdir64)
++weak_alias (__readdir64, readdir64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,11 @@
++/* 'readdir64_r' is the same as 'readdir_r', because
++   struct dirent64 == struct dirent.  */
++
++#define readdir64_r __no_readdir64_r_decl
++#define __readdir64_r __no___readdir64_r_decl
++#include <sysdeps/unix/readdir_r.c>
++#undef __readdir64_r
++#undef readdir64_r
++
++strong_alias (__readdir_r, __readdir64_r)
++weak_alias (__readdir64_r, readdir64_r)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readelflib.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readelflib.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readelflib.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readelflib.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,239 @@
++/* Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Andreas Jaeger <aj@suse.de>, 1999 and
++		  Jakub Jelinek <jakub@redhat.com>, 1999.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This code is a heavily simplified version of the readelf program
++   that's part of the current binutils development version.  For architectures
++   which need to handle both 32bit and 64bit ELF libraries,  this file is
++   included twice for each arch size.  */
++
++/* check_ptr checks that a pointer is in the mmaped file and doesn't
++   point outside it.  */
++#undef check_ptr
++#define check_ptr(ptr)						\
++do								\
++  {								\
++    if ((void *)(ptr) < file_contents				\
++	|| (void *)(ptr) > (file_contents+file_length))		\
++      {								\
++	error (0, 0, _("file %s is truncated\n"), file_name);	\
++	return 1;						\
++      }								\
++  }								\
++ while (0);
++
++/* Recognize the common names of the dynamic loader: ld.so* and ld-*.so.  */
++static inline int
++is_ld_so (const char *file_name)
++{
++  file_name = basename (file_name);
++  if (strcmp (file_name, "ld.so") == 0)
++    return 1;
++  if (strncmp (file_name, "ld.so.", 6) == 0)
++    return 1;
++  if (strncmp (file_name, "ld-", 3) == 0
++      && strcmp (file_name + 3 + strspn (file_name + 3, "0123456789.") - 1,
++		 ".so") == 0)
++    return 1;
++  return 0;
++}
++
++/* Returns 0 if everything is ok, != 0 in case of error.  */
++int
++process_elf_file (const char *file_name, const char *lib, int *flag,
++		  unsigned int *osversion, char **soname, void *file_contents,
++		  size_t file_length)
++{
++  int i;
++  unsigned int j;
++  int loadaddr;
++  unsigned int dynamic_addr;
++  size_t dynamic_size;
++  char *program_interpreter;
++  
++  ElfW(Ehdr) *elf_header;
++  ElfW(Phdr) *elf_pheader, *segment;
++  ElfW(Dyn) *dynamic_segment, *dyn_entry;
++  char *dynamic_strings;  
++
++  elf_header = (ElfW(Ehdr) *) file_contents;
++  *osversion = 0;
++
++  if (elf_header->e_ident [EI_CLASS] != ElfW (CLASS))
++    {
++      if (opt_verbose)
++	{
++	  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
++	    error (0, 0, _("%s is a 32 bit ELF file.\n"), file_name);
++	  else if (elf_header->e_ident [EI_CLASS] == ELFCLASS64)
++	    error (0, 0, _("%s is a 64 bit ELF file.\n"), file_name);
++	  else
++	    error (0, 0, _("Unknown ELFCLASS in file %s.\n"), file_name);
++	}
++      return 1;
++    }
++
++  /* ld.so is simultaneously a shared object and an executable.  */
++  if (!(elf_header->e_type == ET_DYN
++	|| (elf_header->e_type == ET_EXEC && is_ld_so (file_name))))
++    {
++      error (0, 0, _("%s is not a shared object file (Type: %d).\n"), file_name,
++	     elf_header->e_type);
++      return 1;
++    }
++  
++  /* Get information from elf program header.  */
++  elf_pheader = (ElfW(Phdr) *) (elf_header->e_phoff + file_contents);
++  check_ptr (elf_pheader);
++
++  /* The library is an elf library, now search for soname and
++     libc5/libc6.  */
++  *flag = FLAG_ELF;
++  
++  loadaddr = -1;
++  dynamic_addr = 0;
++  dynamic_size = 0;
++  program_interpreter = NULL;
++  for (i = 0, segment = elf_pheader;
++       i < elf_header->e_phnum; i++, segment++)
++    {
++      check_ptr (segment);
++
++      switch (segment->p_type)
++	{
++	case PT_LOAD:
++	  if (loadaddr == -1)
++	    loadaddr = (segment->p_vaddr & 0xfffff000)
++	      - (segment->p_offset & 0xfffff000);
++	  break;
++
++	case PT_DYNAMIC:
++	  if (dynamic_addr)
++	    error (0, 0, _("more than one dynamic segment\n"));
++
++	  dynamic_addr = segment->p_offset;
++	  dynamic_size = segment->p_filesz;
++	  break;
++
++	case PT_INTERP:
++	  program_interpreter = (char *) (file_contents + segment->p_offset);
++	  check_ptr (program_interpreter);
++
++	  /* Check if this is enough to classify the binary.  */
++	  for (j = 0; j < sizeof (interpreters) / sizeof (interpreters [0]);
++	       ++j)
++	    if (strcmp (program_interpreter, interpreters[j].soname) == 0)
++	      {
++		*flag = interpreters[j].flag;
++		break;
++	      }
++	  break;
++
++	case PT_NOTE:
++	  if (!*osversion && segment->p_filesz == 32 && segment->p_align >= 4)
++	    {
++	      ElfW(Word) *abi_note = (ElfW(Word) *) (file_contents
++						     + segment->p_offset);
++	      if (abi_note [0] == 4 && abi_note [1] == 16 && abi_note [2] == 1
++		  && memcmp (abi_note + 3, "GNU", 4) == 0)
++		*osversion = (abi_note [4] << 24) |
++			     ((abi_note [5] & 0xff) << 16) |
++			     ((abi_note [6] & 0xff) << 8) |
++			     (abi_note [7] & 0xff);
++	    }
++	  break;
++
++	default:
++	  break;
++	}
++      
++    }
++  if (loadaddr == -1)
++    {
++      /* Very strange. */
++      loadaddr = 0;
++    }
++
++  /* Now we can read the dynamic sections.  */
++  if (dynamic_size == 0)
++    return 1;
++  
++  dynamic_segment = (ElfW(Dyn) *) (file_contents + dynamic_addr);
++  check_ptr (dynamic_segment);
++
++  /* Find the string table.  */
++  dynamic_strings = NULL;
++  for (dyn_entry = dynamic_segment; dyn_entry->d_tag != DT_NULL;
++       ++dyn_entry)
++    {
++      check_ptr (dyn_entry);
++      if (dyn_entry->d_tag == DT_STRTAB)
++	{
++	  dynamic_strings = (char *) (file_contents + dyn_entry->d_un.d_val - loadaddr);
++	  check_ptr (dynamic_strings);
++	  break;
++	}
++    }
++
++  if (dynamic_strings == NULL)
++    return 1;
++
++  /* Now read the DT_NEEDED and DT_SONAME entries.  */
++  for (dyn_entry = dynamic_segment; dyn_entry->d_tag != DT_NULL;
++       ++dyn_entry)
++    {
++      if (dyn_entry->d_tag == DT_NEEDED || dyn_entry->d_tag == DT_SONAME)
++	{
++	  char *name = dynamic_strings + dyn_entry->d_un.d_val;
++	  check_ptr (name);
++
++	  if (dyn_entry->d_tag == DT_NEEDED)
++	    {
++	      
++	      if (*flag == FLAG_ELF)
++		{
++		  /* Check if this is enough to classify the binary.  */
++		  for (j = 0;
++		       j < sizeof (known_libs) / sizeof (known_libs [0]);
++		       ++j)
++		    if (strcmp (name, known_libs [j].soname) == 0)
++		      {
++			*flag = known_libs [j].flag;
++			break;
++		      }
++		}
++	    }
++
++	  else if (dyn_entry->d_tag == DT_SONAME)
++	    *soname = xstrdup (name);
++	  
++	  /* Do we have everything we need?  */
++	  if (*soname && *flag != FLAG_ELF)
++	    return 0;
++	}
++    }
++
++  /* We reach this point only if the file doesn't contain a DT_SONAME
++     or if we can't classify the library.  If it doesn't have a
++     soname, return the name of the library.  */
++  if (*soname == NULL)
++    *soname = xstrdup (lib);
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,46 @@
++/* readv for FreeBSD.
++   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/param.h>
++#include <sys/uio.h>
++
++#include <sysdep.h>
++#include <sys/syscall.h>
++#include <bp-checks.h>
++
++extern ssize_t __syscall_readv (int, __const struct iovec *__unbounded, int);
++
++static ssize_t __atomic_readv_replacement (int, __const struct iovec *,
++					   int) internal_function;
++
++ssize_t
++__libc_readv (int fd, const struct iovec *vector, int count)
++{
++  if (count <= UIO_MAXIOV)
++    return INLINE_SYSCALL (readv, 3, fd, CHECK_N (vector, count), count);
++  else
++    return __atomic_readv_replacement (fd, vector, count);
++}
++strong_alias (__libc_readv, __readv)
++weak_alias (__libc_readv, readv)
++
++#define __libc_readv static internal_function __atomic_readv_replacement
++#include <sysdeps/posix/readv.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,34 @@
++/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/socket.h>
++#include <sysdep.h>
++
++/* The real syscall's name.  See sysdeps/unix/inet/syscalls.list.  */
++#define __syscall_recvfrom __libc_recvfrom
++
++/* Read N bytes into BUF from socket FD.
++   Return the number of bytes read or -1 for error.  */
++
++ssize_t
++__libc_recv (int fd, void *buf, size_t n, int flags)
++{
++  return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
++}
++
++weak_alias (__libc_recv, recv)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,45 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sched.h>
++#include <sys/types.h>
++#include <errno.h>
++#include <sys/rtprio.h>
++
++/* Retrieve scheduling parameters for a particular process.  */
++int
++__sched_getparam (pid_t pid, struct sched_param *param)
++{
++  /* kFreeBSD return bogus values for SYS_sched_param (see PR kern/76485);
++     fortunately the same information can be retrieved through the rtprio()
++     system call.  */
++  struct rtprio rtp;
++
++  if (__rtprio (RTP_LOOKUP, pid, &rtp) >= 0)
++    {
++      if (RTP_PRIO_IS_REALTIME (rtp.type))
++        param->sched_priority = RTP_PRIO_MAX - rtp.prio;
++      else
++        param->sched_priority = 0;
++    }
++
++  return 0;
++}
++
++weak_alias (__sched_getparam, sched_getparam)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
++#include <sysdeps/unix/seekdir.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,85 @@
++/* Copyright (C) 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Robert Millan <robertmh@gnu.org>
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*-
++ * Copyright (c) 2002 Doug Rabson
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ */
++
++#include <sys/sem.h>
++#include <sys/syscall.h>
++#include <stdarg.h> /* va_list */
++#include <stdlib.h> /* NULL */
++
++/* union semun from FreeBSD <sys/sem.h> */
++/*
++ * semctl's arg parameter structure
++ */
++union semun
++{
++  int val;			/* value for SETVAL */
++  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
++  unsigned short *array;	/* array for GETALL & SETALL */
++};
++
++
++int
++semctl (int semid, int semnum, int cmd, ...)
++{
++  va_list ap;
++  union semun semun;
++  union semun *semun_ptr;
++
++  va_start (ap, cmd);
++  if (cmd == IPC_SET || cmd == IPC_STAT || cmd == GETALL
++      || cmd == SETVAL || cmd == SETALL)
++    {
++      semun = va_arg (ap, union semun);
++      semun_ptr = &semun;
++    }
++  else
++    {
++      semun_ptr = NULL;
++    }
++  va_end (ap);
++
++  return syscall (SYS_semctl, semid, semnum, cmd, semun_ptr);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/socket.h>
++#include <sysdep.h>
++
++/* The real syscall's name.  See sysdeps/unix/inet/syscalls.list.  */
++#define __syscall_sendto __libc_sendto
++
++/* Send N bytes of BUF to socket FD.
++   Return the number of bytes sent or -1.  */
++
++ssize_t
++__libc_send (int fd, const void *buf, size_t n, int flags)
++{
++  return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
++}
++
++weak_alias (__libc_send, __send)
++libc_hidden_weak (__send)
++
++weak_alias (__send, send)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++
++/* Set the name of the current NIS domain to NAME, which is LEN bytes long
++   (excluding a possible trailing NUL byte).  This call is restricted to
++   the super-user.  */
++
++int
++setdomainname (const char *name, size_t len)
++{
++  /* Set the "kern.domainname" sysctl value.  */
++  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
++
++  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
++    return -1;
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++
++/* Set the current machine's Internet number to ID.
++   This call is restricted to the super-user.  */
++
++int
++sethostid (long int id)
++{
++  /* Set the "kern.hostid" sysctl value.  */
++  int value = id;
++  int request[2] = { CTL_KERN, KERN_HOSTID };
++
++  if (__sysctl (request, 2, NULL, NULL, &value, sizeof (value)) < 0)
++    return -1;
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,37 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/sysctl.h>
++
++/* Set the name of the current host to NAME, which is LEN bytes long
++   (excluding a possible trailing NUL byte).  This call is restricted to
++   the super-user.  */
++
++int
++sethostname (const char *name, size_t len)
++{
++  /* Set the "kern.hostname" sysctl value.  */
++  int request[2] = { CTL_KERN, KERN_HOSTNAME };
++
++  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
++    return -1;
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,34 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sysdep.h>
++
++/* Defined in getlogin_r.c.  */
++extern char *__getlogin_cache;
++
++extern int __syscall_setlogin (const char *__name);
++
++int
++setlogin (const char *name)
++{
++  /* FIXME: Not multithread-safe.  */
++  __getlogin_cache = NULL;
++  return INLINE_SYSCALL (setlogin, 1, name);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1 @@
++/* 'setrlimit64' is the same as 'setrlimit', because __rlim64_t == __rlim_t.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,46 @@
++/* Copyright (C) 1991,1995,1996,1997,2002,2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++#include <errno.h>
++#include <stddef.h>
++#include <signal.h>
++
++extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
++
++int
++__libc_sigaction (sig, act, oact)
++     int sig;
++     const struct sigaction *act;
++     struct sigaction *oact;
++{
++  if (sig <= 0 || sig >= NSIG)
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++
++  return INLINE_SYSCALL (sigaction, 3, sig, act, oact);
++}
++libc_hidden_def (__libc_sigaction)
++
++#ifndef LIBC_SIGACTION
++weak_alias (__libc_sigaction, __sigaction)
++libc_hidden_weak (__sigaction)
++weak_alias (__libc_sigaction, sigaction)
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++/* The sigreturn syscall cannot be explicitly called on FreeBSD, only
++   implicitly by returning from a signal handler.  */
++#include <sysdeps/generic/sigreturn.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Convert between lowlevel sigmask and libc representation of sigset_t.
++   FreeBSD version.
++   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++static inline int __attribute__ ((unused))
++sigset_set_old_mask (sigset_t *set, int mask)
++{
++  set->__sigbits[0] = (unsigned int) mask;
++  set->__sigbits[1] = 0;
++  set->__sigbits[2] = 0;
++  set->__sigbits[3] = 0;
++
++  return 0;
++}
++
++static inline int __attribute__ ((unused))
++sigset_get_old_mask (const sigset_t *set)
++{
++  return (unsigned int) set->__sigbits[0];
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,3 @@
++/* We can reuse the Linux implementation with some tricks.  */
++#define __NR_sigaltstack 1
++#include <sysdeps/unix/sysv/linux/sigstack.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,44 @@
++/* Implementation of the POSIX sleep function using nanosleep.
++   Copyright (C) 1996-1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <time.h>
++
++/* The default implementation of sleep() in sysdeps/posix/sleep.c, based on
++   SIGALRM, does not mix well with threads.  Therefore we use the nanosleep()
++   system call.  */
++unsigned int
++__sleep (unsigned int seconds)
++{
++  struct timespec ts = { tv_sec: seconds, tv_nsec: 0 };
++  int ret;
++
++  /* This is not necessary but some buggy programs depend on this.  */
++  if (seconds == 0)
++    return 0;
++
++  ret = __nanosleep (&ts, &ts);
++
++  if (ret == 0)
++    return 0;
++
++  /* Round remaining time.  */
++  return (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
++}
++
++weak_alias (__sleep, sleep)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,71 @@
++/* Convert between different 'struct stat' formats.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++
++/* Convert a 'struct stat16' to 'struct stat'.  */
++static inline void
++stat16_to_stat (const struct stat16 *p16, struct stat *q)
++{
++  q->st_dev = p16->st_dev;
++  q->st_ino = p16->st_ino;
++  q->st_mode = p16->st_mode;
++  q->st_nlink = p16->st_nlink;
++  q->st_uid = p16->st_uid;
++  q->st_gid = p16->st_gid;
++  q->st_rdev = p16->st_rdev;
++  q->st_atime = p16->st_atime;
++  q->st_atimensec = p16->st_atimensec;
++  q->st_mtime = p16->st_mtime;
++  q->st_mtimensec = p16->st_mtimensec;
++  q->st_ctime = p16->st_ctime;
++  q->st_ctimensec = p16->st_ctimensec;
++  q->st_size = p16->st_size;
++  q->st_blocks = p16->st_blocks;
++  q->st_blksize = p16->st_blksize;
++  q->st_flags = p16->st_flags;
++  q->st_gen = p16->st_gen;
++  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
++}
++
++/* Convert a 'struct stat16' to 'struct stat64'.  */
++static inline void
++stat16_to_stat64 (const struct stat16 *p16, struct stat64 *q)
++{
++  q->st_dev = p16->st_dev;
++  q->st_ino = p16->st_ino;
++  q->st_mode = p16->st_mode;
++  q->st_nlink = p16->st_nlink;
++  q->st_uid = p16->st_uid;
++  q->st_gid = p16->st_gid;
++  q->st_rdev = p16->st_rdev;
++  q->st_atime = p16->st_atime;
++  q->st_atimensec = p16->st_atimensec;
++  q->st_mtime = p16->st_mtime;
++  q->st_mtimensec = p16->st_mtimensec;
++  q->st_ctime = p16->st_ctime;
++  q->st_ctimensec = p16->st_ctimensec;
++  q->st_size = p16->st_size;
++  q->st_blocks = p16->st_blocks;
++  q->st_blksize = p16->st_blksize;
++  q->st_flags = p16->st_flags;
++  q->st_gen = p16->st_gen;
++  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/stat32conv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/stat32conv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/stat32conv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/stat32conv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,71 @@
++/* Convert between different 'struct stat' formats.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++
++/* Convert a 'struct stat32' to 'struct stat'.  */
++static inline void
++stat32_to_stat (const struct stat32 *p32, struct stat *q)
++{
++  q->st_dev = p32->st_dev;
++  q->st_ino = p32->st_ino;
++  q->st_mode = p32->st_mode;
++  q->st_nlink = p32->st_nlink;
++  q->st_uid = p32->st_uid;
++  q->st_gid = p32->st_gid;
++  q->st_rdev = p32->st_rdev;
++  q->st_atime = p32->st_atime;
++  q->st_atimensec = p32->st_atimensec;
++  q->st_mtime = p32->st_mtime;
++  q->st_mtimensec = p32->st_mtimensec;
++  q->st_ctime = p32->st_ctime;
++  q->st_ctimensec = p32->st_ctimensec;
++  q->st_size = p32->st_size;
++  q->st_blocks = p32->st_blocks;
++  q->st_blksize = p32->st_blksize;
++  q->st_flags = p32->st_flags;
++  q->st_gen = p32->st_gen;
++  memcpy (q->__unused1, p32->__unused1, sizeof (p32->__unused1));
++}
++
++/* Convert a 'struct stat32' to 'struct stat64'.  */
++static inline void
++stat32_to_stat64 (const struct stat32 *p32, struct stat64 *q)
++{
++  q->st_dev = p32->st_dev;
++  q->st_ino = p32->st_ino;
++  q->st_mode = p32->st_mode;
++  q->st_nlink = p32->st_nlink;
++  q->st_uid = p32->st_uid;
++  q->st_gid = p32->st_gid;
++  q->st_rdev = p32->st_rdev;
++  q->st_atime = p32->st_atime;
++  q->st_atimensec = p32->st_atimensec;
++  q->st_mtime = p32->st_mtime;
++  q->st_mtimensec = p32->st_mtimensec;
++  q->st_ctime = p32->st_ctime;
++  q->st_ctimensec = p32->st_ctimensec;
++  q->st_size = p32->st_size;
++  q->st_blocks = p32->st_blocks;
++  q->st_blksize = p32->st_blksize;
++  q->st_flags = p32->st_flags;
++  q->st_gen = p32->st_gen;
++  memcpy (q->__unused1, p32->__unused1, sizeof (p32->__unused1));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statconv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statconv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statconv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statconv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,46 @@
++/* Convert between different 'struct stat' formats.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++
++/* Convert a 'struct stat' to 'struct stat64'.  */
++static inline void
++stat_to_stat64 (const struct stat *p32, struct stat64 *p64)
++{
++  p64->st_dev = p32->st_dev;
++  p64->st_ino = p32->st_ino;
++  p64->st_mode = p32->st_mode;
++  p64->st_nlink = p32->st_nlink;
++  p64->st_uid = p32->st_uid;
++  p64->st_gid = p32->st_gid;
++  p64->st_rdev = p32->st_rdev;
++  p64->st_atime = p32->st_atime;
++  p64->st_atimensec = p32->st_atimensec;
++  p64->st_mtime = p32->st_mtime;
++  p64->st_mtimensec = p32->st_mtimensec;
++  p64->st_ctime = p32->st_ctime;
++  p64->st_ctimensec = p32->st_ctimensec;
++  p64->st_size = p32->st_size;
++  p64->st_blocks = p32->st_blocks;
++  p64->st_blksize = p32->st_blksize;
++  p64->st_flags = p32->st_flags;
++  p64->st_gen = p32->st_gen;
++  memcpy (p64->__unused1, p32->__unused1, sizeof (p32->__unused1));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,38 @@
++/* Return information about the filesystem on which FILE resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statfs.h>
++
++#include "statfsconv.c"
++
++/* Return information about the filesystem on which FILE resides.  */
++int
++statfs64 (const char *file, struct statfs64 *buf)
++{
++  struct statfs buf32;
++
++  if (__statfs (file, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statfs64'.  */
++  statfs_to_statfs64 (&buf32, buf);
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,49 @@
++/* Convert between different 'struct statfs' formats.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++
++/* Convert a 'struct statfs' to 'struct statfs64'.  */
++static inline void
++statfs_to_statfs64 (const struct statfs *p32, struct statfs64 *p64)
++{
++  p64->__unused1 = p32->__unused1;
++  p64->f_bsize = p32->f_bsize;
++  p64->f_iosize = p32->f_iosize;
++  p64->f_blocks = p32->f_blocks;
++  p64->f_bfree = p32->f_bfree;
++  p64->f_bavail = p32->f_bavail;
++  p64->f_files = p32->f_files;
++  p64->f_ffree = p32->f_ffree;
++  p64->f_fsid = p32->f_fsid;
++  p64->f_owner = p32->f_owner;
++  p64->f_type = p32->f_type;
++  p64->f_flags = p32->f_flags;
++  p64->f_syncwrites = p32->f_syncwrites;
++  p64->f_asyncwrites = p32->f_asyncwrites;
++  memcpy (p64->f_fstypename, p32->f_fstypename, sizeof (p32->f_fstypename));
++  memcpy (p64->f_mntonname, p32->f_mntonname, sizeof (p32->f_mntonname));
++  p64->f_syncreads = p32->f_syncreads;
++  p64->f_asyncreads = p32->f_asyncreads;
++  p64->__unused2 = p32->__unused2;
++  memcpy (p64->f_mntfromname, p32->f_mntfromname, sizeof (p32->f_mntfromname));
++  p64->__unused3 = p32->__unused3;
++  memcpy (p64->__unused4, p32->__unused4, sizeof (p32->__unused4));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,41 @@
++/* Return information about the filesystem on which FILE resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statvfs.h>
++#include <sys/statfs.h>
++
++#include "statvfsconv.c"
++
++/* Return information about the filesystem on which FILE resides.  */
++int
++__statvfs64 (const char *file, struct statvfs64 *buf)
++{
++  struct statfs buf32;
++
++  if (__statfs (file, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
++  statfs_to_statvfs64 (&buf32, buf);
++
++  return 0;
++}
++
++weak_alias (__statvfs64, statvfs64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,40 @@
++/* Return information about the filesystem on which FILE resides.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/statvfs.h>
++#include <sys/statfs.h>
++
++#include "statvfsconv.c"
++
++/* Return information about the filesystem on which FILE resides.  */
++int
++statvfs (const char *file, struct statvfs *buf)
++{
++  struct statfs buf32;
++
++  if (__statfs (file, &buf32) < 0)
++    return -1;
++
++  /* Convert a 'struct statfs' to 'struct statvfs'.  */
++  statfs_to_statvfs (&buf32, buf);
++
++  return 0;
++}
++libc_hidden_weak (statvfs)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfsconv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfsconv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfsconv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfsconv.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,79 @@
++/* Convert between 'struct statfs' and 'struct statvfs', 'struct statvfs64'.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++#include <sys/mount.h>
++#include <sys/syslimits.h>
++
++/* Convert a 'struct statfs' to 'struct statvfs'.  */
++static inline void
++statfs_to_statvfs (const struct statfs *p32, struct statvfs *p)
++{
++  /* FIXME: What is the difference between f_bsize and f_frsize in
++     'struct statvfs64'?  */
++  p->f_bsize = p32->f_bsize;
++  p->f_frsize = p32->f_bsize;
++
++  p->f_blocks = p32->f_blocks;
++  p->f_bfree = p32->f_bfree;
++  p->f_bavail = p32->f_bavail;
++
++  p->f_files = p32->f_files;
++  p->f_ffree = p32->f_ffree;
++  p->f_favail = p32->f_ffree;	/* Hmm.  May be filesystem dependent.  */
++
++  p->f_fsid = p32->f_fsid;
++  p->f_flag =
++    (p32->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
++    | (p32->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
++    | (p32->f_flags & MNT_NODEV ? ST_NODEV : 0)
++    | (p32->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
++    | (p32->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0);
++  p->f_namemax = PATH_MAX;	/* Hmm.  May be filesystem dependent.  */
++  memset (p->f_spare, '\0', sizeof (p->f_spare));
++}
++
++/* Convert a 'struct statfs' to 'struct statvfs64'.  */
++static inline void
++statfs_to_statvfs64 (const struct statfs *p32, struct statvfs64 *p)
++{
++  /* FIXME: What is the difference between f_bsize and f_frsize in
++     'struct statvfs64'?  */
++  p->f_bsize = p32->f_bsize;
++  p->f_frsize = p32->f_bsize;
++
++  p->f_blocks = p32->f_blocks;
++  p->f_bfree = p32->f_bfree;
++  p->f_bavail = p32->f_bavail;
++
++  p->f_files = p32->f_files;
++  p->f_ffree = p32->f_ffree;
++  p->f_favail = p32->f_ffree;	/* Hmm.  May be filesystem dependent.  */
++
++  p->f_fsid = p32->f_fsid;
++  p->f_flag =
++    (p32->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
++    | (p32->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
++    | (p32->f_flags & MNT_NODEV ? ST_NODEV : 0)
++    | (p32->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
++    | (p32->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0);
++  p->f_namemax = PATH_MAX;	/* Hmm.  May be filesystem dependent.  */
++  memset (p->f_spare, '\0', sizeof (p->f_spare));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,24 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_KD_H
++#define _SYS_KD_H	1
++
++#include <sys/consio.h>
++
++#endif	/* sys/kd.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ktrace.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ktrace.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ktrace.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ktrace.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,184 @@
++/* 'ktrace' system call debugger support interface.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_KTRACE_H
++#define _SYS_KTRACE_H	1
++
++#include <features.h>
++
++/* Define MAXCOMLEN.  */
++#include <sys/param.h>
++
++/* Define register_t.  */
++#include <sys/types.h>
++
++/* Define __sighandler_t, __sigset_t.  */
++#include <signal.h>
++
++/* Define 'struct timeval'.  */
++#define __need_timeval
++#include <bits/time.h>
++
++
++/* Structure of records written to the system call trace log file.
++   A header of type ktr_header, followed by a variable length buffer.  */
++
++struct ktr_header
++  {
++    int ktr_len;			/* Length of ktr_buf.  */
++    short ktr_type;			/* Trace record type.  */
++    __pid_t ktr_pid;			/* Process id.  */
++    char ktr_comm[MAXCOMLEN+1];		/* Command name.  */
++    struct timeval ktr_time;		/* Timestamp.  */
++    void *ktr_buf;			/* Pointer to ktr_len bytes.
++					   (Ignore in the log file.)  */
++  };
++
++/* Possible values of ktr_type.  */
++enum
++{
++  KTR_SYSCALL = 1,		/* System call record.  */
++#define KTR_SYSCALL KTR_SYSCALL
++  KTR_SYSRET = 2,		/* Return from system call record.  */
++#define KTR_SYSRET KTR_SYSRET
++  KTR_NAMEI = 3,		/* Namei record.  */
++#define KTR_NAMEI KTR_NAMEI
++  KTR_GENIO = 4,		/* Generic process I/O record.  */
++#define KTR_GENIO KTR_GENIO
++  KTR_PSIG = 5,			/* Processed signal record.  */
++#define KTR_PSIG KTR_PSIG
++  KTR_CSW = 6,			/* Context switch record.  */
++#define KTR_CSW KTR_CSW
++  KTR_USER = 7			/* User defined record.  */
++#define KTR_USER KTR_USER
++};
++
++/* ktr_buf for KTR_SYSCALL: System call record.  */
++struct ktr_syscall
++  {
++    short ktr_code;			/* Syscall number.  */
++    short ktr_narg;			/* Number of arguments.  */
++    register_t ktr_args __flexarr;
++  };
++
++/* ktr_buf for KTR_SYSRET: Return from system call record.  */
++struct ktr_sysret
++  {
++    short ktr_code;			/* Syscall number.  */
++    short ktr_eosys;
++    int ktr_error;
++    register_t ktr_retval;
++  };
++
++/* ktr_buf for KTR_NAMEI: Namei record.
++   It contains the pathname.  */
++
++/* ktr_buf for KTR_GENIO: Generic process I/O record.  */
++enum uio_rw
++{
++  UIO_READ,
++  UIO_WRITE
++};
++struct ktr_genio
++  {
++    int ktr_fd;				/* File descriptor.  */
++    enum uio_rw ktr_rw;			/* I/O direction.  */
++    char ktr_data __flexarr;		/* Data successfully read/written.  */
++  };
++
++/* ktr_buf for KTR_PSIG: Processed signal record.  */
++struct ktr_psig
++  {
++    int signo;
++    __sighandler_t action;
++    int code;
++    sigset_t mask;
++  };
++
++/* ktr_buf for KTR_CSW: Context switch record.  */
++struct ktr_csw
++  {
++    int out;				/* 1 if switch out, 0 if switch in.  */
++    int user;				/* 1 if usermode, 0 if kernel mode.  */
++  };
++
++/* Maximum size of ktr_buf for KTR_USER: User defined record.  */
++#define KTR_USER_MAXLEN	2048
++
++
++/* The OP_FLAGS argument of ktrace() consists of an operation and
++   some flags.  This macro extracts the operation.  */
++#define KTROP(op_flags) ((op_flags) & 3)
++
++/* Possible values for operation in OP_FLAGS argument of ktrace().  */
++enum
++{
++  KTROP_SET = 0,			/* Set trace facilities.  */
++#define KTROP_SET KTROP_SET
++  KTROP_CLEAR = 1,			/* Clear trace facilities.  */
++#define KTROP_CLEAR KTROP_CLEAR
++  KTROP_CLEARFILE = 2			/* Stop all tracing to file.  */
++#define KTROP_CLEARFILE KTROP_CLEARFILE
++};
++
++/* Possible flags to be ORed into OP_FLAGS argument of ktrace().  */
++enum
++{
++  KTRFLAG_DESCEND = 4	/* Perform operation on all children processes too.  */
++#define KTRFLAG_DESCEND KTRFLAG_DESCEND
++};
++
++
++/* The FAC is an OR of some trace facilities.  */
++enum
++{
++  KTRFAC_SYSCALL = 1 << KTR_SYSCALL,	/* Trace system calls.  */
++#define KTRFAC_SYSCALL KTRFAC_SYSCALL
++  KTRFAC_SYSRET = 1 << KTR_SYSRET,	/* Trace system call returns.  */
++#define KTRFAC_SYSRET KTRFAC_SYSRET
++  KTRFAC_NAMEI = 1 << KTR_NAMEI,	/* Trace namei operations.  */
++#define KTRFAC_NAMEI KTRFAC_NAMEI
++  KTRFAC_GENIO = 1 << KTR_GENIO,	/* Trace generic process I/O.  */
++#define KTRFAC_GENIO KTRFAC_GENIO
++  KTRFAC_PSIG = 1 << KTR_PSIG,		/* Trace signal processing.  */
++#define KTRFAC_PSIG KTRFAC_PSIG
++  KTRFAC_CSW = 1 << KTR_CSW,		/* Trace context switches.  */
++#define KTRFAC_CSW KTRFAC_CSW
++  KTRFAC_USER = 1 << KTR_USER,		/* Trace user defined records.  */
++#define KTRFAC_USER KTRFAC_USER
++  KTRFAC_INHERIT = 1 << 30	    /* Inherit trace flags to new children.  */
++#define KTRFAC_INHERIT KTRFAC_INHERIT
++};
++
++
++__BEGIN_DECLS
++
++/* Enable system call tracing for the process PID.
++   Trace records will be written to TRACEFILE; this file is truncated.  If
++   OP_FLAGS contains KTROP_CLEAR, TRACEFILE may be NULL.
++   FAC contains the facilities to switch on or off.  */
++extern int ktrace (__const char *__tracefile, int __op_flags, int __fac,
++		   __pid_t pid) __THROW;
++
++/* Write a user defined record to the current process' trace log file.  */
++extern int utrace (__const void *__buf, size_t __len) __THROW;
++
++__END_DECLS
++
++#endif /* _SYS_KTRACE_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,439 @@
++/* Header file for handling mounted filesystems.  FreeBSD version.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_MOUNT_H
++#define _SYS_MOUNT_H	1
++
++#include <features.h>
++
++/* Retrieving the list of mounted filesystems.  */
++
++#include <bits/statfs.h>
++
++#include <sys/ucred.h>
++#include <sys/queue.h>
++
++/*
++ * File identifier.
++ * These are unique per filesystem on a single machine.
++ */
++#define	MAXFIDSZ	16
++
++struct fid {
++	u_short		fid_len;		/* length of data in bytes */
++	u_short		fid_reserved;		/* force longword alignment */
++	char		fid_data[MAXFIDSZ];	/* data (variable length) */
++};
++
++/*
++ * filesystem statistics
++ */
++#define	MFSNAMELEN	16		/* length of type name including null */
++#define	MNAMELEN	88		/* size of on/from name bufs */
++#define	STATFS_VERSION	0x20030518	/* current version number */
++
++
++/*
++ * User specifiable flags.
++ */
++#define	MNT_RDONLY	0x00000001	/* read only filesystem */
++#define	MNT_SYNCHRONOUS	0x00000002	/* filesystem written synchronously */
++#define	MNT_NOEXEC	0x00000004	/* can't exec from filesystem */
++#define	MNT_NOSUID	0x00000008	/* don't honor setuid bits on fs */
++#define	MNT_NODEV	0x00000010	/* don't interpret special files */
++#define	MNT_UNION	0x00000020	/* union with underlying filesystem */
++#define	MNT_ASYNC	0x00000040	/* filesystem written asynchronously */
++#define	MNT_SUIDDIR	0x00100000	/* special handling of SUID on dirs */
++#define	MNT_SOFTDEP	0x00200000	/* soft updates being done */
++#define	MNT_NOSYMFOLLOW	0x00400000	/* do not follow symlinks */
++#define	MNT_JAILDEVFS	0x02000000	/* jail-friendly DEVFS behaviour */
++#define	MNT_MULTILABEL	0x04000000	/* MAC support for individual objects */
++#define	MNT_ACLS	0x08000000	/* ACL support enabled */
++#define	MNT_NOATIME	0x10000000	/* disable update of file access time */
++#define	MNT_NOCLUSTERR	0x40000000	/* disable cluster read */
++#define	MNT_NOCLUSTERW	0x80000000	/* disable cluster write */
++
++/*
++ * NFS export related mount flags.
++ */
++#define	MNT_EXRDONLY	0x00000080	/* exported read only */
++#define	MNT_EXPORTED	0x00000100	/* filesystem is exported */
++#define	MNT_DEFEXPORTED	0x00000200	/* exported to the world */
++#define	MNT_EXPORTANON	0x00000400	/* use anon uid mapping for everyone */
++#define	MNT_EXKERB	0x00000800	/* exported with Kerberos uid mapping */
++#define	MNT_EXPUBLIC	0x20000000	/* public export (WebNFS) */
++
++/*
++ * Flags set by internal operations,
++ * but visible to the user.
++ * XXX some of these are not quite right.. (I've never seen the root flag set)
++ */
++#define	MNT_LOCAL	0x00001000	/* filesystem is stored locally */
++#define	MNT_QUOTA	0x00002000	/* quotas are enabled on filesystem */
++#define	MNT_ROOTFS	0x00004000	/* identifies the root filesystem */
++#define	MNT_USER	0x00008000	/* mounted by a user */
++#define	MNT_IGNORE	0x00800000	/* do not show entry in df */
++
++/*
++ * Mask of flags that are visible to statfs().
++ * XXX I think that this could now become (~(MNT_CMDFLAGS))
++ * but the 'mount' program may need changing to handle this.
++ */
++#define	MNT_VISFLAGMASK	(MNT_RDONLY	| MNT_SYNCHRONOUS | MNT_NOEXEC	| \
++			MNT_NOSUID	| MNT_NODEV	| MNT_UNION	| \
++			MNT_ASYNC	| MNT_EXRDONLY	| MNT_EXPORTED	| \
++			MNT_DEFEXPORTED	| MNT_EXPORTANON| MNT_EXKERB	| \
++			MNT_LOCAL	| MNT_USER	| MNT_QUOTA	| \
++			MNT_ROOTFS	| MNT_NOATIME	| MNT_NOCLUSTERR| \
++			MNT_NOCLUSTERW	| MNT_SUIDDIR	| MNT_SOFTDEP	| \
++			MNT_IGNORE	| MNT_EXPUBLIC	| MNT_NOSYMFOLLOW | \
++			MNT_JAILDEVFS	| MNT_MULTILABEL | MNT_ACLS)
++
++/* Mask of flags that can be updated. */
++#define	MNT_UPDATEMASK (MNT_NOSUID	| MNT_NOEXEC	| MNT_NODEV	| \
++			MNT_SYNCHRONOUS	| MNT_UNION	| MNT_ASYNC	| \
++			MNT_NOATIME | \
++			MNT_NOSYMFOLLOW	| MNT_IGNORE	| MNT_JAILDEVFS	| \
++			MNT_NOCLUSTERR	| MNT_NOCLUSTERW | MNT_SUIDDIR	| \
++			MNT_ACLS	| MNT_USER)
++
++/*
++ * External filesystem command modifier flags.
++ * Unmount can use the MNT_FORCE flag.
++ * XXX These are not STATES and really should be somewhere else.
++ */
++#define	MNT_UPDATE	0x00010000	/* not a real mount, just an update */
++#define	MNT_DELEXPORT	0x00020000	/* delete export host lists */
++#define	MNT_RELOAD	0x00040000	/* reload filesystem data */
++#define	MNT_FORCE	0x00080000	/* force unmount or readonly change */
++#define	MNT_SNAPSHOT	0x01000000	/* snapshot the filesystem */
++#define	MNT_BYFSID	0x08000000	/* specify filesystem by ID. */
++#define MNT_CMDFLAGS   (MNT_UPDATE	| MNT_DELEXPORT	| MNT_RELOAD	| \
++			MNT_FORCE	| MNT_SNAPSHOT	| MNT_BYFSID)
++/*
++ * Internal filesystem control flags stored in mnt_kern_flag.
++ *
++ * MNTK_UNMOUNT locks the mount entry so that name lookup cannot proceed
++ * past the mount point.  This keeps the subtree stable during mounts
++ * and unmounts.
++ *
++ * MNTK_UNMOUNTF permits filesystems to detect a forced unmount while
++ * dounmount() is still waiting to lock the mountpoint. This allows
++ * the filesystem to cancel operations that might otherwise deadlock
++ * with the unmount attempt (used by NFS).
++ */
++#define MNTK_UNMOUNTF	0x00000001	/* forced unmount in progress */
++#define MNTK_UNMOUNT	0x01000000	/* unmount in progress */
++#define	MNTK_MWAIT	0x02000000	/* waiting for unmount to finish */
++#define MNTK_WANTRDWR	0x04000000	/* upgrade to read/write requested */
++#define	MNTK_SUSPEND	0x08000000	/* request write suspension */
++#define	MNTK_SUSPENDED	0x10000000	/* write operations are suspended */
++
++/*
++ * Sysctl CTL_VFS definitions.
++ *
++ * Second level identifier specifies which filesystem. Second level
++ * identifier VFS_VFSCONF returns information about all filesystems.
++ * Second level identifier VFS_GENERIC is non-terminal.
++ */
++#define	VFS_VFSCONF		0	/* get configured filesystems */
++#define	VFS_GENERIC		0	/* generic filesystem information */
++/*
++ * Third level identifiers for VFS_GENERIC are given below; third
++ * level identifiers for specific filesystems are given in their
++ * mount specific header files.
++ */
++#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
++#define VFS_CONF	2	/* struct: vfsconf for filesystem given
++				   as next argument */
++
++/*
++ * Flags for various system call interfaces.
++ *
++ * waitfor flags to vfs_sync() and getfsstat()
++ */
++#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
++#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
++#define MNT_LAZY	3	/* push data not written by filesystem syncer */
++
++/*
++ * Generic file handle
++ */
++struct fhandle {
++	fsid_t	fh_fsid;	/* Filesystem id of mount point */
++	struct	fid fh_fid;	/* Filesys specific id */
++};
++typedef struct fhandle	fhandle_t;
++
++/*
++ * Export arguments for local filesystem mount calls.
++ */
++struct export_args {
++	int	ex_flags;		/* export related flags */
++	uid_t	ex_root;		/* mapping for root uid */
++	struct	xucred ex_anon;		/* mapping for anonymous user */
++	struct	sockaddr *ex_addr;	/* net address to which exported */
++	u_char	ex_addrlen;		/* and the net address length */
++	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
++	u_char	ex_masklen;		/* and the smask length */
++	char	*ex_indexfile;		/* index file for WebNFS URLs */
++};
++
++/*
++ * Structure holding information for a publicly exported filesystem
++ * (WebNFS). Currently the specs allow just for one such filesystem.
++ */
++struct nfs_public {
++	int		np_valid;	/* Do we hold valid information */
++	fhandle_t	np_handle;	/* Filehandle for pub fs (internal) */
++	struct mount	*np_mount;	/* Mountpoint of exported fs */
++	char		*np_index;	/* Index file */
++};
++
++/*
++ * Filesystem configuration information. One of these exists for each
++ * type of filesystem supported by the kernel. These are searched at
++ * mount time to identify the requested filesystem.
++ *
++ * XXX: Never change the first two arguments!
++ */
++struct vfsconf {
++	u_int	vfc_version;		/* ABI version number */
++	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
++	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
++	int	vfc_typenum;		/* historic filesystem type number */
++	int	vfc_refcount;		/* number mounted of this type */
++	int	vfc_flags;		/* permanent flags */
++	struct	vfsoptdecl *vfc_opts;	/* mount options */
++	TAILQ_ENTRY(vfsconf) vfc_list;	/* list of vfscons */
++};
++
++/* Userland version of the struct vfsconf. */
++struct xvfsconf {
++	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
++	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
++	int	vfc_typenum;		/* historic filesystem type number */
++	int	vfc_refcount;		/* number mounted of this type */
++	int	vfc_flags;		/* permanent flags */
++	struct	vfsconf *vfc_next;	/* next in list */
++};
++
++#ifndef BURN_BRIDGES
++struct ovfsconf {
++	void	*vfc_vfsops;
++	char	vfc_name[32];
++	int	vfc_index;
++	int	vfc_refcount;
++	int	vfc_flags;
++};
++#endif
++
++/*
++ * NB: these flags refer to IMPLEMENTATION properties, not properties of
++ * any actual mounts; i.e., it does not make sense to change the flags.
++ */
++#define	VFCF_STATIC	0x00010000	/* statically compiled into kernel */
++#define	VFCF_NETWORK	0x00020000	/* may get data over the network */
++#define	VFCF_READONLY	0x00040000	/* writes are not implemented */
++#define VFCF_SYNTHETIC	0x00080000	/* data does not represent real files */
++#define	VFCF_LOOPBACK	0x00100000	/* aliases some other mounted FS */
++#define	VFCF_UNICODE	0x00200000	/* stores file names as Unicode*/
++
++typedef u_int32_t fsctlop_t;
++
++struct vfsidctl {
++	int		vc_vers;	/* should be VFSIDCTL_VERS1 (below) */
++	fsid_t		vc_fsid;	/* fsid to operate on. */
++	char		vc_fstypename[MFSNAMELEN];
++					/* type of fs 'nfs' or '*' */
++	fsctlop_t	vc_op;		/* operation VFS_CTL_* (below) */
++	void		*vc_ptr;	/* pointer to data structure. */
++	size_t		vc_len;		/* sizeof said structure. */
++	u_int32_t	vc_spare[12];	/* spare (must be zero). */
++};
++
++/* vfsidctl API version. */
++#define VFS_CTL_VERS1	0x01
++
++/*
++ * New style VFS sysctls, do not reuse/conflict with the namespace for
++ * private sysctls.
++ * All "global" sysctl ops have the 33rd bit set:
++ * 0x...1....
++ * Private sysctl ops should have the 33rd bit unset.
++ */
++#define VFS_CTL_QUERY	0x00010001	/* anything wrong? (vfsquery) */
++#define VFS_CTL_TIMEO	0x00010002	/* set timeout for vfs notification */
++#define VFS_CTL_NOLOCKS	0x00010003	/* disable file locking */
++
++struct vfsquery {
++	u_int32_t	vq_flags;
++	u_int32_t	vq_spare[31];
++};
++
++/* vfsquery flags */
++#define VQ_NOTRESP	0x0001	/* server down */
++#define VQ_NEEDAUTH	0x0002	/* server bad auth */
++#define VQ_LOWDISK	0x0004	/* we're low on space */
++#define VQ_MOUNT	0x0008	/* new filesystem arrived */
++#define VQ_UNMOUNT	0x0010	/* filesystem has left */
++#define VQ_DEAD		0x0020	/* filesystem is dead, needs force unmount */
++#define VQ_ASSIST	0x0040	/* filesystem needs assistance from external
++				   program */
++#define VQ_NOTRESPLOCK	0x0080	/* server lockd down */
++#define VQ_FLAG0100	0x0100	/* placeholder */
++#define VQ_FLAG0200	0x0200	/* placeholder */
++#define VQ_FLAG0400	0x0400	/* placeholder */
++#define VQ_FLAG0800	0x0800	/* placeholder */
++#define VQ_FLAG1000	0x1000	/* placeholder */
++#define VQ_FLAG2000	0x2000	/* placeholder */
++#define VQ_FLAG4000	0x4000	/* placeholder */
++#define VQ_FLAG8000	0x8000	/* placeholder */
++
++
++struct iovec;
++struct uio;
++
++
++#include <sys/cdefs.h>
++
++struct stat;
++
++__BEGIN_DECLS
++
++/* Mounting and unmounting filesystems.  */
++int	fhopen(const struct fhandle *, int);
++int	fhstat(const struct fhandle *, struct stat *);
++int	fhstatfs(const struct fhandle *, struct statfs *);
++int	fstatfs(int, struct statfs *);
++int	getfh(const char *, fhandle_t *);
++int	getfsstat(struct statfs *, long, int);
++int	getmntinfo(struct statfs **, int);
++int	lgetfh(const char *, fhandle_t *);
++int	mount(const char *, const char *, int, void *);
++int	nmount(struct iovec *, unsigned int, int);
++int	statfs(const char *, struct statfs *);
++int	unmount(const char *, int);
++
++/* C library stuff */
++int	getvfsbyname(const char *, struct xvfsconf *);
++
++/* getfsstat() appears in BSD 4.4.  A variant of this API is found on OSF/1,
++   but on that system the user also needs to include <sys/fs_types.h>.  */
++
++#ifndef __USE_FILE_OFFSET64
++extern int getfsstat (struct statfs *__buf, long __bufsize,
++		      int __flags) __THROW;
++#else
++# ifdef __REDIRECT
++extern int __REDIRECT (getfsstat,
++		       (struct statfs *__buf, long __bufsize, int __flags)
++			 __THROW,
++		       getfsstat64);
++# else
++#  define getfsstat getfsstat64
++# endif
++#endif
++#ifdef __USE_LARGEFILE64
++extern int getfsstat64 (struct statfs64 *__buf, long __bufsize,
++			int __flags) __THROW;
++#endif
++
++#ifdef _LIBC
++extern int __getfsstat (struct statfs *__buf, long __bufsize, int __flags);
++extern int __getfsstat64 (struct statfs64 *__buf, long __bufsize, int __flags);
++#endif
++
++/* getmntinfo() appears in BSD 4.4.  */
++
++#ifndef __USE_FILE_OFFSET64
++extern int getmntinfo (struct statfs **__mntbufp, int __flags) __THROW;
++#else
++# ifdef __REDIRECT
++extern int __REDIRECT (getmntinfo,
++		       (struct statfs **__mntbufp, int __flags) __THROW,
++		       getmntinfo64);
++# else
++#  define getmntinfo getmntinfo64
++# endif
++#endif
++#ifdef __USE_LARGEFILE64
++extern int getmntinfo64 (struct statfs64 **__mntbufp, int __flags) __THROW;
++#endif
++
++#ifdef _LIBC
++extern int __getmntinfo (struct statfs **__mntbufp, int __flags);
++#endif
++
++__END_DECLS
++
++
++/* Opening files on specified mounted filesystems.
++   These system calls are reserved to the superuser, for security reasons.  */
++
++#include <sys/stat.h>
++
++__BEGIN_DECLS
++
++/* Return in *FHP the file handle corresponding to the file or directory
++   PATH.  */
++extern int getfh (__const char *__path, fhandle_t *__fhp) __THROW;
++
++/* Open a file handle *FHP, using the open() like FLAGS.  Return the
++   new file descriptor.  */
++extern int fhopen (__const fhandle_t *__fhp, int __flags) __THROW;
++
++/* Get file attributes for the file whose handle is *FHP, and return them
++   in *BUF.  Like fhopen + fstat + close.  */
++#ifndef __USE_FILE_OFFSET64
++extern int fhstat (__const fhandle_t *__fhp, struct stat *__buf) __THROW;
++#else
++# ifdef __REDIRECT
++extern int __REDIRECT (fhstat,
++		       (__const fhandle_t *__fhp, struct stat *__buf) __THROW,
++		       fhstat64);
++# else
++#  define fhstat fhstat64
++# endif
++#endif
++#ifdef __USE_LARGEFILE64
++extern int fhstat64 (__const fhandle_t *__fhp, struct stat64 *__buf) __THROW;
++#endif
++
++/* Return information about the filesystem on which the file resides whose
++   handle is *FHP.  Like fhopen + fstatfs + close.  */
++#ifndef __USE_FILE_OFFSET64
++extern int fhstatfs (__const fhandle_t *__fhp, struct statfs *__buf) __THROW;
++#else
++# ifdef __REDIRECT
++extern int __REDIRECT (fhstatfs,
++		       (__const fhandle_t *__fhp, struct statfs *__buf) __THROW,
++		       fhstatfs64);
++# else
++#  define fhstatfs fhstatfs64
++# endif
++#endif
++#ifdef __USE_LARGEFILE64
++extern int fhstatfs64 (__const fhandle_t *__fhp,
++		       struct statfs64 *__buf) __THROW;
++#endif
++
++__END_DECLS
++
++#endif /* _SYS_MOUNT_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,236 @@
++/* Copyright (C) 1995,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_PARAM_H
++#define _SYS_PARAM_H	1
++
++#include <limits.h>
++#include <sys/syslimits.h>
++
++#ifndef NULL
++#define NULL 0
++#endif
++
++/*
++ * __FreeBSD_version numbers are documented in the Porter's Handbook.
++ * If you bump the version for any reason, you should update the documentation
++ * there.
++ * Currently this lives here:
++ *
++ *      doc/en_US.ISO8859-1/books/porters-handbook/book.sgml
++ *
++ * scheme is:  <major><two digit minor><0 if release branch, otherwise 1>xx
++ */
++#include <osreldate.h>
++
++/* Some inet code expects that this file defines the 'u_int32_t' type.  */
++#include <sys/types.h>
++
++/*
++ * Machine-independent constants (some used in following include files).
++ * Redefined constants are from POSIX 1003.1 limits file.
++ *
++ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
++ * MAXLOGNAME should be == UT_NAMESIZE+1 (see <utmp.h>)
++ */
++
++#define MAXCOMLEN       19              /* max command name remembered */
++#define MAXINTERP       32              /* max interpreter file name length */
++#define MAXLOGNAME      17              /* max login name length (incl. NUL) */
++#define MAXUPRC         CHILD_MAX       /* max simultaneous processes */
++#define NCARGS          ARG_MAX         /* max bytes for an exec function */
++#define NGROUPS         NGROUPS_MAX     /* max number groups */
++#define NOGROUP         65535           /* marker for empty group set member */
++#define MAXHOSTNAMELEN  256             /* max hostname size */
++#define SPECNAMELEN     63              /* max length of devicename */
++
++/* BSD names for some <limits.h> values.  */
++
++#define	NBBY		CHAR_BIT
++#ifndef	NGROUPS
++# define NGROUPS	NGROUPS_MAX
++#endif
++#define	MAXSYMLINKS	32
++#define	CANBSIZ		MAX_CANON
++#define	NCARGS		ARG_MAX
++#define MAXPATHLEN	PATH_MAX
++
++/* The following is not really correct but it is a value we used for a
++   long time and which seems to be usable.  People should not use NOFILE
++   anyway.  */
++#define NOFILE		OPEN_MAX
++
++/* Bit map related macros.  */
++#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
++#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
++#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
++#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
++
++/* Macros for counting and rounding.  */
++#ifndef howmany
++# define howmany(x, y)	(((x) + ((y) - 1)) / (y))
++#endif
++#ifdef __GNUC__
++# define roundup(x, y)	(__builtin_constant_p (y) && powerof2 (y)	      \
++			 ? (((x) + (y) - 1) & ~((y) - 1))		      \
++			 : ((((x) + ((y) - 1)) / (y)) * (y)))
++#else
++# define roundup(x, y)	((((x) + ((y) - 1)) / (y)) * (y))
++#endif
++#define powerof2(x)	((((x) - 1) & (x)) == 0)
++
++/* Macros for min/max.  */
++#define	MIN(a,b) (((a)<(b))?(a):(b))
++#define	MAX(a,b) (((a)>(b))?(a):(b))
++
++/* Machine type dependent parameters. */
++#include <machine/param.h>
++				 
++#ifndef DEV_BSHIFT
++#define DEV_BSHIFT	9               /* log2(DEV_BSIZE) */
++#endif
++#define DEV_BSIZE	(1<<DEV_BSHIFT)
++
++#ifndef BLKDEV_IOSIZE
++#define BLKDEV_IOSIZE	PAGE_SIZE        /* default block device I/O size */
++#endif
++#ifndef DFLTPHYS
++#define DFLTPHYS	(64 * 1024)     /* default max raw I/O transfer size */
++#endif
++#ifndef MAXPHYS
++#define MAXPHYS		(128 * 1024)    /* max raw I/O transfer size */
++#endif
++#ifndef MAXDUMPPGS
++#define MAXDUMPPGS	(DFLTPHYS/PAGE_SIZE)
++#ifndef MAXHOSTNAMELEN
++#define MAXHOSTNAMELEN 64 /* XXX */
++#endif /* No MAXHOSTNAMELEN.  */
++
++/*
++ * Constants related to network buffer management.
++ * MCLBYTES must be no larger than PAGE_SIZE.
++ */
++#ifndef	MSIZE
++#define MSIZE		256		/* size of an mbuf */
++#endif	/* MSIZE */
++
++#ifndef	MCLSHIFT
++#define MCLSHIFT	11		/* convert bytes to mbuf clusters */
++#endif	/* MCLSHIFT */
++
++#define MCLBYTES	(1 << MCLSHIFT)	/* size of an mbuf cluster */
++
++/*
++ * Some macros for units conversion
++ */
++
++/* clicks to bytes */
++#ifndef ctob
++#define ctob(x)	((x)<<PAGE_SHIFT)
++#endif
++
++/* bytes to clicks */
++#ifndef btoc
++#define btoc(x)	(((vm_offset_t)(x)+PAGE_MASK)>>PAGE_SHIFT)
++#endif
++
++/*
++ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
++ * want to shift an unsigned type to avoid sign extension and we don't
++ * want to widen `bytes' unnecessarily.  Assume that the result fits in
++ * a daddr_t.
++ */
++#ifndef btodb
++#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
++	(sizeof (bytes) > sizeof(long) \
++	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
++	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
++#endif
++
++#ifndef dbtob
++#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
++	((off_t)(db) << DEV_BSHIFT)
++#endif
++
++#endif /* _NO_NAMESPACE_POLLUTION */
++
++#define	PRIMASK	0x0ff
++#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
++#define	PDROP	0x200	/* OR'd with pri to stop re-entry of interlock mutex */
++
++#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
++
++#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
++
++#define	NODEV	(dev_t)(-1)	/* non-existent device */
++
++#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
++#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
++				/* Data chars/clist. */
++#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
++#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
++
++/*
++ * File system parameters and macros.
++ *
++ * MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
++ *		per block.  MAXBSIZE may be made larger without effecting
++ *		any existing filesystems as long as it does not exceed MAXPHYS,
++ *		and may be made smaller at the risk of not being able to use
++ *		filesystems which require a block size exceeding MAXBSIZE.
++ *
++ * BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
++ *		minimum KVM memory reservation the kernel is willing to make.
++ *		Filesystems can of course request smaller chunks.  Actual 
++ *		backing memory uses a chunk size of a page (PAGE_SIZE).
++ *
++ *		If you make BKVASIZE too small you risk seriously fragmenting
++ *		the buffer KVM map which may slow things down a bit.  If you
++ *		make it too big the kernel will not be able to optimally use 
++ *		the KVM memory reserved for the buffer cache and will wind 
++ *		up with too-few buffers.
++ *
++ *		The default is 16384, roughly 2x the block size used by a
++ *		normal UFS filesystem.
++ */
++#define MAXBSIZE	65536	/* must be power of 2 */
++#define BKVASIZE	16384	/* must be power of 2 */
++#define BKVAMASK	(BKVASIZE-1)
++
++/*
++ * Scale factor for scaled integers used to count %cpu time and load avgs.
++ *
++ * The number of CPU `tick's that map to a unique `%age' can be expressed
++ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
++ * can be calculated (assuming 32 bits) can be closely approximated using
++ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
++ *
++ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
++ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
++ */
++#define	FSHIFT	11		/* bits to right of fixed binary point */
++#define FSCALE	(1<<FSHIFT)
++
++#define dbtoc(db)			/* calculates devblks to pages */ \
++	((db + (ctodb(1) - 1)) >> (PAGE_SHIFT - DEV_BSHIFT))
++ 
++#define ctodb(db)			/* calculates pages to devblks */ \
++	((db) << (PAGE_SHIFT - DEV_BSHIFT))
++
++#endif	/* _SYS_PARAM_H_ */
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,132 @@
++/* `ptrace' debugger support interface.  FreeBSD version.
++   Copyright (C) 1996-1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_PTRACE_H
++#define _SYS_PTRACE_H	1
++
++#include <features.h>
++
++__BEGIN_DECLS
++
++/* Type of the REQUEST argument to `ptrace.'  */
++enum __ptrace_request
++{
++  /* Indicate that the process making this request should be traced.
++     All signals received by this process can be intercepted by its
++     parent, and its parent can use the other `ptrace' requests.  */
++  PTRACE_TRACEME = 0,
++#define PT_TRACE_ME PTRACE_TRACEME
++
++  /* Return the word in the process's text space at address ADDR.  */
++  PTRACE_PEEKTEXT = 1,
++#define PT_READ_I PTRACE_PEEKTEXT
++
++  /* Return the word in the process's data space at address ADDR.  */
++  PTRACE_PEEKDATA = 2,
++#define PT_READ_D PTRACE_PEEKDATA
++
++#if 1 /* NB: removed in FreeBSD 4.6 */
++  /* Return the word in the process's user area at offset ADDR.  */
++  PTRACE_PEEKUSER = 3,
++#define PT_READ_U PTRACE_PEEKUSER
++#endif
++
++  /* Write the word DATA into the process's text space at address ADDR.  */
++  PTRACE_POKETEXT = 4,
++#define PT_WRITE_I PTRACE_POKETEXT
++
++  /* Write the word DATA into the process's data space at address ADDR.  */
++  PTRACE_POKEDATA = 5,
++#define PT_WRITE_D PTRACE_POKEDATA
++
++#if 1 /* NB: removed in FreeBSD 4.6 */
++  /* Write the word DATA into the process's user area at offset ADDR.  */
++  PTRACE_POKEUSER = 6,
++#define PT_WRITE_U PTRACE_POKEUSER
++#endif
++
++  /* Continue the process.  */
++  PTRACE_CONT = 7,
++#define PT_CONTINUE PTRACE_CONT
++
++  /* Kill the process.  */
++  PTRACE_KILL = 8,
++#define PT_KILL PTRACE_KILL
++
++  /* Single step the process.
++     This is not supported on all machines.  */
++  PTRACE_SINGLESTEP = 9,
++#define PT_STEP PTRACE_SINGLESTEP
++
++  /* Attach to a process that is already running. */
++  PTRACE_ATTACH = 10,
++#define PT_ATTACH PTRACE_ATTACH
++
++  /* Detach from a process attached to with PTRACE_ATTACH.  */
++  PTRACE_DETACH = 11,
++#define PT_DETACH PTRACE_DETACH
++
++  /* CPU specific requests start here.  */
++  __PTRACE_FIRSTMACH = 32,
++
++  /* Get all general purpose registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_GETREGS,
++#define PT_GETREGS PTRACE_GETREGS
++
++  /* Set all general purpose registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_SETREGS,
++#define PT_SETREGS PTRACE_SETREGS
++
++  /* Get all floating point registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_GETFPREGS,
++#define PT_GETFPREGS PTRACE_GETFPREGS
++
++  /* Set all floating point registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_SETFPREGS,
++#define PT_SETFPREGS PTRACE_SETFPREGS
++
++  /* Get all debug registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_GETDBREGS,
++#define PT_GETDBREGS PTRACE_GETDBREGS
++
++  /* Set all debug registers used by a processes.
++     This is not supported on all machines.  */
++   PTRACE_SETDBREGS
++#define PT_SETDBREGS PTRACE_SETDBREGS
++};
++
++/* Perform process tracing functions.  REQUEST is one of the values
++   above, and determines the action to be taken.
++   For all requests except PTRACE_TRACEME, PID specifies the process to be
++   traced.
++
++   PID and the other arguments described above for the various requests should
++   appear (those that are used for the particular request) as:
++     pid_t PID, void *ADDR, int DATA, void *ADDR2
++   after REQUEST.  */
++extern int ptrace (enum __ptrace_request __request, ...) __THROW;
++
++__END_DECLS
++
++#endif /* _SYS_PTRACE_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,86 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/*
++ * Copyright (c) 1989, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
++ * $FreeBSD: src/sys/sys/unistd.h,v 1.22.2.1 2000/03/18 23:20:12 jasone Exp $
++ */
++
++#ifndef _SYS_RFORK_H
++#define _SYS_RFORK_H
++
++#include <features.h>
++
++/*
++ * rfork() options.
++ *
++ * XXX currently, operations without RFPROC set are not supported.
++ */
++#define RFNAMEG		(1<<0)  /* UNIMPL new plan9 `name space' */
++#define RFENVG		(1<<1)  /* UNIMPL copy plan9 `env space' */
++#define RFFDG		(1<<2)  /* copy fd table */
++#define RFNOTEG		(1<<3)  /* UNIMPL create new plan9 `note group' */
++#define RFPROC		(1<<4)  /* change child (else changes curproc) */
++#define RFMEM		(1<<5)  /* share `address space' */
++#define RFNOWAIT	(1<<6)  /* parent need not wait() on child */ 
++#define RFCNAMEG	(1<<10) /* UNIMPL zero plan9 `name space' */
++#define RFCENVG		(1<<11) /* UNIMPL zero plan9 `env space' */
++#define RFCFDG		(1<<12) /* zero fd table */
++#define RFTHREAD	(1<<13)	/* enable kernel thread support */
++#define RFSIGSHARE	(1<<14)	/* share signal handlers */
++#define RFLINUXTHPN     (1<<16) /* do linux clone exit parent notification */
++#define RFPPWAIT	(1<<31) /* parent sleeps until child exits (vfork) */
++
++__BEGIN_DECLS
++
++extern int rfork (int __flags) __THROW;
++
++#ifdef _LIBC
++extern int __rfork (int __flags);
++#endif
++
++__END_DECLS
++
++#endif /* _SYS_RFORK_H */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,34 @@
++/* Calls to enable swapping on specified locations.  FreeBSD version.
++   Copyright (C) 1996-1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef __SYS_SWAP_H
++
++#define __SYS_SWAP_H	1
++#include <features.h>
++
++
++__BEGIN_DECLS
++
++/* Make the block special device PATH available to the system for swapping.
++   This call is restricted to the super-user.  */
++extern int swapon (__const char *__path) __THROW;
++
++__END_DECLS
++
++#endif /* sys/swap.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,375 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYSCALL_H
++#define _SYSCALL_H	1
++
++#define	SYS_syscall	0
++#define	SYS_exit	1
++#define	SYS_fork	2
++#define	SYS_read	3
++#define	SYS_write	4
++#define	SYS_open	5
++#define	SYS_close	6
++#define	SYS_wait4	7
++				/* 8 is old creat */
++#define	SYS_link	9
++#define	SYS_unlink	10
++				/* 11 is obsolete execv */
++#define	SYS_chdir	12
++#define	SYS_fchdir	13
++#define	SYS_mknod	14
++#define	SYS_chmod	15
++#define	SYS_chown	16
++#define	SYS_obreak	17
++				/* 18 is old getfsstat */
++				/* 19 is old lseek */
++#define	SYS_getpid	20
++#define	SYS_mount	21
++#define	SYS_unmount	22
++#define	SYS_setuid	23
++#define	SYS_getuid	24
++#define	SYS_geteuid	25
++#define	SYS_ptrace	26
++#define	SYS_recvmsg	27
++#define	SYS_sendmsg	28
++#define	SYS_recvfrom	29
++#define	SYS_accept	30
++#define	SYS_getpeername	31
++#define	SYS_getsockname	32
++#define	SYS_access	33
++#define	SYS_chflags	34
++#define	SYS_fchflags	35
++#define	SYS_sync	36
++#define	SYS_kill	37
++				/* 38 is old stat */
++#define	SYS_getppid	39
++				/* 40 is old lstat */
++#define	SYS_dup	41
++#define	SYS_pipe	42
++#define	SYS_getegid	43
++#define	SYS_profil	44
++#define	SYS_ktrace	45
++				/* 46 is old sigaction */
++#define	SYS_getgid	47
++				/* 48 is old sigprocmask */
++#define	SYS_getlogin	49
++#define	SYS_setlogin	50
++#define	SYS_acct	51
++				/* 52 is old sigpending */
++#define	SYS_sigaltstack	53
++#define	SYS_ioctl	54
++#define	SYS_reboot	55
++#define	SYS_revoke	56
++#define	SYS_symlink	57
++#define	SYS_readlink	58
++#define	SYS_execve	59
++#define	SYS_umask	60
++#define	SYS_chroot	61
++				/* 62 is old fstat */
++				/* 63 is old getkerninfo */
++				/* 64 is old getpagesize */
++#define	SYS_msync	65
++#define	SYS_vfork	66
++				/* 67 is obsolete vread */
++				/* 68 is obsolete vwrite */
++#define	SYS_sbrk	69
++#define	SYS_sstk	70
++				/* 71 is old mmap */
++#define	SYS_vadvise	72
++#define	SYS_munmap	73
++#define	SYS_mprotect	74
++#define	SYS_madvise	75
++				/* 76 is obsolete vhangup */
++				/* 77 is obsolete vlimit */
++#define	SYS_mincore	78
++#define	SYS_getgroups	79
++#define	SYS_setgroups	80
++#define	SYS_getpgrp	81
++#define	SYS_setpgid	82
++#define	SYS_setitimer	83
++				/* 84 is old wait */
++#define	SYS_swapon	85
++#define	SYS_getitimer	86
++				/* 87 is old gethostname */
++				/* 88 is old sethostname */
++#define	SYS_getdtablesize	89
++#define	SYS_dup2	90
++#define	SYS_fcntl	92
++#define	SYS_select	93
++#define	SYS_fsync	95
++#define	SYS_setpriority	96
++#define	SYS_socket	97
++#define	SYS_connect	98
++				/* 99 is old accept */
++#define	SYS_getpriority	100
++				/* 101 is old send */
++				/* 102 is old recv */
++				/* 103 is old sigreturn */
++#define	SYS_bind	104
++#define	SYS_setsockopt	105
++#define	SYS_listen	106
++				/* 107 is obsolete vtimes */
++				/* 108 is old sigvec */
++				/* 109 is old sigblock */
++				/* 110 is old sigsetmask */
++				/* 111 is old sigsuspend */
++				/* 112 is old sigstack */
++				/* 113 is old recvmsg */
++				/* 114 is old sendmsg */
++				/* 115 is obsolete vtrace */
++#define	SYS_gettimeofday	116
++#define	SYS_getrusage	117
++#define	SYS_getsockopt	118
++#define	SYS_readv	120
++#define	SYS_writev	121
++#define	SYS_settimeofday	122
++#define	SYS_fchown	123
++#define	SYS_fchmod	124
++				/* 125 is old recvfrom */
++#define	SYS_setreuid	126
++#define	SYS_setregid	127
++#define	SYS_rename	128
++				/* 129 is old truncate */
++				/* 130 is old ftruncate */
++#define	SYS_flock	131
++#define	SYS_mkfifo	132
++#define	SYS_sendto	133
++#define	SYS_shutdown	134
++#define	SYS_socketpair	135
++#define	SYS_mkdir	136
++#define	SYS_rmdir	137
++#define	SYS_utimes	138
++				/* 139 is obsolete 4.2 sigreturn */
++#define	SYS_adjtime	140
++				/* 141 is old getpeername */
++				/* 142 is old gethostid */
++				/* 143 is old sethostid */
++				/* 144 is old getrlimit */
++				/* 145 is old setrlimit */
++				/* 146 is old killpg */
++#define	SYS_setsid	147
++#define	SYS_quotactl	148
++				/* 149 is old quota */
++				/* 150 is old getsockname */
++#define	SYS_nfssvc	155
++				/* 156 is old getdirentries */
++				/* 157 is old statfs */
++				/* 158 is old fstatfs */
++#define	SYS_lgetfh	160
++#define	SYS_getfh	161
++#define	SYS_getdomainname	162
++#define	SYS_setdomainname	163
++#define	SYS_uname	164
++#define	SYS_sysarch	165
++#define	SYS_rtprio	166
++#define	SYS_semsys	169
++#define	SYS_msgsys	170
++#define	SYS_shmsys	171
++#define	SYS_pread	173
++#define	SYS_pwrite	174
++#define	SYS_ntp_adjtime	176
++#define	SYS_setgid	181
++#define	SYS_setegid	182
++#define	SYS_seteuid	183
++#define	SYS_stat	188
++#define	SYS_fstat	189
++#define	SYS_lstat	190
++#define	SYS_pathconf	191
++#define	SYS_fpathconf	192
++#define	SYS_getrlimit	194
++#define	SYS_setrlimit	195
++#define	SYS_getdirentries	196
++#define	SYS_mmap	197
++#define	SYS___syscall	198
++#define	SYS_lseek	199
++#define	SYS_truncate	200
++#define	SYS_ftruncate	201
++#define	SYS_sysctl	202
++#define	SYS_mlock	203
++#define	SYS_munlock	204
++#define	SYS_undelete	205
++#define	SYS_futimes	206
++#define	SYS_getpgid	207
++#define	SYS_poll	209
++#define	SYS_semctl	220
++#define	SYS_semget	221
++#define	SYS_semop	222
++#define	SYS_msgctl	224
++#define	SYS_msgget	225
++#define	SYS_msgsnd	226
++#define	SYS_msgrcv	227
++#define	SYS_shmat	228
++#define	SYS_shmctl	229
++#define	SYS_shmdt	230
++#define	SYS_shmget	231
++#define	SYS_clock_gettime	232
++#define	SYS_clock_settime	233
++#define	SYS_clock_getres	234
++#define	SYS_nanosleep	240
++#define	SYS_minherit	250
++#define	SYS_rfork	251
++#define	SYS_openbsd_poll	252
++#define	SYS_issetugid	253
++#define	SYS_lchown	254
++#define	SYS_getdents	272
++#define	SYS_lchmod	274
++#define	SYS_netbsd_lchown	275
++#define	SYS_lutimes	276
++#define	SYS_netbsd_msync	277
++#define	SYS_nstat	278
++#define	SYS_nfstat	279
++#define	SYS_nlstat	280
++				/* 297 is old fhstatfs */
++#define	SYS_fhopen	298
++#define	SYS_fhstat	299
++#define	SYS_modnext	300
++#define	SYS_modstat	301
++#define	SYS_modfnext	302
++#define	SYS_modfind	303
++#define	SYS_kldload	304
++#define	SYS_kldunload	305
++#define	SYS_kldfind	306
++#define	SYS_kldnext	307
++#define	SYS_kldstat	308
++#define	SYS_kldfirstmod	309
++#define	SYS_getsid	310
++#define	SYS_setresuid	311
++#define	SYS_setresgid	312
++				/* 313 is obsolete signanosleep */
++#define	SYS_aio_return	314
++#define	SYS_aio_suspend	315
++#define	SYS_aio_cancel	316
++#define	SYS_aio_error	317
++#define	SYS_aio_read	318
++#define	SYS_aio_write	319
++#define	SYS_lio_listio	320
++#define	SYS_yield	321
++#define	SYS_thr_sleep	322
++#define	SYS_thr_wakeup	323
++#define	SYS_mlockall	324
++#define	SYS_munlockall	325
++#define	SYS_getcwd	326
++#define	SYS_sched_setparam	327
++#define	SYS_sched_getparam	328
++#define	SYS_sched_setscheduler	329
++#define	SYS_sched_getscheduler	330
++#define	SYS_sched_yield	331
++#define	SYS_sched_get_priority_max	332
++#define	SYS_sched_get_priority_min	333
++#define	SYS_sched_rr_get_interval	334
++#define	SYS_utrace	335
++				/* 336 is old sendfile */
++#define	SYS_kldsym	337
++#define	SYS_jail	338
++#define	SYS_sigprocmask	340
++#define	SYS_sigsuspend	341
++				/* 342 is old sigaction */
++#define	SYS_sigpending	343
++				/* 344 is old sigreturn */
++#define	SYS_sigtimedwait	345
++#define	SYS_sigwaitinfo	346
++#define	SYS_acl_get_file	347
++#define	SYS_acl_set_file	348
++#define	SYS_acl_get_fd	349
++#define	SYS_acl_set_fd	350
++#define	SYS_acl_delete_file	351
++#define	SYS_acl_delete_fd	352
++#define	SYS_acl_aclcheck_file	353
++#define	SYS_acl_aclcheck_fd	354
++#define	SYS_extattrctl	355
++#define	SYS_extattr_set_file	356
++#define	SYS_extattr_get_file	357
++#define	SYS_extattr_delete_file	358
++#define	SYS_aio_waitcomplete	359
++#define	SYS_getresuid	360
++#define	SYS_getresgid	361
++#define	SYS_kqueue	362
++#define	SYS_kevent	363
++#define	SYS_extattr_set_fd	371
++#define	SYS_extattr_get_fd	372
++#define	SYS_extattr_delete_fd	373
++#define	SYS_setugid	374
++#define	SYS_nfsclnt	375
++#define	SYS_eaccess	376
++#define	SYS_nmount	378
++#define	SYS_kse_exit	379
++#define	SYS_kse_wakeup	380
++#define	SYS_kse_create	381
++#define	SYS_kse_thr_interrupt	382
++#define	SYS_kse_release	383
++#define	SYS_mac_get_proc	384
++#define	SYS_mac_set_proc	385
++#define	SYS_mac_get_fd	386
++#define	SYS_mac_get_file	387
++#define	SYS_mac_set_fd	388
++#define	SYS_mac_set_file	389
++#define	SYS_kenv	390
++#define	SYS_lchflags	391
++#define	SYS_uuidgen	392
++#define	SYS_sendfile	393
++#define	SYS_mac_syscall	394
++#define	SYS_getfsstat	395
++#define	SYS_statfs	396
++#define	SYS_fstatfs	397
++#define	SYS_fhstatfs	398
++#define	SYS_ksem_close	400
++#define	SYS_ksem_post	401
++#define	SYS_ksem_wait	402
++#define	SYS_ksem_trywait	403
++#define	SYS_ksem_init	404
++#define	SYS_ksem_open	405
++#define	SYS_ksem_unlink	406
++#define	SYS_ksem_getvalue	407
++#define	SYS_ksem_destroy	408
++#define	SYS_mac_get_pid	409
++#define	SYS_mac_get_link	410
++#define	SYS_mac_set_link	411
++#define	SYS_extattr_set_link	412
++#define	SYS_extattr_get_link	413
++#define	SYS_extattr_delete_link	414
++#define	SYS_mac_execve	415
++#define	SYS_sigaction	416
++#define	SYS_sigreturn	417
++#define	SYS_getcontext	421
++#define	SYS_setcontext	422
++#define	SYS_swapcontext	423
++#define	SYS_swapoff	424
++#define	SYS_acl_get_link	425
++#define	SYS_acl_set_link	426
++#define	SYS_acl_delete_link	427
++#define	SYS_acl_aclcheck_link	428
++#define	SYS_sigwait	429
++#define	SYS_thr_create	430
++#define	SYS_thr_exit	431
++#define	SYS_thr_self	432
++#define	SYS_thr_kill	433
++#define	SYS__umtx_lock	434
++#define	SYS__umtx_unlock	435
++#define	SYS_jail_attach	436
++#define	SYS_extattr_list_fd	437
++#define	SYS_extattr_list_file	438
++#define	SYS_extattr_list_link	439
++#define	SYS_kse_switchin	440
++#define	SYS_ksem_timedwait	441
++#define	SYS_thr_suspend	442
++#define	SYS_thr_wake	443
++#define	SYS_kldunloadf	444
++#define	SYS_MAXSYSCALL	445
++
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Definitions of macros to access `dev_t' values.  FreeBSD version.
++   Copyright (C) 1996-1997, 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_SYSMACROS_H
++#define _SYS_SYSMACROS_H	1
++
++/* For compatibility we provide alternative names.
++
++   The problem here is that compilers other than GCC probably don't
++   have the `long long' type and so `dev_t' is actually an array.  */
++#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
++#define minor(dev) ((int)((dev) & 0xffff00ff))
++#define makedev(major, minor) (((major) << 8) | (minor))
++
++#endif /* sys/sysmacros.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,96 @@
++/*-
++ * Copyright (c) 1982, 1986, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ * (c) UNIX System Laboratories, Inc.
++ * All or some portions of this file are derived from material licensed
++ * to the University of California by American Telephone and Telegraph
++ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
++ * the permission of UNIX System Laboratories, Inc.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
++ */
++
++/*
++ * System wide defaults for terminal state.  FreeBSD version.
++ */
++#ifndef _SYS_TTYDEFAULTS_H_
++#define _SYS_TTYDEFAULTS_H_
++
++/*
++ * Defaults on "first" open.
++ */
++#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
++#define TTYDEF_OFLAG	(OPOST | ONLCR)
++#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
++#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
++#define TTYDEF_SPEED	(B9600)
++
++/*
++ * Control Character Defaults
++ */
++#define CTRL(x)	(x&037)
++#define CEOF		CTRL('d')
++#ifdef _POSIX_VDISABLE
++# define CEOL		_POSIX_VDISABLE
++#else
++# define CEOL		((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
++#endif
++#define CERASE		0177
++#define CINTR		CTRL('c')
++#define CSTATUS		CTRL('t')
++#define CKILL		CTRL('u')
++#define CMIN		1
++#define CQUIT		034		/* FS, ^\ */
++#define CSUSP		CTRL('z')
++#define CTIME		0
++#define CDSUSP		CTRL('y')
++#define CSTART		CTRL('q')
++#define CSTOP		CTRL('s')
++#define CLNEXT		CTRL('v')
++#define CDISCARD 	CTRL('o')
++#define CWERASE 	CTRL('w')
++#define CREPRINT 	CTRL('r')
++#define CEOT		CEOF
++/* compat */
++#define CBRK		CEOL
++#define CRPRNT		CREPRINT
++#define CFLUSH		CDISCARD
++
++/* PROTECTED INCLUSION ENDS HERE */
++#endif /* !_SYS_TTYDEFAULTS_H_ */
++
++/*
++ * #define TTYDEFCHARS to include an array of default control characters.
++ */
++#ifdef TTYDEFCHARS
++cc_t	ttydefchars[NCCS] = {
++	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
++	_POSIX_VDISABLE, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
++	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
++};
++#undef TTYDEFCHARS
++#endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,46 @@
++/* Data structures for user-level context switching.  Generic version.
++   Copyright (C) 1997-1999, 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This file's definitions suffice for any platform where all
++   the machine-specific state is described in `struct sigcontext'.  */
++
++#ifndef _SYS_UCONTEXT_H
++#define _SYS_UCONTEXT_H	1
++
++#include <features.h>
++#include <signal.h>
++
++/* We need the signal context definitions even if they are not used
++   included in <signal.h>.  */
++#include <bits/sigcontext.h>
++
++/* This include file defines the type 'mcontext_t'.  */
++#include <bits/mcontext.h>
++
++/* Userlevel context.  */
++typedef struct ucontext
++  {
++    __sigset_t uc_sigmask;
++    mcontext_t uc_mcontext;
++    struct ucontext *uc_link;
++    stack_t uc_stack;
++    int __unused1[8];
++  } ucontext_t;
++
++#endif /* sys/ucontext.h */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,44 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/sysctl.h>
++#include <string.h>
++
++/* Read or write system parameters.  */
++int
++__sysctlbyname (const char *name, void *oldval, size_t *oldlenp, void *newval, size_t newlen)
++{
++  int request[CTL_MAXNAME];
++  size_t requestlen = sizeof (request);
++
++  /* Convert the string NAME to a binary encoded request.  The kernel
++     contains a routine for doing this, called "name2oid".  But the way
++     to call it is a little bit strange.  */
++  int name2oid_request[2] = { 0, 3 };
++  if (__sysctl (name2oid_request, 2, request, &requestlen,
++		(void *) name, strlen (name))
++      < 0)
++    return -1;
++
++  /* Now call sysctl using the binary encoded request.  */
++  return __sysctl (request, requestlen / sizeof (int),
++		   oldval, oldlenp, newval, newlen);
++}
++
++weak_alias (__sysctlbyname, sysctlbyname)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,2 @@
++/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
++#include <sysdeps/unix/telldir.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/adjtime.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/adjtime.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/adjtime.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/adjtime.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,50 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <sys/time.h>
++
++extern int __syscall_adjtime (const struct __kernel_timeval *delta,
++			      struct __kernel_timeval *olddelta);
++
++int
++__adjtime (const struct timeval *delta, struct timeval *olddelta)
++{
++  struct __kernel_timeval kdelta;
++  int retval;
++
++  kdelta.tv_sec  = delta->tv_sec;
++  kdelta.tv_usec = delta->tv_usec;
++  if (olddelta != NULL)
++    {
++      struct __kernel_timeval kolddelta;
++
++      retval = __syscall_adjtime (&kdelta, &kolddelta);
++      if (retval >= 0)
++	{
++	  olddelta->tv_sec  = kolddelta.tv_sec;
++	  olddelta->tv_usec = kolddelta.tv_usec;
++	}
++    }
++  else
++    retval = __syscall_adjtime (&kdelta, NULL);
++  return retval;
++}
++
++weak_alias (__adjtime, adjtime)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/futimes.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/futimes.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/futimes.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/futimes.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,42 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <sys/time.h>
++
++extern int __syscall_futimes (int fd, const struct __kernel_timeval tvp[2]);
++
++int
++__futimes (int fd, const struct timeval tvp[2])
++{
++  if (tvp != NULL)
++    {
++      struct __kernel_timeval ktv[2];
++
++      ktv[0].tv_sec  = tvp[0].tv_sec;
++      ktv[0].tv_usec = tvp[0].tv_usec;
++      ktv[1].tv_sec  = tvp[1].tv_sec;
++      ktv[1].tv_usec = tvp[1].tv_usec;
++      return __syscall_futimes (fd, ktv);
++    }
++  else
++    return __syscall_futimes (fd, NULL);
++}
++
++weak_alias (__futimes, futimes)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getitimer.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getitimer.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getitimer.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getitimer.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,48 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <sys/time.h>
++
++extern int __syscall_getitimer (int which, struct __kernel_itimerval *value);
++
++int
++__getitimer (enum __itimer_which which, struct itimerval *value)
++{
++  struct __kernel_itimerval kvalue;
++  int retval;
++
++  if (value == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  retval = __syscall_getitimer (which, &kvalue);
++  if (retval >= 0)
++    {
++      value->it_interval.tv_sec  = kvalue.it_interval.tv_sec;
++      value->it_interval.tv_usec = kvalue.it_interval.tv_usec;
++      value->it_value.tv_sec  = kvalue.it_value.tv_sec;
++      value->it_value.tv_usec = kvalue.it_value.tv_usec;
++    }
++  return retval;
++}
++
++weak_alias (__getitimer, getitimer)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getrusage.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getrusage.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getrusage.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/getrusage.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,62 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <sys/resource.h>
++
++extern int __syscall_getrusage (int who, struct __kernel_rusage *usage);
++
++int
++__getrusage (enum __rusage_who who, struct rusage *usage)
++{
++  struct __kernel_rusage kusage;
++  int retval;
++
++  if (usage == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  retval = __syscall_getrusage (who, &kusage);
++  if (retval >= 0)
++    {
++      usage->ru_utime.tv_sec  = kusage.ru_utime.tv_sec;
++      usage->ru_utime.tv_usec = kusage.ru_utime.tv_usec;
++      usage->ru_stime.tv_sec  = kusage.ru_stime.tv_sec;
++      usage->ru_stime.tv_usec = kusage.ru_stime.tv_usec;
++      usage->ru_maxrss = kusage.ru_maxrss;
++      usage->ru_ixrss = kusage.ru_ixrss;
++      usage->ru_idrss = kusage.ru_idrss;
++      usage->ru_isrss = kusage.ru_isrss;
++      usage->ru_minflt = kusage.ru_minflt;
++      usage->ru_majflt = kusage.ru_majflt;
++      usage->ru_nswap = kusage.ru_nswap;
++      usage->ru_inblock = kusage.ru_inblock;
++      usage->ru_oublock = kusage.ru_oublock;
++      usage->ru_msgsnd = kusage.ru_msgsnd;
++      usage->ru_msgrcv = kusage.ru_msgrcv;
++      usage->ru_nsignals = kusage.ru_nsignals;
++      usage->ru_nvcsw = kusage.ru_nvcsw;
++      usage->ru_nivcsw = kusage.ru_nivcsw;
++    }
++  return retval;
++}
++
++weak_alias (__getrusage, getrusage)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/gettimeofday.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/gettimeofday.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/gettimeofday.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/gettimeofday.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,51 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <sys/time.h>
++
++extern int __syscall_gettimeofday (struct __kernel_timeval *tv,
++				   struct timezone *tz);
++
++#undef __gettimeofday
++
++int
++__gettimeofday (struct timeval *tv, struct timezone *tz)
++{
++  struct __kernel_timeval ktv;
++  int retval;
++
++  if (tv == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  retval = __syscall_gettimeofday (&ktv, tz);
++  if (retval >= 0)
++    {
++      tv->tv_sec  = ktv.tv_sec;
++      tv->tv_usec = ktv.tv_usec;
++    }
++  return retval;
++}
++
++INTDEF(__gettimeofday)
++
++weak_alias (__gettimeofday, gettimeofday)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/lutimes.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/lutimes.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/lutimes.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/lutimes.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,43 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <sys/time.h>
++
++extern int __syscall_lutimes (const char *file,
++			      const struct __kernel_timeval tvp[2]);
++
++int
++__lutimes (const char *file, const struct timeval tvp[2])
++{
++  if (tvp != NULL)
++    {
++      struct __kernel_timeval ktv[2];
++
++      ktv[0].tv_sec  = tvp[0].tv_sec;
++      ktv[0].tv_usec = tvp[0].tv_usec;
++      ktv[1].tv_sec  = tvp[1].tv_sec;
++      ktv[1].tv_usec = tvp[1].tv_usec;
++      return __syscall_lutimes (file, ktv);
++    }
++  else
++    return __syscall_lutimes (file, NULL);
++}
++
++weak_alias (__lutimes, lutimes)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/Makefile sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/Makefile
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/Makefile	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,19 @@
++# Particular system calls:
++
++ifeq ($(subdir),misc)
++sysdep_routines += sys_select sys_utimes sys_lutimes sys_futimes
++endif
++
++ifeq ($(subdir),posix)
++sysdep_routines += sys_nanosleep sys_sched_rr_gi
++endif
++
++ifeq ($(subdir),time)
++sysdep_routines += \
++ sys_adjtime sys_gettimeofday sys_settimeofday \
++ sys_getitimer sys_setitimer
++endif
++
++ifeq ($(subdir),resource)
++sysdep_routines += sys_getrusage
++endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/nanosleep.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/nanosleep.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/nanosleep.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/nanosleep.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,53 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <time.h>
++
++extern int __syscall_nanosleep (const struct __kernel_timespec *requested_time,
++				struct __kernel_timespec *remaining);
++
++int
++__libc_nanosleep (const struct timespec *requested_time,
++		  struct timespec *remaining)
++{
++  struct __kernel_timespec krequested_time;
++  int retval;
++
++  krequested_time.tv_sec  = requested_time->tv_sec;
++  krequested_time.tv_nsec = requested_time->tv_nsec;
++  if (remaining != NULL)
++    {
++      struct __kernel_timespec kremaining;
++
++      retval = __syscall_nanosleep (&krequested_time, &kremaining);
++      if (retval >= 0 || errno == EINTR)
++	{
++	  remaining->tv_sec  = kremaining.tv_sec;
++	  remaining->tv_nsec = kremaining.tv_nsec;
++	}
++    }
++  else
++    retval = __syscall_nanosleep (&krequested_time, NULL);
++  return retval;
++}
++
++weak_alias (__libc_nanosleep, __nanosleep)
++weak_alias (__libc_nanosleep, nanosleep)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/README sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/README
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/README	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/README	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,5 @@
++This directory contains the glue code for using a 64-bit __time_t with a
++32-bit __kernel_time_t type. All system calls taking arguments with
++'time_t', 'struct timeval', 'struct timespec', 'struct itimerval',
++'struct rusage' need some special handling. The benefit is that user programs
++will not need to switch from a 32-bit time_t to a 64-bit time_t in 2038.
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/sched_rr_gi.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/sched_rr_gi.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/sched_rr_gi.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/sched_rr_gi.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,49 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <time.h>
++#include <sched.h>
++#include <sys/types.h>
++
++extern int __syscall_sched_rr_get_interval (pid_t pid,
++					    struct __kernel_timespec *t);
++
++int
++__sched_rr_get_interval (pid_t pid, struct timespec *t)
++{
++  struct __kernel_timespec kt;
++  int retval;
++
++  if (t == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  retval = __syscall_sched_rr_get_interval (pid, &kt);
++  if (retval >= 0)
++    {
++      t->tv_sec  = kt.tv_sec;
++      t->tv_nsec = kt.tv_nsec;
++    }
++  return retval;
++}
++
++weak_alias (__sched_rr_get_interval, sched_rr_get_interval)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/select.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/select.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/select.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/select.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,52 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <sys/types.h>
++#include <sys/time.h>
++
++extern int __syscall_select (int nfds,
++			     fd_set *readfds,
++			     fd_set *writefds,
++			     fd_set *exceptfds,
++			     struct __kernel_timeval *timeout);
++
++int
++__select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
++	  struct timeval *timeout)
++{
++  int retval;
++
++  if (timeout != NULL)
++    {
++      struct __kernel_timeval ktimeout;
++
++      ktimeout.tv_sec  = timeout->tv_sec;
++      ktimeout.tv_usec = timeout->tv_usec;
++      retval = __syscall_select (nfds, readfds, writefds, exceptfds, &ktimeout);
++      timeout->tv_sec  = ktimeout.tv_sec;
++      timeout->tv_usec = ktimeout.tv_usec;
++    }
++  else
++    retval = __syscall_select (nfds, readfds, writefds, exceptfds, NULL);
++  return retval;
++}
++libc_hidden_def (__select)
++
++weak_alias (__select, select)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/setitimer.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/setitimer.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/setitimer.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/setitimer.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,62 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <sys/time.h>
++
++extern int __syscall_setitimer (int which,
++				const struct __kernel_itimerval *new,
++				struct __kernel_itimerval *old);
++
++int
++__setitimer (enum __itimer_which which,
++	     const struct itimerval *new, struct itimerval *old)
++{
++  int retval;
++  struct __kernel_itimerval knew;
++
++  if (new == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  knew.it_interval.tv_sec  = new->it_interval.tv_sec;
++  knew.it_interval.tv_usec = new->it_interval.tv_usec;
++  knew.it_value.tv_sec  = new->it_value.tv_sec;
++  knew.it_value.tv_usec = new->it_value.tv_usec;
++  if (old != NULL)
++    {
++      struct __kernel_itimerval kold;
++
++      retval = __syscall_setitimer (which, &knew, &kold);
++      if (retval >= 0)
++	{
++	  old->it_interval.tv_sec  = kold.it_interval.tv_sec;
++	  old->it_interval.tv_usec = kold.it_interval.tv_usec;
++	  old->it_value.tv_sec  = kold.it_value.tv_sec;
++	  old->it_value.tv_usec = kold.it_value.tv_usec;
++	}
++    }
++  else
++    retval = __syscall_setitimer (which, &knew, NULL);
++  return retval;
++}
++
++weak_alias (__setitimer, setitimer)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/settimeofday.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/settimeofday.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/settimeofday.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/settimeofday.c	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,42 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <errno.h>
++#include <sys/time.h>
++
++extern int __syscall_settimeofday (const struct __kernel_timeval *tv,
++				   const struct timezone *tz);
++
++int
++__settimeofday (const struct timeval *tv, const struct timezone *tz)
++{
++  struct __kernel_timeval ktv;
++
++  if (tv == NULL)
++    {
++      errno = EFAULT;
++      return -1;
++    }
++  ktv.tv_sec  = tv->tv_sec;
++  ktv.tv_usec = tv->tv_usec;
++  return __syscall_settimeofday (&ktv, tz);
++}
++
++weak_alias (__settimeofday, settimeofday)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/syscalls.list sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/syscalls.list
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/syscalls.list	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/syscalls.list	2005-08-23 17:35:06.000000000 +0200
+@@ -0,0 +1,14 @@
++# File name	Caller	Syscall name		Args	Strong name	Weak names
++
++sys_adjtime	-	adjtime			i:pp	__syscall_adjtime
++sys_futimes	-	futimes			i:ip	__syscall_futimes
++sys_getitimer	-	getitimer		i:ip	__syscall_getitimer
++sys_getrusage	-	getrusage		i:ip	__syscall_getrusage
++sys_gettimeofday -	gettimeofday		i:PP	__syscall_gettimeofday
++sys_lutimes	-	lutimes			i:sp	__syscall_lutimes
++sys_nanosleep	-	nanosleep		i:pp	__syscall_nanosleep
++sys_sched_rr_gi	-	sched_rr_get_interval	i:ip	__syscall_sched_rr_get_interval
++sys_select	-	select			i:iPPPP	__syscall_select
++sys_setitimer	-	setitimer		i:ipp	__syscall_setitimer
++sys_settimeofday -	settimeofday		i:PP	__syscall_settimeofday
++sys_utimes	-	utimes			i:sp	__syscall_utimes
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/utimes.c sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/utimes.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/utimes.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/time-64/utimes.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,43 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <stddef.h>
++#include <sys/time.h>
++
++extern int __syscall_utimes (const char *file,
++			     const struct __kernel_timeval tvp[2]);
++
++int
++__utimes (const char *file, const struct timeval tvp[2])
++{
++  if (tvp != NULL)
++    {
++      struct __kernel_timeval ktv[2];
++
++      ktv[0].tv_sec  = tvp[0].tv_sec;
++      ktv[0].tv_usec = tvp[0].tv_usec;
++      ktv[1].tv_sec  = tvp[1].tv_sec;
++      ktv[1].tv_usec = tvp[1].tv_usec;
++      return __syscall_utimes (file, ktv);
++    }
++  else
++    return __syscall_utimes (file, NULL);
++}
++
++weak_alias (__utimes, utimes)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c	2005-08-23 17:51:30.000000000 +0200
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++int
++__truncate64 (const char *file, __off64_t length)
++{
++  /* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
++  return __truncate (file, (__off_t) length);
++}
++
++weak_alias (__truncate64, truncate64)
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c	2005-08-23 17:51:36.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <unistd.h>
++#include <sys/types.h>
++#include <sysdep.h>
++
++/* The real system call has a word of padding before the 64-bit off_t
++   argument.  */
++extern int __syscall_truncate (const char *__file, int __unused1,
++			       __off_t __length) __THROW;
++
++int
++__truncate (const char *file, __off_t length)
++{
++  /* We pass 2 arguments in 4 words.  */
++  return INLINE_SYSCALL (truncate, 2, file, 0, length);
++}
++
++weak_alias (__truncate, truncate)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,126 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/utsname.h>
++#include <sys/sysctl.h>
++#include <errno.h>
++#include <string.h>
++
++/* Dummy values used as a fallback.  */
++#define UNAME_SYSNAME	"GNU/kFreeBSD"
++#define UNAME_RELEASE	"4.0"
++#define UNAME_VERSION	"GENERIC"
++#define UNAME_MACHINE	"mmix"
++
++/* Put information about the system in NAME.  */
++int
++__uname (struct utsname *name)
++{
++  /* Fill nodename: "uname -n".  Fetch sysctl "kern.hostname".  */
++  {
++    int request[2] = { CTL_KERN, KERN_HOSTNAME };
++    size_t len = sizeof (name->nodename);
++    if (__sysctl (request, 2, name->nodename, &len, NULL, 0) >= 0)
++      {
++	if (len < sizeof (name->nodename))
++	  name->nodename[len] = '\0';
++      }
++    else
++      {
++	if (errno != ENOMEM)
++	  strncpy (name->nodename, "localhost", sizeof (name->nodename));
++      }
++  }
++
++  /* Fill sysname: "uname -s".  Fetch sysctl "kern.ostype".  */
++  {
++    strncpy (name->sysname, UNAME_SYSNAME, sizeof (name->sysname));
++  }
++
++  /* Fill release: "uname -r".  Fetch sysctl "kern.osrelease".  */
++  {
++    int request[2] = { CTL_KERN, KERN_OSRELEASE };
++    size_t len = sizeof (name->release);
++    if (__sysctl (request, 2, name->release, &len, NULL, 0) >= 0)
++      {
++	if (len < sizeof (name->release))
++	  name->release[len] = '\0';
++      }
++    else
++      {
++	if (errno != ENOMEM)
++	  strncpy (name->release, UNAME_RELEASE, sizeof (name->release));
++      }
++  }
++
++  /* Fill version: "uname -v".  Fetch sysctl "kern.version".  */
++  {
++    int request[2] = { CTL_KERN, KERN_VERSION };
++    size_t len = sizeof (name->version);
++    if (__sysctl (request, 2, name->version, &len, NULL, 0) >= 0)
++      {
++	if (len < sizeof (name->version))
++	  name->version[len] = '\0';
++      }
++    else
++      {
++	if (errno != ENOMEM)
++	  strncpy (name->version, UNAME_VERSION, sizeof (name->version));
++      }
++
++    /* Remove trailing whitespace.  Turn non-trailing whitespace to
++       spaces.  */
++    {
++      char *p0 = name->version;
++      char *p = p0 + __strnlen (p0, sizeof (name->version));
++
++      while (p > p0 && (p[-1] == '\t' || p[-1] == '\n' || p[-1] == ' '))
++	*--p = '\0';
++
++      while (p > p0)
++	{
++	  --p;
++	  if (*p == '\t' || *p == '\n')
++	    *p = ' ';
++	}
++    }
++  }
++
++  /* Fill machine: "uname -m".  Fetch sysctl "hw.machine".  */
++  {
++    int request[2] = { CTL_HW, HW_MACHINE };
++    size_t len = sizeof (name->machine);
++    if (__sysctl (request, 2, name->machine, &len, NULL, 0) >= 0)
++      {
++	if (len < sizeof (name->machine))
++	  name->machine[len] = '\0';
++      }
++    else
++      {
++	if (errno != ENOMEM)
++	  strncpy (name->machine, UNAME_MACHINE, sizeof (name->machine));
++      }
++  }
++
++  return 0;
++}
++libc_hidden_def (__uname)
++
++weak_alias (__uname, uname)
++libc_hidden_def (uname)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,50 @@
++/* Implementation of the BSD usleep function using nanosleep.
++   Copyright (C) 1996-1997, 1999, 2001-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <time.h>
++#include <unistd.h>
++
++extern int __libc_nanosleep (const struct timespec *requested_time,
++			     struct timespec *remaining);
++
++int
++usleep (useconds_t useconds)
++{
++  unsigned int sec;
++  unsigned int usec;
++  struct timespec ts;
++
++  /* POSIX:2001 says that useconds >= 1000000 is invalid; nevertheless let's
++     be forgiving.  */
++  if (__builtin_expect (useconds < 1000000, 1))
++    {
++      sec = 0;
++      usec = useconds;
++    }
++  else
++    {
++      sec = useconds / 1000000;
++      usec = useconds % 1000000;
++    }
++
++  ts.tv_sec = sec;
++  ts.tv_nsec = usec * 1000;	/* Multiply as 32-bit integers.  */
++
++  return __libc_nanosleep (&ts, NULL);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,70 @@
++/* Return info on filesystem.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sys/ustat.h>
++#include <sys/mount.h>
++#include <sys/stat.h>
++#include <stdlib.h>
++#include <string.h>
++#include <errno.h>
++
++int
++ustat (dev_t dev, struct ustat *ubuf)
++{
++  int mntcount;
++  struct statfs *mntlist;
++
++  /* Search for the device among the f_mntfromname fields of all mounted
++     filesystems.  */
++  mntcount = __getmntinfo (&mntlist, 0);
++  if (mntcount == 0 && errno != 0)
++    return -1;
++  if (mntcount > 0)
++    {
++      int i;
++
++      for (i = 0; i < mntcount; i++)
++	{
++	  struct statfs *mnt = &mntlist[i];
++	  struct stat statbuf;
++
++	  if ((__strnlen (mnt->f_mntfromname, sizeof (mnt->f_mntfromname))
++	       < sizeof (mnt->f_mntfromname))
++	      && __xstat (_STAT_VER, mnt->f_mntfromname, &statbuf) >= 0
++	      && S_ISBLK (statbuf.st_mode)
++	      && statbuf.st_rdev == dev)
++	    {
++	      /* Found the device.  Now produce the result.  */
++	      memset (ubuf, '\0', sizeof (struct ustat));
++	      ubuf->f_tfree = mnt->f_bfree;
++	      ubuf->f_tinode = mnt->f_ffree;
++
++	      free (mntlist);
++	      return 0;
++	    }
++	}
++
++      free (mntlist);
++    }
++
++  /* DEV is not among the mounted devices.  */
++  __set_errno (EINVAL);
++  return -1;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,50 @@
++/* The `struct utmp' type, describing entries in the utmp file.  For FreeBSD.
++   Copyright (C) 1993, 1996-1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _UTMP_H
++# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
++#endif
++
++#include <paths.h>
++#include <time.h>
++
++
++#define	UT_NAMESIZE	16
++#define	UT_LINESIZE	8
++#define	UT_HOSTSIZE	16
++
++
++struct lastlog
++  {
++    time_t ll_time;
++    char ll_line[UT_LINESIZE];
++    char ll_host[UT_HOSTSIZE];
++  };
++
++struct utmp
++  {
++    char ut_line[UT_LINESIZE];
++    char ut_user[UT_NAMESIZE];
++#define ut_name ut_user
++    char ut_host[UT_HOSTSIZE];
++    __kernel_time_t ut_time;
++  };
++
++
++#define _HAVE_UT_HOST 1		/* We have the ut_host field.  */
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <utmp.h>
++#include <string.h>
++
++extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
++
++/* Copy the information in UTMPX to UTMP. */
++void
++getutmp (const struct utmpx *utmpx, struct utmp *utmp)
++{
++  if (__utmpx_to_utmp (utmpx, utmp) < 0)
++    memset (utmp, '\0', sizeof (struct utmp));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <utmp.h>
++#include <string.h>
++
++extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
++
++/* Copy the information in UTMP to UTMPX. */
++void
++getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
++{
++  if (__utmp_to_utmpx (utmp, utmpx) < 0)
++    memset (utmpx, '\0', sizeof (struct utmpx));
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,46 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <utmp.h>
++#include <stddef.h>
++
++extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
++
++/* Static buffer to store the result.  */
++static struct utmpx buffer;
++
++struct utmpx *
++__getutxent (void)
++{
++  for (;;)
++    {
++      struct utmp *tmp = __getutent ();
++
++      if (tmp == NULL)
++	return NULL;
++
++      if (__utmp_to_utmpx (tmp, &buffer) >= 0)
++	return &buffer;
++
++      /* Skip entries that cannot be converted to utmpx.  */
++    }
++}
++
++weak_alias (__getutxent, getutxent)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,68 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <stddef.h>
++#include <string.h>
++
++extern struct utmpx *__getutxent (void);
++
++struct utmpx *
++getutxid (const struct utmpx *id)
++{
++  switch (id->ut_type)
++    {
++    case INIT_PROCESS:
++    case LOGIN_PROCESS:
++    case USER_PROCESS:
++    case DEAD_PROCESS:
++      for (;;)
++	{
++	  struct utmpx *next = __getutxent ();
++
++	  if (next == NULL)
++	    return NULL;
++
++	  switch (next->ut_type)
++	    {
++	    case INIT_PROCESS:
++	    case LOGIN_PROCESS:
++	    case USER_PROCESS:
++	    case DEAD_PROCESS:
++	      if (strncmp (next->ut_id, id->ut_id, sizeof (id->ut_id)) == 0)
++		return next;
++	      break;
++	    default:
++	      break;
++	    }
++	}
++
++    default:
++      for (;;)
++	{
++	  struct utmpx *next = __getutxent ();
++
++	  if (next == NULL)
++	    return NULL;
++
++	  if (next->ut_type == id->ut_type)
++	    return next;
++	}
++    }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,40 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <stddef.h>
++#include <string.h>
++
++extern struct utmpx *__getutxent (void);
++
++struct utmpx *
++getutxline (const struct utmpx *line)
++{
++  for (;;)
++    {
++      struct utmpx *next = __getutxent ();
++
++      if (next == NULL)
++	return NULL;
++
++      if ((next->ut_type == LOGIN_PROCESS || next->ut_type == USER_PROCESS)
++	  && strncmp (next->ut_line, line->ut_line, __UT_LINESIZE) == 0)
++	return next;
++    }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,6 @@
++# Additional functions:
++
++ifeq ($(subdir),login)
++# For <utmpx.h>.
++sysdep_routines += utmpconv
++endif
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,50 @@
++/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <utmp.h>
++#include <stddef.h>
++#include <string.h>
++
++extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
++extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
++
++/* Static buffer to store the result.  */
++static struct utmpx buffer;
++
++struct utmpx *
++pututxline (const struct utmpx *utmpx)
++{
++  struct utmp tmp;
++
++  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
++    {
++      struct utmp *tmpres = __pututline (&tmp);
++
++      if (tmpres != NULL)
++	{
++	  if (__utmp_to_utmpx (tmpres, &buffer) >= 0)
++	    return &buffer;
++
++	  /* Hmm.  We wrote a 'struct utmp' that we cannot convert back
++	     to 'struct utmpx'.  Shouldn't happen that often.  */
++	  return NULL;
++	}
++    }
++  return NULL;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,31 @@
++/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <utmpx.h>
++#include <utmp.h>
++
++extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
++
++void
++updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)
++{
++  struct utmp tmp;
++
++  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
++    __updwtmp (wtmpx_file, &tmp);
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,227 @@
++/* Convert between 'struct utmp' and 'struct utmx'.
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* We reuse the 'struct utmp' file format also for 'struct utmpx' records.
++   The mapping from 'struct utmp' to 'struct utmpx' is injective; the
++   reverse mapping succeeds only when common conventions are respected.  */
++
++#include <utmp.h>
++#include <utmpx.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++
++/* Compare two 'struct utmpx' records.  */
++int
++__utmpx_equal (const struct utmpx *u1, const struct utmpx *u2)
++{
++  return (u1->ut_type == u2->ut_type)
++	 && (u1->ut_pid == u2->ut_pid)
++	 && (strncmp (u1->ut_line, u2->ut_line, __UT_LINESIZE) == 0)
++	 && (strncmp (u1->ut_id, u2->ut_id, sizeof (u1->ut_id)) == 0)
++	 && (strncmp (u1->ut_user, u2->ut_user, __UT_NAMESIZE) == 0)
++	 && (strncmp (u1->ut_host, u2->ut_host, __UT_HOSTSIZE) == 0)
++	 && (u1->ut_exit.e_termination == u2->ut_exit.e_termination)
++	 && (u1->ut_exit.e_exit == u2->ut_exit.e_exit)
++	 && (u1->ut_session == u2->ut_session)
++	 && (u1->ut_tv.tv_sec == u2->ut_tv.tv_sec)
++	 && (u1->ut_tv.tv_usec == u2->ut_tv.tv_usec)
++	 && (memcmp (u1->ut_addr_v6, u2->ut_addr_v6, sizeof (u1->ut_addr_v6))
++	     == 0);
++}
++
++int
++__utmp_to_utmpx (const struct utmp *u, struct utmpx *ux)
++{
++  memset (ux, '\0', sizeof (struct utmpx));
++
++  if (u->ut_line[0] == '\0' && u->ut_name[0] == '\0' && u->ut_host[0] == '\0')
++    {
++      ux->ut_type = EMPTY;
++    }
++  else
++    {
++      if (u->ut_line[0] == '~' && u->ut_line[1] == '\0')
++	{
++	  if (strncmp (u->ut_name, "runlevel", UT_NAMESIZE) == 0)
++	    ux->ut_type = RUN_LVL;
++	  else if (strncmp (u->ut_name, "reboot", UT_NAMESIZE) == 0)
++	    ux->ut_type = BOOT_TIME;
++	  else if (strncmp (u->ut_name, "acct", UT_NAMESIZE) == 0)
++	    ux->ut_type = ACCOUNTING;
++	  else
++	    return -1;
++	}
++      else if (u->ut_line[0] == '{' && u->ut_line[1] == '\0')
++	{
++	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
++	    ux->ut_type = NEW_TIME;
++	  else
++	    return -1;
++	}
++      else if (u->ut_line[0] == '|' && u->ut_line[1] == '\0')
++	{
++	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
++	    ux->ut_type = OLD_TIME;
++	  else
++	    return -1;
++	}
++      else
++	{
++	  if (strncmp (u->ut_name, "INIT", UT_NAMESIZE) == 0)
++	    ux->ut_type = INIT_PROCESS;
++	  else if (strncmp (u->ut_name, "LOGIN", UT_NAMESIZE) == 0)
++	    ux->ut_type = LOGIN_PROCESS;
++	  else if (strncmp (u->ut_name, "", UT_NAMESIZE) == 0)
++	    ux->ut_type = DEAD_PROCESS;
++	  else
++	    ux->ut_type = USER_PROCESS;
++
++	  if (ux->ut_type == LOGIN_PROCESS || ux->ut_type == USER_PROCESS)
++	    strncpy (ux->ut_user, u->ut_name, UT_NAMESIZE);
++
++	  if (strncmp (u->ut_line, "tty", 3) == 0)
++	    {
++	      strncpy (ux->ut_line, u->ut_line, UT_LINESIZE);
++	      strncpy (ux->ut_id, u->ut_line + 3, sizeof (ux->ut_id));
++	    }
++	  else
++	    {
++	      strncpy (ux->ut_id, u->ut_line, sizeof (ux->ut_id));
++	    }
++	}
++
++      strncpy (ux->ut_host, u->ut_host, UT_HOSTSIZE);
++
++      /* Hack: Recover the ut_pid from the hidden place after the host.  */
++      if (__strnlen (u->ut_host, UT_HOSTSIZE) < UT_HOSTSIZE - 2)
++	{
++	  const char *hidden = u->ut_host + strlen (u->ut_host) + 1;
++
++	  if (hidden[0] != '\0')
++	    {
++	      size_t n = UT_HOSTSIZE - strlen (u->ut_host) - 1;
++	      char buf[UT_HOSTSIZE];
++	      unsigned long pid;
++	      char *endp;
++
++	      strncpy (buf, hidden, n);
++	      buf[n] = '\0';
++
++	      pid = strtoul (buf, &endp, 10);
++	      if (endp != buf && *endp == '\0')
++		ux->ut_pid = pid;
++	    }
++	}
++
++      ux->ut_tv.tv_sec = u->ut_time;
++      ux->ut_tv.tv_usec = 0;
++    }
++
++  return 0;
++}
++
++int
++__utmpx_to_utmp (const struct utmpx *ux, struct utmp *u)
++{
++  char buf[10+1];
++
++  switch (ux->ut_type)
++    {
++    case EMPTY:
++      strncpy (u->ut_line, "", UT_LINESIZE);
++      strncpy (u->ut_name, "", UT_NAMESIZE);
++      strncpy (u->ut_host, "", UT_HOSTSIZE);
++      break;
++
++    case RUN_LVL:
++      strncpy (u->ut_line, "~", UT_LINESIZE);
++      strncpy (u->ut_name, "runlevel", UT_NAMESIZE);
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    case BOOT_TIME:
++      strncpy (u->ut_line, "~", UT_LINESIZE);
++      strncpy (u->ut_name, "reboot", UT_NAMESIZE);
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    case NEW_TIME:
++      strncpy (u->ut_line, "{", UT_LINESIZE);
++      strncpy (u->ut_name, "date", UT_NAMESIZE);
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    case OLD_TIME:
++      strncpy (u->ut_line, "|", UT_LINESIZE);
++      strncpy (u->ut_name, "date", UT_NAMESIZE);
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    case INIT_PROCESS:
++    case LOGIN_PROCESS:
++    case USER_PROCESS:
++    case DEAD_PROCESS:
++      if (ux->ut_line[0] != '\0')
++	strncpy (u->ut_line, ux->ut_line, UT_LINESIZE);
++      else
++	strncpy (u->ut_line, ux->ut_id, sizeof (ux->ut_id));
++      switch (ux->ut_type)
++	{
++	case INIT_PROCESS:
++	  strncpy (u->ut_name, "INIT", UT_NAMESIZE);
++	  break;
++	case LOGIN_PROCESS:
++	  strncpy (u->ut_name, "LOGIN", UT_NAMESIZE);
++	  break;
++	case USER_PROCESS:
++	  strncpy (u->ut_name, ux->ut_user, UT_NAMESIZE);
++	  break;
++	case DEAD_PROCESS:
++	  strncpy (u->ut_name, "", UT_NAMESIZE);
++	  break;
++	}
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    case ACCOUNTING:
++      strncpy (u->ut_line, "~", UT_LINESIZE);
++      strncpy (u->ut_name, "acct", UT_NAMESIZE);
++      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
++      break;
++
++    default:
++      return -1;
++    }
++
++  u->ut_time = ux->ut_tv.tv_sec;
++
++  /* Hack: Put the ut_pid at a hidden place where there is likely room.  */
++  if (ux->ut_pid != 0)
++    {
++      size_t room = UT_HOSTSIZE - strlen (u->ut_host) - 1;
++
++      sprintf (buf, "%lu", (unsigned long) ux->ut_pid);
++      if (strlen (buf) <= room)
++	strncpy (u->ut_host + strlen (u->ut_host) + 1, buf, room);
++    }
++
++  return 0;
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,50 @@
++/* Copyright (C) 1996-1999,2000-2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <string.h>
++#include <utmp.h>
++
++#include "utmp-private.h"
++
++/* Test whether two entries match.  */
++static int
++__utmp_equal (const struct utmp *entry, const struct utmp *match)
++{
++  /* This implementation is consistent with the __utmp_to_utmpx function.  */
++  return
++    (!((entry->ut_line[0] == '\0' && entry->ut_name[0] == '\0'
++	&& entry->ut_host[0] == '\0')
++       || ((entry->ut_line[0] == '~' || entry->ut_line[0] == '{'
++	    || entry->ut_line[0] == '|')
++	   && entry->ut_line[1] == '\0'))
++     &&
++     !((match->ut_line[0] == '\0' && match->ut_name[0] == '\0'
++	&& match->ut_host[0] == '\0')
++       || ((match->ut_line[0] == '~' || match->ut_line[0] == '{'
++	    || match->ut_line[0] == '|')
++	   && match->ut_line[1] == '\0'))
++     &&
++#if _HAVE_UT_ID - 0
++     (entry->ut_id[0] && match->ut_id[0]
++      ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
++      : strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0)
++#else
++     strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0
++#endif
++     );
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1 @@
++#include <sysdeps/generic/utmp_file.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1 @@
++#include <sysdeps/unix/sysv/linux/utmp_file.c>
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,68 @@
++libc {
++  GLIBC_2.2.6 {
++    # c*
++    clone;
++
++    # e*
++    extattrctl; extattr_delete_file; extattr_get_file; extattr_set_file;
++
++    # f*
++    fhopen; fhstat; fhstatfs; futimes;
++
++    # g*
++    getdents; getfh; getfsstat; getfsstat64; getmntinfo; getmntinfo64;
++    getresgid; getresuid;
++
++    # i*
++    issetugid;
++
++    # j*
++    jail;
++
++    # k*
++    kldfind; kldfirstmod; kldload; kldnext; kldstat; kldsym; kldunload;
++    ktrace;
++
++    # l*
++    lchmod; lutimes;
++
++    # m*
++    minherit; modfind; modfnext; modnext; modstat;
++
++    # n*
++    ntp_adjtime; ntp_gettime;
++
++    # q*
++    quotactl;
++
++    # r*
++    rfork; rtprio;
++
++    # s*
++    sendfile; setresgid; setresuid; swapon; sysarch; sysctl; sysctlbyname;
++
++    # u*
++    undelete; unmount; utrace;
++
++    # see <sys/acl.h>.
++    __acl_aclcheck_fd; __acl_aclcheck_file; __acl_delete_fd; __acl_delete_file;
++    __acl_get_fd; __acl_get_file; __acl_set_fd; __acl_set_file;
++
++    # see <errno.h>.
++    __errno_location;
++
++    # see <sys/sysctl.h>.
++    __sysctl;
++
++    # Questionable system calls. These functions may be removed at any moment.
++    __syscall_aio_cancel; __syscall_aio_error; __syscall_aio_read;
++    __syscall_aio_return; __syscall_aio_suspend; __syscall_aio_waitcomplete;
++    __syscall_aio_write; __syscall_lio_listio;
++    __syscall_obreak;
++    __syscall_thr_sleep; __syscall_thr_wakeup; __syscall_yield;
++  }
++  GLIBC_PRIVATE {
++    # needed by libpthread.
++    __clone; __libc_fork; __libc_sigaction;
++  }
++}
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,47 @@
++/* writev for FreeBSD.
++   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/param.h>
++#include <sys/uio.h>
++
++#include <sysdep.h>
++#include <sys/syscall.h>
++#include <bp-checks.h>
++
++extern ssize_t __syscall_writev (int, const struct iovec *__unbounded, int);
++
++static ssize_t __atomic_writev_replacement (int, const struct iovec *,
++					    int) internal_function;
++
++ssize_t
++__libc_writev (int fd, const struct iovec *vector, int count)
++{
++  if (count <= UIO_MAXIOV)
++    return INLINE_SYSCALL (writev, 3, fd, CHECK_N (vector, count), count);
++  else
++    return __atomic_writev_replacement (fd, vector, count);
++}
++strong_alias (__libc_writev, __writev)
++weak_alias (__libc_writev, writev)
++
++#define __libc_writev static internal_function __atomic_writev_replacement
++#include <sysdeps/posix/writev.c>
++
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,48 @@
++/* xmknod call using old-style Unix mknod and mkfifo system calls.
++   Copyright (C) 1991, 1993, 1995-1997, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++
++extern int __syscall_mknod (const char *, mode_t, dev_t);
++extern int __mkfifo (const char *, mode_t);
++
++/* Create a device file named PATH, with permission and special bits MODE
++   and device number DEV (which can be constructed from major and minor
++   device numbers with the `makedev' macro above).  */
++int
++__xmknod (int vers, const char *path, mode_t mode, dev_t *dev)
++{
++  if (vers != _MKNOD_VER)
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++
++  /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
++     must use the mkfifo() system call for this purpose.  */
++  if (S_ISFIFO (mode))
++    return __mkfifo (path, mode & ~S_IFMT);
++
++  return __syscall_mknod (path, mode, *dev);
++}
++libc_hidden_def (__xmknod)
++
++weak_alias (__xmknod, _xmknod)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,47 @@
++/* xstat using FreeBSD stat, nstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_nstat (const char *__unbounded, struct stat32 *__unbounded);
++
++int
++__xstat64 (int vers, const char *file, struct stat64 *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nstat (CHECK_STRING (file), __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat64 (&buf32, buf);
++      return result;
++    }
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__xstat64)
+diff -Nur sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c	1970-01-01 01:00:00.000000000 +0100
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c	2005-08-23 17:35:07.000000000 +0200
+@@ -0,0 +1,57 @@
++/* xstat using FreeBSD stat, nstat system calls.
++   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stddef.h>
++#include <sys/stat.h>
++#include <bits/stat16.h>
++#include <bits/stat32.h>
++#include <bp-checks.h>
++
++#include "stat32conv.c"
++
++extern int __syscall_stat (const char *__unbounded, struct stat16 *__unbounded);
++extern int __syscall_nstat (const char *__unbounded, struct stat32 *__unbounded);
++
++int
++__xstat (int vers, const char *file, struct stat *buf)
++{
++  if (__builtin_expect (vers == _STAT_VER, 1))
++    {
++      struct stat32 buf32;
++      int result = __syscall_nstat (CHECK_STRING (file), __ptrvalue (&buf32));
++      if (result == 0)
++	stat32_to_stat (&buf32, buf);
++      return result;
++    }
++  else if (__builtin_expect (vers == _STAT_VER_nstat, 1))
++    return __syscall_nstat (CHECK_STRING (file),
++			    CHECK_1 ((struct stat32 *) buf));
++  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
++    return __syscall_stat (CHECK_STRING (file),
++			   CHECK_1 ((struct stat16 *) buf));
++  else
++    {
++      __set_errno (EINVAL);
++      return -1;
++    }
++}
++hidden_def (__xstat)
++
++weak_alias (__xstat, _xstat)
+--- sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile	2005-08-23 22:29:11.000000000 +0200
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile	2005-08-23 22:26:38.000000000 +0200
+@@ -0,0 +1,105 @@
++# Use bash, not /bin/sh, for executing scripts, because the native
++# FreeBSD /bin/sh does not interpret the  IFS="<tab>" read ...  command
++# in localedata/tst-fmon.sh correctly.
++SHELL = bash
++
++# Additional header files to be installed in $prefix/include:
++
++ifeq ($(subdir),misc)
++sysdep_headers += \
++ sys/ktrace.h \
++ sys/mount.h \
++ sys/rfork.h
++endif
++
++ifeq ($(subdir),stdlib)
++sysdep_headers += \
++ bits/mcontext.h
++endif
++
++# Additional functions, and particular system calls:
++
++ifeq ($(subdir),csu)
++# For <errno.h>.
++sysdep_routines += errno-loc
++endif
++
++ifeq ($(subdir),io)
++# For <unistd.h>.
++sysdep_routines += sys_getcwd sys_lseek
++# For <fcntl.h>.
++sysdep_routines += sys_open
++# For <sys/stat.h>.
++sysdep_routines += sys_fstat sys_lstat sys_mknod sys_nfstat sys_nlstat sys_nstat sys_stat
++# For <sys/statfs.h>.
++sysdep_routines += fstatfs64 statfs64
++# Other.
++sysdep_routines += lchmod
++endif
++
++ifeq ($(subdir),dirent)
++# For <dirent.h>.
++sysdep_routines += sys_getdents sys_getdirentries getdirentries getdirentries64
++endif
++
++ifeq ($(subdir),misc)
++# For <sched.h>.
++sysdep_routines += clone start_thread
++# For <unistd.h>.
++sysdep_routines += sys_ftruncate sys_truncate
++# For <sys/acl.h>.
++sysdep_routines += acl_aclcheck_fd acl_aclcheck_file acl_delete_fd acl_delete_file acl_get_fd acl_get_file acl_set_fd acl_set_file
++# For <sys/extattr.h>.
++sysdep_routines += extattrctl extattr_delete_file extattr_get_file extattr_set_file
++# For <sys/jail.h>.
++sysdep_routines += jail
++# For <sys/ktrace.h>.
++sysdep_routines += ktrace utrace
++# For <sys/linker.h>.
++sysdep_routines += kldfind kldfirstmod kldload kldnext kldstat kldsym kldunload
++# For <sys/mman.h>.
++sysdep_routines += minherit sys_mmap
++# For <sys/mount.h>.
++sysdep_routines += fhopen sys_fhstat fhstat fhstat64 fhstatfs fhstatfs64 getfh getfsstat getfsstat64 getmntinfo getmntinfo64
++# For <sys/ptrace.h>.
++sysdep_routines += sys_ptrace
++# For <sys/rfork.h>.
++sysdep_routines += rfork
++# For <sys/rtprio.h>.
++sysdep_routines += rtprio
++# For <sys/socket.h>.
++sysdep_routines += bsd_sendfile
++# For <sys/sysctl.h>.
++sysdep_routines += sysctl sysctlbyname
++# For <sys/uio.h>.
++sysdep_routines += sys_readv sys_writev
++# Other.
++sysdep_routines += sys_aio_cancel sys_aio_error sys_aio_read sys_aio_return sys_aio_suspend sys_aio_waitcomplete sys_aio_write sys_lio_listio issetugid modfind modfnext modnext modstat obreak quotactl rfork sysarch thr_sleep thr_wakeup undelete yield
++endif
++
++ifeq ($(subdir),posix)
++# For <unistd.h>.
++sysdep_routines += sys_getlogin sys_pread sys_pwrite sys_setlogin
++endif
++
++ifeq ($(subdir),time)
++# For <sys/timex.h>.
++sysdep_routines += ntp_adjtime ntp_gettime
++endif
++
++# Linuxthreads dependencies.
++
++ifeq ($(subdir),posix)
++sysdep_headers += bits/pthreadtypes.h bits/initspin.h
++endif
++
++# Don't compile the ctype glue code, since we have a much better <ctype.h>
++# than the old non-GNU C library.
++inhibit-glue = yes
++
++# Special ELF hacks.
++ifeq ($(subdir),elf)
++
++sysdep-rtld-routines += dl-brk dl-sbrk
++
++endif
+--- /dev/null	2005-08-24 15:28:26.000000000 +0200
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-procinfo.h	2005-08-24 15:31:57.000000000 +0200
+@@ -0,0 +1,47 @@
++/* kFreeBSD/i386 version of processor capability information handling macros.
++   Copyright (C) 1998-2002, 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _DL_PROCINFO_H
++
++#include <sysdeps/i386/dl-procinfo.h>
++#include <ldsodefs.h>
++
++
++#undef _dl_procinfo
++static inline int
++__attribute__ ((unused))
++_dl_procinfo (int word)
++{
++  int i;
++
++  _dl_printf ("AT_HWCAP:   ");
++
++  for (i = 0; i < _DL_HWCAP_COUNT; ++i)
++    if (word & (1 << i))
++      _dl_printf (" %s", GLRO(dl_x86_cap_flags)[i]);
++
++  _dl_printf ("\n");
++
++  return 0;
++}
++
++#define DL_ADJUST_PROCINFO
++
++#endif /* _DL_PROCINFO_H */
+--- /dev/null	2005-08-24 17:01:13.000000000 +0200
++++ sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-execstack.c	2005-08-24 17:00:56.000000000 +0200
+@@ -0,0 +1,58 @@
++/* Stack executability handling for GNU dynamic linker.  Linux version.
++   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <ldsodefs.h>
++#include <sys/mman.h>
++#include <errno.h>
++#include <libintl.h>
++#include <stdbool.h>
++#include <stackinfo.h>
++#include <caller.h>
++
++
++extern int __stack_prot attribute_relro attribute_hidden;
++
++
++int
++internal_function
++_dl_make_stack_executable (void **stack_endp)
++{
++  /* This gives us the highest/lowest page that needs to be changed.  */
++  uintptr_t page = ((uintptr_t) *stack_endp
++		    & -(intptr_t) GLRO(dl_pagesize));
++
++  /* Challenge the caller.  */
++  if (__builtin_expect (__check_caller (RETURN_ADDRESS (0),
++					allow_ldso|allow_libpthread) != 0, 0)
++      || __builtin_expect (*stack_endp != __libc_stack_end, 0))
++    return EPERM;
++
++  if (__builtin_expect (__mprotect ((void *) page, GLRO(dl_pagesize),
++				    __stack_prot) != 0, 0))
++    return errno;
++
++  /* Clear the address.  */
++  *stack_endp = NULL;
++
++  /* Remember that we changed the permission.  */
++  GL(dl_stack_flags) |= PF_X;
++
++  return 0;
++}
++rtld_hidden_def (_dl_make_stack_executable)
+--- /dev/null	2005-08-25 00:04:39.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/fork.c	2005-08-24 23:57:38.000000000 +0200
+@@ -0,0 +1,43 @@
++/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <fork.h>
++#include <bits/libc-lock.h>
++
++#ifndef SHARED
++weak_extern (__pthread_fork);
++#endif
++
++struct fork_block __fork_block =
++{
++  .lock = PTHREAD_MUTEX_INITIALIZER,
++  .prepare_list = { &__fork_block.prepare_list, &__fork_block.prepare_list },
++  .parent_list = { &__fork_block.parent_list, &__fork_block.parent_list },
++  .child_list = { &__fork_block.child_list, &__fork_block.child_list }
++};
++
++pid_t
++__libc_fork (void)
++{
++  return __libc_maybe_call2 (pthread_fork, (&__fork_block), ARCH_FORK ());
++}
++weak_alias (__libc_fork, __fork)
++libc_hidden_def (__fork)
++weak_alias (__libc_fork, fork)
+--- /dev/null	2005-08-25 00:04:44.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/fork.h	2005-08-24 23:57:38.000000000 +0200
+@@ -0,0 +1,60 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <list.h>
++#include <bits/libc-lock.h>
++#include <sysdep.h>
++
++struct fork_block
++{
++  /* Lock to protect handling of fork handlers.  */
++  __libc_lock_define (, lock);
++
++  /* Lists of registered fork handlers.  */
++  list_t prepare_list;
++  list_t parent_list;
++  list_t child_list;
++};
++
++extern struct fork_block __fork_block attribute_hidden;
++
++/* Elements of the fork handler lists.  */
++struct fork_handler
++{
++  list_t list;
++  void (*handler) (void);
++  void *dso_handle;
++};
++
++
++/* Function to call to unregister fork handlers.  */
++extern void __unregister_atfork (void *dso_handle) attribute_hidden;
++#define UNREGISTER_ATFORK(dso_handle) __unregister_atfork (dso_handle)
++
++
++/* C library side function to register new fork handlers.  */
++extern int __register_atfork (void (*__prepare) (void),
++			      void (*__parent) (void),
++			      void (*__child) (void),
++			      void *dso_handle);
++libc_hidden_proto (__register_atfork)
++
++#ifndef ARCH_FORK
++# define ARCH_FORK() INLINE_SYSCALL (fork, 0)
++#endif
+--- /dev/null	2005-08-25 00:04:51.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/raise.c	2005-08-24 23:57:46.000000000 +0200
+@@ -0,0 +1,36 @@
++/* Copyright (C) 1991, 1996, 2002, 2003 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <signal.h>
++#include <unistd.h>
++#include <bits/libc-lock.h>
++
++#ifndef SHARED
++weak_extern (__pthread_raise)
++#endif
++
++/* Raise the signal SIG.  */
++int
++raise (sig)
++     int sig;
++{
++  return __libc_maybe_call2 (pthread_raise, (sig),
++			     __kill (__getpid (), sig));
++}
++libc_hidden_def (raise)
++weak_alias (raise, gsignal)
+--- /dev/null	2005-08-25 00:04:51.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/register-atfork.c	2005-08-24 23:57:52.000000000 +0200
+@@ -0,0 +1,88 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stdlib.h>
++#include "fork.h"
++
++
++int
++__register_atfork (prepare, parent, child, dso_handle)
++     void (*prepare) (void);
++     void (*parent) (void);
++     void (*child) (void);
++     void *dso_handle;
++{
++  struct fork_handler *new_prepare = NULL;
++  struct fork_handler *new_parent = NULL;
++  struct fork_handler *new_child = NULL;
++
++  if (prepare != NULL)
++    {
++      new_prepare = (struct fork_handler *) malloc (sizeof (*new_prepare));
++      if (new_prepare == NULL)
++	goto out1;
++
++      new_prepare->handler = prepare;
++      new_prepare->dso_handle = dso_handle;
++    }
++
++  if (parent != NULL)
++    {
++      new_parent = (struct fork_handler *) malloc (sizeof (*new_parent));
++      if (new_parent == NULL)
++	goto out2;
++
++      new_parent->handler = parent;
++      new_parent->dso_handle = dso_handle;
++    }
++
++  if (child != NULL)
++    {
++      new_child = (struct fork_handler *) malloc (sizeof (*new_child));
++      if (new_child == NULL)
++	{
++	  free (new_parent);
++	out2:
++	  free (new_prepare);
++	out1:
++	  return errno;
++	}
++
++      new_child->handler = child;
++      new_child->dso_handle = dso_handle;
++    }
++
++  /* Get the lock to not conflict with running forks.  */
++  __libc_lock_lock (__fork_block.lock);
++
++  /* Now that we have all the handlers allocate enqueue them.  */
++  if (new_prepare != NULL)
++    list_add_tail (&new_prepare->list, &__fork_block.prepare_list);
++  if (new_parent != NULL)
++    list_add_tail (&new_parent->list, &__fork_block.parent_list);
++  if (new_child != NULL)
++    list_add_tail (&new_child->list, &__fork_block.child_list);
++
++  /* Release the lock.  */
++  __libc_lock_unlock (__fork_block.lock);
++
++  return 0;
++}
++libc_hidden_def (__register_atfork)
+--- /dev/null	2005-08-25 00:04:51.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/unregister-atfork.c	2005-08-24 23:57:55.000000000 +0200
+@@ -0,0 +1,49 @@
++/* Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <stdlib.h>
++#include "fork.h"
++
++
++void
++__unregister_atfork (dso_handle)
++     void *dso_handle;
++{
++  /* Get the lock to not conflict with running forks.  */
++  __libc_lock_lock (__fork_block.lock);
++
++  list_t *runp;
++  list_t *prevp;
++
++  list_for_each_prev_safe (runp, prevp, &__fork_block.prepare_list)
++    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
++      list_del (runp);
++
++  list_for_each_prev_safe (runp, prevp, &__fork_block.parent_list)
++    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
++      list_del (runp);
++
++  list_for_each_prev_safe (runp, prevp, &__fork_block.child_list)
++    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
++      list_del (runp);
++
++  /* Release the lock.  */
++  __libc_lock_unlock (__fork_block.lock);
++}
+--- /dev/null	2005-08-25 00:05:15.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions	2005-08-24 23:58:04.000000000 +0200
+@@ -0,0 +1,5 @@
++libc {
++  GLIBC_2.3.2 {
++    __register_atfork;
++  }
++}
+--- /dev/null	2005-08-25 00:05:21.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile	2005-08-24 23:57:32.000000000 +0200
+@@ -0,0 +1,3 @@
++ifeq ($(subdir),linuxthreads)
++sysdep_routines += register-atfork unregister-atfork
++endif
+--- /dev/null	2005-08-25 00:29:00.000000000 +0200
++++ ./linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep-cancel.h	2005-08-25 00:28:44.000000000 +0200
+@@ -0,0 +1,177 @@
++/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++#include <tls.h>
++#include <pt-machine.h>
++#ifndef __ASSEMBLER__
++# include <linuxthreads/internals.h>
++#endif
++
++#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
++
++# undef PSEUDO
++# define PSEUDO(name, syscall_name, args)				      \
++  .text;								      \
++  ENTRY (name)								      \
++    SINGLE_THREAD_P;							      \
++    jne L(pseudo_cancel);						      \
++    DO_CALL (syscall_name, args);					      \
++    jb SYSCALL_ERROR_LABEL;						      \
++    ret;								      \
++  L(pseudo_cancel):							      \
++    CENABLE								      \
++    SAVE_OLDTYPE_##args							      \
++    PUSHCARGS_##args							      \
++    DOCARGS_##args							      \
++    movl $SYS_ify (syscall_name), %eax;					      \
++    int $0x80								      \
++    POPCARGS_##args;							      \
++    POPSTATE_##args							      \
++    jb SYSCALL_ERROR_LABEL;						      \
++  L(pseudo_end):
++
++# define SAVE_OLDTYPE_0	movl %eax, %ecx;
++# define SAVE_OLDTYPE_1	SAVE_OLDTYPE_0
++# define SAVE_OLDTYPE_2	pushl %eax;
++# define SAVE_OLDTYPE_3	SAVE_OLDTYPE_2
++# define SAVE_OLDTYPE_4	SAVE_OLDTYPE_2
++# define SAVE_OLDTYPE_5	SAVE_OLDTYPE_2
++
++# define PUSHCARGS_0	/* No arguments to push.  */
++# define DOCARGS_0	/* No arguments to frob.  */
++# define POPCARGS_0	/* No arguments to pop.  */
++# define _PUSHCARGS_0	/* No arguments to push.  */
++# define _POPCARGS_0	/* No arguments to pop.  */
++
++# define PUSHCARGS_1	movl %ebx, %edx; PUSHCARGS_0
++# define DOCARGS_1	_DOARGS_1 (4)
++# define POPCARGS_1	POPCARGS_0; movl %edx, %ebx
++# define _PUSHCARGS_1	pushl %ebx; L(PUSHBX2): _PUSHCARGS_0
++# define _POPCARGS_1	_POPCARGS_0; popl %ebx; L(POPBX2):
++
++# define PUSHCARGS_2	PUSHCARGS_1
++# define DOCARGS_2	_DOARGS_2 (12)
++# define POPCARGS_2	POPCARGS_1
++# define _PUSHCARGS_2	_PUSHCARGS_1
++# define _POPCARGS_2	_POPCARGS_1
++
++# define PUSHCARGS_3	_PUSHCARGS_2
++# define DOCARGS_3	_DOARGS_3 (20)
++# define POPCARGS_3	_POPCARGS_3
++# define _PUSHCARGS_3	_PUSHCARGS_2
++# define _POPCARGS_3	_POPCARGS_2
++
++# define PUSHCARGS_4	_PUSHCARGS_4
++# define DOCARGS_4	_DOARGS_4 (28)
++# define POPCARGS_4	_POPCARGS_4
++# define _PUSHCARGS_4	pushl %esi; L(PUSHSI2): _PUSHCARGS_3
++# define _POPCARGS_4	_POPCARGS_3; popl %esi; L(POPSI2):
++
++# define PUSHCARGS_5	_PUSHCARGS_5
++# define DOCARGS_5	_DOARGS_5 (36)
++# define POPCARGS_5	_POPCARGS_5
++# define _PUSHCARGS_5	pushl %edi; L(PUSHDI2): _PUSHCARGS_4
++# define _POPCARGS_5	_POPCARGS_4; popl %edi; L(POPDI2):
++
++# ifdef IS_IN_libpthread
++#  define CENABLE	call __pthread_enable_asynccancel;
++#  define CDISABLE	call __pthread_disable_asynccancel
++# elif defined IS_IN_librt
++#  ifdef PIC
++#   define CENABLE	pushl %ebx; \
++			call __i686.get_pc_thunk.bx; \
++			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
++			call __librt_enable_asynccancel@PLT; \
++			popl %ebx;
++#   define CDISABLE	pushl %ebx; \
++			call __i686.get_pc_thunk.bx; \
++			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
++			call __librt_disable_asynccancel@PLT; \
++			popl %ebx;
++#  else
++#   define CENABLE	call __librt_enable_asynccancel;
++#   define CDISABLE	call __librt_disable_asynccancel
++#  endif
++# else
++#  define CENABLE	call __libc_enable_asynccancel;
++#  define CDISABLE	call __libc_disable_asynccancel
++# endif
++# define POPSTATE_0	pushl %eax; movl %ecx, %eax; CDISABLE; popl %eax;
++# define POPSTATE_1	POPSTATE_0
++# define POPSTATE_2	xchgl (%esp), %eax; CDISABLE; popl %eax;
++# define POPSTATE_3	POPSTATE_2
++# define POPSTATE_4	POPSTATE_2
++# define POPSTATE_5	POPSTATE_2
++
++#if !defined NOT_IN_libc
++# define __local_multiple_threads __libc_multiple_threads
++#elif defined IS_IN_libpthread
++# define __local_multiple_threads __pthread_multiple_threads
++#else
++# define __local_multiple_threads __librt_multiple_threads
++#endif
++
++# ifndef __ASSEMBLER__
++#  if defined FLOATING_STACKS && USE___THREAD && defined PIC
++#   define SINGLE_THREAD_P \
++  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
++				   p_header.data.multiple_threads) == 0, 1)
++#  else
++extern int __local_multiple_threads
++#   if !defined NOT_IN_libc || defined IS_IN_libpthread
++  attribute_hidden;
++#   else
++  ;
++#   endif
++#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
++#  endif
++# else
++#  if !defined PIC
++#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads
++#  elif defined FLOATING_STACKS && USE___THREAD
++#   define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
++#  else
++#   if !defined NOT_IN_libc || defined IS_IN_libpthread
++#    define __SINGLE_THREAD_CMP cmpl $0, __local_multiple_threads@GOTOFF(%ecx)
++#   else
++#    define __SINGLE_THREAD_CMP \
++  movl __local_multiple_threads@GOT(%ecx), %ecx;\
++  cmpl $0, (%ecx)
++#   endif
++#   if !defined HAVE_HIDDEN || !USE___THREAD
++#    define SINGLE_THREAD_P \
++  SETUP_PIC_REG (cx);				\
++  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
++  __SINGLE_THREAD_CMP
++#   else
++#    define SINGLE_THREAD_P \
++  call __i686.get_pc_thunk.cx;			\
++  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
++  __SINGLE_THREAD_CMP
++#   endif
++#  endif
++# endif
++
++#elif !defined __ASSEMBLER__
++
++/* This code should never be used but we define it anyhow.  */
++# define SINGLE_THREAD_P (1)
++
++#endif
+--- /dev/null	2005-08-25 00:57:30.000000000 +0200
++++ ./sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls.list	2005-08-25 01:00:29.000000000 +0200
+@@ -0,0 +1,131 @@
++# File name	Caller	Syscall name		# args	Strong name	Weak names
++
++acl_aclcheck_fd	-	acl_aclcheck_fd		i:iip	__acl_aclcheck_fd
++acl_aclcheck_file -	acl_aclcheck_file	i:sip	__acl_aclcheck_file
++acl_delete_fd	-	acl_delete_fd		i:ii	__acl_delete_fd
++acl_delete_file	-	acl_delete_file		i:si	__acl_delete_file
++acl_get_fd	-	acl_get_fd		i:iip	__acl_get_fd
++acl_get_file	-	acl_get_file		i:sip	__acl_get_file
++acl_set_fd	-	acl_set_fd		i:iip	__acl_set_fd
++acl_set_file	-	acl_set_file		i:sip	__acl_set_file
++sys_aio_cancel	-	aio_cancel		i:ip	__syscall_aio_cancel
++sys_aio_error	-	aio_error		i:p	__syscall_aio_error
++sys_aio_read	-	aio_read		i:p	__syscall_aio_read
++sys_aio_return	-	aio_return		i:p	__syscall_aio_return
++sys_aio_suspend	-	aio_suspend		i:bnP	__syscall_aio_suspend
++sys_aio_waitcomplete -	aio_waitcomplete	i:pp	__syscall_aio_waitcomplete
++sys_aio_write	-	aio_write		i:p	__syscall_aio_write
++sys_clock_getres -	clock_getres		i:ip	__syscall_clock_getres
++sys_clock_gettime -	clock_gettime		i:ip	__syscall_clock_gettime
++sys_clock_settime -	clock_settime		i:ip	__syscall_clock_settime
++sys_execve	-	execve			i:ppp	__syscall_execve
++extattrctl	-	extattrctl		i:sisI	extattrctl
++extattr_delete_file -	extattr_delete_file	i:ss	extattr_delete_file
++extattr_get_file -	extattr_get_file	i:ssbn	extattr_get_file
++extattr_set_file -	extattr_set_file	i:ssbn	extattr_set_file
++fhopen		-	fhopen			i:pi	fhopen
++sys_fork	-	fork			i:	__syscall_fork fork
++sys_fhstat	-	fhstat			i:pp	__syscall_fhstat
++fhstatfs	-	fhstatfs		i:pp	__fhstatfs	fhstatfs
++sys_fstat	-	fstat			i:ip	__syscall_fstat
++sys_ftruncate	-	ftruncate		i:iii	__syscall_ftruncate
++futimes		-	futimes			i:ip	__futimes	futimes
++sys_getcwd	-	getcwd			i:bn	__syscall_getcwd
++sys_getdents	-	getdents		i:ibn	__syscall_getdents
++sys_getdirentries -	getdirentries		i:ibnP	__syscall_getdirentries
++getfh		-	getfh			i:sp	getfh
++getfsstat	-	getfsstat		i:pii	__getfsstat	getfsstat
++sys_getlogin	-	getlogin		i:bn	__syscall_getlogin
++getpgid		-	getpgid			i:i	__getpgid	__getpgid_internal getpgid
++getpgrp		-	getpgrp			i:	getpgrp
++getresgid	-	getresgid		i:ppp	getresgid
++getresuid	-	getresuid		i:ppp	getresuid
++getrlimit	-	getrlimit		i:ip	__getrlimit	getrlimit getrlimit64
++getsid		-	getsid			i:i	getsid
++issetugid	-	issetugid		i:	issetugid
++jail		-	jail			i:p	jail
++kldfind		-	kldfind			i:s	kldfind
++kldfirstmod	-	kldfirstmod		i:i	kldfirstmod
++kldload		-	kldload			i:s	kldload
++kldnext		-	kldnext			i:i	kldnext
++kldstat		-	kldstat			i:ip	kldstat
++kldsym		-	kldsym			i:iip	kldsym
++kldunload	-	kldunload		i:i	kldunload
++ktrace		-	ktrace			i:siii	ktrace
++lchmod		-	lchmod			i:si	lchmod
++lchown		-	lchown			i:sii	__lchown	lchown
++sys_lio_listio	-	lio_listio		i:ibnP	__syscall_lio_listio
++sys_lseek	-	lseek			i:iiii	__syscall_lseek
++sys_lstat	-	lstat			i:sp	__syscall_lstat
++lutimes		-	lutimes			i:sp	__lutimes	lutimes
++posix_madvise	-	madvise			i:pii	posix_madvise
++minherit	-	minherit		i:aii	minherit
++mincore		-	mincore			i:anV	mincore
++mlock		-	mlock			i:bn	mlock
++mlockall	-	mlockall		i:i	mlockall
++mkfifo		-	mkfifo			i:si	__mkfifo	mkfifo
++sys_mknod	-	mknod			i:sii	__syscall_mknod
++sys_mmap	-	mmap			b:aniiiii __syscall_mmap
++modfind		-	modfind			i:s	modfind
++modfnext	-	modfnext		i:i	modfnext
++modnext		-	modnext			i:i	modnext
++modstat		-	modstat			i:ip	modstat
++msgctl		-	msgctl			i:iip	msgctl
++msgget		-	msgget			i:ii	msgget
++msgrcv		-	msgrcv			i:ibnii	__libc_msgrcv	msgrcv
++msgsnd		-	msgsnd			i:ibni	__libc_msgsnd	msgsnd
++munlock		-	munlock			i:ai	munlock
++munlockall	-	munlockall		i:	munlockall
++nanosleep	-	nanosleep		i:pp	__libc_nanosleep __nanosleep nanosleep
++sys_nfstat	-	nfstat			i:ip	__syscall_nfstat
++sys_nlstat	-	nlstat			i:sp	__syscall_nlstat
++sys_nstat	-	nstat			i:sp	__syscall_nstat
++ntp_adjtime	-	ntp_adjtime		i:p	ntp_adjtime
++obreak		-	obreak			i:a	__syscall_obreak
++sys_open	-	open			i:siv	__syscall_open
++poll		-	poll			i:pii	__poll		poll
++sys_pread	-	pread			i:ibnii	__syscall_pread
++sys_ptrace	-	ptrace			i:iipi	__syscall_ptrace
++sys_pwrite	-	pwrite			i:ibnii	__syscall_pwrite
++quotactl	-	quotactl		i:siip	quotactl
++sys_readv	-	readv			i:ipi	__syscall_readv
++rfork		-	rfork			i:i	__rfork		rfork
++rtprio		-	rtprio			i:iip	__rtprio	rtprio
++sched_gets	-	sched_getscheduler	i:i	__sched_getscheduler sched_getscheduler
++sched_primax	-	sched_get_priority_max	i:i	__sched_get_priority_max sched_get_priority_max
++sched_primin	-	sched_get_priority_min	i:i	__sched_get_priority_min sched_get_priority_min
++sched_rr_gi	-	sched_rr_get_interval	i:ip	__sched_rr_get_interval sched_rr_get_interval
++sched_setp	-	sched_setparam		i:ip	__sched_setparam sched_setparam
++sched_sets	-	sched_setscheduler	i:iip	__sched_setscheduler sched_setscheduler
++sched_yield	-	sched_yield		i:	__sched_yield sched_yield
++semget		-	semget			i:iii	semget
++semop		-	semop			i:ipi	semop
++bsd_sendfile	-	sendfile		i:iiiippi bsd_sendfile
++setegid		-	setegid			i:i	setegid
++seteuid		-	seteuid			i:i	seteuid
++setgid		-	setgid			i:i	__setgid	setgid
++sys_setlogin	-	setlogin		i:s	__syscall_setlogin
++setpgid		-	setpgid			i:ii	__setpgid	setpgid
++setresgid	-	setresgid		i:iii	setresgid
++setresuid	-	setresuid		i:iii	setresuid
++setrlimit	-	setrlimit		i:ip	__setrlimit	setrlimit setrlimit64
++setsid		-	setsid			i:	__setsid	setsid
++setuid		-	setuid			i:i	__setuid	setuid
++shmat		-	shmat			i:iai	shmat
++shmctl		-	shmctl			i:iip	shmctl
++shmdt		-	shmdt			i:a	shmdt
++shmget		-	shmget			i:iii	shmget
++sys_sigaction	-	sigaction		i:ipp   __syscall_sigaction
++sigpending	-	sigpending		i:p	sigpending
++sigprocmask	-	sigprocmask		i:iPP	__sigprocmask	sigprocmask
++sigsuspend	-	sigsuspend		i:p	__sigsuspend	sigsuspend
++sys_stat	-	stat			i:sp	__syscall_stat
++sysarch		-	sysarch			i:ip	__sysarch	sysarch
++sysctl		-	sysctl			i:pibNbn __sysctl	sysctl
++thr_sleep	-	thr_sleep		i:p	__syscall_thr_sleep
++thr_wakeup	-	thr_wakeup		i:i	__syscall_thr_wakeup
++sys_truncate	-	truncate		i:sii	__syscall_truncate
++undelete	-	undelete		i:s	undelete
++utrace		-	utrace			i:bn	utrace
++sys_writev	-	writev			i:ipi	__syscall_writev
++yield		-	yield			i:	__syscall_yield
+--- /dev/null	2005-08-25 00:57:30.000000000 +0200
++++ linuxthreads/sysdeps/unix/bsd/bsd4.4/kfreebsd/execve.c	2005-08-25 00:34:58.000000000 +0200
+@@ -0,0 +1,42 @@
++/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <errno.h>
++#include <unistd.h>
++
++#include <sysdep.h>
++#include <alloca.h>
++#include <sys/syscall.h>
++#include <bp-checks.h>
++
++extern void __pthread_kill_other_threads_np (void);
++weak_extern (__pthread_kill_other_threads_np)
++
++int
++__execve (file, argv, envp)
++     const char *file;
++     char *const argv[];
++     char *const envp[];
++{
++  /* If this is a threaded application kill all other threads.  */
++  if (__pthread_kill_other_threads_np)
++    __pthread_kill_other_threads_np ();
++  
++  return INLINE_SYSCALL (execve, 3, file, argv, envp);
++}
++weak_alias (__execve, execve)
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/patches/kfreebsd-ugly-hacks.dpatch
+++ glibc-2.3.5/debian/patches/kfreebsd-ugly-hacks.dpatch
@@ -0,0 +1,45 @@
+#! /bin/sh -e
+
+# All lines beginning with `# DP:' are a description of the patch.
+# DP: Description: Ugly hacks to support GNU/kFreeBSD
+# DP: Related bugs: 
+# DP: Dpatch author: aurel32@debian.org
+# DP: Patch author: aurel32@debian.org
+# DP: Upstream status: Not submitted
+# DP: Status Details: 
+# DP: Date: 20050616
+
+if [ $# -ne 2 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+case "$1" in
+    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
+    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
+    *)
+	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+	exit 1
+esac
+exit 0
+# append the patch here and adjust the -p? flag in the patch calls.
+--- sysdeps/gnu/_G_config.h.orig	2005-08-18 23:12:51.000000000 +0200
++++ sysdeps/gnu/_G_config.h	2005-08-18 23:13:09.000000000 +0200
+@@ -69,7 +69,6 @@
+ 
+ #define _G_HAVE_PRINTF_FP 1
+ #define _G_HAVE_MMAP 1
+-#define _G_HAVE_MREMAP 1
+ #define _G_HAVE_LONG_DOUBLE_IO 1
+ #define _G_HAVE_IO_FILE_OPEN 1
+ #define _G_HAVE_IO_GETLINE_INFO 1
+--- elf/dl-load.c.orig	2005-08-24 01:45:36.000000000 +0200
++++ elf/dl-load.c	2005-08-18 16:54:47.000000000 +0200
+@@ -1495,7 +1495,7 @@
+     [EI_CLASS] = ELFW(CLASS),
+     [EI_DATA] = byteorder,
+     [EI_VERSION] = EV_CURRENT,
+-    [EI_OSABI] = ELFOSABI_SYSV,
++    [EI_OSABI] = ELFOSABI_FREEBSD,
+     [EI_ABIVERSION] = 0
+   };
+   static const struct
only in patch2:
unchanged:
--- glibc-2.3.5.orig/debian/sysdeps/kfreebsd.mk
+++ glibc-2.3.5/debian/sysdeps/kfreebsd.mk
@@ -0,0 +1,60 @@
+GLIBC_OVERLAYS ?= $(shell ls nptl* glibc-linuxthreads* glibc-ports* glibc-libidn*)
+MIN_KERNEL_SUPPORTED := 5.2.0
+libc = libc0.1
+
+# Support multiple makes at once based on number of processors
+# Common wisdom says parallel make can be up to 2n+1.
+# Should we do that to get faster builds?
+NJOBS:=$(shell getconf _NPROCESSORS_ONLN 2>/dev/null || echo 1)
+ifeq ($(NJOBS),-1)
+ NJOBS:=1
+endif
+
+ifeq ($(NJOBS),0)
+ NJOBS=1
+endif
+
+# Linuxthreads Config
+threads = yes
+libc_add-ons = linuxthreads $(add-ons)
+
+libc_extra_config_options = $(extra_config_options) --without-tls --disable-compatible-utmp
+
+ifndef KFREEBSD_SOURCE
+  KFREEBSD_HEADERS := /usr/include
+else
+  KFREEBSD_HEADERS := $(KFREEBSD_SOURCE)/sys
+endif
+
+# Minimum Kernel supported
+with_headers = --with-headers=$(shell pwd)/debian/include --enable-kernel=$(call xx,MIN_KERNEL_SUPPORTED)
+
+KERNEL_HEADER_DIR = $(stamp)mkincludedir
+$(stamp)mkincludedir:
+	rm -rf debian/include
+	mkdir debian/include
+	ln -s $(KFREEBSD_HEADERS)/machine debian/include
+	ln -s $(KFREEBSD_HEADERS)/net debian/include
+	ln -s $(KFREEBSD_HEADERS)/osreldate.h debian/include
+	ln -s $(KFREEBSD_HEADERS)/sys debian/include
+	ln -s $(KFREEBSD_HEADERS)/vm debian/include
+
+	# To make configure happy if libc0.1-dev is not installed.
+	touch debian/include/assert.h
+
+	touch $@
+
+# Also to make configure happy.
+export CPPFLAGS = -isystem $(shell pwd)/debian/include
+
+# This round of ugliness decomposes the FreeBSD kernel version number
+# into an integer so it can be easily compared and then does so.
+CURRENT_KERNEL_VERSION=$(shell uname -r)
+define kernel_check
+(minimum=$$((`echo $(1) | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1 \* 10000 + \2 \* 100 + \3/'`)); \
+current=$$((`echo $(CURRENT_KERNEL_VERSION) | sed 's/\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100/'`)); \
+if [ $$current -lt $$minimum ]; then \
+  false; \
+fi)
+endef
+
