
clisp currently fails on both kfreebsd-i386 and kfreebsd-amd64

Even clisp 2.38-7 (available from gnuab) is not buildable on 
current kfreebsd-i386 (neither with current libsigsegv 2.4-4, 
neither with libsigsegv 2.3-3). 
This is long standing indirect regression, cause still unknown :-(


There is also issue with libsigsegv in our glibc (fixed in r2025).
The pthread wrapper around signal handler does not pass 4th argument.   
As a result, loading of libpthread.so breaks functionality of libsigsegv


libsigsegv 2.4-4 needs small fixup for amd64,
upcoming libsigsegv 2.5 also for configure.ac/configure:

diff -ur libsigsegv-2.5/src/fault-freebsd-i386.h libsigsegv-2.5/src/fault-freebsd-i386.h
--- libsigsegv-2.5/src/fault-freebsd-i386.h	2005-05-20 21:47:21.000000000 +0200
+++ libsigsegv-2.5/src/fault-freebsd-i386.h	2007-11-15 16:38:38.000000000 +0100
@@ -18,4 +18,8 @@
 #define SIGSEGV_FAULT_HANDLER_ARGLIST  int sig, int code, struct sigcontext *scp, void *addr
 #define SIGSEGV_FAULT_ADDRESS  addr
 #define SIGSEGV_FAULT_CONTEXT  scp
+#ifdef __x86_64__
+#define SIGSEGV_FAULT_STACKPOINTER  scp->sc_rsp
+#else
 #define SIGSEGV_FAULT_STACKPOINTER  scp->sc_esp
+#endif
diff -ur libsigsegv-2.5/configure.ac libsigsegv-2.5/configure.ac
--- libsigsegv-2.5/configure.ac	2007-11-11 19:35:23.000000000 +0100
+++ libsigsegv-2.5/configure.ac	2007-11-15 16:34:43.000000000 +0100
@@ -74,7 +74,7 @@
 dnl List of signals that are sent when an invalid virtual memory address
 dnl is accessed, or when the stack overflows.
 case "$host_os" in
-  sunos4* | freebsd* | openbsd* | netbsd*)
+  sunos4* | freebsd* | openbsd* | netbsd* | k*bsd*)
     CFG_SIGNALS=signals-bsd.h ;;
   hpux*)
     CFG_SIGNALS=signals-hpux.h ;;
@@ -298,7 +298,7 @@
 fi
 if test -z "$CFG_FAULT" && test "$sv_cv_fault_bsd" = yes; then
   case "$host_os" in
-    freebsd*)
+    freebsd*|kfreebsd*)
       case "$host_cpu" in
         i?86 | x86_64)
           CFG_FAULT=fault-freebsd-i386.h
diff -ur libsigsegv-2.5/configure libsigsegv-2.5/configure
--- libsigsegv-2.5/configure	2007-11-11 19:39:31.000000000 +0100
+++ libsigsegv-2.5/configure	2007-11-15 16:36:26.000000000 +0100
@@ -19468,7 +19468,7 @@
 
 
 case "$host_os" in
-  sunos4* | freebsd* | openbsd* | netbsd*)
+  sunos4* | freebsd* | openbsd* | netbsd* | k*bsd*)
     CFG_SIGNALS=signals-bsd.h ;;
   hpux*)
     CFG_SIGNALS=signals-hpux.h ;;
@@ -23351,7 +23351,7 @@
 fi
 if test -z "$CFG_FAULT" && test "$sv_cv_fault_bsd" = yes; then
   case "$host_os" in
-    freebsd*)
+    freebsd*|kfreebsd*)
       case "$host_cpu" in
         i?86 | x86_64)
           CFG_FAULT=fault-freebsd-i386.h



ffcall does not work correctly, see #451356

also main clisp needs fix up for kfreebsd-amd64:


only in patch2:
unchanged:
--- clisp-2.42.orig/configure
+++ clisp-2.42/configure
@@ -726,8 +726,10 @@
 stacksizelimit=`ulimit -s 2>/dev/null || :` # cygwin /bin/sh ulimit is broken
 # need 3 separate test calls because of "integer expression expected" errors
 # when $stacksizelimit is "" or "unlimited" (no short-circuiting!)
+set +e
 test -z "$stacksizelimit" || { test "$stacksizelimit" != unlimited && test "$stacksizelimit" -lt ${STACK_LIMIT}; }
 STACK_TOO_SMALL=$?      # 0=true => need to reset; 1=false => big enough
+set -e
 
 if test -z "$do_build"; then
 
only in patch2:
unchanged:
--- clisp-2.42.orig/src/lispbibl.d
+++ clisp-2.42/src/lispbibl.d
@@ -3000,7 +3000,7 @@
 #endif
 
 
-#if (oint_addr_shift == 0) && (addr_shift == 0) && defined(TYPECODES) && !defined(WIDE_SOFT) && !(defined(SUN3) && !defined(UNIX_SUNOS4) && !defined(WIDE_SOFT)) && !(defined(AMD64) && defined(UNIX_LINUX))
+#if (oint_addr_shift == 0) && (addr_shift == 0) && defined(TYPECODES) && !defined(WIDE_SOFT) && !(defined(SUN3) && !defined(UNIX_SUNOS4) && !defined(WIDE_SOFT)) && !defined(AMD64)
 # If the address bits are the lower ones and not WIDE_SOFT,
 # memory mapping may be possible.
 
only in patch2:
unchanged:
--- clisp-2.42.orig/src/spvw.d
+++ clisp-2.42/src/spvw.d
@@ -2682,7 +2682,7 @@
       var aint end = bitm(oint_addr_len-1); # keep garcol_bit zero
        #endif
       var aint part = floor(end - (start & (end-1)),5);
-      #if defined(AMD64) && defined(UNIX_LINUX)
+      #if defined(AMD64)
       # Don't use more than 36 address bits, otherwise mmap() fails.
       part &= 0x0000000FFFFFFFFFUL;
       #endif
@@ -2724,7 +2724,7 @@
         #endif
        #endif
       var aint part = floor(end - (start & (end-1)),5);
-      #if defined(AMD64) && defined(UNIX_LINUX)
+      #if defined(AMD64)
       # Don't use more than 36 address bits, otherwise mmap() fails.
       part &= 0x0000000FFFFFFFFFUL;
       #endif
only in patch2:
unchanged:
--- clisp-2.42.orig/src/spvw_page.d
+++ clisp-2.42/src/spvw_page.d
@@ -113,7 +113,7 @@
       # only a 2^32 size address space.
       #define oint_addr_relevant_len  32
     #endif
-    #if (defined(IA64) || defined(AMD64)) && defined(UNIX_LINUX)
+    #if (defined(IA64) || defined(AMD64))
       # It is unlikely that more than 4 GB will be used.
       #define oint_addr_relevant_len  32
     #endif
