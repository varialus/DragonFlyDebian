diff -Nur sysdeps/generic/accept.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/accept.c
--- sysdeps/generic/accept.c	2001-07-07 21:21:19.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/accept.c	2002-12-31 21:38:16.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,6 +33,7 @@
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (accept)
 
 
 stub_warning (accept)
diff -Nur sysdeps/generic/allocalim.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/allocalim.h
--- sysdeps/generic/allocalim.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/allocalim.h	2002-10-09 11:19:59.000000000 +0200
@@ -0,0 +1,4 @@
+extern inline int __libc_use_alloca (size_t size)
+{
+  return size <= __MAX_ALLOCA_CUTOFF;
+}
diff -Nur sysdeps/generic/allocrtsig.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/allocrtsig.c
--- sysdeps/generic/allocrtsig.c	2002-08-12 02:17:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/allocrtsig.c	2002-12-31 21:38:40.000000000 +0100
@@ -33,7 +33,7 @@
 
 static int initialized;
 
-#include "testrtsig.h"
+#include <testrtsig.h>
 
 static void
 init (void)
@@ -62,6 +62,7 @@
 #endif
   return current_rtmin;
 }
+libc_hidden_def (__libc_current_sigrtmin)
 
 /* Return number of available real-time signal with lowest priority.  */
 int
@@ -73,6 +74,7 @@
 #endif
   return current_rtmax;
 }
+libc_hidden_def (__libc_current_sigrtmax)
 
 /* Allocate real-time signal with highest/lowest available
    priority.  Please note that we don't use a lock since we assume
diff -Nur sysdeps/generic/atomicity.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/atomicity.h
--- sysdeps/generic/atomicity.h	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/atomicity.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/* Low-level functions for atomic operations.  Stub version.
-   Copyright (C) 1997,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _ATOMICITY_H
-#define _ATOMICITY_H	1
-
-#include <inttypes.h>
-
-#warning stub atomicity functions are not atomic
-
-static inline int
-__attribute__ ((unused))
-exchange_and_add (volatile uint32_t *mem, int val)
-{
-  int result = *mem;
-  *mem += val;
-  return result;
-}
-
-static inline void
-__attribute__ ((unused))
-atomic_add (volatile uint32_t *mem, int val)
-{
-  *mem += val;
-}
-
-static inline int
-__attribute__ ((unused))
-compare_and_swap (volatile long int *p, long int oldval, long int newval)
-{
-  if (*p != oldval)
-    return 0;
-
-  *p = newval;
-  return 1;
-}
-
-#endif /* atomicity.h */
diff -Nur sysdeps/generic/backtrace.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/backtrace.c
--- sysdeps/generic/backtrace.c	2002-07-15 04:08:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/backtrace.c	2004-01-16 09:07:01.000000000 +0100
@@ -1,5 +1,5 @@
 /* Return backtrace of current program state.  Generic version.
-   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -23,11 +23,7 @@
 #include <frame.h>
 #include <sigcontextinfo.h>
 #include <bp-checks.h>
-
-/* This is a global variable set at program start time.  It marks the
-   highest used stack address.  */
-extern void *__libc_stack_end;
-
+#include <ldsodefs.h>
 
 /* This implementation assumes a stack layout that matches the defaults
    used by gcc's `__builtin_frame_address' and `__builtin_return_address'
diff -Nur sysdeps/generic/backtracesymsfd.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/backtracesymsfd.c
--- sysdeps/generic/backtracesymsfd.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/backtracesymsfd.c	2003-04-19 18:52:31.000000000 +0200
@@ -1,5 +1,5 @@
 /* Write formatted list with names for addresses in backtrace to a file.
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -23,11 +23,12 @@
 #include <sys/uio.h>
 
 #include <stdio-common/_itoa.h>
+#include <not-cancel.h>
 
 #if __ELF_NATIVE_CLASS == 32
 # define WORD_WIDTH 8
 #else
-/* We assyme 64bits.  */
+/* We assume 64bits.  */
 # define WORD_WIDTH 16
 #endif
 
@@ -55,7 +56,8 @@
       iov[2].iov_base = (void *) "]\n";
       iov[2].iov_len = 2;
 
-      __writev (fd, iov, 3);
+      /* We prefer to use the non-cancelable interface if it is available.  */
+      writev_not_cancel_no_status (fd, iov, 3);
     }
 }
 weak_alias (__backtrace_symbols_fd, backtrace_symbols_fd)
diff -Nur sysdeps/generic/bits/atomic.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/atomic.h
--- sysdeps/generic/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/atomic.h	2003-03-23 00:00:14.000000000 +0100
@@ -0,0 +1,43 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_ATOMIC_H
+#define _BITS_ATOMIC_H	1
+
+/* We have by default no support for atomic operations.  So define
+   them non-atomic.  If this is a problem somebody will have to come
+   up with real definitions.  */
+
+/* The only basic operation needed is compare and exchange.  */
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gret = *__gmemp;				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     if (__gret == (oldval))					      \
+       *__gmemp = __gnewval;					      \
+     __gret; })
+
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     *__gmemp == (oldval) ? (*__gmemp = __gnewval, 0) : 1; })
+
+#endif	/* bits/atomic.h */
diff -Nur sysdeps/generic/bits/confname.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/confname.h
--- sysdeps/generic/bits/confname.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/confname.h	2004-11-27 21:52:06.000000000 +0100
@@ -1,5 +1,6 @@
 /* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
-   Copyright (C) 1993, 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1993,1995-1998,2000,2001,2003,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -62,8 +63,10 @@
 #define _PC_REC_XFER_ALIGN		_PC_REC_XFER_ALIGN
     _PC_ALLOC_SIZE_MIN,
 #define _PC_ALLOC_SIZE_MIN		_PC_ALLOC_SIZE_MIN
-    _PC_SYMLINK_MAX
+    _PC_SYMLINK_MAX,
 #define _PC_SYMLINK_MAX			_PC_SYMLINK_MAX
+    _PC_2_SYMLINKS
+#define _PC_2_SYMLINKS			_PC_2_SYMLINKS
   };
 
 /* Values for the argument to `sysconf'.  */
@@ -458,109 +461,141 @@
 #define _SC_TRACE_EVENT_FILTER		_SC_TRACE_EVENT_FILTER
     _SC_TRACE_INHERIT,
 #define _SC_TRACE_INHERIT		_SC_TRACE_INHERIT
-    _SC_TRACE_LOG
+    _SC_TRACE_LOG,
 #define _SC_TRACE_LOG			_SC_TRACE_LOG
+
+    _SC_LEVEL1_ICACHE_SIZE,
+#define _SC_LEVEL1_ICACHE_SIZE		_SC_LEVEL1_ICACHE_SIZE
+    _SC_LEVEL1_ICACHE_ASSOC,
+#define _SC_LEVEL1_ICACHE_ASSOC		_SC_LEVEL1_ICACHE_ASSOC
+    _SC_LEVEL1_ICACHE_LINESIZE,
+#define _SC_LEVEL1_ICACHE_LINESIZE	_SC_LEVEL1_ICACHE_LINESIZE
+    _SC_LEVEL1_DCACHE_SIZE,
+#define _SC_LEVEL1_DCACHE_SIZE		_SC_LEVEL1_DCACHE_SIZE
+    _SC_LEVEL1_DCACHE_ASSOC,
+#define _SC_LEVEL1_DCACHE_ASSOC		_SC_LEVEL1_DCACHE_ASSOC
+    _SC_LEVEL1_DCACHE_LINESIZE,
+#define _SC_LEVEL1_DCACHE_LINESIZE	_SC_LEVEL1_DCACHE_LINESIZE
+    _SC_LEVEL2_CACHE_SIZE,
+#define _SC_LEVEL2_CACHE_SIZE		_SC_LEVEL2_CACHE_SIZE
+    _SC_LEVEL2_CACHE_ASSOC,
+#define _SC_LEVEL2_CACHE_ASSOC		_SC_LEVEL2_CACHE_ASSOC
+    _SC_LEVEL2_CACHE_LINESIZE,
+#define _SC_LEVEL2_CACHE_LINESIZE	_SC_LEVEL2_CACHE_LINESIZE
+    _SC_LEVEL3_CACHE_SIZE,
+#define _SC_LEVEL3_CACHE_SIZE		_SC_LEVEL3_CACHE_SIZE
+    _SC_LEVEL3_CACHE_ASSOC,
+#define _SC_LEVEL3_CACHE_ASSOC		_SC_LEVEL3_CACHE_ASSOC
+    _SC_LEVEL3_CACHE_LINESIZE,
+#define _SC_LEVEL3_CACHE_LINESIZE	_SC_LEVEL3_CACHE_LINESIZE
+    _SC_LEVEL4_CACHE_SIZE,
+#define _SC_LEVEL4_CACHE_SIZE		_SC_LEVEL4_CACHE_SIZE
+    _SC_LEVEL4_CACHE_ASSOC,
+#define _SC_LEVEL4_CACHE_ASSOC		_SC_LEVEL4_CACHE_ASSOC
+    _SC_LEVEL4_CACHE_LINESIZE,
+#define _SC_LEVEL4_CACHE_LINESIZE	_SC_LEVEL4_CACHE_LINESIZE
+    /* Leave room here, maybe we need a few more cache levels some day.  */
+
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+#define _SC_IPV6			_SC_IPV6
+    _SC_RAW_SOCKETS
+#define _SC_RAW_SOCKETS			_SC_RAW_SOCKETS
   };
 
-#if (defined __USE_POSIX2 || defined __USE_UNIX98 \
-     || defined __USE_FILE_OFFSET64 || defined __USE_LARGEFILE64 \
-     || defined __USE_LARGEFILE)
 /* Values for the NAME argument to `confstr'.  */
 enum
   {
     _CS_PATH,			/* The default search path.  */
 #define _CS_PATH		_CS_PATH
 
-# if (defined __USE_FILE_OFFSET64 || defined __USE_LARGEFILE64 \
-     || defined __USE_LARGEFILE)
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+# define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
+
+    _CS_GNU_LIBC_VERSION,
+#define _CS_GNU_LIBC_VERSION	_CS_GNU_LIBC_VERSION
+    _CS_GNU_LIBPTHREAD_VERSION,
+#define _CS_GNU_LIBPTHREAD_VERSION	_CS_GNU_LIBPTHREAD_VERSION
+
     _CS_LFS_CFLAGS = 1000,
-#  define _CS_LFS_CFLAGS		_CS_LFS_CFLAGS
+#define _CS_LFS_CFLAGS	_CS_LFS_CFLAGS
     _CS_LFS_LDFLAGS,
-#  define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
+#define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
     _CS_LFS_LIBS,
-#  define _CS_LFS_LIBS		_CS_LFS_LIBS
+#define _CS_LFS_LIBS		_CS_LFS_LIBS
     _CS_LFS_LINTFLAGS,
-#  define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
+#define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
     _CS_LFS64_CFLAGS,
-#  define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
+#define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
     _CS_LFS64_LDFLAGS,
-#  define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
+#define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
     _CS_LFS64_LIBS,
-#  define _CS_LFS64_LIBS		_CS_LFS64_LIBS
+#define _CS_LFS64_LIBS	_CS_LFS64_LIBS
     _CS_LFS64_LINTFLAGS,
-#  define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS
-# endif
+#define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS
 
-# ifdef __USE_UNIX98
     _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
-#  define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
+#define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
     _CS_XBS5_ILP32_OFF32_LDFLAGS,
-#  define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
+#define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
     _CS_XBS5_ILP32_OFF32_LIBS,
-#  define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
+#define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
     _CS_XBS5_ILP32_OFF32_LINTFLAGS,
-#  define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
+#define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
     _CS_XBS5_ILP32_OFFBIG_CFLAGS,
-#  define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
     _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
-#  define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
     _CS_XBS5_ILP32_OFFBIG_LIBS,
-#  define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
+#define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
     _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
-#  define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
     _CS_XBS5_LP64_OFF64_CFLAGS,
-#  define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
+#define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
     _CS_XBS5_LP64_OFF64_LDFLAGS,
-#  define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
+#define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
     _CS_XBS5_LP64_OFF64_LIBS,
-#  define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
+#define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
     _CS_XBS5_LP64_OFF64_LINTFLAGS,
-#  define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
+#define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
     _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
-#  define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
     _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
-#  define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
     _CS_XBS5_LPBIG_OFFBIG_LIBS,
-#  define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
+#define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
     _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
-#  define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
-# endif
-# ifdef __USE_XOPEN2K
+#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
+
     _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
     _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
     _CS_POSIX_V6_ILP32_OFF32_LIBS,
-#  define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
     _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
+#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
     _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
     _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
     _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
-#  define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
     _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
-#  define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
+#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
     _CS_POSIX_V6_LP64_OFF64_CFLAGS,
-#  define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
     _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
-#  define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
     _CS_POSIX_V6_LP64_OFF64_LIBS,
-#  define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
+#define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
     _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
-#  define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
+#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
     _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
-#  define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
     _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
-#  define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
     _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
-#  define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
-    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
-#  define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
-# endif
-
-    _CS_V6_WIDTH_RESTRICTED_ENVS
-# define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
   };
-#endif
diff -Nur sysdeps/generic/bits/dlfcn.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/dlfcn.h
--- sysdeps/generic/bits/dlfcn.h	2001-10-27 02:01:16.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/dlfcn.h	2004-09-23 09:37:00.000000000 +0200
@@ -1,5 +1,5 @@
 /* System dependent definitions for run-time dynamic loading.
-   Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1996-2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,6 +26,7 @@
 #define RTLD_NOW	0x00002	/* Immediate function call binding.  */
 #define	RTLD_BINDING_MASK   0x3	/* Mask of binding time value.  */
 #define RTLD_NOLOAD	0x00004	/* Do not load the object.  */
+#define RTLD_DEEPBIND	0x00008	/* Use deep binding.  */
 
 /* If the following bit is set in the MODE argument to `dlopen',
    the symbols of the loaded object and its dependencies are made
diff -Nur sysdeps/generic/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/environments.h
--- sysdeps/generic/bits/environments.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/environments.h	2004-11-26 09:13:48.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -72,4 +72,7 @@
 # define _XBS5_LP64_OFF64	-1
 # define _XBS5_LPBIG_OFFBIG	-1
 
+/* CFLAGS.  */
+#define __ILP32_OFFBIG_CFLAGS   "-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+
 #endif /* __WORDSIZE == 32 */
diff -Nur sysdeps/generic/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/fcntl.h
--- sysdeps/generic/bits/fcntl.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/fcntl.h	2004-05-03 23:39:39.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for stub configuration.
-   Copyright (C) 1991, 1992, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1997, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -54,7 +54,7 @@
 #define	F_SETFD		2	/* Set file descriptor flags.  */
 #define	F_GETFL		3	/* Get file status flags.  */
 #define	F_SETFL		4	/* Set file status flags.  */
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
 # define F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
 #endif
diff -Nur sysdeps/generic/bits/huge_valf.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_valf.h
--- sysdeps/generic/bits/huge_valf.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_valf.h	2004-03-15 22:44:08.000000000 +0100
@@ -0,0 +1,29 @@
+/* Stub `HUGE_VALF' constant.
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1996, 1997, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_valf.h> directly; include <math.h> instead."
+#endif
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALF	(__builtin_huge_valf())
+#else
+# define HUGE_VALF	1e37f
+#endif
diff -Nur sysdeps/generic/bits/huge_val.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_val.h
--- sysdeps/generic/bits/huge_val.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_val.h	2004-03-15 22:44:08.000000000 +0100
@@ -1,6 +1,6 @@
 /* Stub `HUGE_VAL' constant.
    Used by <stdlib.h> and <math.h> functions for overflow.
-   Copyright (C) 1992, 1996, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1992, 1996, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,5 +22,8 @@
 # error "Never use <bits/huge_val.h> directly; include <math.h> instead."
 #endif
 
-
-#define	   HUGE_VAL	1e37
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VAL	(__builtin_huge_val())
+#else
+# define HUGE_VAL	1e37
+#endif
diff -Nur sysdeps/generic/bits/huge_vall.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_vall.h
--- sysdeps/generic/bits/huge_vall.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/huge_vall.h	2004-03-15 22:44:08.000000000 +0100
@@ -0,0 +1,29 @@
+/* Default `HUGE_VALL' constant.
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1996, 1997, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
+#endif
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALL	(__builtin_huge_vall())
+#else
+# define HUGE_VALL	((long double) HUGE_VAL)
+#endif
diff -Nur sysdeps/generic/bits/inf.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/inf.h
--- sysdeps/generic/bits/inf.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/inf.h	2004-03-15 22:44:08.000000000 +0100
@@ -0,0 +1,33 @@
+/* Default `INFINITY' constant.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/inf.h> directly; include <math.h> instead."
+#endif
+
+/* If we don't have real infinity, then we're supposed to produce a float
+   value that overflows at translation time, which is required to produce
+   a diagnostic.  GCC's __builtin_inff produces a quite nice diagnostic
+   that tells the user that the target doesn't support infinities.  */
+
+#if __GNUC_PREREQ(3,3)
+# define INFINITY	(__builtin_inff())
+#else
+# define INFINITY	(1e9999f)
+#endif
diff -Nur sysdeps/generic/bits/in.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/in.h
--- sysdeps/generic/bits/in.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/in.h	2004-08-11 00:05:17.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,12 +22,6 @@
 # error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
 #endif
 
-/* Link numbers.  */
-#define	IMPLINK_IP		155
-#define	IMPLINK_LOWEXPER	156
-#define	IMPLINK_HIGHEXPER	158
-
-
 /* Options for use with `getsockopt' and `setsockopt' at the IP level.
    The first word in the comment at the right is the data type used;
    "bool" means a boolean value stored in an `int'.  */
@@ -54,18 +48,11 @@
     char ip_opts[40];		/* Actually variable in size.  */
   };
 
-/* Structure used for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP. */
-struct ip_mreq
-  {
-    struct in_addr imr_multiaddr;	/* IP multicast address of group */
-    struct in_addr imr_interface;	/* local IP address of interface */
-  };
-
 /* IPV6 socket options.  */
 #define IPV6_ADDRFORM		1
 #define IPV6_RXINFO		2
-#define IPV6_RXHOPOPTS		3
-#define IPV6_RXDSTOPTS		4
+#define IPV6_HOPOPTS		3
+#define IPV6_DSTOPTS		4
 #define IPV6_RTHDR		5
 #define IPV6_PKTOPTIONS		6
 #define IPV6_CHECKSUM		7
@@ -85,6 +72,8 @@
 /* Obsolete synonyms for the above.  */
 #define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
 #define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
 
 /* Routing header options for IPv6.  */
 #define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
diff -Nur sysdeps/generic/bits/ipctypes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/ipctypes.h
--- sysdeps/generic/bits/ipctypes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/ipctypes.h	2002-10-24 01:49:00.000000000 +0200
@@ -0,0 +1,37 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.  Generic.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include <bits/ipctypes.h> directly.
+ */
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+/* Used in `struct shmid_ds'.  */
+# if __WORDSIZE == 32
+typedef unsigned short int __ipc_pid_t;
+# else
+typedef int __ipc_pid_t;
+# endif
+
+
+#endif /* bits/ipctypes.h */
diff -Nur sysdeps/generic/bits/libc-lock.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/libc-lock.h
--- sysdeps/generic/bits/libc-lock.h	2002-08-26 23:16:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/libc-lock.h	2003-08-25 11:07:41.000000000 +0200
@@ -1,5 +1,5 @@
 /* libc-internal interface for mutex locks.  Stub version.
-   Copyright (C) 1996,97,99,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1996,97,99,2000-2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,6 +30,7 @@
    of libc.  */
 #define __libc_lock_define(CLASS,NAME)
 #define __libc_lock_define_recursive(CLASS,NAME)
+#define __rtld_lock_define_recursive(CLASS,NAME)
 #define __libc_rwlock_define(CLASS,NAME)
 
 /* Define an initialized lock variable NAME with storage class CLASS.  */
@@ -39,6 +40,7 @@
 /* Define an initialized recursive lock variable NAME with storage
    class CLASS.  */
 #define __libc_lock_define_initialized_recursive(CLASS,NAME)
+#define __rtld_lock_define_initialized_recursive(CLASS,NAME)
 
 /* Initialize the named lock variable, leaving it in a consistent, unlocked
    state.  */
@@ -47,6 +49,7 @@
 
 /* Same as last but this time we initialize a recursive mutex.  */
 #define __libc_lock_init_recursive(NAME)
+#define __rtld_lock_init_recursive(NAME)
 
 /* Finalize the named lock variable, which must be locked.  It cannot be
    used again until __libc_lock_init is called again on it.  This must be
@@ -64,6 +67,7 @@
 
 /* Lock the recursive named lock variable.  */
 #define __libc_lock_lock_recursive(NAME)
+#define __rtld_lock_lock_recursive(NAME)
 
 /* Try to lock the named lock variable.  */
 #define __libc_lock_trylock(NAME) 0
@@ -79,6 +83,7 @@
 
 /* Unlock the recursive named lock variable.  */
 #define __libc_lock_unlock_recursive(NAME)
+#define __rtld_lock_unlock_recursive(NAME)
 
 
 /* Define once control variable.  */
@@ -112,6 +117,8 @@
   if ((DOIT) && __save_FCT != 0)					    \
     (*__save_FCT)(__save_ARG);						    \
 
+#define __libc_cleanup_push(fct, arg) __libc_cleanup_region_start (1, fct, arg)
+#define __libc_cleanup_pop(execute) __libc_cleanup_region_end (execute)
 
 /* We need portable names for some of the functions.  */
 #define __libc_mutex_unlock
diff -Nur sysdeps/generic/bits/libc-tsd.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/libc-tsd.h
--- sysdeps/generic/bits/libc-tsd.h	2002-09-02 20:48:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/libc-tsd.h	2002-10-16 00:50:42.000000000 +0200
@@ -51,8 +51,9 @@
    We don't define an enum for the possible key values, because the KEYs
    translate directly into variables by macro magic.  */
 
-#if USE_TLS && HAVE___THREAD
-# define __libc_tsd_define(CLASS, KEY)	CLASS __thread void *__libc_tsd_##KEY;
+#if USE___THREAD
+# define __libc_tsd_define(CLASS, KEY)	\
+  CLASS __thread void *__libc_tsd_##KEY attribute_tls_model_ie;
 
 # define __libc_tsd_address(KEY)	(&__libc_tsd_##KEY)
 # define __libc_tsd_get(KEY)		(__libc_tsd_##KEY)
@@ -60,7 +61,7 @@
 #else
 # define __libc_tsd_define(CLASS, KEY)	CLASS void *__libc_tsd_##KEY##_data;
 
-# define __libc_tsd_address(KEY)	(&__libc_tsd_##KEY)
+# define __libc_tsd_address(KEY)	(&__libc_tsd_##KEY##_data)
 # define __libc_tsd_get(KEY)		(__libc_tsd_##KEY##_data)
 # define __libc_tsd_set(KEY, VALUE)	(__libc_tsd_##KEY##_data = (VALUE))
 #endif
diff -Nur sysdeps/generic/bits/mathdef.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/mathdef.h
--- sysdeps/generic/bits/mathdef.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/mathdef.h	2004-03-15 22:44:08.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,10 +30,6 @@
 typedef double double_t;	/* `double' expressions are evaluated as
 				   `double'.  */
 
-/* Define `INFINITY' as value of type `float'.  */
-# define INFINITY	HUGE_VALF
-
-
 /* The values returned by `ilogb' for 0 and NaN respectively.  */
 # define FP_ILOGB0	(-2147483647)
 # define FP_ILOGBNAN	2147483647
diff -Nur sysdeps/generic/bits/mqueue.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/mqueue.h
--- sysdeps/generic/bits/mqueue.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/mqueue.h	2004-04-13 04:11:34.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MQUEUE_H
+# error "Never use <bits/mqueue.h> directly; include <mqueue.h> instead."
+#endif
+
+typedef int mqd_t;
+
+struct mq_attr
+{
+  long int mq_flags;	/* Message queue flags.  */
+  long int mq_maxmsg;	/* Maximum number of messages.  */
+  long int mq_msgsize;	/* Maximum message size.  */
+  long int mq_curmsgs;	/* Number of messages currently queued.  */
+};
diff -Nur sysdeps/generic/bits/pthreadtypes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/pthreadtypes.h
--- sysdeps/generic/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/pthreadtypes.h	2002-11-11 00:22:34.000000000 +0100
@@ -0,0 +1 @@
+/* No thread support.  */
diff -Nur sysdeps/generic/bits/sched.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/sched.h
--- sysdeps/generic/bits/sched.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/sched.h	2003-05-10 19:47:05.000000000 +0200
@@ -1,6 +1,6 @@
 /* Definitions of constants and data structure for POSIX 1003.1b-1993
    scheduling interface.
-   Copyright (C) 1996, 1997, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,3 +33,39 @@
 {
   int __sched_priority;
 };
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	1024
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# define __CPU_ZERO(cpusetp) \
+  do {									      \
+    unsigned int __i;							      \
+    cpu_set *__arr = (cpusetp);						      \
+    for (__i = 0; __i < sizeof (cpu_set) / sizeof (__cpu_mask); ++__i)	      \
+      __arr->__bits[__i] = 0;						      \
+  } while (0)
+# define __CPU_SET(cpu, cpusetp) \
+  ((cpusetp)->__bits[__CPUELT (cpu)] |= __CPUMASK (cpu))
+# define __CPU_CLR(cpu, cpusetp) \
+  ((cpusetp)->__bits[__CPUELT (cpu)] &= ~__CPUMASK (cpu))
+# define __CPU_ISSET(cpu, cpusetp) \
+  (((cpusetp)->__bits[__CPUELT (cpu)] & __CPUMASK (cpu)) != 0)
+#endif
diff -Nur sysdeps/generic/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/shm.h
--- sysdeps/generic/bits/shm.h	2002-08-24 00:18:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/shm.h	2004-08-12 19:27:21.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,6 +32,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -51,3 +54,5 @@
     __pid_t shm_lpid;			/* pid of last shmop */
     shmatt_t shm_nattch;		/* number of current attaches */
   };
+
+__END_DECLS
diff -Nur sysdeps/generic/bits/stdio-lock.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/stdio-lock.h
--- sysdeps/generic/bits/stdio-lock.h	2001-08-24 05:28:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/stdio-lock.h	2003-08-29 21:56:11.000000000 +0200
@@ -1,5 +1,5 @@
 /* Thread package specific definitions of stream lock type.  Generic version.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,7 @@
 #define _IO_lock_init(_name)	__libc_lock_init_recursive (_name)
 #define _IO_lock_fini(_name)	__libc_lock_fini_recursive (_name)
 #define _IO_lock_lock(_name)	__libc_lock_lock_recursive (_name)
+#define _IO_lock_trylock(_name)	__libc_lock_trylock_recursive (_name)
 #define _IO_lock_unlock(_name)	__libc_lock_unlock_recursive (_name)
 
 
@@ -44,5 +45,14 @@
 #define _IO_cleanup_region_end(_doit) \
   __libc_cleanup_region_end (_doit)
 
+#if defined _LIBC && !defined NOT_IN_libc
+# define _IO_acquire_lock(_fp) \
+  _IO_cleanup_region_start ((void (*) (void *)) _IO_funlockfile, (_fp));      \
+  _IO_flockfile (_fp)
+
+# define _IO_release_lock(_fp) \
+  _IO_funlockfile (_fp);						      \
+  _IO_cleanup_region_end (0)
+#endif
 
 #endif /* bits/stdio-lock.h */
diff -Nur sysdeps/generic/bits/time.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/time.h
--- sysdeps/generic/bits/time.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/time.h	2003-03-03 05:42:14.000000000 +0100
@@ -1,5 +1,5 @@
-/* System-dependent timing definitions.  Stub version.
-   Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+/* System-dependent timing definitions.  Generic version.
+   Copyright (C) 1996,1997,1999-2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,24 +25,45 @@
 # ifndef _BITS_TIME_H
 #  define _BITS_TIME_H	1
 
-#  define CLOCKS_PER_SEC 60
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   include <bits/types.h>
+extern long int __sysconf (int);
+#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
+#  endif
 
 #  ifdef __USE_POSIX199309
 /* Identifier for system-wide realtime clock.  */
-#   define CLOCK_REALTIME	0
+#   define CLOCK_REALTIME		0
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		1
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
 
 /* Flag to indicate time is absolute.  */
-#   define TIMER_ABSTIME	1
+#   define TIMER_ABSTIME		1
 #  endif
 
 # endif	/* bits/time.h */
 #endif
 
-
 #ifdef __need_timeval
 # undef __need_timeval
 # ifndef _STRUCT_TIMEVAL
 #  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
 /* A time value that is accurate to the nearest
    microsecond but also has a range of years.  */
 struct timeval
diff -Nur sysdeps/generic/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/types.h
--- sysdeps/generic/bits/types.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/types.h	2004-09-26 10:47:37.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,1992,94-1999,2000,2001 Free Software Foundation, Inc.
+/* bits/types.h -- definitions of __*_t types underlying *_t types.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,18 +25,39 @@
 #define	_BITS_TYPES_H	1
 
 #include <features.h>
+#include <bits/wordsize.h>
 
 #define __need_size_t
 #include <stddef.h>
 
 /* Convenience types.  */
 typedef unsigned char __u_char;
-typedef unsigned short __u_short;
+typedef unsigned short int __u_short;
 typedef unsigned int __u_int;
-typedef unsigned long __u_long;
-#ifdef __GNUC__
-typedef unsigned long long int __u_quad_t;
-typedef long long int __quad_t;
+typedef unsigned long int __u_long;
+
+/* Fixed-size types, underlying types depend on word size and compiler.  */
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#if __WORDSIZE == 64
+typedef signed long int __int64_t;
+typedef unsigned long int __uint64_t;
+#elif defined __GLIBC_HAVE_LONG_LONG
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+#endif
+
+/* quad_t is also 64 bits.  */
+#if __WORDSIZE == 64
+typedef long int __quad_t;
+typedef unsigned long int __u_quad_t;
+#elif defined __GLIBC_HAVE_LONG_LONG
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
 #else
 typedef struct
 {
@@ -46,86 +68,132 @@
   __u_long __val[2];
 } __u_quad_t;
 #endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#ifdef __GNUC__
-typedef signed long long int __int64_t;
-typedef unsigned long long int __uint64_t;
-#endif
-typedef __quad_t *__qaddr_t;
 
-typedef int __dev_t;		/* Type of device numbers.  */
-typedef unsigned int __uid_t;	/* Type of user identifications.  */
-typedef unsigned int __gid_t;	/* Type of group identifications.  */
-typedef unsigned int __ino_t;	/* Type of file serial numbers.  */
-typedef __quad_t __ino64_t;	/* Type of file serial numbers (LFS).  */
-typedef unsigned int __mode_t;	/* Type of file attribute bitmasks.  */
-typedef unsigned short int __nlink_t; /* Type of file link counts.  */
-typedef long int __off_t;	/* Type of file sizes and offsets.  */
-typedef __quad_t __loff_t;	/* Type of file sizes and offsets.  */
-typedef __loff_t __off64_t;	/* Type of file sizes and offsets (LFS).  */
-typedef int __pid_t;		/* Type of process identifications.  */
-typedef int __ssize_t;		/* Type of a byte count, or error.  */
-typedef __u_quad_t __fsid_t;	/* Type of file system IDs.  */
-typedef long int __clock_t;	/* Type of CPU usage counts.  */
-typedef long int __rlim_t;	/* Type for resource measurement.  */
-typedef __quad_t __rlim64_t;	/* Type for resource measurement (LFS).  */
-typedef unsigned int __id_t;	/* General type for IDs.  */
 
-/* Everythin' else.  */
-typedef long int __daddr_t;	/* The type of a disk address.  */
-typedef char *__caddr_t;
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef long int __suseconds_t;
-typedef long int __swblk_t;	/* Type of a swap block maybe?  */
-typedef long int __key_t;	/* Type of an IPC key */
-
+/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
+   macros for each of the OS types we define below.  The definitions
+   of those macros must use the following macros for underlying types.
+   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
+   variants of each of the following integer types on this machine.
+
+	16		-- "natural" 16-bit type (always short)
+	32		-- "natural" 32-bit type (always int)
+	64		-- "natural" 64-bit type (long or long long)
+	LONG32		-- 32-bit type, traditionally long
+	QUAD		-- 64-bit type, always long long
+	WORD		-- natural type of __WORDSIZE bits (int or long)
+	LONGWORD	-- type of __WORDSIZE bits, traditionally long
+
+   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
+   conventional uses of `long' or `long long' type modifiers match the
+   types we define, even when a less-adorned type would be the same size.
+   This matters for (somewhat) portably writing printf/scanf formats for
+   these types, where using the appropriate l or ll format modifiers can
+   make the typedefs and the formats match up across all GNU platforms.  If
+   we used `long' when it's 64 bits where `long long' is expected, then the
+   compiler would warn about the formats not matching the argument types,
+   and the programmer changing them to shut up the compiler would break the
+   program's portability.
+
+   Here we assume what is presently the case in all the GCC configurations
+   we support: long long is always 64 bits, long is always word/address size,
+   and int is always 32 bits.  */
+
+#define	__S16_TYPE		short int
+#define __U16_TYPE		unsigned short int
+#define	__S32_TYPE		int
+#define __U32_TYPE		unsigned int
+#define __SLONGWORD_TYPE	long int
+#define __ULONGWORD_TYPE	unsigned long int
+#if __WORDSIZE == 32
+# define __SQUAD_TYPE		__quad_t
+# define __UQUAD_TYPE		__u_quad_t
+# define __SWORD_TYPE		int
+# define __UWORD_TYPE		unsigned int
+# define __SLONG32_TYPE		long int
+# define __ULONG32_TYPE		unsigned long int
+# define __S64_TYPE		__quad_t
+# define __U64_TYPE		__u_quad_t
+#elif __WORDSIZE == 64
+# define __SQUAD_TYPE		long int
+# define __UQUAD_TYPE		unsigned long int
+# define __SWORD_TYPE		long int
+# define __UWORD_TYPE		unsigned long int
+# define __SLONG32_TYPE		int
+# define __ULONG32_TYPE		unsigned int
+# define __S64_TYPE		long int
+# define __U64_TYPE		unsigned long int
+#else
+# error
+#endif
+#include <bits/typesizes.h>	/* Defines __*_T_TYPE macros.  */
+
+/* We want __extension__ before typedef's that use nonstandard base types
+   such as `long long' in C89 mode.  */
+#define __STD_TYPE __extension__ typedef
+
+
+__STD_TYPE __DEV_T_TYPE __dev_t;	/* Type of device numbers.  */
+__STD_TYPE __UID_T_TYPE __uid_t;	/* Type of user identifications.  */
+__STD_TYPE __GID_T_TYPE __gid_t;	/* Type of group identifications.  */
+__STD_TYPE __INO_T_TYPE __ino_t;	/* Type of file serial numbers.  */
+__STD_TYPE __INO64_T_TYPE __ino64_t;	/* Type of file serial numbers (LFS).*/
+__STD_TYPE __MODE_T_TYPE __mode_t;	/* Type of file attribute bitmasks.  */
+__STD_TYPE __NLINK_T_TYPE __nlink_t;	/* Type of file link counts.  */
+__STD_TYPE __OFF_T_TYPE __off_t;	/* Type of file sizes and offsets.  */
+__STD_TYPE __OFF64_T_TYPE __off64_t;	/* Type of file sizes and offsets (LFS).  */
+__STD_TYPE __PID_T_TYPE __pid_t;	/* Type of process identifications.  */
+__STD_TYPE __FSID_T_TYPE __fsid_t;	/* Type of file system IDs.  */
+__STD_TYPE __CLOCK_T_TYPE __clock_t;	/* Type of CPU usage counts.  */
+__STD_TYPE __RLIM_T_TYPE __rlim_t;	/* Type for resource measurement.  */
+__STD_TYPE __RLIM64_T_TYPE __rlim64_t;	/* Type for resource measurement (LFS).  */
+__STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
+__STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
+__STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
+__STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */
+
+__STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
+__STD_TYPE __SWBLK_T_TYPE __swblk_t;	/* Type of a swap block maybe?  */
+__STD_TYPE __KEY_T_TYPE __key_t;	/* Type of an IPC key.  */
 
 /* Clock ID used in clock and timer functions.  */
-typedef int __clockid_t;
+__STD_TYPE __CLOCKID_T_TYPE __clockid_t;
 
 /* Timer ID returned by `timer_create'.  */
-typedef int __timer_t;
-
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define	__FD_SETSIZE	256
-
-
-/* XXX Used in `struct shmid_ds'.  */
-typedef unsigned short int __ipc_pid_t;
-
+__STD_TYPE __TIMER_T_TYPE __timer_t;
 
 /* Type to represent block size.  */
-typedef unsigned int __blksize_t;
+__STD_TYPE __BLKSIZE_T_TYPE __blksize_t;
 
 /* Types from the Large File Support interface.  */
 
-/* Type to count number os disk blocks.  */
-typedef long int __blkcnt_t;
-typedef __quad_t __blkcnt64_t;
+/* Type to count number of disk blocks.  */
+__STD_TYPE __BLKCNT_T_TYPE __blkcnt_t;
+__STD_TYPE __BLKCNT64_T_TYPE __blkcnt64_t;
 
 /* Type to count file system blocks.  */
-typedef unsigned int __fsblkcnt_t;
-typedef __u_quad_t __fsblkcnt64_t;
+__STD_TYPE __FSBLKCNT_T_TYPE __fsblkcnt_t;
+__STD_TYPE __FSBLKCNT64_T_TYPE __fsblkcnt64_t;
 
-/* Type to count file system inodes.  */
-typedef unsigned long int __fsfilcnt_t;
-typedef __u_quad_t __fsfilcnt64_t;
-
-/* Used in XTI.  */
-typedef int __t_scalar_t;
-typedef unsigned int __t_uscalar_t;
+/* Type to count file system nodes.  */
+__STD_TYPE __FSFILCNT_T_TYPE __fsfilcnt_t;
+__STD_TYPE __FSFILCNT64_T_TYPE __fsfilcnt64_t;
+
+__STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */
+
+/* These few don't really vary by system, they always correspond
+   to one of the other defined types.  */
+typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
 
 /* Duplicates info from stdint.h but this is used in unistd.h.  */
-typedef long int __intptr_t;
+__STD_TYPE __SWORD_TYPE __intptr_t;
 
 /* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
+__STD_TYPE __U32_TYPE __socklen_t;
+
+
+#undef __STD_TYPE
 
 #endif /* bits/types.h */
diff -Nur sysdeps/generic/bits/typesizes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/typesizes.h
--- sysdeps/generic/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/typesizes.h	2003-07-31 21:34:16.000000000 +0200
@@ -0,0 +1,66 @@
+/* bits/typesizes.h -- underlying types for *_t.  Generic version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff -Nur sysdeps/generic/bits/waitstatus.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/waitstatus.h
--- sysdeps/generic/bits/waitstatus.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/waitstatus.h	2004-09-28 03:58:03.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions of status bits for `wait' et al.
-   Copyright (C) 1992, 1994, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -38,23 +38,25 @@
 #define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)
 
 /* Nonzero if STATUS indicates termination by a signal.  */
-#ifdef	__GNUC__
-# define __WIFSIGNALED(status) \
-  (__extension__ ({ int __status = (status);				      \
-		    !__WIFSTOPPED(__status) && !__WIFEXITED(__status); }))
-#else	/* Not GCC.  */
-# define __WIFSIGNALED(status)	(!__WIFSTOPPED(status) && !__WIFEXITED(status))
-#endif	/* GCC.  */
+#define __WIFSIGNALED(status) \
+  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)
 
 /* Nonzero if STATUS indicates the child is stopped.  */
 #define	__WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)
 
+/* Nonzero if STATUS indicates the child continued after a stop.  We only
+   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
+#ifdef WCONTINUED
+# define __WIFCONTINUED(status)	((status) == __W_CONTINUED)
+#endif
+
 /* Nonzero if STATUS indicates the child dumped core.  */
 #define	__WCOREDUMP(status)	((status) & __WCOREFLAG)
 
 /* Macros for constructing status values.  */
 #define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
 #define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
+#define __W_CONTINUED		0xffff
 #define	__WCOREFLAG		0x80
 
 
diff -Nur sysdeps/generic/bits/xtitypes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/xtitypes.h
--- sysdeps/generic/bits/xtitypes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bits/xtitypes.h	2002-10-24 01:48:42.000000000 +0200
@@ -0,0 +1,34 @@
+/* bits/xtitypes.h -- Define some types used by <bits/stropts.h>.  Generic.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STROPTS_H
+# error "Never include <bits/xtitypes.h> directly; use <stropts.h> instead."
+#endif
+
+#ifndef _BITS_XTITYPES_H
+#define _BITS_XTITYPES_H	1
+
+#include <bits/types.h>
+
+/* This type is used by some structs in <bits/stropts.h>.  */
+typedef __SLONGWORD_TYPE __t_scalar_t;
+typedef __ULONGWORD_TYPE __t_uscalar_t;
+
+
+#endif /* bits/xtitypes.h */
diff -Nur sysdeps/generic/bp-semctl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bp-semctl.h
--- sysdeps/generic/bp-semctl.h	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bp-semctl.h	2002-12-17 00:17:42.000000000 +0100
@@ -41,7 +41,7 @@
     case SETALL:
       {
 	struct semid_ds ds;
-	union semun un = { buf: &ds };
+	union semun un = { .buf = &ds };
 	unsigned int length = ~0;
 
 	/* It's unfortunate that we need to make a recursive
diff -Nur sysdeps/generic/bp-thunks.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bp-thunks.h
--- sysdeps/generic/bp-thunks.h	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bp-thunks.h	2003-05-02 04:20:50.000000000 +0200
@@ -1,5 +1,5 @@
 /* Bounded-pointer syscall thunk support.
-   Copyright (C) 2000 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Greg McGary <greg@mcgary.org>
 
@@ -21,6 +21,8 @@
 #ifndef _bpthunks_h_
 #define _bpthunks_h_
 
+#ifndef __ASSEMBLER__
+
 /* This header is included by the syscall BP thunks defined in
    sysd-syscalls, as created by sysdeps/unix/make-syscalls.sh.  It
    includes all headers that contain prototype declarations for system
@@ -51,7 +53,7 @@
 #include <sys/quota.h>
 #include <sys/resource.h>
 #include <sys/select.h>
-#include <sys/sendfile.h>
+#include <io/sys/sendfile.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
@@ -61,7 +63,8 @@
 #include <sys/times.h>
 #include <sys/timex.h>
 #include <sys/utsname.h>
-#include <sys/vm86.h>
 #include <sys/wait.h>
 
+#endif /* Not __ASSEMBLER__.  */
+
 #endif /* _bpthunks_h_ */
diff -Nur sysdeps/generic/bsd-_setjmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bsd-_setjmp.c
--- sysdeps/generic/bsd-_setjmp.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/bsd-_setjmp.c	2002-12-31 10:35:32.000000000 +0100
@@ -1,5 +1,5 @@
 /* BSD `_setjmp' entry point to `sigsetjmp (..., 0)'.  Stub version.
-   Copyright (C) 1994, 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,3 +32,4 @@
 {
   return __sigsetjmp (env, 0);
 }
+libc_hidden_def (_setjmp)
diff -Nur sysdeps/generic/cabsf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cabsf.c
--- sysdeps/generic/cabsf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cabsf.c	2004-01-13 10:08:04.000000000 +0100
@@ -0,0 +1,29 @@
+/* Return the complex absolute value of float complex value.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <complex.h>
+#include <math.h>
+
+float
+__cabsf (float _Complex z)
+{
+  return __hypotf (__real__ z, __imag__ z);
+}
+weak_alias (__cabsf, cabsf)
diff -Nur sysdeps/generic/cargf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cargf.c
--- sysdeps/generic/cargf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cargf.c	2004-01-13 10:08:04.000000000 +0100
@@ -0,0 +1,29 @@
+/* Compute argument of complex float value.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <complex.h>
+#include <math.h>
+
+float
+__cargf (__complex__ float x)
+{
+  return __atan2f (__imag__ x, __real__ x);
+}
+weak_alias (__cargf, cargf)
diff -Nur sysdeps/generic/check_fds.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/check_fds.c
--- sysdeps/generic/check_fds.c	2002-04-14 20:27:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/check_fds.c	2003-04-23 03:54:03.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,6 +32,7 @@
 #endif
 
 #include <device-nrs.h>
+#include <not-cancel.h>
 
 
 /* Should other OSes (e.g., Hurd) have different versions which can
@@ -39,6 +40,7 @@
 static void
 check_one_fd (int fd, int mode)
 {
+  /* Note that fcntl() with this parameter is not a cancellation point.  */
   if (__builtin_expect (__libc_fcntl (fd, F_GETFD), 0) == -1
       && errno == EBADF)
     {
@@ -47,7 +49,7 @@
       /* Something is wrong with this descriptor, it's probably not
 	 opened.  Open /dev/null so that the SUID program we are
 	 about to start does not accidently use this descriptor.  */
-      int nullfd = __libc_open (_PATH_DEVNULL, mode);
+      int nullfd = open_not_cancel (_PATH_DEVNULL, mode, 0);
       /* We are very paranoid here.  With all means we try to ensure
 	 that we are actually opening the /dev/null device and nothing
 	 else.
diff -Nur sysdeps/generic/check_pf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/check_pf.c
--- sysdeps/generic/check_pf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/check_pf.c	2003-06-10 10:52:14.000000000 +0200
@@ -0,0 +1,50 @@
+/* Determine protocol families for which interfaces exist.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ifaddrs.h>
+#include <netdb.h>
+
+
+void
+attribute_hidden
+__check_pf (bool *seen_ipv4, bool *seen_ipv6)
+{
+  /* Get the interface list via getifaddrs.  */
+  struct ifaddrs *ifa = NULL;
+  if (getifaddrs (&ifa) != 0)
+    {
+      /* We cannot determine what interfaces are available.  Be
+	 pessimistic.  */
+      *seen_ipv4 = true;
+      *seen_ipv6 = true;
+      return;
+    }
+
+  *seen_ipv4 = false;
+  *seen_ipv6 = false;
+
+  struct ifaddrs *runp;
+  for (runp = ifa; runp != NULL; runp = runp->ifa_next)
+    if (runp->ifa_addr->sa_family == PF_INET)
+      *seen_ipv4 = true;
+    else if (runp->ifa_addr->sa_family == PF_INET6)
+      *seen_ipv6 = true;
+
+  (void) freeifaddrs (ifa);
+}
diff -Nur sysdeps/generic/chflags.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/chflags.c
--- sysdeps/generic/chflags.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/chflags.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,7 +22,7 @@
 
 /* Change the flags of FILE to FLAGS.  */
 
-int chflags __P ((const char *file, int flags));
+int chflags (const char *file, int flags) __THROW;
 
 int
 chflags (file, flags)
diff -Nur sysdeps/generic/cimagf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cimagf.c
--- sysdeps/generic/cimagf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/cimagf.c	2004-01-13 10:08:04.000000000 +0100
@@ -0,0 +1,28 @@
+/* Return imaginary part of complex float value.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <complex.h>
+
+float
+__cimagf (float _Complex z)
+{
+  return __imag__ z;
+}
+weak_alias (__cimagf, cimagf)
diff -Nur sysdeps/generic/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/configure
--- sysdeps/generic/configure	2002-09-29 19:59:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,58 +1,107 @@
- 
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+
 if test -z "$inhibit_glue"; then
 # For signame.c, used in make_siglist.
+
+
 for ac_func in psignal
 do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:8: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat > conftest.$ac_ext <<EOF
-#line 13 "configure"
-#include "confdefs.h"
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
 
-int main() {
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-$ac_func();
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
-; return 0; }
-EOF
-if { (eval echo configure:36: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
 fi
-rm -f conftest*
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
 fi
 done
 
diff -Nur sysdeps/generic/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/configure.in
--- sysdeps/generic/configure.in	1994-12-08 10:00:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/configure.in	2002-10-18 21:38:00.000000000 +0200
@@ -1,4 +1,3 @@
-sinclude(./aclocal.m4)dnl
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 
 if test -z "$inhibit_glue"; then
diff -Nur sysdeps/generic/conjf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/conjf.c
--- sysdeps/generic/conjf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/conjf.c	2004-01-13 10:08:04.000000000 +0100
@@ -0,0 +1,28 @@
+/* Return complex conjugate of complex float value.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <complex.h>
+
+float _Complex
+__conjf (float _Complex z)
+{
+  return ~z;
+}
+weak_alias (__conjf, conjf)
diff -Nur sysdeps/generic/crealf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/crealf.c
--- sysdeps/generic/crealf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/crealf.c	2004-01-13 10:08:04.000000000 +0100
@@ -0,0 +1,28 @@
+/* Return real part of complex float value.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <complex.h>
+
+float
+__crealf (float _Complex z)
+{
+  return __real__ z;
+}
+weak_alias (__crealf, crealf)
diff -Nur sysdeps/generic/creat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/creat.c
--- sysdeps/generic/creat.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/creat.c	2003-01-07 01:12:31.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,14 +18,19 @@
 
 #include <fcntl.h>
 #include <sys/types.h>
+#include <sysdep-cancel.h>
 
 #undef	creat
 
 /* Create FILE with protections MODE.  */
 int
-creat (file, mode)
+__libc_creat (file, mode)
      const char *file;
      mode_t mode;
 {
   return __open (file, O_WRONLY|O_CREAT|O_TRUNC, mode);
 }
+weak_alias (__libc_creat, creat)
+
+/* __open handles cancellation.  */
+LIBC_CANCEL_HANDLED ();
diff -Nur sysdeps/generic/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/Dist
--- sysdeps/generic/Dist	2002-08-28 10:22:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/Dist	2003-02-21 07:58:09.000000000 +0100
@@ -23,3 +23,4 @@
 bp-sym.h
 bp-start.h
 bits/link.h
+sysdep-cancel.h
diff -Nur sysdeps/generic/dl-cache.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-cache.c
--- sysdeps/generic/dl-cache.c	2002-02-06 18:23:41.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-cache.c	2004-03-19 01:36:32.000000000 +0100
@@ -1,5 +1,5 @@
 /* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
-   Copyright (C) 1996,1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1996-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -107,12 +107,12 @@
 		if (_dl_cache_check_flags (flags)			      \
 		    && _dl_cache_verify_ptr (lib->value))		      \
 		  {							      \
-		    if (best == NULL || flags == GL(dl_correct_cache_id))     \
+		    if (best == NULL || flags == GLRO(dl_correct_cache_id))   \
 		      {							      \
 			HWCAP_CHECK;					      \
 			best = cache_data + lib->value;			      \
 									      \
-			if (flags == GL(dl_correct_cache_id))		      \
+			if (flags == GLRO(dl_correct_cache_id))		      \
 			  /* We've found an exact match for the shared	      \
 			     object and no general `ELF' release.  Stop	      \
 			     searching.  */				      \
@@ -133,6 +133,45 @@
 while (0)
 
 
+int
+internal_function
+_dl_cache_libcmp (const char *p1, const char *p2)
+{
+  while (*p1 != '\0')
+    {
+      if (*p1 >= '0' && *p1 <= '9')
+        {
+          if (*p2 >= '0' && *p2 <= '9')
+            {
+	      /* Must compare this numerically.  */
+	      int val1;
+	      int val2;
+
+	      val1 = *p1++ - '0';
+	      val2 = *p2++ - '0';
+	      while (*p1 >= '0' && *p1 <= '9')
+	        val1 = val1 * 10 + *p1++ - '0';
+	      while (*p2 >= '0' && *p2 <= '9')
+	        val2 = val2 * 10 + *p2++ - '0';
+	      if (val1 != val2)
+		return val1 - val2;
+	    }
+	  else
+            return 1;
+        }
+      else if (*p2 >= '0' && *p2 <= '9')
+        return -1;
+      else if (*p1 != *p2)
+        return *p1 - *p2;
+      else
+	{
+	  ++p1;
+	  ++p2;
+	}
+    }
+  return *p1 - *p2;
+}
+
 
 /* Look up NAME in ld.so.cache and return the file name stored there,
    or null if none is found.  */
@@ -148,8 +187,8 @@
   const char *best;
 
   /* Print a message if the loading of libs is traced.  */
-  if (__builtin_expect (GL(dl_debug_mask) & DL_DEBUG_LIBS, 0))
-    INTUSE(_dl_debug_printf) (" search cache=%s\n", LD_SO_CACHE);
+  if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
+    _dl_debug_printf (" search cache=%s\n", LD_SO_CACHE);
 
   if (cache == NULL)
     {
@@ -204,12 +243,7 @@
 
   if (cache_new != (void *) -1)
     {
-      /* This file ends in static libraries where we don't have a hwcap.  */
-      unsigned long int *hwcap;
       uint64_t platform;
-#ifndef SHARED
-      weak_extern (_dl_hwcap);
-#endif
 
       /* This is where the strings start.  */
       cache_data = (const char *) cache_new;
@@ -217,22 +251,25 @@
       /* Now we can compute how large the string table is.  */
       cache_data_size = (const char *) cache + cachesize - cache_data;
 
-      hwcap = &GL(dl_hwcap);
-      platform = _dl_string_platform (GL(dl_platform));
-      if (platform != -1)
+      platform = _dl_string_platform (GLRO(dl_platform));
+      if (platform != (uint64_t) -1)
 	platform = 1ULL << platform;
 
       /* Only accept hwcap if it's for the right platform.  */
+#ifdef USE_TLS
+# define _DL_HWCAP_TLS_MASK (1LL << 63)
+#else
+# define _DL_HWCAP_TLS_MASK 0
+#endif
 #define HWCAP_CHECK \
-      if (GL(dl_osversion)						      \
-	  && cache_new->libs[middle].osversion > GL(dl_osversion))	      \
+      if (GLRO(dl_osversion) && lib->osversion > GLRO(dl_osversion))	      \
 	continue;							      \
       if (_DL_PLATFORMS_COUNT && platform != -1				      \
 	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != 0			      \
 	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != platform)		      \
 	continue;							      \
-      if (hwcap								      \
-	  && ((lib->hwcap & *hwcap & ~_DL_HWCAP_PLATFORM) > *hwcap))	      \
+      if (lib->hwcap							      \
+	  & ~(GLRO(dl_hwcap) | _DL_HWCAP_PLATFORM | _DL_HWCAP_TLS_MASK))      \
 	continue
       SEARCH_CACHE (cache_new);
     }
@@ -250,8 +287,9 @@
     }
 
   /* Print our result if wanted.  */
-  if (__builtin_expect (GL(dl_debug_mask) & DL_DEBUG_LIBS, 0) && best != NULL)
-    INTUSE(_dl_debug_printf) ("  trying file=%s\n", best);
+  if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0)
+      && best != NULL)
+    _dl_debug_printf ("  trying file=%s\n", best);
 
   return best;
 }
@@ -270,5 +308,4 @@
       cache = NULL;
     }
 }
-INTDEF (_dl_unload_cache)
 #endif
diff -Nur sysdeps/generic/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-cache.h
--- sysdeps/generic/dl-cache.h	2002-08-25 11:25:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-cache.h	2003-06-25 10:01:22.000000000 +0200
@@ -1,5 +1,5 @@
 /* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
-   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,6 +32,10 @@
 # define LD_SO_CACHE SYSCONFDIR "/ld.so.cache"
 #endif
 
+#ifndef add_system_dir
+# define add_system_dir(dir) add_dir (dir)
+#endif
+
 #define CACHEMAGIC "ld.so-1.7.0"
 
 /* libc5 and glibc 2.0/2.1 use the same format.  For glibc 2.2 another
@@ -97,41 +101,5 @@
 (((addr) + __alignof__ (struct cache_file_new) -1)	\
  & (~(__alignof__ (struct cache_file_new) - 1)))
 
-static inline int
-__attribute__ ((__unused__))
-_dl_cache_libcmp (const char *p1, const char *p2)
-{
-  while (*p1 != '\0')
-    {
-      if (*p1 >= '0' && *p1 <= '9')
-        {
-          if (*p2 >= '0' && *p2 <= '9')
-            {
-	      /* Must compare this numerically.  */
-	      int val1;
-	      int val2;
-
-	      val1 = *p1++ - '0';
-	      val2 = *p2++ - '0';
-	      while (*p1 >= '0' && *p1 <= '9')
-	        val1 = val1 * 10 + *p1++ - '0';
-	      while (*p2 >= '0' && *p2 <= '9')
-	        val2 = val2 * 10 + *p2++ - '0';
-	      if (val1 != val2)
-		return val1 - val2;
-	    }
-	  else
-            return 1;
-        }
-      else if (*p2 >= '0' && *p2 <= '9')
-        return -1;
-      else if (*p1 != *p2)
-        return *p1 - *p2;
-      else
-	{
-	  ++p1;
-	  ++p2;
-	}
-    }
-  return *p1 - *p2;
-}
+extern int _dl_cache_libcmp (const char *p1, const char *p2)
+     internal_function;
diff -Nur sysdeps/generic/dl-execstack.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-execstack.c
--- sysdeps/generic/dl-execstack.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-execstack.c	2004-01-16 03:44:39.000000000 +0100
@@ -0,0 +1,32 @@
+/* Stack executability handling for GNU dynamic linker.  Stub version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <errno.h>
+
+/* There is no portable way to know the bounds of the initial thread's stack
+   so as to mprotect it.  */
+
+int
+internal_function
+_dl_make_stack_executable (void **stack_endp)
+{
+  return ENOSYS;
+}
+rtld_hidden_def (_dl_make_stack_executable)
diff -Nur sysdeps/generic/dl-fptr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-fptr.c
--- sysdeps/generic/dl-fptr.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-fptr.c	2004-03-06 09:12:40.000000000 +0100
@@ -0,0 +1,323 @@
+/* Manage function descriptors.  Generic version.
+   Copyright (C) 1999,2000,2001,2002,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <libintl.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/mman.h>
+#include <link.h>
+#include <ldsodefs.h>
+#include <elf/dynamic-link.h>
+#include <dl-fptr.h>
+#include <atomic.h>
+
+#ifndef ELF_MACHINE_BOOT_FPTR_TABLE_LEN
+/* ELF_MACHINE_BOOT_FPTR_TABLE_LEN should be greater than the number of
+   dynamic symbols in ld.so.  */
+# define ELF_MACHINE_BOOT_FPTR_TABLE_LEN 256
+#endif
+
+#ifndef ELF_MACHINE_LOAD_ADDRESS
+# error "ELF_MACHINE_LOAD_ADDRESS is not defined."
+#endif
+
+#ifndef COMPARE_AND_SWAP
+# define COMPARE_AND_SWAP(ptr, old, new) \
+  (atomic_compare_and_exchange_bool_acq (ptr, new, old) == 0)
+#endif
+
+ElfW(Addr) _dl_boot_fptr_table [ELF_MACHINE_BOOT_FPTR_TABLE_LEN];
+
+static struct local
+  {
+    struct fdesc_table *root;
+    struct fdesc *free_list;
+    unsigned int npages;		/* # of pages to allocate */
+    /* the next to members MUST be consecutive! */
+    struct fdesc_table boot_table;
+    struct fdesc boot_fdescs[1024];
+  }
+local =
+  {
+    .root = &local.boot_table,
+    .npages = 2,
+    .boot_table =
+      {
+	.len = sizeof (local.boot_fdescs) / sizeof (local.boot_fdescs[0]),
+	.first_unused = 0
+      }
+  };
+
+/* Create a new fdesc table and return a pointer to the first fdesc
+   entry.  The fdesc lock must have been acquired already.  */
+
+static struct fdesc_table *
+new_fdesc_table (struct local *l, size_t *size)
+{
+  size_t old_npages = l->npages;
+  size_t new_npages = old_npages + old_npages;
+  struct fdesc_table *new_table;
+
+  /* If someone has just created a new table, we return NULL to tell
+     the caller to use the new table.  */
+  if (! COMPARE_AND_SWAP (&l->npages, old_npages, new_npages))
+    return (struct fdesc_table *) NULL;
+
+  *size = old_npages * GLRO(dl_pagesize);
+  new_table = __mmap (NULL, *size,
+		      PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
+  if (new_table == MAP_FAILED)
+    _dl_signal_error (errno, NULL, NULL,
+		      N_("cannot map pages for fdesc table"));
+
+  new_table->len
+    = (*size - sizeof (*new_table)) / sizeof (struct fdesc);
+  new_table->first_unused = 1;
+  return new_table;
+}
+
+
+static ElfW(Addr)
+make_fdesc (ElfW(Addr) ip, ElfW(Addr) gp)
+{
+  struct fdesc *fdesc = NULL;
+  struct fdesc_table *root;
+  unsigned int old;
+  struct local *l;
+
+  ELF_MACHINE_LOAD_ADDRESS (l, local);
+
+ retry:
+  root = l->root;
+  while (1)
+    {
+      old = root->first_unused;
+      if (old >= root->len)
+	break;
+      else if (COMPARE_AND_SWAP (&root->first_unused, old, old + 1))
+	{
+	  fdesc = &root->fdesc[old];
+	  goto install;
+	}
+    }
+
+  if (l->free_list)
+    {
+      /* Get it from free-list.  */
+      do
+	{
+	  fdesc = l->free_list;
+	  if (fdesc == NULL)
+	    goto retry;
+	}
+      while (! COMPARE_AND_SWAP ((ElfW(Addr) *) &l->free_list,
+				 (ElfW(Addr)) fdesc, fdesc->ip));
+    }
+  else
+    {
+      /* Create a new fdesc table.  */
+      size_t size;
+      struct fdesc_table *new_table = new_fdesc_table (l, &size);
+
+      if (new_table == NULL)
+	goto retry;
+
+      new_table->next = root;
+      if (! COMPARE_AND_SWAP ((ElfW(Addr) *) &l->root,
+			      (ElfW(Addr)) root,
+			      (ElfW(Addr)) new_table))
+	{
+	  /* Someone has just installed a new table. Return NULL to
+	     tell the caller to use the new table.  */
+	  __munmap (new_table, size);
+	  goto retry;
+	}
+
+      /* Note that the first entry was reserved while allocating the
+	 memory for the new page.  */
+      fdesc = &new_table->fdesc[0];
+    }
+
+ install:
+  fdesc->ip = ip;
+  fdesc->gp = gp;
+
+  return (ElfW(Addr)) fdesc;
+}
+
+
+static inline ElfW(Addr) * __attribute__ ((always_inline))
+make_fptr_table (struct link_map *map)
+{
+  const ElfW(Sym) *symtab
+    = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
+  const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+  ElfW(Addr) *fptr_table;
+  size_t size;
+  size_t len;
+
+  /* XXX Apparently the only way to find out the size of the dynamic
+     symbol section is to assume that the string table follows right
+     afterwards...  */
+  len = ((strtab - (char *) symtab)
+	 / map->l_info[DT_SYMENT]->d_un.d_val);
+  size = ((len * sizeof (fptr_table[0]) + GLRO(dl_pagesize) - 1)
+	  & -GLRO(dl_pagesize));
+  /* XXX We don't support here in the moment systems without MAP_ANON.
+     There probably are none for IA-64.  In case this is proven wrong
+     we will have to open /dev/null here and use the file descriptor
+     instead of the hard-coded -1.  */
+  fptr_table = __mmap (NULL, size,
+		       PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE,
+		       -1, 0);
+  if (fptr_table == MAP_FAILED)
+    _dl_signal_error (errno, NULL, NULL,
+		      N_("cannot map pages for fptr table"));
+
+  if (COMPARE_AND_SWAP ((ElfW(Addr) *) &map->l_mach.fptr_table,
+			(ElfW(Addr)) NULL, (ElfW(Addr)) fptr_table))
+    map->l_mach.fptr_table_len = len;
+  else
+    __munmap (fptr_table, len * sizeof (fptr_table[0]));
+
+  return map->l_mach.fptr_table;
+}
+
+
+ElfW(Addr)
+_dl_make_fptr (struct link_map *map, const ElfW(Sym) *sym,
+	       ElfW(Addr) ip)
+{
+  ElfW(Addr) *ftab = map->l_mach.fptr_table;
+  const ElfW(Sym) *symtab;
+  Elf_Symndx symidx;
+  struct local *l;
+
+  if (__builtin_expect (ftab == NULL, 0))
+    ftab = make_fptr_table (map);
+
+  symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
+  symidx = sym - symtab;
+
+  if (symidx >= map->l_mach.fptr_table_len)
+    _dl_signal_error (0, NULL, NULL,
+		      N_("internal error: symidx out of range of fptr table"));
+
+  while (ftab[symidx] == 0)
+    {
+      /* GOT has already been relocated in elf_get_dynamic_info -
+	 don't try to relocate it again.  */
+      ElfW(Addr) fdesc
+	= make_fdesc (ip, map->l_info[DT_PLTGOT]->d_un.d_ptr);
+
+      if (__builtin_expect (COMPARE_AND_SWAP (&ftab[symidx], (ElfW(Addr)) NULL,
+					      fdesc), 1))
+	{
+	  /* Noone has updated the entry and the new function
+	     descriptor has been installed.  */
+#if 0
+	  const char *strtab
+	    = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+
+	  ELF_MACHINE_LOAD_ADDRESS (l, local);
+	  if (l->root != &l->boot_table
+	      || l->boot_table.first_unused > 20)
+	    _dl_debug_printf ("created fdesc symbol `%s' at %lx\n",
+			      strtab + sym->st_name, ftab[symidx]);
+#endif
+	  break;
+	}
+      else
+	{
+	  /* We created a duplicated function descriptor. We put it on
+	     free-list.  */
+	  struct fdesc *f = (struct fdesc *) fdesc;
+
+	  ELF_MACHINE_LOAD_ADDRESS (l, local);
+
+	  do
+	    f->ip = (ElfW(Addr)) l->free_list;
+	  while (! COMPARE_AND_SWAP ((ElfW(Addr) *) &l->free_list,
+				     f->ip, fdesc));
+	}
+    }
+
+  return ftab[symidx];
+}
+
+
+void
+_dl_unmap (struct link_map *map)
+{
+  ElfW(Addr) *ftab = map->l_mach.fptr_table;
+  struct fdesc *head = NULL, *tail = NULL;
+  size_t i;
+
+  __munmap ((void *) map->l_map_start,
+	    map->l_map_end - map->l_map_start);
+
+  if (ftab == NULL)
+    return;
+
+  /* String together the fdesc structures that are being freed.  */
+  for (i = 0; i < map->l_mach.fptr_table_len; ++i)
+    {
+      if (ftab[i])
+	{
+	  *(struct fdesc **) ftab[i] = head;
+	  head = (struct fdesc *) ftab[i];
+	  if (tail == NULL)
+	    tail = head;
+	}
+    }
+
+  /* Prepend the new list to the free_list: */
+  if (tail)
+    do
+      tail->ip = (ElfW(Addr)) local.free_list;
+    while (! COMPARE_AND_SWAP ((ElfW(Addr) *) &local.free_list,
+			       tail->ip, (ElfW(Addr)) head));
+
+  __munmap (ftab, (map->l_mach.fptr_table_len
+		   * sizeof (map->l_mach.fptr_table[0])));
+
+  map->l_mach.fptr_table = NULL;
+}
+
+
+ElfW(Addr)
+_dl_lookup_address (const void *address)
+{
+  ElfW(Addr) addr = (ElfW(Addr)) address;
+  struct fdesc_table *t;
+  unsigned long int i;
+
+  for (t = local.root; t != NULL; t = t->next)
+    {
+      i = (struct fdesc *) addr - &t->fdesc[0];
+      if (i < t->first_unused && addr == (ElfW(Addr)) &t->fdesc[i])
+	{
+	  addr = t->fdesc[i].ip;
+	  break;
+	}
+    }
+
+  return addr;
+}
diff -Nur sysdeps/generic/dl-fptr.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-fptr.h
--- sysdeps/generic/dl-fptr.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-fptr.h	2003-05-02 04:37:21.000000000 +0200
@@ -0,0 +1,44 @@
+/* Function descriptors. Generic version.
+   Copyright (C) 1995, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef dl_fptr_h
+#define dl_fptr_h 1
+
+/* An FDESC is a function descriptor.  */
+
+struct fdesc
+  {
+    ElfW(Addr) ip;	/* code entry point */
+    ElfW(Addr) gp;	/* global pointer */
+  };
+
+struct fdesc_table
+  {
+    struct fdesc_table *next;
+    unsigned int len;			/* # of entries in fdesc table */
+    volatile unsigned int first_unused;	/* index of first available entry */
+    struct fdesc fdesc[0];
+  };
+
+extern ElfW(Addr) _dl_boot_fptr_table [];
+
+extern ElfW(Addr) _dl_make_fptr (struct link_map *, const ElfW(Sym) *,
+				 ElfW(Addr));
+
+#endif /* !dl_fptr_h */
diff -Nur sysdeps/generic/dl-hash.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-hash.h
--- sysdeps/generic/dl-hash.h	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-hash.h	2003-06-18 20:29:38.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute hash value for given string according to ELF standard.
-   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,7 +24,7 @@
 /* This is the hashing function specified by the ELF ABI.  In the
    first five operations no overflow is possible so we optimized it a
    bit.  */
-static inline unsigned int
+static unsigned int
 _dl_elf_hash (const unsigned char *name)
 {
   unsigned long int hash = 0;
diff -Nur sysdeps/generic/dl-iteratephdr-static.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-iteratephdr-static.c
--- sysdeps/generic/dl-iteratephdr-static.c	2002-08-27 06:52:37.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-iteratephdr-static.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* Get static program's program headers.
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2001.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-#include <errno.h>
-#include <elf/link.h>
-#include <stddef.h>
-
-int
-dl_iterate_phdr (int (*callback) (struct dl_phdr_info *info,
-				  size_t size, void *data), void *data)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/generic/dl-lookupcfg.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-lookupcfg.h
--- sysdeps/generic/dl-lookupcfg.h	2002-09-29 19:46:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-lookupcfg.h	2002-10-11 14:19:50.000000000 +0200
@@ -22,6 +22,9 @@
 
    However, because of how _dl_sym and _dl_tls_symaddr are written, every
    platform needs it when we support TLS.  */
+
+#include <tls.h>		/* Defines USE_TLS (or doesn't).  */
+
 #ifdef USE_TLS
 # define DL_LOOKUP_RETURNS_MAP
 #else
diff -Nur sysdeps/generic/dl-origin.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-origin.c
--- sysdeps/generic/dl-origin.c	2002-03-01 06:44:26.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-origin.c	2004-03-06 09:12:40.000000000 +0100
@@ -1,5 +1,5 @@
 /* Find path of executable.
-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -26,22 +26,21 @@
 #include <dl-dst.h>
 
 
-#undef _dl_get_origin
 const char *
 _dl_get_origin (void)
 {
   char *result = (char *) -1;
   /* We use the environment variable LD_ORIGIN_PATH.  If it is set make
      a copy and strip out trailing slashes.  */
-  if (GL(dl_origin_path) != NULL)
+  if (GLRO(dl_origin_path) != NULL)
     {
-      size_t len = strlen (GL(dl_origin_path));
+      size_t len = strlen (GLRO(dl_origin_path));
       result = (char *) malloc (len + 1);
       if (result == NULL)
 	result = (char *) -1;
       else
 	{
-	  char *cp = __mempcpy (result, GL(dl_origin_path), len);
+	  char *cp = __mempcpy (result, GLRO(dl_origin_path), len);
 	  while (cp > result + 1 && cp[-1] == '/')
 	    --cp;
 	  *cp = '\0';
@@ -50,4 +49,3 @@
 
   return result;
 }
-INTDEF(_dl_get_origin)
diff -Nur sysdeps/generic/dl-symaddr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-symaddr.c
--- sysdeps/generic/dl-symaddr.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-symaddr.c	2003-05-02 05:28:25.000000000 +0200
@@ -0,0 +1,33 @@
+/* Get the symbol address.  Generic version.
+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <dl-fptr.h>
+
+void *
+_dl_symbol_address (struct link_map *map, const ElfW(Sym) *ref)
+{
+  ElfW(Addr) value = (map ? map->l_addr : 0) + ref->st_value;
+
+  /* Return the pointer to function descriptor. */
+  if (ELFW(ST_TYPE) (ref->st_info) == STT_FUNC)
+    return (void *) _dl_make_fptr (map, ref, value);
+  else
+    return (void *) value;
+}
diff -Nur sysdeps/generic/dl-sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-sysdep.c
--- sysdeps/generic/dl-sysdep.c	2002-07-20 19:30:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-sysdep.c	2004-11-06 01:24:47.000000000 +0100
@@ -1,5 +1,5 @@
 /* Operating system support for run-time dynamic linker.  Generic Unix version.
-   Copyright (C) 1995-1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,6 +37,7 @@
 #include <dl-procinfo.h>
 #include <dl-osinfo.h>
 #include <hp-timing.h>
+#include <tls.h>
 
 extern char **_environ attribute_hidden;
 extern void _end attribute_hidden;
@@ -47,13 +48,14 @@
 #ifdef NEED_DL_BASE_ADDR
 ElfW(Addr) _dl_base_addr;
 #endif
-int __libc_enable_secure = 0;
+int __libc_enable_secure attribute_relro = 0;
 INTVARDEF(__libc_enable_secure)
 int __libc_multiple_libcs = 0;	/* Defining this here avoids the inclusion
 				   of init-first.  */
 /* This variable contains the lowest stack address ever used.  */
-void *__libc_stack_end;
-static ElfW(auxv_t) *_dl_auxv;
+void *__libc_stack_end attribute_relro = NULL;
+rtld_hidden_data_def(__libc_stack_end)
+static ElfW(auxv_t) *_dl_auxv attribute_relro;
 
 #ifndef DL_FIND_ARG_COMPONENTS
 # define DL_FIND_ARG_COMPONENTS(cookie, argc, argv, envp, auxp)	\
@@ -68,6 +70,9 @@
   } while (0)
 #endif
 
+#ifndef DL_STACK_END
+# define DL_STACK_END(cookie) ((void *) (cookie))
+#endif
 
 ElfW(Addr)
 _dl_sysdep_start (void **start_argptr,
@@ -78,21 +83,31 @@
   ElfW(Word) phnum = 0;
   ElfW(Addr) user_entry;
   ElfW(auxv_t) *av;
+#ifdef HAVE_AUX_SECURE
+# define set_seen(tag) (tag)	/* Evaluate for the side effects.  */
+# define set_seen_secure() ((void) 0)
+#else
   uid_t uid = 0;
   gid_t gid = 0;
-#ifdef HAVE_AUX_XID
-# define set_seen(tag) (tag) /* Evaluate for the side effects.  */
-#else
   unsigned int seen = 0;
-# define M(type) (1 << (type))
-# define set_seen(tag) seen |= M ((tag)->a_type)
+# define set_seen_secure() (seen = -1)
+# ifdef HAVE_AUX_XID
+#  define set_seen(tag) (tag)	/* Evaluate for the side effects.  */
+# else
+#  define M(type) (1 << (type))
+#  define set_seen(tag) seen |= M ((tag)->a_type)
+# endif
+#endif
+#ifdef NEED_DL_SYSINFO
+  uintptr_t new_sysinfo = 0;
 #endif
 
+  __libc_stack_end = DL_STACK_END (start_argptr);
   DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, INTUSE(_dl_argv), _environ,
 			  _dl_auxv);
 
   user_entry = (ElfW(Addr)) ENTRY_POINT;
-  GL(dl_platform) = NULL; /* Default to nothing known about the platform.  */
+  GLRO(dl_platform) = NULL; /* Default to nothing known about the platform.  */
 
   for (av = _dl_auxv; av->a_type != AT_NULL; set_seen (av++))
     switch (av->a_type)
@@ -104,7 +119,7 @@
 	phnum = av->a_un.a_val;
 	break;
       case AT_PAGESZ:
-	GL(dl_pagesize) = av->a_un.a_val;
+	GLRO(dl_pagesize) = av->a_un.a_val;
 	break;
       case AT_ENTRY:
 	user_entry = av->a_un.a_val;
@@ -114,6 +129,7 @@
 	_dl_base_addr = av->a_un.a_val;
 	break;
 #endif
+#ifndef HAVE_AUX_SECURE
       case AT_UID:
       case AT_EUID:
 	uid ^= av->a_un.a_val;
@@ -122,42 +138,73 @@
       case AT_EGID:
 	gid ^= av->a_un.a_val;
 	break;
+#endif
+      case AT_SECURE:
+#ifndef HAVE_AUX_SECURE
+	seen = -1;
+#endif
+	INTUSE(__libc_enable_secure) = av->a_un.a_val;
+	break;
       case AT_PLATFORM:
-	GL(dl_platform) = av->a_un.a_ptr;
+	GLRO(dl_platform) = av->a_un.a_ptr;
 	break;
       case AT_HWCAP:
-	GL(dl_hwcap) = av->a_un.a_val;
+	GLRO(dl_hwcap) = av->a_un.a_val;
 	break;
       case AT_CLKTCK:
-	GL(dl_clktck) = av->a_un.a_val;
+	GLRO(dl_clktck) = av->a_un.a_val;
 	break;
       case AT_FPUCW:
-	GL(dl_fpu_control) = av->a_un.a_val;
+	GLRO(dl_fpu_control) = av->a_un.a_val;
 	break;
+#ifdef NEED_DL_SYSINFO
+      case AT_SYSINFO:
+	new_sysinfo = av->a_un.a_val;
+	break;
+#endif
+#if defined NEED_DL_SYSINFO || defined NEED_DL_SYSINFO_DSO
+      case AT_SYSINFO_EHDR:
+	GLRO(dl_sysinfo_dso) = av->a_un.a_ptr;
+	break;
+#endif
+#ifdef DL_PLATFORM_AUXV
+      DL_PLATFORM_AUXV
+#endif
       }
 
 #ifdef DL_SYSDEP_OSCHECK
   DL_SYSDEP_OSCHECK (dl_fatal);
 #endif
 
-  /* Fill in the values we have not gotten from the kernel through the
-     auxiliary vector.  */
-#ifndef HAVE_AUX_XID
-# define SEE(UID, var, uid) \
+#ifndef HAVE_AUX_SECURE
+  if (seen != -1)
+    {
+      /* Fill in the values we have not gotten from the kernel through the
+	 auxiliary vector.  */
+# ifndef HAVE_AUX_XID
+#  define SEE(UID, var, uid) \
    if ((seen & M (AT_##UID)) == 0) var ^= __get##uid ()
-  SEE (UID, uid, uid);
-  SEE (EUID, uid, euid);
-  SEE (GID, gid, gid);
-  SEE (EGID, gid, egid);
+      SEE (UID, uid, uid);
+      SEE (EUID, uid, euid);
+      SEE (GID, gid, gid);
+      SEE (EGID, gid, egid);
+# endif
+
+      /* If one of the two pairs of IDs does not match this is a setuid
+	 or setgid run.  */
+      INTUSE(__libc_enable_secure) = uid | gid;
+    }
 #endif
 
-  /* If one of the two pairs of IDs does not mattch this is a setuid
-     or setgid run.  */
-  INTUSE(__libc_enable_secure) = uid | gid;
-
 #ifndef HAVE_AUX_PAGESIZE
-  if (GL(dl_pagesize) == 0)
-    GL(dl_pagesize) = __getpagesize ();
+  if (GLRO(dl_pagesize) == 0)
+    GLRO(dl_pagesize) = __getpagesize ();
+#endif
+
+#if defined NEED_DL_SYSINFO
+  /* Only set the sysinfo value if we also have the vsyscall DSO.  */
+  if (GLRO(dl_sysinfo_dso) != 0 && new_sysinfo)
+    GLRO(dl_sysinfo) = new_sysinfo;
 #endif
 
 #ifdef DL_SYSDEP_INIT
@@ -169,8 +216,8 @@
 #endif
 
   /* Determine the length of the platform name.  */
-  if (GL(dl_platform) != NULL)
-    GL(dl_platformlen) = strlen (GL(dl_platform));
+  if (GLRO(dl_platform) != NULL)
+    GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
 
   if (__sbrk (0) == &_end)
     /* The dynamic linker was run as a program, and so the initial break
@@ -178,7 +225,8 @@
        will consume the rest of this page, so tell the kernel to move the
        break up that far.  When the user program examines its break, it
        will see this new value and not clobber our data.  */
-    __sbrk (GL(dl_pagesize) - ((&_end - (void *) 0) & (GL(dl_pagesize) - 1)));
+    __sbrk (GLRO(dl_pagesize)
+	    - ((&_end - (void *) 0) & (GLRO(dl_pagesize) - 1)));
 
   /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
      allocated.  If necessary we are doing it ourself.  If it is not
@@ -207,59 +255,83 @@
   buf[63] = '\0';
 
   /* The following code assumes that the AT_* values are encoded
-  starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values
-  close by (otherwise the array will be too large).  In case we have
-  to support a platform where these requirements are not fulfilled
-  some alternative implementation has to be used.  */
+     starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values
+     close by (otherwise the array will be too large).  In case we have
+     to support a platform where these requirements are not fulfilled
+     some alternative implementation has to be used.  */
   for (av = _dl_auxv; av->a_type != AT_NULL; ++av)
     {
       static const struct
       {
 	const char label[20];
-	enum { dec, hex, str } form;
+	enum { unknown = 0, dec, hex, str, ignore } form;
       } auxvars[] =
 	{
-	  [AT_EXECFD - 2] =		{ "AT_EXECFD:      ", dec },
-	  [AT_PHDR - 2] =		{ "AT_PHDR:        0x", hex },
-	  [AT_PHENT - 2] =		{ "AT_PHENT:       ", dec },
-	  [AT_PHNUM - 2] =		{ "AT_PHNUM:       ", dec },
-	  [AT_PAGESZ - 2] =		{ "AT_PAGESZ:      ", dec },
-	  [AT_BASE - 2] =		{ "AT_BASE:        0x", hex },
-	  [AT_FLAGS - 2] =		{ "AT_FLAGS:       0x", hex },
-	  [AT_ENTRY - 2] =		{ "AT_ENTRY:       0x", hex },
-	  [AT_NOTELF - 2] =		{ "AT_NOTELF:      ", hex },
-	  [AT_UID - 2] =		{ "AT_UID:         ", dec },
-	  [AT_EUID - 2] =		{ "AT_EUID:        ", dec },
-	  [AT_GID - 2] =		{ "AT_GID:         ", dec },
-	  [AT_EGID - 2] =		{ "AT_EGID:        ", dec },
-	  [AT_PLATFORM - 2] =		{ "AT_PLATFORM:    ", str },
-	  [AT_HWCAP - 2] =		{ "AT_HWCAP:       ", hex },
-	  [AT_CLKTCK - 2] =		{ "AT_CLKTCK:      ", dec },
-	  [AT_FPUCW - 2] =		{ "AT_FPUCW:       ", hex },
-	  [AT_DCACHEBSIZE - 2] =	{ "AT_DCACHEBSIZE: 0x", hex },
-	  [AT_ICACHEBSIZE - 2] =	{ "AT_ICACHEBSIZE: 0x", hex },
-	  [AT_UCACHEBSIZE - 2] =	{ "AT_UCACHEBSIZE: 0x", hex }
+	  [AT_EXECFD - 2] =		{ "AT_EXECFD:       ", dec },
+	  [AT_PHDR - 2] =		{ "AT_PHDR:         0x", hex },
+	  [AT_PHENT - 2] =		{ "AT_PHENT:        ", dec },
+	  [AT_PHNUM - 2] =		{ "AT_PHNUM:        ", dec },
+	  [AT_PAGESZ - 2] =		{ "AT_PAGESZ:       ", dec },
+	  [AT_BASE - 2] =		{ "AT_BASE:         0x", hex },
+	  [AT_FLAGS - 2] =		{ "AT_FLAGS:        0x", hex },
+	  [AT_ENTRY - 2] =		{ "AT_ENTRY:        0x", hex },
+	  [AT_NOTELF - 2] =		{ "AT_NOTELF:       ", hex },
+	  [AT_UID - 2] =		{ "AT_UID:          ", dec },
+	  [AT_EUID - 2] =		{ "AT_EUID:         ", dec },
+	  [AT_GID - 2] =		{ "AT_GID:          ", dec },
+	  [AT_EGID - 2] =		{ "AT_EGID:         ", dec },
+	  [AT_PLATFORM - 2] =		{ "AT_PLATFORM:     ", str },
+	  [AT_HWCAP - 2] =		{ "AT_HWCAP:        ", hex },
+	  [AT_CLKTCK - 2] =		{ "AT_CLKTCK:       ", dec },
+	  [AT_FPUCW - 2] =		{ "AT_FPUCW:        ", hex },
+	  [AT_DCACHEBSIZE - 2] =	{ "AT_DCACHEBSIZE:  0x", hex },
+	  [AT_ICACHEBSIZE - 2] =	{ "AT_ICACHEBSIZE:  0x", hex },
+	  [AT_UCACHEBSIZE - 2] =	{ "AT_UCACHEBSIZE:  0x", hex },
+	  [AT_IGNOREPPC - 2] =		{ "AT_IGNOREPPC", ignore },
+	  [AT_SECURE - 2] =		{ "AT_SECURE:       ", dec },
+	  [AT_SYSINFO - 2] =		{ "AT_SYSINFO:      0x", hex },
+	  [AT_SYSINFO_EHDR - 2] =	{ "AT_SYSINFO_EHDR: 0x", hex },
 	};
       unsigned int idx = (unsigned int) (av->a_type - 2);
 
+      if ((unsigned int) av->a_type < 2u || auxvars[idx].form == ignore)
+	continue;
+
       assert (AT_NULL == 0);
       assert (AT_IGNORE == 1);
-      if (idx < sizeof (auxvars) / sizeof (auxvars[0]))
+
+      if (av->a_type == AT_HWCAP)
+	{
+	  /* This is handled special.  */
+	  if (_dl_procinfo (av->a_un.a_val) == 0)
+	    continue;
+	}
+
+      if (idx < sizeof (auxvars) / sizeof (auxvars[0])
+	  && auxvars[idx].form != unknown)
 	{
-	  if (av->a_type != AT_HWCAP || _dl_procinfo (av->a_un.a_val) < 0)
-	    {
-	      const char *val = av->a_un.a_ptr;
-
-	      if (__builtin_expect (auxvars[idx].form, dec) == dec)
-		val = _itoa ((unsigned long int) av->a_un.a_val,
-			     buf + sizeof buf - 1, 10, 0);
-	      else if (__builtin_expect (auxvars[idx].form, hex) == hex)
-		val = _itoa ((unsigned long int) av->a_un.a_val,
-			     buf + sizeof buf - 1, 16, 0);
+	  const char *val = av->a_un.a_ptr;
+
+	  if (__builtin_expect (auxvars[idx].form, dec) == dec)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 10, 0);
+	  else if (__builtin_expect (auxvars[idx].form, hex) == hex)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 16, 0);
 
-	      _dl_printf ("%s%s\n", auxvars[idx].label, val);
-	    }
+	  _dl_printf ("%s%s\n", auxvars[idx].label, val);
+
+	  continue;
 	}
+
+      /* Unknown value: print a generic line.  */
+      char buf2[17];
+      buf[sizeof (buf2) - 1] = '\0';
+      const char *val2 = _itoa ((unsigned long int) av->a_un.a_val,
+				buf2 + sizeof buf2 - 1, 16, 0);
+      const char *val =  _itoa ((unsigned long int) av->a_type,
+				buf + sizeof buf - 1, 16, 0);
+      _dl_printf ("AT_??? (0x%s): 0x%s\n", val, val2);
     }
 }
 
@@ -271,7 +343,7 @@
 		      size_t *max_capstrlen)
 {
   /* Determine how many important bits are set.  */
-  unsigned long int masked = GL(dl_hwcap) & GL(dl_hwcap_mask);
+  unsigned long int masked = GLRO(dl_hwcap) & GLRO(dl_hwcap_mask);
   size_t cnt = platform != NULL;
   size_t n, m;
   size_t total;
@@ -285,17 +357,17 @@
     if ((masked & (1UL << n)) != 0)
       ++cnt;
 
+#ifdef USE_TLS
+  /* For TLS enabled builds always add 'tls'.  */
+  ++cnt;
+#else
   if (cnt == 0)
     {
       /* If we have platform name and no important capability we only have
 	 the base directory to search.  */
       result = (struct r_strlenpair *) malloc (sizeof (*result));
       if (result == NULL)
-	{
-	no_memory:
-	  INTUSE(_dl_signal_error) (ENOMEM, NULL, NULL,
-				    N_("cannot create capability list"));
-	}
+	goto no_memory;
 
       result[0].str = (char *) result;	/* Does not really matter.  */
       result[0].len = 0;
@@ -303,6 +375,7 @@
       *sz = 1;
       return result;
     }
+#endif
 
   /* Create temporary data structure to generate result table.  */
   temp = (struct r_strlenpair *) alloca (cnt * sizeof (*temp));
@@ -321,11 +394,16 @@
       temp[m].len = platform_len;
       ++m;
     }
+#ifdef USE_TLS
+  temp[m].str = "tls";
+  temp[m].len = 3;
+  ++m;
+#endif
   assert (m == cnt);
 
   /* Determine the total size of all strings together.  */
   if (cnt == 1)
-    total = temp[0].len;
+    total = temp[0].len + 1;
   else
     {
       total = (1UL << (cnt - 2)) * (temp[0].len + temp[cnt - 1].len + 2);
@@ -338,7 +416,13 @@
   *sz = 1 << cnt;
   result = (struct r_strlenpair *) malloc (*sz * sizeof (*result) + total);
   if (result == NULL)
-    goto no_memory;
+    {
+#ifndef USE_TLS
+    no_memory:
+#endif
+      _dl_signal_error (ENOMEM, NULL, NULL,
+			N_("cannot create capability list"));
+    }
 
   if (cnt == 1)
     {
@@ -372,7 +456,7 @@
     }
   else
     {
-      n = 1 << cnt;
+      n = 1 << (cnt - 1);
       do
 	{
 	  n -= 2;
diff -Nur sysdeps/generic/dl-sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-sysdep.h
--- sysdeps/generic/dl-sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-sysdep.h	2003-03-04 08:56:25.000000000 +0100
@@ -0,0 +1,37 @@
+/* System-specific settings for dynamic linker code.  Generic version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DL_SYSDEP_H
+#define _DL_SYSDEP_H   1
+
+/* This macro must be defined to either 0 or 1.
+
+   If 1, then an errno global variable hidden in ld.so will work right with
+   all the errno-using libc code compiled for ld.so, and there is never a
+   need to share the errno location with libc.  This is appropriate only if
+   all the libc functions that ld.so uses are called without PLT and always
+   get the versions linked into ld.so rather than the libc ones.  */
+
+#ifdef IS_IN_rtld
+# define RTLD_PRIVATE_ERRNO 1
+#else
+# define RTLD_PRIVATE_ERRNO 0
+#endif
+
+#endif /* dl-sysdep.h */
diff -Nur sysdeps/generic/dl-tls.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-tls.c
--- sysdeps/generic/dl-tls.c	2002-08-20 09:53:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/dl-tls.c	2005-02-16 11:23:02.000000000 +0100
@@ -1,5 +1,5 @@
 /* Thread-local storage handling in the ELF dynamic linker.  Generic version.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,6 +31,10 @@
 # include <dl-tls.h>
 # include <ldsodefs.h>
 
+/* Amount of excess space to allocate in the static TLS area
+   to allow dynamic loading of modules defining IE-model TLS data.  */
+# define TLS_STATIC_SURPLUS	64 + DL_NNS * 100
+
 /* Value used for dtv entries for which the allocation is delayed.  */
 # define TLS_DTV_UNALLOCATED	((void *) -1l)
 
@@ -61,7 +65,10 @@
       /* Note that this branch will never be executed during program
 	 start since there are no gaps at that time.  Therefore it
 	 does not matter that the dl_tls_dtv_slotinfo is not allocated
-	 yet when the function is called for the first times.  */
+	 yet when the function is called for the first times.
+
+	 NB: the offset +1 is due to the fact that DTV[0] is used
+	 for something else.  */
       result = GL(dl_tls_static_nelem) + 1;
       /* If the following would not be true we mustn't have assumed
 	 there is a gap.  */
@@ -84,11 +91,11 @@
 	}
       while ((runp = runp->next) != NULL);
 
-      if (result >= GL(dl_tls_max_dtv_idx))
+      if (result > GL(dl_tls_max_dtv_idx))
 	{
 	  /* The new index must indeed be exactly one higher than the
 	     previous high.  */
-	  assert (result == GL(dl_tls_max_dtv_idx));
+	  assert (result == GL(dl_tls_max_dtv_idx) + 1);
 
 	  /* There is no gap anymore.  */
 	  GL(dl_tls_dtv_gaps) = false;
@@ -106,14 +113,15 @@
   return result;
 }
 
+# ifdef SHARED
 
 void
 internal_function
 _dl_determine_tlsoffset (void)
 {
   struct dtv_slotinfo *slotinfo;
-  size_t max_align = __alignof__ (void *);
-  size_t offset;
+  size_t max_align = TLS_TCB_ALIGN;
+  size_t offset, freetop = 0, freebottom = 0;
   size_t cnt;
 
   /* The first element of the dtv slot info list is allocated.  */
@@ -122,80 +130,168 @@
      dl_tls_dtv_slotinfo_list list.  */
   assert (GL(dl_tls_dtv_slotinfo_list)->next == NULL);
 
+  slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
+
+  /* Determining the offset of the various parts of the static TLS
+     block has several dependencies.  In addition we have to work
+     around bugs in some toolchains.
+
+     Each TLS block from the objects available at link time has a size
+     and an alignment requirement.  The GNU ld computes the alignment
+     requirements for the data at the positions *in the file*, though.
+     I.e, it is not simply possible to allocate a block with the size
+     of the TLS program header entry.  The data is layed out assuming
+     that the first byte of the TLS block fulfills
+
+       p_vaddr mod p_align == &TLS_BLOCK mod p_align
+
+     This means we have to add artificial padding at the beginning of
+     the TLS block.  These bytes are never used for the TLS data in
+     this module but the first byte allocated must be aligned
+     according to mod p_align == 0 so that the first byte of the TLS
+     block is aligned according to p_vaddr mod p_align.  This is ugly
+     and the linker can help by computing the offsets in the TLS block
+     assuming the first byte of the TLS block is aligned according to
+     p_align.
+
+     The extra space which might be allocated before the first byte of
+     the TLS block need not go unused.  The code below tries to use
+     that memory for the next TLS block.  This can work if the total
+     memory requirement for the next TLS block is smaller than the
+     gap.  */
+
 # if TLS_TCB_AT_TP
   /* We simply start with zero.  */
   offset = 0;
 
-  slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
   for (cnt = 1; slotinfo[cnt].map != NULL; ++cnt)
     {
       assert (cnt < GL(dl_tls_dtv_slotinfo_list)->len);
 
+      size_t firstbyte = (-slotinfo[cnt].map->l_tls_firstbyte_offset
+			  & (slotinfo[cnt].map->l_tls_align - 1));
+      size_t off;
       max_align = MAX (max_align, slotinfo[cnt].map->l_tls_align);
 
-      /* Compute the offset of the next TLS block.  */
-      offset = roundup (offset + slotinfo[cnt].map->l_tls_blocksize,
-			slotinfo[cnt].map->l_tls_align);
+      if (freebottom - freetop >= slotinfo[cnt].map->l_tls_blocksize)
+	{
+	  off = roundup (freetop + slotinfo[cnt].map->l_tls_blocksize
+			 - firstbyte, slotinfo[cnt].map->l_tls_align)
+		+ firstbyte;
+	  if (off <= freebottom)
+	    {
+	      freetop = off;
+
+	      /* XXX For some architectures we perhaps should store the
+		 negative offset.  */
+	      slotinfo[cnt].map->l_tls_offset = off;
+	      continue;
+	    }
+	}
+
+      off = roundup (offset + slotinfo[cnt].map->l_tls_blocksize - firstbyte,
+		     slotinfo[cnt].map->l_tls_align) + firstbyte;
+      if (off > offset + slotinfo[cnt].map->l_tls_blocksize
+		+ (freebottom - freetop))
+	{
+	  freetop = offset;
+	  freebottom = off - slotinfo[cnt].map->l_tls_blocksize;
+	}
+      offset = off;
 
       /* XXX For some architectures we perhaps should store the
 	 negative offset.  */
-      slotinfo[cnt].map->l_tls_offset = offset;
+      slotinfo[cnt].map->l_tls_offset = off;
     }
 
-  /* The thread descriptor (pointed to by the thread pointer) has its
-     own alignment requirement.  Adjust the static TLS size
-     and TLS offsets appropriately.  */
-  // XXX How to deal with this.  We cannot simply add zero bytes
-  // XXX after the first (closest to the TCB) TLS block since this
-  // XXX would invalidate the offsets the linker creates for the LE
-  // XXX model.
-
-  GL(dl_tls_static_size) = offset + TLS_TCB_SIZE;
+  GL(dl_tls_static_used) = offset;
+  GL(dl_tls_static_size) = (roundup (offset + TLS_STATIC_SURPLUS, max_align)
+			    + TLS_TCB_SIZE);
 # elif TLS_DTV_AT_TP
   /* The TLS blocks start right after the TCB.  */
   offset = TLS_TCB_SIZE;
 
-  /* The first block starts right after the TCB.  */
-  slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
-  if (slotinfo[1].map != NULL)
+  for (cnt = 1; slotinfo[cnt].map != NULL; ++cnt)
     {
-      size_t prev_size;
+      assert (cnt < GL(dl_tls_dtv_slotinfo_list)->len);
 
-      offset = roundup (offset, slotinfo[1].map->l_tls_align);
-      slotinfo[1].map->l_tls_offset = offset;
-      max_align = slotinfo[1].map->l_tls_align;
-      prev_size = slotinfo[1].map->l_tls_blocksize;
+      size_t firstbyte = (-slotinfo[cnt].map->l_tls_firstbyte_offset
+			  & (slotinfo[cnt].map->l_tls_align - 1));
+      size_t off;
+      max_align = MAX (max_align, slotinfo[cnt].map->l_tls_align);
 
-      for (cnt = 2; slotinfo[cnt].map != NULL; ++cnt)
+      if (slotinfo[cnt].map->l_tls_blocksize <= freetop - freebottom)
 	{
-	  assert (cnt < GL(dl_tls_dtv_slotinfo_list)->len);
-
-	  max_align = MAX (max_align, slotinfo[cnt].map->l_tls_align);
-
-	  /* Compute the offset of the next TLS block.  */
-	  offset = roundup (offset + prev_size,
-			    slotinfo[cnt].map->l_tls_align);
+	  off = roundup (freebottom, slotinfo[cnt].map->l_tls_align);
+	  if (off - freebottom < firstbyte)
+	    off += slotinfo[cnt].map->l_tls_align;
+	  if (off + slotinfo[cnt].map->l_tls_blocksize - firstbyte <= freetop)
+	    {
+	      slotinfo[cnt].map->l_tls_offset = off - firstbyte;
+	      freebottom = off + slotinfo[cnt].map->l_tls_blocksize
+			   - firstbyte;
+	      continue;
+	    }
+	}
 
-	  /* XXX For some architectures we perhaps should store the
-	     negative offset.  */
-	  slotinfo[cnt].map->l_tls_offset = offset;
+      off = roundup (offset, slotinfo[cnt].map->l_tls_align);
+      if (off - offset < firstbyte)
+	off += slotinfo[cnt].map->l_tls_align;
 
-	  prev_size = slotinfo[cnt].map->l_tls_blocksize;
+      slotinfo[cnt].map->l_tls_offset = off - firstbyte;
+      if (off - firstbyte - offset > freetop - freebottom)
+	{
+	  freebottom = offset;
+	  freetop = off - firstbyte;
 	}
 
-      offset += prev_size;
+      offset = off + slotinfo[cnt].map->l_tls_blocksize - firstbyte;
     }
 
-  GL(dl_tls_static_size) = offset;
+  GL(dl_tls_static_used) = offset;
+  GL(dl_tls_static_size) = roundup (offset + TLS_STATIC_SURPLUS,
+				    TLS_TCB_ALIGN);
 # else
 #  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
 # endif
 
   /* The alignment requirement for the static TLS block.  */
-  GL(dl_tls_static_align) = MAX (TLS_TCB_ALIGN, max_align);
+  GL(dl_tls_static_align) = max_align;
 }
 
 
+/* This is called only when the data structure setup was skipped at startup,
+   when there was no need for it then.  Now we have dynamically loaded
+   something needing TLS, or libpthread needs it.  */
+int
+internal_function
+_dl_tls_setup (void)
+{
+  assert (GL(dl_tls_dtv_slotinfo_list) == NULL);
+  assert (GL(dl_tls_max_dtv_idx) == 0);
+
+  const size_t nelem = 2 + TLS_SLOTINFO_SURPLUS;
+
+  GL(dl_tls_dtv_slotinfo_list)
+    = calloc (1, (sizeof (struct dtv_slotinfo_list)
+		  + nelem * sizeof (struct dtv_slotinfo)));
+  if (GL(dl_tls_dtv_slotinfo_list) == NULL)
+    return -1;
+
+  GL(dl_tls_dtv_slotinfo_list)->len = nelem;
+
+  /* Number of elements in the static TLS block.  It can't be zero
+     because of various assumptions.  The one element is null.  */
+  GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx) = 1;
+
+  /* This initializes more variables for us.  */
+  _dl_determine_tlsoffset ();
+
+  return 0;
+}
+rtld_hidden_def (_dl_tls_setup)
+# endif
+
 static void *
 internal_function
 allocate_dtv (void *result)
@@ -207,14 +303,14 @@
      initial set of modules.  This should avoid in most cases expansions
      of the dtv.  */
   dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;
-  dtv = (dtv_t *) malloc ((dtv_length + 2) * sizeof (dtv_t));
+  dtv = calloc (dtv_length + 2, sizeof (dtv_t));
   if (dtv != NULL)
     {
       /* This is the initial length of the dtv.  */
       dtv[0].counter = dtv_length;
-      /* Initialize all of the rest of the dtv (including the
-	 generation counter) with zero to indicate nothing there.  */
-      memset (dtv + 1, '\0', (dtv_length + 1) * sizeof (dtv_t));
+
+      /* The rest of the dtv (including the generation counter) is
+	 Initialize with zero to indicate nothing there.  */
 
       /* Add the dtv to the thread data structures.  */
       INSTALL_DTV (result, dtv);
@@ -241,17 +337,38 @@
 _dl_allocate_tls_storage (void)
 {
   void *result;
+  size_t size = GL(dl_tls_static_size);
+
+# if TLS_DTV_AT_TP
+  /* Memory layout is:
+     [ TLS_PRE_TCB_SIZE ] [ TLS_TCB_SIZE ] [ TLS blocks ]
+			  ^ This should be returned.  */
+  size += (TLS_PRE_TCB_SIZE + GL(dl_tls_static_align) - 1)
+	  & ~(GL(dl_tls_static_align) - 1);
+# endif
 
   /* Allocate a correctly aligned chunk of memory.  */
-  result = __libc_memalign (GL(dl_tls_static_align), GL(dl_tls_static_size));
-  if (__builtin_expect (result != NULL, 0))
+  result = __libc_memalign (GL(dl_tls_static_align), size);
+  if (__builtin_expect (result != NULL, 1))
     {
       /* Allocate the DTV.  */
       void *allocated = result;
 
 # if TLS_TCB_AT_TP
       /* The TCB follows the TLS blocks.  */
-      result = (char *) result + GL(dl_tls_static_size) - TLS_TCB_SIZE;
+      result = (char *) result + size - TLS_TCB_SIZE;
+
+      /* Clear the TCB data structure.  We can't ask the caller (i.e.
+	 libpthread) to do it, because we will initialize the DTV et al.  */
+      memset (result, 0, TLS_TCB_SIZE);
+# elif TLS_DTV_AT_TP
+      result = (char *) result + size - GL(dl_tls_static_size);
+
+      /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before it.
+	 We can't ask the caller (i.e. libpthread) to do it, because we will
+	 initialize the DTV et al.  */
+      memset ((char *) result - TLS_PRE_TCB_SIZE, 0,
+	      TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
 # endif
 
       result = allocate_dtv (result);
@@ -267,14 +384,14 @@
 internal_function
 _dl_allocate_tls_init (void *result)
 {
-  dtv_t *dtv = GET_DTV (result);
-  struct dtv_slotinfo_list *listp;
-  size_t total = 0;
-
   if (result == NULL)
     /* The memory allocation failed.  */
     return NULL;
 
+  dtv_t *dtv = GET_DTV (result);
+  struct dtv_slotinfo_list *listp;
+  size_t total = 0;
+
   /* We have to look prepare the dtv for all currently loaded
      modules using TLS.  For those which are dynamically loaded we
      add the values indicating deferred allocation.  */
@@ -297,7 +414,7 @@
 	    /* Unused entry.  */
 	    continue;
 
-	  if (map->l_type == lt_loaded)
+	  if (map->l_tls_offset == NO_TLS_OFFSET)
 	    {
 	      /* For dynamically loaded modules we simply store
 		 the value indicating deferred allocation.  */
@@ -308,7 +425,7 @@
 	  assert (map->l_tls_modid == cnt);
 	  assert (map->l_tls_blocksize >= map->l_tls_initimage_size);
 # if TLS_TCB_AT_TP
-	  assert (map->l_tls_offset >= map->l_tls_blocksize);
+	  assert ((size_t) map->l_tls_offset >= map->l_tls_blocksize);
 	  dest = (char *) result - map->l_tls_offset;
 # elif TLS_DTV_AT_TP
 	  dest = (char *) result + map->l_tls_offset;
@@ -333,6 +450,7 @@
 
   return result;
 }
+rtld_hidden_def (_dl_allocate_tls_init)
 
 void *
 internal_function
@@ -342,7 +460,7 @@
 				? _dl_allocate_tls_storage ()
 				: allocate_dtv (mem));
 }
-INTDEF(_dl_allocate_tls)
+rtld_hidden_def (_dl_allocate_tls)
 
 
 void
@@ -352,12 +470,25 @@
   dtv_t *dtv = GET_DTV (tcb);
 
   /* The array starts with dtv[-1].  */
-  free (dtv - 1);
+#ifdef SHARED
+  if (dtv != GL(dl_initial_dtv))
+#endif
+    free (dtv - 1);
 
   if (dealloc_tcb)
-    free (tcb);
+    {
+# if TLS_TCB_AT_TP
+      /* The TCB follows the TLS blocks.  Back up to free the whole block.  */
+      tcb -= GL(dl_tls_static_size) - TLS_TCB_SIZE;
+# elif TLS_DTV_AT_TP
+      /* Back up the TLS_PRE_TCB_SIZE bytes.  */
+      tcb -= (TLS_PRE_TCB_SIZE + GL(dl_tls_static_align) - 1)
+	     & ~(GL(dl_tls_static_align) - 1);
+# endif
+      free (tcb);
+    }
 }
-
+rtld_hidden_def (_dl_deallocate_tls)
 
 
 # ifdef SHARED
@@ -377,32 +508,6 @@
 #  ifndef GET_ADDR_OFFSET
 #   define GET_ADDR_OFFSET ti->ti_offset
 #  endif
-/* Systems which do not have tls_index also probably have to define
-   DONT_USE_TLS_INDEX.  */
-
-#  ifndef __TLS_GET_ADDR
-#   define __TLS_GET_ADDR __tls_get_addr
-#  endif
-
-
-/* Return the symbol address given the map of the module it is in and
-   the symbol record.  This is used in dl-sym.c.  */
-void *
-internal_function
-_dl_tls_symaddr (struct link_map *map, const ElfW(Sym) *ref)
-{
-#  ifndef DONT_USE_TLS_INDEX
-  tls_index tmp =
-    {
-      .ti_module = map->l_tls_modid,
-      .ti_offset = ref->st_value
-    };
-
-  return __TLS_GET_ADDR (&tmp);
-#  else
-  return __TLS_GET_ADDR (map->l_tls_modid, ref->st_value);
-#  endif
-}
 
 
 static void *
@@ -475,7 +580,7 @@
 	    {
 	      size_t cnt;
 
-	      for (cnt = total = 0 ? 1 : 0; cnt < listp->len; ++cnt)
+	      for (cnt = total == 0 ? 1 : 0; cnt < listp->len; ++cnt)
 		{
 		  size_t gen = listp->slotinfo[cnt].gen;
 		  struct link_map *map;
@@ -499,7 +604,10 @@
 		      /* If this modid was used at some point the memory
 			 might still be allocated.  */
 		      if (dtv[total + cnt].pointer != TLS_DTV_UNALLOCATED)
-			free (dtv[total + cnt].pointer);
+			{
+			  free (dtv[total + cnt].pointer);
+			  dtv[total + cnt].pointer = TLS_DTV_UNALLOCATED;
+			}
 
 		      continue;
 		    }
diff -Nur sysdeps/generic/elf/backtracesyms.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/elf/backtracesyms.c
--- sysdeps/generic/elf/backtracesyms.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/elf/backtracesyms.c	2003-03-10 10:12:11.000000000 +0100
@@ -1,5 +1,5 @@
 /* Return list with names for address in backtrace.
-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1998,1999,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -48,7 +48,7 @@
   /* Fill in the information we can get from `dladdr'.  */
   for (cnt = 0; cnt < size; ++cnt)
     {
-      status[cnt] = _dl_addr (array[cnt], &info[cnt]);
+      status[cnt] = _dl_addr (array[cnt], &info[cnt], NULL, NULL);
       if (status[cnt] && info[cnt].dli_fname && info[cnt].dli_fname[0] != '\0')
 	/* We have some info, compute the length of the string which will be
 	   "<file-name>(<sym-name>) [+offset].  */
diff -Nur sysdeps/generic/elf/backtracesymsfd.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/elf/backtracesymsfd.c
--- sysdeps/generic/elf/backtracesymsfd.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/elf/backtracesymsfd.c	2003-03-10 10:12:11.000000000 +0100
@@ -1,5 +1,5 @@
 /* Write formatted list with names for addresses in backtrace to a file.
-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -48,7 +48,7 @@
       Dl_info info;
       size_t last = 0;
 
-      if (_dl_addr (array[cnt], &info)
+      if (_dl_addr (array[cnt], &info, NULL, NULL)
 	  && info.dli_fname && info.dli_fname[0] != '\0')
 	{
 	  /* Name of the file.  */
diff -Nur sysdeps/generic/enbl-secure.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/enbl-secure.c
--- sysdeps/generic/enbl-secure.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/enbl-secure.c	2003-05-06 08:33:13.000000000 +0200
@@ -1,5 +1,5 @@
 /* Define and initialize the `__libc_enable_secure' flag.  Generic version.
-   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,12 +23,15 @@
 #include <unistd.h>
 #include <libc-internal.h>
 
+/* If nonzero __libc_enable_secure is already set.  */
+int __libc_enable_secure_decided;
 /* Safest assumption, if somehow the initializer isn't run.  */
 int __libc_enable_secure = 1;
 
 void
 __libc_init_secure (void)
 {
-  __libc_enable_secure = (__geteuid () != __getuid ()
-			  || __getegid () != __getgid ());
+  if (__libc_enable_secure_decided == 0)
+    __libc_enable_secure = (__geteuid () != __getuid ()
+			    || __getegid () != __getgid ());
 }
diff -Nur sysdeps/generic/errno.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/errno.c
--- sysdeps/generic/errno.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/errno.c	2004-10-04 22:59:41.000000000 +0200
@@ -0,0 +1,53 @@
+/* Definition of `errno' variable.  Canonical version.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <tls.h>
+#include <dl-sysdep.h>
+#undef errno
+
+#if RTLD_PRIVATE_ERRNO
+
+/* Code compiled for rtld refers only to this name.  */
+int rtld_errno attribute_hidden;
+
+#elif USE___THREAD
+
+__thread int errno;
+extern __thread int __libc_errno __attribute__ ((alias ("errno")))
+  attribute_hidden;
+
+#else
+
+/* This differs from plain `int errno;' in that it doesn't create
+   a common definition, but a plain symbol that resides in .bss,
+   which can have an alias.  */
+int errno __attribute__ ((nocommon));
+strong_alias (errno, _errno)
+
+/* We declare these with compat_symbol so that they are not visible at
+   link time.  Programs must use the accessor functions.  RTLD is special,
+   since it's not exported from there at any time.  */
+# if defined HAVE_ELF && defined SHARED && defined DO_VERSIONING
+#  include <shlib-compat.h>
+compat_symbol (libc, errno, errno, GLIBC_2_0);
+compat_symbol (libc, _errno, _errno, GLIBC_2_0);
+# endif
+
+#endif
diff -Nur sysdeps/generic/errno-loc.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/errno-loc.c
--- sysdeps/generic/errno-loc.c	2002-07-18 05:13:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/errno-loc.c	2004-10-14 18:13:17.000000000 +0200
@@ -1,6 +1,6 @@
 /* MT support function to get address of `errno' variable, non-threaded
    version.
-   Copyright (C) 1996, 1998, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1998, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,17 +20,18 @@
 
 #include <errno.h>
 #include <tls.h>
-#undef errno
 
-#if USE_TLS && HAVE___THREAD
-extern __thread int errno;
-#else
+#if ! USE___THREAD && !RTLD_PRIVATE_ERRNO
+#undef errno
 extern int errno;
 #endif
 
 int *
+#if ! USE___THREAD
 weak_const_function
+#endif
 __errno_location (void)
 {
   return &errno;
 }
+libc_hidden_def (__errno_location)
diff -Nur sysdeps/generic/fchflags.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/fchflags.c
--- sysdeps/generic/fchflags.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/fchflags.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,7 +22,7 @@
 
 /* Change the flags of the file FD refers to to FLAGS.  */
 
-int fchflags __P ((int fd, int flags));
+int fchflags (int fd, int flags) __THROW;
 
 int
 fchflags (fd, flags)
diff -Nur sysdeps/generic/ffs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ffs.c
--- sysdeps/generic/ffs.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ffs.c	2004-07-05 19:36:13.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1992, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1992, 1997, 1998, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -47,6 +47,7 @@
   return table[x >> a] + a;
 }
 weak_alias (__ffs, ffs)
+libc_hidden_builtin_def (ffs)
 
 #if ULONG_MAX == UINT_MAX
 #undef ffsl
diff -Nur sysdeps/generic/flockfile.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/flockfile.c
--- sysdeps/generic/flockfile.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/flockfile.c	2002-12-16 23:12:27.000000000 +0100
@@ -0,0 +1,30 @@
+/* Lock I/O stream.  Singlethreaded version.
+   Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+
+#undef _IO_flockfile
+
+void
+__flockfile (FILE *stream)
+{
+  /* Do nothing.  Using this version does not do any locking.  */
+}
+weak_alias (__flockfile, flockfile);
+weak_alias (__flockfile, _IO_flockfile)
diff -Nur sysdeps/generic/fork.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/fork.c
--- sysdeps/generic/fork.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/fork.c	2002-12-31 12:03:29.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,6 +29,7 @@
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (__fork)
 stub_warning (fork)
 
 weak_alias (__fork, fork)
diff -Nur sysdeps/generic/framestate.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/framestate.c
--- sysdeps/generic/framestate.c	2002-03-15 09:33:21.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/framestate.c	2004-02-21 10:07:05.000000000 +0100
@@ -1,5 +1,5 @@
 /* __frame_state_for unwinder helper function wrapper.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2001.
 
@@ -20,16 +20,11 @@
 
 #include <dlfcn.h>
 #include <stdlib.h>
+#define STATIC static
 #define __frame_state_for fallback_frame_state_for
 #include <unwind-dw2.c>
 #undef __frame_state_for
 
-struct frame_state * fallback_frame_state_for (void *, struct frame_state *)
-#ifdef _LIBC
-     attribute_hidden
-#endif
-     ;
-
 typedef struct frame_state * (*framesf)(void *pc, struct frame_state *);
 struct frame_state *__frame_state_for (void *pc,
 				       struct frame_state *frame_state);
@@ -46,7 +41,11 @@
       if (handle == NULL
 	  || (frame_state_for
 	      = (framesf) __libc_dlsym (handle, "__frame_state_for")) == NULL)
+#ifndef __USING_SJLJ_EXCEPTIONS__
 	frame_state_for = fallback_frame_state_for;
+#else
+      	frame_state_for = abort;
+#endif
     }
 
   return frame_state_for (pc, frame_state);
diff -Nur sysdeps/generic/ftrylockfile.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ftrylockfile.c
--- sysdeps/generic/ftrylockfile.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ftrylockfile.c	2002-12-16 23:13:00.000000000 +0100
@@ -0,0 +1,31 @@
+/* Try locking I/O stream.  Singlethreaded version.
+   Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+
+#undef _IO_ftrylockfile
+
+int
+__ftrylockfile (FILE *stream)
+{
+  /* Do nothing.  Using this version does not do any locking.  */
+  return 1;
+}
+weak_alias (__ftrylockfile, ftrylockfile);
+weak_alias (__ftrylockfile, _IO_ftrylockfile)
diff -Nur sysdeps/generic/funlockfile.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/funlockfile.c
--- sysdeps/generic/funlockfile.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/funlockfile.c	2002-12-16 23:12:41.000000000 +0100
@@ -0,0 +1,30 @@
+/* Unlock I/O stream.  Singlethreaded version.
+   Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+
+#undef _IO_funlockfile
+
+void
+__funlockfile (FILE *stream)
+{
+  /* Do nothing.  Using this version does not do any locking.  */
+}
+weak_alias (__funlockfile, _IO_funlockfile)
+weak_alias (__funlockfile, funlockfile);
diff -Nur sysdeps/generic/getipv4sourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getipv4sourcefilter.c
--- sysdeps/generic/getipv4sourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getipv4sourcefilter.c	2004-07-26 06:24:12.000000000 +0200
@@ -0,0 +1,32 @@
+/* Get source filter.  Stub version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <netinet/in.h>
+
+
+int
+getipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,
+		     uint32_t *fmode, uint32_t *numsrc, struct in_addr *slist)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (getipv4sourcefilter)
diff -Nur sysdeps/generic/getresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getresgid.c
--- sysdeps/generic/getresgid.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getresgid.c	2002-10-14 03:03:00.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1997,1998,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,12 +19,15 @@
 #include <errno.h>
 #include <unistd.h>
 
+/* Fetch the effective group ID, real group ID, and saved-set group ID,
+   of the calling process.  */
 int
-__getresgid (gid_t egid, gid_t rgid, gid_t sgid)
+__getresgid (gid_t *egid, gid_t *rgid, gid_t *sgid)
 {
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (__getresgid)
 stub_warning (getresgid)
 
 weak_alias (__getresgid, getresgid)
diff -Nur sysdeps/generic/getresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getresuid.c
--- sysdeps/generic/getresuid.c	2001-07-07 21:21:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getresuid.c	2002-10-14 03:03:00.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1997,1998,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,12 +19,15 @@
 #include <errno.h>
 #include <unistd.h>
 
+/* Fetch the effective user ID, real user ID, and saved-set user ID,
+   of the calling process.  */
 int
-__getresuid (uid_t euid, uid_t ruid, uid_t suid)
+__getresuid (uid_t *euid, uid_t *ruid, uid_t *suid)
 {
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (__getresuid)
 stub_warning (getresuid)
 
 weak_alias (__getresuid, getresuid)
diff -Nur sysdeps/generic/getsourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getsourcefilter.c
--- sysdeps/generic/getsourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/getsourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,33 @@
+/* Get source filter.  Stub version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <netinet/in.h>
+
+
+int
+getsourcefilter (int s, uint32_t interface, const struct sockaddr *group,
+		 socklen_t grouplen, uint32_t *fmode, uint32_t *numsrc,
+		 struct sockaddr_storage *slist)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (getsourcefilter)
diff -Nur sysdeps/generic/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/glob64.c
--- sysdeps/generic/glob64.c	2002-08-04 06:32:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/glob64.c	2004-07-01 19:39:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998,99,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998,99,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -42,12 +42,13 @@
   __set_errno (ENOSYS);
   return GLOB_NOSYS;
 }
+libc_hidden_def (glob64)
 
 void
 globfree64 (glob64_t *pglob)
 {
 }
-libc_hidden_def (globfree64);
+libc_hidden_def (globfree64)
 
 stub_warning (glob64)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/glob.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/glob.c
--- sysdeps/generic/glob.c	2002-08-26 23:16:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/glob.c	2004-10-27 20:21:02.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -284,6 +284,7 @@
 #endif
 
 #ifdef _LIBC
+# include <alloca.h>
 # undef strdup
 # define strdup(str) __strdup (str)
 # define sysconf(id) __sysconf (id)
@@ -333,43 +334,47 @@
 #include <glob.h>
 
 #ifdef HAVE_GETLOGIN_R
-extern int getlogin_r __P ((char *, size_t));
+extern int getlogin_r (char *, size_t);
 #else
-extern char *getlogin __P ((void));
+extern char *getlogin (void);
 #endif
 
-static
-#if __GNUC__ - 0 >= 2
-inline
-#endif
-const char *next_brace_sub __P ((const char *begin));
+static const char *next_brace_sub (const char *begin, int flags) __THROW;
 
 #endif /* GLOB_ONLY_P */
 
-static int glob_in_dir __P ((const char *pattern, const char *directory,
-			     int flags,
-			     int (*errfunc) (const char *, int),
-			     glob_t *pglob));
+static int glob_in_dir (const char *pattern, const char *directory,
+			int flags, int (*errfunc) (const char *, int),
+			glob_t *pglob);
 
 #if !defined _LIBC || !defined GLOB_ONLY_P
-static int prefix_array __P ((const char *prefix, char **array, size_t n));
-static int collated_compare __P ((const __ptr_t, const __ptr_t));
+static int prefix_array (const char *prefix, char **array, size_t n) __THROW;
+static int collated_compare (const __ptr_t, const __ptr_t) __THROW;
 
 
-/* Find the end of the sub-pattern in a brace expression.  We define
-   this as an inline function if the compiler permits.  */
-static
-#if __GNUC__ - 0 >= 2
-inline
-#endif
-const char *
-next_brace_sub (cp)
+/* Find the end of the sub-pattern in a brace expression.  */
+static const char *
+next_brace_sub (cp, flags)
      const char *cp;
+     int flags;
 {
   unsigned int depth = 0;
-  while (*cp != '\0' && (*cp != '}' || depth--) && (*cp != ',' || depth))
-    if (*cp++ == '{')
-      depth++;
+  while (*cp != '\0')
+    if ((flags & GLOB_NOESCAPE) == 0 && *cp == '\\')
+      {
+	if (*++cp == '\0')
+	  break;
+	++cp;
+      }
+    else
+      {
+	if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))
+	  break;
+
+	if (*cp++ == '{')
+	  depth++;
+      }
+
   return *cp != '\0' ? cp : NULL;
 }
 
@@ -384,10 +389,13 @@
    If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
    Otherwise, `glob' returns zero.  */
 int
+#ifdef GLOB_ATTRIBUTE
+GLOB_ATTRIBUTE
+#endif
 glob (pattern, flags, errfunc, pglob)
      const char *pattern;
      int flags;
-     int (*errfunc) __P ((const char *, int));
+     int (*errfunc) (const char *, int);
      glob_t *pglob;
 {
   const char *filename;
@@ -409,7 +417,30 @@
 
   if (flags & GLOB_BRACE)
     {
-      const char *begin = strchr (pattern, '{');
+      const char *begin;
+
+      if (flags & GLOB_NOESCAPE)
+	begin = strchr (pattern, '{');
+      else
+	{
+	  begin = pattern;
+	  while (1)
+	    {
+	      if (*begin == '\0')
+		{
+		  begin = NULL;
+		  break;
+		}
+
+	      if (*begin == '\\' && begin[1] != '\0')
+		++begin;
+	      else if (*begin == '{')
+		break;
+
+	      ++begin;
+	    }
+	}
+
       if (begin != NULL)
 	{
 	  /* Allocate working buffer large enough for our work.  Note that
@@ -428,8 +459,8 @@
 	    {
 	      if (!(flags & GLOB_APPEND))
 		{
-		  globfree (pglob);
 		  pglob->gl_pathc = 0;
+		  pglob->gl_pathv = NULL;
 		}
 	      return GLOB_NOSPACE;
 	    }
@@ -445,7 +476,7 @@
 
 	  /* Find the first sub-pattern and at the same time find the
 	     rest after the closing brace.  */
-	  next = next_brace_sub (begin + 1);
+	  next = next_brace_sub (begin + 1, flags);
 	  if (next == NULL)
 	    {
 	      /* It is an illegal expression.  */
@@ -459,7 +490,7 @@
 	  rest = next;
 	  while (*rest != '}')
 	    {
-	      rest = next_brace_sub (rest + 1);
+	      rest = next_brace_sub (rest + 1, flags);
 	      if (rest == NULL)
 		{
 		  /* It is an illegal expression.  */
@@ -524,7 +555,7 @@
 		break;
 
 	      p = next + 1;
-	      next = next_brace_sub (p);
+	      next = next_brace_sub (p, flags);
 	      assert (next != NULL);
 	    }
 
@@ -697,10 +728,12 @@
 		  struct passwd pwbuf;
 		  int save = errno;
 
+#    ifndef _LIBC
 		  if (pwbuflen == -1)
 		    /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.
 		       Try a moderate value.  */
 		    pwbuflen = 1024;
+#    endif
 		  pwtmpbuf = (char *) __alloca (pwbuflen);
 
 		  while (getpwnam_r (name, &pwbuf, pwtmpbuf, pwbuflen, &p)
@@ -711,8 +744,13 @@
 			  p = NULL;
 			  break;
 			}
+#    ifdef _LIBC
+		      pwtmpbuf = extend_alloca (pwtmpbuf, pwbuflen,
+						2 * pwbuflen);
+#    else
 		      pwbuflen *= 2;
 		      pwtmpbuf = (char *) __alloca (pwbuflen);
+#    endif
 		      __set_errno (save);
 		    }
 #   else
@@ -781,10 +819,12 @@
 	    struct passwd pwbuf;
 	    int save = errno;
 
+#   ifndef _LIBC
 	    if (buflen == -1)
 	      /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.  Try a
 		 moderate value.  */
 	      buflen = 1024;
+#   endif
 	    pwtmpbuf = (char *) __alloca (buflen);
 
 	    while (getpwnam_r (user_name, &pwbuf, pwtmpbuf, buflen, &p) != 0)
@@ -794,8 +834,12 @@
 		    p = NULL;
 		    break;
 		  }
+#   ifdef _LIBC
+		pwtmpbuf = extend_alloca (pwtmpbuf, buflen, 2 * buflen);
+#   else
 		buflen *= 2;
 		pwtmpbuf = __alloca (buflen);
+#   endif
 		__set_errno (save);
 	      }
 #  else
@@ -1091,6 +1135,7 @@
 	if (pglob->gl_pathv[pglob->gl_offs + i] != NULL)
 	  free ((__ptr_t) pglob->gl_pathv[pglob->gl_offs + i]);
       free ((__ptr_t) pglob->gl_pathv);
+      pglob->gl_pathv = NULL;
     }
 }
 #if defined _LIBC && !defined globfree
@@ -1229,6 +1274,34 @@
 #endif /* !GLOB_ONLY_P */
 
 
+/* We put this in a separate function mainly to allow the memory
+   allocated with alloca to be recycled.  */
+#if !defined _LIBC || !defined GLOB_ONLY_P
+static int
+link_exists_p (const char *dir, size_t dirlen, const char *fname,
+	       glob_t *pglob, int flags)
+{
+  size_t fnamelen = strlen (fname);
+  char *fullname = (char *) __alloca (dirlen + 1 + fnamelen + 1);
+  struct stat st;
+  struct stat64 st64;
+
+# ifdef HAVE_MEMPCPY
+  mempcpy (mempcpy (mempcpy (fullname, dir, dirlen), "/", 1),
+	   fname, fnamelen + 1);
+# else
+  memcpy (fullname, dir, dirlen);
+  fullname[dirlen] = '/';
+  memcpy (&fullname[dirlen + 1], fname, fnamelen + 1);
+# endif
+
+  return (((flags & GLOB_ALTDIRFUNC)
+	   ? (*pglob->gl_stat) (fullname, &st)
+	   : __stat64 (fullname, &st64)) == 0);
+}
+#endif
+
+
 /* Like `glob', but PATTERN is a final pathname component,
    and matches are searched for in DIRECTORY.
    The GLOB_NOSORT bit in FLAGS is ignored.  No sorting is ever done.
@@ -1238,9 +1311,10 @@
      const char *pattern;
      const char *directory;
      int flags;
-     int (*errfunc) __P ((const char *, int));
+     int (*errfunc) (const char *, int);
      glob_t *pglob;
 {
+  size_t dirlen = strlen (directory);
   __ptr_t stream = NULL;
   struct globlink
     {
@@ -1262,7 +1336,7 @@
       nfound = 0;
     }
   else if (meta == 0 &&
-	   ((flags & GLOB_NOESCAPE) || strchr(pattern, '\\') == NULL))
+	   ((flags & GLOB_NOESCAPE) || strchr (pattern, '\\') == NULL))
     {
       /* Since we use the normal file functions we can also use stat()
 	 to verify the file is there.  */
@@ -1271,7 +1345,6 @@
       struct stat64 st64;
 # endif
       size_t patlen = strlen (pattern);
-      size_t dirlen = strlen (directory);
       char *fullname = (char *) __alloca (dirlen + 1 + patlen + 1);
 
 # ifdef HAVE_MEMPCPY
@@ -1326,9 +1399,9 @@
 	      int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
 			       | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)
 #if defined _AMIGA || defined VMS
-				   | FNM_CASEFOLD
+			       | FNM_CASEFOLD
 #endif
-				   );
+			       );
 	      nfound = 0;
 	      flags |= GLOB_MAGCHAR;
 
@@ -1374,7 +1447,9 @@
 		  /* If we shall match only directories use the information
 		     provided by the dirent call if possible.  */
 		  if ((flags & GLOB_ONLYDIR)
-		      && d->d_type != DT_UNKNOWN && d->d_type != DT_DIR)
+		      && d->d_type != DT_UNKNOWN
+		      && d->d_type != DT_DIR
+		      && d->d_type != DT_LNK)
 		    continue;
 #endif
 
@@ -1382,22 +1457,32 @@
 
 		  if (fnmatch (pattern, name, fnm_flags) == 0)
 		    {
-		      struct globlink *new = (struct globlink *)
-			__alloca (sizeof (struct globlink));
-		      len = NAMLEN (d);
-		      new->name = (char *) malloc (len + 1);
-		      if (new->name == NULL)
-			goto memory_error;
+		      /* If the file we found is a symlink we have to
+			 make sure the target file exists.  */
+		      if (
+#ifdef HAVE_D_TYPE
+			  (d->d_type != DT_UNKNOWN && d->d_type != DT_LNK) ||
+#endif
+			  link_exists_p (directory, dirlen, name, pglob,
+					 flags))
+			{
+			  struct globlink *new = (struct globlink *)
+			    __alloca (sizeof (struct globlink));
+			  len = NAMLEN (d);
+			  new->name = (char *) malloc (len + 1);
+			  if (new->name == NULL)
+			    goto memory_error;
 #ifdef HAVE_MEMPCPY
-		      *((char *) mempcpy ((__ptr_t) new->name, name, len))
-			= '\0';
+			  *((char *) mempcpy ((__ptr_t) new->name, name, len))
+			    = '\0';
 #else
-		      memcpy ((__ptr_t) new->name, name, len);
-		      new->name[len] = '\0';
+			  memcpy ((__ptr_t) new->name, name, len);
+			  new->name[len] = '\0';
 #endif
-		      new->next = names;
-		      names = new;
-		      ++nfound;
+			  new->next = names;
+			  names = new;
+			  ++nfound;
+			}
 		    }
 		}
 	    }
diff -Nur sysdeps/generic/herrno-loc.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/herrno-loc.c
--- sysdeps/generic/herrno-loc.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/herrno-loc.c	2002-12-31 21:39:25.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (C) 1996, 97, 98, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <netdb.h>
+#include <tls.h>
+
+#if ! USE___THREAD
+# undef h_errno
+extern int h_errno;
+#endif
+
+/* When threaded, h_errno may be a per-thread variable.  */
+int *
+weak_const_function
+__h_errno_location (void)
+{
+  return &h_errno;
+}
+libc_hidden_def (__h_errno_location)
diff -Nur sysdeps/generic/ifaddrs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifaddrs.c
--- sysdeps/generic/ifaddrs.c	2002-07-25 00:56:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifaddrs.c	2003-06-10 10:55:09.000000000 +0200
@@ -1,5 +1,5 @@
 /* getifaddrs -- get names and addresses of all network interfaces
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,6 +30,7 @@
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (getifaddrs)
 stub_warning (getifaddrs)
 
 void
@@ -41,4 +42,5 @@
   /* Can't be called properly if getifaddrs never succeeded.  */
   abort ();
 }
+libc_hidden_def (freeifaddrs)
 stub_warning (freeifaddrs)
diff -Nur sysdeps/generic/ifreq.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifreq.c
--- sysdeps/generic/ifreq.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifreq.c	2004-05-07 05:51:40.000000000 +0200
@@ -0,0 +1,80 @@
+/* Copyright (C) 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "ifreq.h"
+
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  int fd = sockfd;
+  struct ifconf ifc;
+  int rq_len;
+  int nifs;
+# define RQ_IFS	4
+
+  if (fd < 0)
+    fd = __opensock ();
+  if (fd < 0)
+    {
+      *num_ifs = 0;
+      *ifreqs = NULL;
+      return;
+    }
+
+  ifc.ifc_buf = NULL;
+  rq_len = RQ_IFS * sizeof (struct ifreq) / 2; /* Doubled in the loop.  */
+  do
+    {
+      ifc.ifc_len = rq_len *= 2;
+      void *newp = realloc (ifc.ifc_buf, ifc.ifc_len);
+      if (newp == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  free (ifc.ifc_buf);
+
+	  if (fd != sockfd)
+	    __close (fd);
+	  *num_ifs = 0;
+	  *ifreqs = NULL;
+	  return;
+	}
+      ifc.ifc_buf = newp;
+    }
+  while (rq_len < sizeof (struct ifreq) + ifc.ifc_len);
+
+  if (fd != sockfd)
+    __close (fd);
+
+#ifdef _HAVE_SA_LEN
+  struct ifreq *ifr = *ifreqs;
+  nifs = 0;
+  while ((char *) ifr < ifc.ifc_buf + ifc.ifc_len)
+    {
+      ++nifs;
+      ifr = __if_nextreq (ifr);
+      if (ifr == NULL)
+	break;
+    }
+#else
+  nifs = ifc.ifc_len / sizeof (struct ifreq);
+#endif
+
+  *num_ifs = nifs;
+  *ifreqs = realloc (ifc.ifc_buf, nifs * sizeof (struct ifreq));
+}
diff -Nur sysdeps/generic/ifreq.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifreq.h
--- sysdeps/generic/ifreq.h	2002-09-21 02:28:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ifreq.h	2003-06-28 10:26:05.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>.
 
@@ -24,61 +24,18 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 
-
-static inline void
-__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
-{
-  int fd = sockfd;
-  struct ifconf ifc;
-  int rq_len;
-  int nifs;
-# define RQ_IFS	4
-
-  if (fd < 0)
-    fd = __opensock ();
-  if (fd < 0)
-    {
-      *num_ifs = 0;
-      *ifreqs = NULL;
-      return;
-    }
-
-  ifc.ifc_buf = NULL;
-  rq_len = RQ_IFS * sizeof (struct ifreq) / 2; /* Doubled in the loop.  */
-  do
-    {
-      ifc.ifc_len = rq_len *= 2;
-      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
-      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
-	{
-	  if (ifc.ifc_buf)
-	    free (ifc.ifc_buf);
-
-	  if (fd != sockfd)
-	    __close (fd);
-	  *num_ifs = 0;
-	  *ifreqs = NULL;
-	  return;
-	}
-    }
-  while (rq_len < sizeof (struct ifreq) + ifc.ifc_len);
-
-  nifs = ifc.ifc_len / sizeof (struct ifreq);
-
-  if (fd != sockfd)
-    __close (fd);
-
-  *num_ifs = nifs;
-  *ifreqs = realloc (ifc.ifc_buf, nifs * sizeof (struct ifreq));
-}
-
-
 static inline struct ifreq *
 __if_nextreq (struct ifreq *ifr)
 {
+#ifdef _HAVE_SA_LEN
+  if (ifr->ifr_addr.sa_len > sizeof ifr->ifr_addr)
+    return (struct ifreq *) ((char *) &ifr->ifr_addr + ifr->ifr_addr.sa_len);
+#endif
   return ifr + 1;
 }
 
+extern void __ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd);
+
 
 static inline void
 __if_freereq (struct ifreq *ifreqs, int num_ifs)
diff -Nur sysdeps/generic/initfini.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/initfini.c
--- sysdeps/generic/initfini.c	2001-09-25 03:13:41.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/initfini.c	2004-08-16 06:50:53.000000000 +0200
@@ -11,11 +11,19 @@
    License, the Free Software Foundation gives you unlimited
    permission to link the compiled version of this file with other
    programs, and to distribute those programs without any restriction
-   coming from the use of this file.  (The GNU Lesser General Public
+   coming from the use of this file. (The GNU Lesser General Public
    License restrictions do apply in other respects; for example, they
    cover modification of the file, and distribution when not linked
    into another program.)
 
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
diff -Nur sysdeps/generic/init-first.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/init-first.c
--- sysdeps/generic/init-first.c	2002-03-13 04:37:32.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/init-first.c	2003-01-15 09:04:34.000000000 +0100
@@ -20,6 +20,8 @@
 #include <unistd.h>
 #include <sys/types.h>
 
+/* Set nonzero if we have to be prepared for more then one libc being
+   used in the process.  Safe assumption if initializer never runs.  */
 int __libc_multiple_libcs attribute_hidden = 1;
 
 extern void __libc_init (int, char **, char **);
diff -Nur sysdeps/generic/inttypes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/inttypes.h
--- sysdeps/generic/inttypes.h	2001-10-07 22:16:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/inttypes.h	2004-09-08 00:23:42.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -68,8 +68,8 @@
 # define PRIdLEAST64	__PRI64_PREFIX "d"
 
 # define PRIdFAST8	"d"
-# define PRIdFAST16	"d"
-# define PRIdFAST32	"d"
+# define PRIdFAST16	__PRIPTR_PREFIX "d"
+# define PRIdFAST32	__PRIPTR_PREFIX "d"
 # define PRIdFAST64	__PRI64_PREFIX "d"
 
 
@@ -84,8 +84,8 @@
 # define PRIiLEAST64	__PRI64_PREFIX "i"
 
 # define PRIiFAST8	"i"
-# define PRIiFAST16	"i"
-# define PRIiFAST32	"i"
+# define PRIiFAST16	__PRIPTR_PREFIX "i"
+# define PRIiFAST32	__PRIPTR_PREFIX "i"
 # define PRIiFAST64	__PRI64_PREFIX "i"
 
 /* Octal notation.  */
@@ -100,8 +100,8 @@
 # define PRIoLEAST64	__PRI64_PREFIX "o"
 
 # define PRIoFAST8	"o"
-# define PRIoFAST16	"o"
-# define PRIoFAST32	"o"
+# define PRIoFAST16	__PRIPTR_PREFIX "o"
+# define PRIoFAST32	__PRIPTR_PREFIX "o"
 # define PRIoFAST64	__PRI64_PREFIX "o"
 
 /* Unsigned integers.  */
@@ -116,8 +116,8 @@
 # define PRIuLEAST64	__PRI64_PREFIX "u"
 
 # define PRIuFAST8	"u"
-# define PRIuFAST16	"u"
-# define PRIuFAST32	"u"
+# define PRIuFAST16	__PRIPTR_PREFIX "u"
+# define PRIuFAST32	__PRIPTR_PREFIX "u"
 # define PRIuFAST64	__PRI64_PREFIX "u"
 
 /* lowercase hexadecimal notation.  */
@@ -132,8 +132,8 @@
 # define PRIxLEAST64	__PRI64_PREFIX "x"
 
 # define PRIxFAST8	"x"
-# define PRIxFAST16	"x"
-# define PRIxFAST32	"x"
+# define PRIxFAST16	__PRIPTR_PREFIX "x"
+# define PRIxFAST32	__PRIPTR_PREFIX "x"
 # define PRIxFAST64	__PRI64_PREFIX "x"
 
 /* UPPERCASE hexadecimal notation.  */
@@ -148,8 +148,8 @@
 # define PRIXLEAST64	__PRI64_PREFIX "X"
 
 # define PRIXFAST8	"X"
-# define PRIXFAST16	"X"
-# define PRIXFAST32	"X"
+# define PRIXFAST16	__PRIPTR_PREFIX "X"
+# define PRIXFAST32	__PRIPTR_PREFIX "X"
 # define PRIXFAST64	__PRI64_PREFIX "X"
 
 
@@ -331,8 +331,8 @@
 #   define __strtol_internal_defined	1
 #  endif
 extern __inline intmax_t
-strtoimax (__const char *__restrict nptr, char **__restrict endptr,
-	   int base) __THROW
+__NTH (strtoimax (__const char *__restrict nptr, char **__restrict endptr,
+		  int base))
 {
   return __strtol_internal (nptr, endptr, base, 0);
 }
@@ -346,8 +346,8 @@
 #   define __strtoul_internal_defined	1
 #  endif
 extern __inline uintmax_t
-strtoumax (__const char *__restrict nptr, char **__restrict endptr,
-	   int base) __THROW
+__NTH (strtoumax (__const char *__restrict nptr, char **__restrict endptr,
+		  int base))
 {
   return __strtoul_internal (nptr, endptr, base, 0);
 }
@@ -360,8 +360,8 @@
 #   define __wcstol_internal_defined	1
 #  endif
 extern __inline intmax_t
-wcstoimax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr,
-	   int base) __THROW
+__NTH (wcstoimax (__const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
 {
   return __wcstol_internal (nptr, endptr, base, 0);
 }
@@ -377,8 +377,8 @@
 #   define __wcstoul_internal_defined	1
 #  endif
 extern __inline uintmax_t
-wcstoumax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr,
-	   int base) __THROW
+__NTH (wcstoumax (__const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
 {
   return __wcstoul_internal (nptr, endptr, base, 0);
 }
@@ -394,8 +394,8 @@
 #   define __strtoll_internal_defined	1
 #  endif
 extern __inline intmax_t
-strtoimax (__const char *__restrict nptr, char **__restrict endptr,
-	   int base) __THROW
+__NTH (strtoimax (__const char *__restrict nptr, char **__restrict endptr,
+		  int base))
 {
   return __strtoll_internal (nptr, endptr, base, 0);
 }
@@ -412,8 +412,8 @@
 #   define __strtoull_internal_defined	1
 #  endif
 extern __inline uintmax_t
-strtoumax (__const char *__restrict nptr, char **__restrict endptr,
-	   int base) __THROW
+__NTH (strtoumax (__const char *__restrict nptr, char **__restrict endptr,
+		  int base))
 {
   return __strtoull_internal (nptr, endptr, base, 0);
 }
@@ -428,8 +428,8 @@
 #   define __wcstoll_internal_defined	1
 #  endif
 extern __inline intmax_t
-wcstoimax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr,
-	   int base) __THROW
+__NTH (wcstoimax (__const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
 {
   return __wcstoll_internal (nptr, endptr, base, 0);
 }
@@ -447,8 +447,8 @@
 #   define __wcstoull_internal_defined	1
 #  endif
 extern __inline uintmax_t
-wcstoumax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr,
-	   int base) __THROW
+__NTH (wcstoumax (__const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
 {
   return __wcstoull_internal (nptr, endptr, base, 0);
 }
diff -Nur sysdeps/generic/lchmod.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lchmod.c
--- sysdeps/generic/lchmod.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lchmod.c	2002-10-19 22:03:45.000000000 +0200
@@ -0,0 +1,33 @@
+/* lchmod -- Change the protections of a file or symbolic link.  Stub version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/* Change the protections of FILE to MODE.  */
+int
+lchmod (const char *file, mode_t mode)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+stub_warning (lchmod)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/ldconfig.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ldconfig.h
--- sysdeps/generic/ldconfig.h	2002-09-15 04:18:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ldconfig.h	2003-03-14 06:32:49.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 1999.
 
@@ -32,6 +32,8 @@
 #define FLAG_X8664_LIB64	0x0300
 #define FLAG_S390_LIB64		0x0400
 #define FLAG_POWERPC_LIB64	0x0500
+#define FLAG_MIPS64_LIBN32	0x0600
+#define FLAG_MIPS64_LIBN64	0x0700
 
 /* Declared in cache.c.  */
 extern void print_cache (const char *cache_name);
diff -Nur sysdeps/generic/ldsodefs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ldsodefs.h
--- sysdeps/generic/ldsodefs.h	2002-08-29 01:39:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/ldsodefs.h	2005-04-06 04:50:21.000000000 +0200
@@ -1,5 +1,5 @@
 /* Run-time dynamic linker data structures for loaded ELF shared objects.
-   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,7 @@
 #include <sys/mman.h>
 #include <link.h>
 #include <dl-lookupcfg.h>
+#include <dl-sysdep.h>
 #include <bits/libc-lock.h>
 #include <hp-timing.h>
 #include <tls.h>
@@ -96,9 +97,16 @@
 /* Reloc type classes as returned by elf_machine_type_class().
    ELF_RTYPE_CLASS_PLT means this reloc should not be satisfied by
    some PLT symbol, ELF_RTYPE_CLASS_COPY means this reloc should not be
-   satisfied by any symbol in the executable.  */
+   satisfied by any symbol in the executable.  Some architectures do
+   not support copy relocations.  In this case we define the macro to
+   zero so that the code for handling them gets automatically optimized
+   out.  */
 #define ELF_RTYPE_CLASS_PLT 1
-#define ELF_RTYPE_CLASS_COPY 2
+#ifndef DL_NO_COPY_RELOCS
+# define ELF_RTYPE_CLASS_COPY 2
+#else
+# define ELF_RTYPE_CLASS_COPY 0
+#endif
 
 /* ELF uses the PF_x macros to specify the segment permissions, mmap
    uses PROT_xxx.  In most cases the three macros have the values 1, 2,
@@ -163,22 +171,20 @@
   };
 
 
-/* Test whether given NAME matches any of the names of the given object.  */
-static __inline int
-__attribute__ ((unused))
-_dl_name_match_p (const char *__name, struct link_map *__map)
-{
-  int __found = strcmp (__name, __map->l_name) == 0;
-  struct libname_list *__runp = __map->l_libname;
+/* Bit masks for the objects which valid callers can come from to
+   functions with restricted interface.  */
+enum allowmask
+  {
+    allow_libc = 1,
+    allow_libdl = 2,
+    allow_libpthread = 4,
+    allow_ldso = 8
+  };
 
-  while (! __found && __runp != NULL)
-    if (strcmp (__name, __runp->name) == 0)
-      __found = 1;
-    else
-      __runp = __runp->next;
 
-  return __found;
-}
+/* Test whether given NAME matches any of the names of the given object.  */
+extern int _dl_name_match_p (const char *__name, struct link_map *__map)
+     internal_function;
 
 /* Function used as argument for `_dl_receive_error' function.  The
    arguments are the error code, error string, and the objname the
@@ -210,37 +216,27 @@
   /* Don't change the order of the following elements.  'dl_loaded'
      must remain the first element.  Forever.  */
 
-  /* And a pointer to the map for the main map.  */
-  EXTERN struct link_map *_dl_loaded;
-  /* Number of object in the _dl_loaded list.  */
-  EXTERN unsigned int _dl_nloaded;
-  /* Array representing global scope.  */
-  EXTERN struct r_scope_elem *_dl_global_scope[2];
-  /* Direct pointer to the searchlist of the main object.  */
-  EXTERN struct r_scope_elem *_dl_main_searchlist;
-  /* Copy of the content of `_dl_main_searchlist'.  */
-  EXTERN struct r_scope_elem _dl_initial_searchlist;
-  /* This is zero at program start to signal that the global scope map is
-     allocated by rtld.  Later it keeps the size of the map.  It might be
-     reset if in _dl_close if the last global object is removed.  */
-  EXTERN size_t _dl_global_scope_alloc;
-
-  /* If nonzero the appropriate debug information is printed.  */
-  EXTERN int _dl_debug_mask;
-#define DL_DEBUG_LIBS	    (1 << 0)
-#define DL_DEBUG_IMPCALLS   (1 << 1)
-#define DL_DEBUG_BINDINGS   (1 << 2)
-#define DL_DEBUG_SYMBOLS    (1 << 3)
-#define DL_DEBUG_VERSIONS   (1 << 4)
-#define DL_DEBUG_RELOC      (1 << 5)
-#define DL_DEBUG_FILES      (1 << 6)
-#define DL_DEBUG_STATISTICS (1 << 7)
-/* These two are used only internally.  */
-#define DL_DEBUG_HELP       (1 << 8)
-#define DL_DEBUG_PRELINK    (1 << 9)
-
-  /* Cached value of `getpagesize ()'.  */
-  EXTERN size_t _dl_pagesize;
+/* Non-shared code has no support for multiple namespaces.  */
+#ifdef SHARED
+# define DL_NNS 16
+#else
+# define DL_NNS 1
+#endif
+  EXTERN struct link_namespaces
+  {
+    /* And a pointer to the map for the main map.  */
+    struct link_map *_ns_loaded;
+    /* Number of object in the _dl_loaded list.  */
+    unsigned int _ns_nloaded;
+    /* Array representing global scope.  */
+    struct r_scope_elem *_ns_global_scope[2];
+    /* Direct pointer to the searchlist of the main object.  */
+    struct r_scope_elem *_ns_main_searchlist;
+    /* This is zero at program start to signal that the global scope map is
+       allocated by rtld.  Later it keeps the size of the map.  It might be
+       reset if in _dl_close if the last global object is removed.  */
+    size_t _ns_global_scope_alloc;
+  } _dl_ns[DL_NNS];
 
   /* During the program run we must not modify the global data of
      loaded shared object simultanously in two threads.  Therefore we
@@ -249,49 +245,59 @@
      This must be a recursive lock since the initializer function of
      the loaded object might as well require a call to this function.
      At this time it is not anymore a problem to modify the tables.  */
-  __libc_lock_define_recursive (EXTERN, _dl_load_lock)
+  __rtld_lock_define_recursive (EXTERN, _dl_load_lock)
 
-  /* OS version.  */
-  EXTERN unsigned int _dl_osversion;
-  /* Platform name.  */
-  EXTERN const char *_dl_platform;
-  EXTERN size_t _dl_platformlen;
+  /* Incremented whenever something may have been added to dl_loaded.  */
+  EXTERN unsigned long long _dl_load_adds;
 
 #ifndef MAP_ANON
   /* File descriptor referring to the zero-fill device.  */
   EXTERN int _dl_zerofd;
 #endif
 
-  /* CLK_TCK as reported by the kernel.  */
-  EXTERN int _dl_clktck;
-
-  /* If nonzero print warnings messages.  */
-  EXTERN int _dl_verbose;
-
-  /* Do we do lazy relocations?  */
-  EXTERN int _dl_lazy;
-
-  /* Nonzero if runtime lookups should not update the .got/.plt.  */
-  EXTERN int _dl_bind_not;
-
-  /* Nonzero if references should be treated as weak during runtime
-     linking.  */
-  EXTERN int _dl_dynamic_weak;
-
-  /* Default floating-point control word.  */
-  EXTERN fpu_control_t _dl_fpu_control;
-
   /* The object to be initialized first.  */
   EXTERN struct link_map *_dl_initfirst;
 
 #if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL
   /* Start time on CPU clock.  */
   EXTERN hp_timing_t _dl_cpuclock_offset;
+#endif
 
-  /* Overhead of a high-precision timing measurement.  */
-  EXTERN hp_timing_t _dl_hp_timing_overhead;
+  /* Map of shared object to be profiled.  */
+  EXTERN struct link_map *_dl_profile_map;
+
+  /* Counters for the number of relocations performed.  */
+  EXTERN unsigned long int _dl_num_relocations;
+  EXTERN unsigned long int _dl_num_cache_relocations;
+
+  /* List of search directories.  */
+  EXTERN struct r_search_path_elem *_dl_all_dirs;
+
+#ifdef _LIBC_REENTRANT
+  EXTERN void **(*_dl_error_catch_tsd) (void) __attribute__ ((const));
 #endif
 
+  /* Structure describing the dynamic linker itself.  */
+  EXTERN struct link_map _dl_rtld_map;
+
+#if defined SHARED && defined _LIBC_REENTRANT \
+    && defined __rtld_lock_default_lock_recursive
+  EXTERN void (*_dl_rtld_lock_recursive) (void *);
+  EXTERN void (*_dl_rtld_unlock_recursive) (void *);
+#endif
+
+  /* Prevailing state of the stack, PF_X indicating it's executable.  */
+  EXTERN ElfW(Word) _dl_stack_flags;
+
+  /* If loading a shared object requires that we make the stack executable
+     when it was not, we do it by calling this function.
+     It returns an errno code or zero on success.  */
+  EXTERN int (*_dl_make_stack_executable_hook) (void **) internal_function;
+
+  /* Keep the conditional TLS members at the end so the layout of the
+     structure used by !USE_TLS code matches the prefix of the layout in
+     the USE_TLS rtld.  Note that `struct link_map' is conditionally
+     defined as well, so _dl_rtld_map needs to be last before this.  */
 #ifdef USE_TLS
   /* Highest dtv index currently needed.  */
   EXTERN size_t _dl_tls_max_dtv_idx;
@@ -312,6 +318,8 @@
   EXTERN size_t _dl_tls_static_nelem;
   /* Size of the static TLS block.  */
   EXTERN size_t _dl_tls_static_size;
+  /* Size actually allocated in the static TLS block.  */
+  EXTERN size_t _dl_tls_static_used;
   /* Alignment requirement of the static TLS block.  */
   EXTERN size_t _dl_tls_static_align;
 
@@ -327,78 +335,246 @@
   EXTERN void *_dl_initial_dtv;
   /* Generation counter for the dtv.  */
   EXTERN size_t _dl_tls_generation;
+
+  EXTERN void (*_dl_init_static_tls) (struct link_map *);
 #endif
 
-  /* Name of the shared object to be profiled (if any).  */
-  EXTERN const char *_dl_profile;
-  /* Map of shared object to be profiled.  */
-  EXTERN struct link_map *_dl_profile_map;
-  /* Filename of the output file.  */
-  EXTERN const char *_dl_profile_output;
-  /* Map of shared object to be prelink traced.  */
-  EXTERN struct link_map *_dl_trace_prelink_map;
-  /* Name of the object we want to trace the prelinking.  */
-  EXTERN const char *_dl_trace_prelink;
+#ifdef SHARED
+};
+# define __rtld_global_attribute__
+# ifdef IS_IN_rtld
+#  ifdef HAVE_VISIBILITY_ATTRIBUTE
+#   ifdef HAVE_SDATA_SECTION
+#    define __rtld_local_attribute__ \
+	    __attribute__ ((visibility ("hidden"), section (".sdata")))
+#    undef __rtld_global_attribute__
+#    define __rtld_global_attribute__ __attribute__ ((section (".sdata")))
+#   else
+#    define __rtld_local_attribute__ __attribute__ ((visibility ("hidden")))
+#   endif
+#  else
+#   define __rtld_local_attribute__
+#  endif
+extern struct rtld_global _rtld_local __rtld_local_attribute__;
+#  undef __rtld_local_attribute__
+# endif
+extern struct rtld_global _rtld_global __rtld_global_attribute__;
+# undef __rtld_global_attribute__
+#endif
+
+#ifndef SHARED
+# define GLRO(name) _##name
+#else
+# ifdef IS_IN_rtld
+#  define GLRO(name) _rtld_local_ro._##name
+# else
+#  define GLRO(name) _rtld_global_ro._##name
+# endif
+struct rtld_global_ro
+{
+#endif
+
+  /* If nonzero the appropriate debug information is printed.  */
+  EXTERN int _dl_debug_mask;
+#define DL_DEBUG_LIBS	    (1 << 0)
+#define DL_DEBUG_IMPCALLS   (1 << 1)
+#define DL_DEBUG_BINDINGS   (1 << 2)
+#define DL_DEBUG_SYMBOLS    (1 << 3)
+#define DL_DEBUG_VERSIONS   (1 << 4)
+#define DL_DEBUG_RELOC      (1 << 5)
+#define DL_DEBUG_FILES      (1 << 6)
+#define DL_DEBUG_STATISTICS (1 << 7)
+#define DL_DEBUG_UNUSED	    (1 << 8)
+/* These two are used only internally.  */
+#define DL_DEBUG_HELP       (1 << 9)
+#define DL_DEBUG_PRELINK    (1 << 10)
+
+  /* Cached value of `getpagesize ()'.  */
+  EXTERN size_t _dl_pagesize;
+
+  /* OS version.  */
+  EXTERN unsigned int _dl_osversion;
+  /* Platform name.  */
+  EXTERN const char *_dl_platform;
+  EXTERN size_t _dl_platformlen;
+
+  /* Copy of the content of `_dl_main_searchlist' at startup time.  */
+  EXTERN struct r_scope_elem _dl_initial_searchlist;
+
+  /* CLK_TCK as reported by the kernel.  */
+  EXTERN int _dl_clktck;
+
+  /* If nonzero print warnings messages.  */
+  EXTERN int _dl_verbose;
+
+  /* File descriptor to write debug messages to.  */
+  EXTERN int _dl_debug_fd;
+
+  /* Do we do lazy relocations?  */
+  EXTERN int _dl_lazy;
+
+  /* Nonzero if runtime lookups should not update the .got/.plt.  */
+  EXTERN int _dl_bind_not;
+
+  /* Nonzero if references should be treated as weak during runtime
+     linking.  */
+  EXTERN int _dl_dynamic_weak;
+
+  /* Default floating-point control word.  */
+  EXTERN fpu_control_t _dl_fpu_control;
 
   /* Expected cache ID.  */
   EXTERN int _dl_correct_cache_id;
 
-  /* Counters for the number of relocations performed.  */
-  EXTERN unsigned long int _dl_num_relocations;
-  EXTERN unsigned long int _dl_num_cache_relocations;
-
   /* Mask for hardware capabilities that are available.  */
   EXTERN unsigned long int _dl_hwcap;
 
   /* Mask for important hardware capabilities we honour. */
   EXTERN unsigned long int _dl_hwcap_mask;
 
+  /* Get architecture specific definitions.  */
+#define PROCINFO_DECL
+#ifndef PROCINFO_CLASS
+# define PROCINFO_CLASS EXTERN
+#endif
+#include <dl-procinfo.c>
+
   /* Names of shared object for which the RPATH should be ignored.  */
   EXTERN const char *_dl_inhibit_rpath;
 
   /* Location of the binary.  */
   EXTERN const char *_dl_origin_path;
 
-  /* List of search directories.  */
-  EXTERN struct r_search_path_elem *_dl_all_dirs;
+  /* -1 if the dynamic linker should honor library load bias,
+     0 if not, -2 use the default (honor biases for normal
+     binaries, don't honor for PIEs).  */
+  EXTERN ElfW(Addr) _dl_use_load_bias;
+
+  /* Name of the shared object to be profiled (if any).  */
+  EXTERN const char *_dl_profile;
+  /* Filename of the output file.  */
+  EXTERN const char *_dl_profile_output;
+  /* Name of the object we want to trace the prelinking.  */
+  EXTERN const char *_dl_trace_prelink;
+  /* Map of shared object to be prelink traced.  */
+  EXTERN struct link_map *_dl_trace_prelink_map;
+
+  /* All search directories defined at startup.  */
   EXTERN struct r_search_path_elem *_dl_init_all_dirs;
 
-  /* File descriptor to write debug messages to.  */
-  EXTERN int _dl_debug_fd;
+#if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL
+  /* Overhead of a high-precision timing measurement.  */
+  EXTERN hp_timing_t _dl_hp_timing_overhead;
+#endif
 
-  /* Get architecture specific definitions.  */
-#define PROCINFO_DECL
-#include <dl-procinfo.c>
+#ifdef NEED_DL_SYSINFO
+  /* Syscall handling improvements.  This is very specific to x86.  */
+  EXTERN uintptr_t _dl_sysinfo;
+#endif
+
+#if defined NEED_DL_SYSINFO || defined NEED_DL_SYSINFO_DSO
+  /* The vsyscall page is a virtual DSO pre-mapped by the kernel.
+     This points to its ELF header.  */
+  EXTERN const ElfW(Ehdr) *_dl_sysinfo_dso;
+#endif
 
-  /* Structure describing the dynamic linker itself.  */
-  EXTERN struct link_map _dl_rtld_map;
 #ifdef SHARED
+  /* We add a function table to _rtld_global which is then used to
+     call the function instead of going through the PLT.  The result
+     is that we can avoid exporting the functions and we do not jump
+     PLT relocations in libc.so.  */
+  const char *(*_dl_get_origin) (void);
+  size_t (*_dl_dst_count) (const char *, int);
+  char *(*_dl_dst_substitute) (struct link_map *, const char *, char *, int);
+  struct link_map *(internal_function *_dl_map_object) (struct link_map *,
+							const char *, int,
+							int, int, int, Lmid_t);
+  void (internal_function *_dl_map_object_deps) (struct link_map *,
+						 struct link_map **,
+						 unsigned int, int, int);
+  void (*_dl_relocate_object) (struct link_map *, struct r_scope_elem *[],
+			       int, int);
+  int (internal_function *_dl_check_map_versions) (struct link_map *, int,
+						   int);
+  void (internal_function *_dl_init) (struct link_map *, int, char **,
+					char **);
+  void (*_dl_debug_state) (void);
+#ifndef MAP_COPY
+  void (*_dl_unload_cache) (void);
+#endif
+  void (*_dl_debug_printf) (const char *, ...)
+       __attribute__ ((__format__ (__printf__, 1, 2)));
+  int (internal_function *_dl_catch_error) (const char **, const char **,
+					    void (*) (void *), void *);
+  void (internal_function *_dl_signal_error) (int, const char *, const char *,
+					      const char *);
+  void (internal_function *_dl_start_profile) (void);
+  void (*_dl_mcount) (ElfW(Addr) frompc, ElfW(Addr) selfpc);
+  lookup_t (internal_function *_dl_lookup_symbol_x) (const char *,
+						     struct link_map *,
+						     const ElfW(Sym) **,
+						     struct r_scope_elem *[],
+						     const struct r_found_version *,
+						     int, int,
+						     struct link_map *);
+  int (*_dl_check_caller) (const void *, enum allowmask);
+
 };
 # define __rtld_global_attribute__
 # ifdef IS_IN_rtld
 #  ifdef HAVE_VISIBILITY_ATTRIBUTE
-#   ifdef HAVE_SDATA_SECTION
-#    define __rtld_local_attribute__ \
-	    __attribute__ ((visibility ("hidden"), section (".sdata")))
-#    undef __rtld_global_attribute__
-#    define __rtld_global_attribute__ __attribute__ ((section (".sdata")))
-#   else
-#    define __rtld_local_attribute__ __attribute__ ((visibility ("hidden")))
-#   endif
+#   define __rtld_local_attribute__ __attribute__ ((visibility ("hidden")))
 #  else
 #   define __rtld_local_attribute__
 #  endif
-extern struct rtld_global _rtld_local __rtld_local_attribute__;
+extern struct rtld_global_ro _rtld_local_ro
+    attribute_relro __rtld_local_attribute__;
+extern struct rtld_global_ro _rtld_global_ro
+    attribute_relro __rtld_global_attribute__;
+#  undef __rtld_local_attribute__
+# else
+/* We cheat a bit here.  We declare the variable as as const even
+   though it is at startup.  */
+extern const struct rtld_global_ro _rtld_global_ro
+    attribute_relro __rtld_global_attribute__;
 # endif
-extern struct rtld_global _rtld_global __rtld_global_attribute__;
+# undef __rtld_global_attribute__
 #endif
 #undef EXTERN
 
+#ifdef IS_IN_rtld
+/* This is the initial value of GL(dl_error_catch_tsd).
+   A non-TLS libpthread will change it.  */
+extern void **_dl_initial_error_catch_tsd (void) __attribute__ ((const))
+     attribute_hidden;
+#endif
+
+/* This is the initial value of GL(dl_make_stack_executable_hook).
+   A threads library can change it.  */
+extern int _dl_make_stack_executable (void **stack_endp) internal_function;
+rtld_hidden_proto (_dl_make_stack_executable)
+
+/* Variable pointing to the end of the stack (or close to it).  This value
+   must be constant over the runtime of the application.  Some programs
+   might use the variable which results in copy relocations on some
+   platforms.  But this does not matter, ld.so can always use the local
+   copy.  */
+extern void *__libc_stack_end attribute_relro;
+rtld_hidden_proto (__libc_stack_end)
+
 /* Parameters passed to the dynamic linker.  */
-extern int _dl_argc attribute_hidden;
-extern char **_dl_argv;
+extern int _dl_argc attribute_hidden attribute_relro;
+extern char **_dl_argv
+#ifndef DL_ARGV_NOT_RELRO
+     attribute_relro
+#endif
+     ;
 #ifdef IS_IN_rtld
-extern char **_dl_argv_internal attribute_hidden;
+extern char **_dl_argv_internal attribute_hidden
+# ifndef DL_ARGV_NOT_RELRO
+     attribute_relro
+# endif
+     ;
 # define rtld_progname (INTUSE(_dl_argv)[0])
 #else
 # define rtld_progname _dl_argv[0]
@@ -411,6 +587,12 @@
 extern const char _dl_out_of_memory_internal[] attribute_hidden;
 #endif
 
+/* Flag set at startup and cleared when the last initializer has run.  */
+extern int _dl_starting_up;
+weak_extern (_dl_starting_up)
+#ifdef IS_IN_rtld
+extern int _dl_starting_up_internal attribute_hidden;
+#endif
 
 /* OS-dependent function to open the zero-fill device.  */
 extern int _dl_sysdep_open_zero_fill (void); /* dl-sysdep.c */
@@ -420,10 +602,7 @@
    interpreted as for a `printf' call.  All the lines start with a
    tag showing the PID.  */
 extern void _dl_debug_printf (const char *fmt, ...)
-     __attribute__ ((__format__ (__printf__, 1, 2)));
-extern void _dl_debug_printf_internal (const char *fmt, ...)
-     __attribute__ ((__format__ (__printf__, 1, 2)))
-     attribute_hidden;
+     __attribute__ ((__format__ (__printf__, 1, 2))) attribute_hidden;
 
 /* Write message on the debug file descriptor.  The parameters are
    interpreted as for a `printf' call.  All the lines buf the first
@@ -466,11 +645,6 @@
    problem.  */
 extern void _dl_signal_error (int errcode, const char *object,
 			      const char *occurred, const char *errstring)
-     internal_function
-     __attribute__ ((__noreturn__));
-extern void _dl_signal_error_internal (int errcode, const char *object,
-				       const char *occurred,
-				       const char *errstring)
      internal_function __attribute__ ((__noreturn__)) attribute_hidden;
 
 /* Like _dl_signal_error, but may return when called in the context of
@@ -495,13 +669,8 @@
    value to allow additional security checks.  */
 extern struct link_map *_dl_map_object (struct link_map *loader,
 					const char *name, int preloaded,
-					int type, int trace_mode, int mode)
-     internal_function;
-extern struct link_map *_dl_map_object_internal (struct link_map *loader,
-						 const char *name,
-						 int preloaded,
-						 int type, int trace_mode,
-						 int mode)
+					int type, int trace_mode, int mode,
+					Lmid_t nsid)
      internal_function attribute_hidden;
 
 /* Call _dl_map_object on the dependencies of MAP, and set up
@@ -512,11 +681,6 @@
 				 struct link_map **preloads,
 				 unsigned int npreloads, int trace_mode,
 				 int open_mode)
-     internal_function;
-extern void _dl_map_object_deps_internal (struct link_map *map,
-					  struct link_map **preloads,
-					  unsigned int npreloads,
-					  int trace_mode, int open_mode)
      internal_function attribute_hidden;
 
 /* Cache the locations of MAP's hash table.  */
@@ -524,6 +688,16 @@
      internal_function attribute_hidden;
 
 
+/* Collect the directories in the search path for LOADER's dependencies.
+   The data structure is defined in <dlfcn.h>.  If COUNTING is true,
+   SI->dls_cnt and SI->dls_size are set; if false, those must be as set
+   by a previous call with COUNTING set, and SI must point to SI->dls_size
+   bytes to be used in filling in the result.  */
+extern void _dl_rtld_di_serinfo (struct link_map *loader,
+				 Dl_serinfo *si, bool counting)
+     internal_function;
+
+
 /* Search loaded objects' symbol tables for a definition of the symbol
    referred to by UNDEF.  *SYM is the symbol table entry containing the
    reference; it is replaced with the defining symbol, and the base load
@@ -533,19 +707,6 @@
    object) is searched in turn.  REFERENCE_NAME should name the object
    containing the reference; it is used in error messages.
    TYPE_CLASS describes the type of symbol we are looking for.  */
-extern lookup_t _dl_lookup_symbol (const char *undef,
-				   struct link_map *undef_map,
-				   const ElfW(Sym) **sym,
-				   struct r_scope_elem *symbol_scope[],
-				   int type_class, int flags)
-     internal_function;
-extern lookup_t _dl_lookup_symbol_internal (const char *undef,
-					    struct link_map *undef_map,
-					    const ElfW(Sym) **sym,
-					    struct r_scope_elem *symbolscope[],
-					    int type_class, int flags)
-     internal_function attribute_hidden;
-
 enum
   {
     /* If necessary add dependency between user and provider object.  */
@@ -556,39 +717,15 @@
   };
 
 /* Lookup versioned symbol.  */
-extern lookup_t _dl_lookup_versioned_symbol (const char *undef,
-					     struct link_map *undef_map,
-					     const ElfW(Sym) **sym,
-					     struct r_scope_elem *symbol_scope[],
-					     const struct r_found_version *version,
-					     int type_class, int explicit)
-     internal_function;
-extern lookup_t _dl_lookup_versioned_symbol_internal (const char *undef,
-						      struct link_map *undef_map,
-						      const ElfW(Sym) **sym,
-						      struct r_scope_elem *symbol_scope[],
-						      const struct r_found_version *version,
-						      int type_class,
-						      int explicit)
+extern lookup_t _dl_lookup_symbol_x (const char *undef,
+				     struct link_map *undef_map,
+				     const ElfW(Sym) **sym,
+				     struct r_scope_elem *symbol_scope[],
+				     const struct r_found_version *version,
+				     int type_class, int explicit,
+				     struct link_map *skip_map)
      internal_function attribute_hidden;
 
-/* For handling RTLD_NEXT we must be able to skip shared objects.  */
-extern lookup_t _dl_lookup_symbol_skip (const char *undef,
-					struct link_map *undef_map,
-					const ElfW(Sym) **sym,
-					struct r_scope_elem *symbol_scope[],
-					struct link_map *skip_this)
-     internal_function;
-
-/* For handling RTLD_NEXT with versioned symbols we must be able to
-   skip shared objects.  */
-extern lookup_t _dl_lookup_versioned_symbol_skip (const char *undef,
-						  struct link_map *undef_map,
-						  const ElfW(Sym) **sym,
-						  struct r_scope_elem *symbol_scope[],
-						  const struct r_found_version *version,
-						  struct link_map *skip_this)
-     internal_function;
 
 /* Look up symbol NAME in MAP's scope and return its run-time address.  */
 extern ElfW(Addr) _dl_symbol_value (struct link_map *map, const char *name)
@@ -597,7 +734,8 @@
 /* Allocate a `struct link_map' for a new object being loaded,
    and enter it into the _dl_main_map list.  */
 extern struct link_map *_dl_new_object (char *realname, const char *libname,
-					int type, struct link_map *loader)
+					int type, struct link_map *loader,
+					int mode, Lmid_t nsid)
      internal_function attribute_hidden;
 
 /* Relocate the given object (if it hasn't already been).
@@ -605,12 +743,13 @@
    If LAZY is nonzero, don't relocate its PLT.  */
 extern void _dl_relocate_object (struct link_map *map,
 				 struct r_scope_elem *scope[],
-				 int lazy, int consider_profiling);
-extern void _dl_relocate_object_internal (struct link_map *map,
-					  struct r_scope_elem *scope[],
-					  int lazy, int consider_profiling)
+				 int lazy, int consider_profiling)
      attribute_hidden;
 
+/* Protect PT_GNU_RELRO area.  */
+extern void _dl_protect_relro (struct link_map *map)
+     internal_function attribute_hidden;
+
 /* Call _dl_signal_error with a message about an unhandled reloc type.
    TYPE is the result of ELFW(R_TYPE) (r_info), i.e. an R_<CPU>_* value.
    PLT is nonzero if this was a PLT reloc; it just affects the message.  */
@@ -638,18 +777,23 @@
 /* Initialize the object in SCOPE by calling the constructors with
    ARGC, ARGV, and ENV as the parameters.  */
 extern void _dl_init (struct link_map *main_map, int argc, char **argv,
-		      char **env) internal_function;
+		      char **env) internal_function attribute_hidden;
 
 /* Call the finalizer functions of all shared objects whose
    initializer functions have completed.  */
 extern void _dl_fini (void) internal_function;
 
+/* Sort array MAPS according to dependencies of the contained objects.  */
+extern void _dl_sort_fini (struct link_map *l, struct link_map **maps,
+			   size_t nmaps, char *used, Lmid_t ns)
+     internal_function;
+
 /* The dynamic linker calls this function before and having changing
    any shared object mappings.  The `r_state' member of `struct r_debug'
    says what change is taking place.  This function's address is
    the value of the `r_brk' member.  */
 extern void _dl_debug_state (void);
-extern void _dl_debug_state_internal (void) attribute_hidden;
+rtld_hidden_proto (_dl_debug_state)
 
 /* Initialize `struct r_debug' if it has not already been done.  The
    argument is the run-time load address of the dynamic linker, to be put
@@ -662,11 +806,7 @@
 
 /* Gather the information needed to install the profiling tables and start
    the timers.  */
-extern void _dl_start_profile (struct link_map *map, const char *output_dir)
-     internal_function;
-extern void _dl_start_profile_internal (struct link_map *map,
-					const char *output_dir)
-     internal_function attribute_hidden;
+extern void _dl_start_profile (void) internal_function attribute_hidden;
 
 /* The actual functions used to keep book on the calls.  */
 extern void _dl_mcount (ElfW(Addr) frompc, ElfW(Addr) selfpc);
@@ -701,8 +841,7 @@
    all the time since this would create problems when the file is replaced.
    Therefore we provide this function to close the file and open it again
    once needed.  */
-extern void _dl_unload_cache (void);
-extern void _dl_unload_cache_internal (void) attribute_hidden;
+extern void _dl_unload_cache (void) attribute_hidden;
 
 /* System-dependent function to read a file's whole contents in the
    most convenient manner available.  *SIZEP gets the size of the
@@ -726,32 +865,56 @@
 
 
 /* Determine next available module ID.  */
-extern size_t _dl_next_tls_modid (void) internal_function;
+extern size_t _dl_next_tls_modid (void) internal_function attribute_hidden;
 
 /* Calculate offset of the TLS blocks in the static TLS block.  */
-extern void _dl_determine_tlsoffset (void) internal_function;
+extern void _dl_determine_tlsoffset (void) internal_function attribute_hidden;
+
+/* Set up the data structures for TLS, when they were not set up at startup.
+   Returns nonzero on malloc failure.
+   This is called from _dl_map_object_from_fd or by libpthread.  */
+extern int _dl_tls_setup (void) internal_function;
+rtld_hidden_proto (_dl_tls_setup)
 
 /* Allocate memory for static TLS block (unless MEM is nonzero) and dtv.  */
 extern void *_dl_allocate_tls (void *mem) internal_function;
+rtld_hidden_proto (_dl_allocate_tls)
 
 /* Get size and alignment requirements of the static TLS block.  */
 extern void _dl_get_tls_static_info (size_t *sizep, size_t *alignp)
      internal_function;
 
+extern void _dl_allocate_static_tls (struct link_map *map)
+     internal_function attribute_hidden;
+
 /* These are internal entry points to the two halves of _dl_allocate_tls,
    only used within rtld.c itself at startup time.  */
 extern void *_dl_allocate_tls_storage (void)
-  internal_function attribute_hidden;
-extern void *_dl_allocate_tls_init (void *)
-  internal_function attribute_hidden;
+     internal_function attribute_hidden;
+extern void *_dl_allocate_tls_init (void *) internal_function;
+rtld_hidden_proto (_dl_allocate_tls_init)
 
 /* Deallocate memory allocated with _dl_allocate_tls.  */
 extern void _dl_deallocate_tls (void *tcb, bool dealloc_tcb) internal_function;
+rtld_hidden_proto (_dl_deallocate_tls)
 
-/* Return the symbol address given the map of the module it is in and
-   the symbol record.  */
-extern void *_dl_tls_symaddr (struct link_map *map, const ElfW(Sym) *ref)
-     internal_function;
+#if defined USE_TLS
+extern void _dl_nothread_init_static_tls (struct link_map *) attribute_hidden;
+#endif
+
+/* Find origin of the executable.  */
+extern const char *_dl_get_origin (void) attribute_hidden;
+
+/* Count DSTs.  */
+extern size_t _dl_dst_count (const char *name, int is_path) attribute_hidden;
+
+/* Substitute DST values.  */
+extern char *_dl_dst_substitute (struct link_map *l, const char *name,
+				 char *result, int is_path) attribute_hidden;
+
+/* Check validity of the caller.  */
+extern int _dl_check_caller (const void *caller, enum allowmask mask)
+     attribute_hidden;
 
 __END_DECLS
 
diff -Nur sysdeps/generic/libc_fatal.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc_fatal.c
--- sysdeps/generic/libc_fatal.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc_fatal.c	2003-07-23 01:54:21.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1993, 1995, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,3 +28,4 @@
 
   abort ();
 }
+libc_hidden_def (__libc_fatal)
diff -Nur sysdeps/generic/libc-start.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc-start.c
--- sysdeps/generic/libc-start.c	2002-09-15 20:53:15.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc-start.c	2005-02-16 10:40:56.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,6 +17,7 @@
    02111-1307 USA.  */
 
 #include <stdlib.h>
+#include <stdio.h>
 #include <unistd.h>
 #include <ldsodefs.h>
 #include <bp-start.h>
@@ -24,37 +25,74 @@
 
 extern void __libc_init_first (int argc, char **argv, char **envp);
 
-extern int _dl_starting_up;
-weak_extern (_dl_starting_up)
 extern int __libc_multiple_libcs;
-extern void *__libc_stack_end;
 
 #include <tls.h>
 #ifndef SHARED
+# include <dl-osinfo.h>
 extern void __pthread_initialize_minimal (void)
-# if !(USE_TLS - 0)
+# if !(USE_TLS - 0) && !defined NONTLS_INIT_TP
      __attribute__ ((weak))
 # endif
      ;
 #endif
 
+#ifdef HAVE_PTR_NTHREADS
+/* We need atomic operations.  */
+# include <atomic.h>
+#endif
+
+
+#ifdef LIBC_START_MAIN
+# ifdef LIBC_START_DISABLE_INLINE
+#  define STATIC static
+# else
+#  define STATIC static inline __attribute__ ((always_inline))
+# endif
+#else
+# define STATIC
+# define LIBC_START_MAIN BP_SYM (__libc_start_main)
+#endif
+
+#ifdef MAIN_AUXVEC_ARG
+/* main gets passed a pointer to the auxiliary.  */
+# define MAIN_AUXVEC_DECL	, void *
+# define MAIN_AUXVEC_PARAM	, auxvec
+#else
+# define MAIN_AUXVEC_DECL
+# define MAIN_AUXVEC_PARAM
+#endif
 
-extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),
-				       int argc,
-				       char *__unbounded *__unbounded ubp_av,
-				       void (*init) (void),
-				       void (*fini) (void),
-				       void (*rtld_fini) (void),
-				       void *__unbounded stack_end)
+STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
+					 MAIN_AUXVEC_DECL),
+			    int argc,
+			    char *__unbounded *__unbounded ubp_av,
+#ifdef LIBC_START_MAIN_AUXVEC_ARG
+			    ElfW(auxv_t) *__unbounded auxvec,
+#endif
+#ifdef INIT_MAIN_ARGS
+			    __typeof (main) init,
+#else
+			    void (*init) (void),
+#endif
+			    void (*fini) (void),
+			    void (*rtld_fini) (void),
+			    void *__unbounded stack_end)
      __attribute__ ((noreturn));
 
-int
-/* GKM FIXME: GCC: this should get __BP_ prefix by virtue of the
-   BPs in the arglist of startup_info.main and startup_info.init. */
-BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),
-		   int argc, char *__unbounded *__unbounded ubp_av,
-		   void (*init) (void), void (*fini) (void),
-		   void (*rtld_fini) (void), void *__unbounded stack_end)
+STATIC int
+LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
+		 int argc, char *__unbounded *__unbounded ubp_av,
+#ifdef LIBC_START_MAIN_AUXVEC_ARG
+		 ElfW(auxv_t) *__unbounded auxvec,
+#endif
+#ifdef INIT_MAIN_ARGS
+		 __typeof (main) init,
+#else
+		 void (*init) (void),
+#endif
+		 void (*fini) (void),
+		 void (*rtld_fini) (void), void *__unbounded stack_end)
 {
   char *__unbounded *__unbounded ubp_ev = &ubp_av[argc + 1];
 #if __BOUNDED_POINTERS__
@@ -66,27 +104,36 @@
   /* Result of the 'main' function.  */
   int result;
 
-#ifndef SHARED
-# ifdef HAVE_AUX_VECTOR
-  void *__unbounded *__unbounded auxvec;
-# endif
-
   __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
-#endif
 
+#ifndef SHARED
   INIT_ARGV_and_ENVIRON;
 
-  /* Store the lowest stack address.  */
+  /* Store the lowest stack address.  This is done in ld.so if this is
+     the code for the DSO.  */
   __libc_stack_end = stack_end;
 
-#ifndef SHARED
 # ifdef HAVE_AUX_VECTOR
   /* First process the auxiliary vector since we need to find the
      program header to locate an eventually present PT_TLS entry.  */
-  for (auxvec = (void *__unbounded *__unbounded) ubp_ev;
-       *auxvec != NULL; ++auxvec);
-  ++auxvec;
-  _dl_aux_init ((ElfW(auxv_t) *) auxvec);
+#  ifndef LIBC_START_MAIN_AUXVEC_ARG
+  ElfW(auxv_t) *__unbounded auxvec;
+  {
+    char *__unbounded *__unbounded evp = ubp_ev;
+    while (*evp++ != NULL)
+      ;
+    auxvec = (ElfW(auxv_t) *__unbounded) evp;
+  }
+#  endif
+  _dl_aux_init (auxvec);
+# endif
+# ifdef DL_SYSDEP_OSCHECK
+  if (!__libc_multiple_libcs)
+    {
+      /* This needs to run to initiliaze _dl_osversion before TLS
+	 setup might check it.  */
+      DL_SYSDEP_OSCHECK (__libc_fatal);
+    }
 # endif
 
   /* Initialize the thread library at least a bit since the libgcc
@@ -94,17 +141,10 @@
      we need to setup errno.  If there is no thread library and we
      handle TLS the function is defined in the libc to initialized the
      TLS handling.  */
-# if !(USE_TLS - 0)
+# if !(USE_TLS - 0) && !defined NONTLS_INIT_TP
   if (__pthread_initialize_minimal)
 # endif
     __pthread_initialize_minimal ();
-
-  /* Some security at this point.  Prevent starting a SUID binary where
-     the standard file descriptors are not opened.  We have to do this
-     only for statically linked applications since otherwise the dynamic
-     loader did the work already.  */
-  if (__builtin_expect (__libc_enable_secure, 0))
-    __libc_check_standard_fds ();
 #endif
 
   /* Register the destructor of the dynamic linker if there is any.  */
@@ -122,31 +162,79 @@
   if (fini)
     __cxa_atexit ((void (*) (void *)) fini, NULL, NULL);
 
+#ifndef SHARED
+  /* Some security at this point.  Prevent starting a SUID binary where
+     the standard file descriptors are not opened.  We have to do this
+     only for statically linked applications since otherwise the dynamic
+     loader did the work already.  */
+  if (__builtin_expect (__libc_enable_secure, 0))
+    __libc_check_standard_fds ();
+#endif
+
   /* Call the initializer of the program, if any.  */
 #ifdef SHARED
-  if (__builtin_expect (GL(dl_debug_mask) & DL_DEBUG_IMPCALLS, 0))
-    _dl_debug_printf ("\ninitialize program: %s\n\n", argv[0]);
+  if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_IMPCALLS, 0))
+    GLRO(dl_debug_printf) ("\ninitialize program: %s\n\n", argv[0]);
 #endif
   if (init)
-    (*init) ();
+    (*init) (
+#ifdef INIT_MAIN_ARGS
+	     argc, argv, __environ MAIN_AUXVEC_PARAM
+#endif
+	     );
 
 #ifdef SHARED
-  if (__builtin_expect (GL(dl_debug_mask) & DL_DEBUG_IMPCALLS, 0))
-    _dl_debug_printf ("\ntransferring control: %s\n\n", argv[0]);
+  if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_IMPCALLS, 0))
+    GLRO(dl_debug_printf) ("\ntransferring control: %s\n\n", argv[0]);
 #endif
 
-#ifdef HAVE_CANCELBUF
-  if (setjmp (THREAD_SELF->cancelbuf) == 0)
-#endif
+#ifdef HAVE_CLEANUP_JMP_BUF
+  /* Memory for the cancellation buffer.  */
+  struct pthread_unwind_buf unwind_buf;
+
+  int not_first_call;
+  not_first_call = setjmp ((struct __jmp_buf_tag *) unwind_buf.cancel_jmp_buf);
+  if (__builtin_expect (! not_first_call, 1))
     {
-      /* XXX This is where the try/finally handling must be used.  */
+      struct pthread *self = THREAD_SELF;
 
-      result = main (argc, argv, __environ);
+      /* Store old info.  */
+      unwind_buf.priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);
+      unwind_buf.priv.data.cleanup = THREAD_GETMEM (self, cleanup);
+
+      /* Store the new cleanup handler info.  */
+      THREAD_SETMEM (self, cleanup_jmp_buf, &unwind_buf);
+
+      /* Run the program.  */
+      result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
     }
-#ifdef HAVE_CANCELBUF
   else
-    /* Not much left to do but to exit the thread, not the process.  */
-    __exit_thread (0);
+    {
+      /* Remove the thread-local data.  */
+# ifdef SHARED
+      __libc_pthread_functions.ptr__nptl_deallocate_tsd ();
+# else
+      extern void __nptl_deallocate_tsd (void) __attribute ((weak));
+      __nptl_deallocate_tsd ();
+# endif
+
+      /* One less thread.  Decrement the counter.  If it is zero we
+	 terminate the entire process.  */
+      result = 0;
+# ifdef SHARED
+      int *const ptr = __libc_pthread_functions.ptr_nthreads;
+# else
+      extern int __nptl_nthreads __attribute ((weak));
+      int *const ptr = &__nptl_nthreads;
+# endif
+
+      if (! atomic_decrement_and_test (ptr))
+	/* Not much left to do but to exit the thread, not the process.  */
+	__exit_thread (0);
+    }
+#else
+  /* Nothing fancy, just call the function.  */
+  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
 #endif
 
   exit (result);
diff -Nur sysdeps/generic/libc-tls.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc-tls.c
--- sysdeps/generic/libc-tls.c	2002-09-15 20:56:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/libc-tls.c	2005-02-26 02:09:44.000000000 +0100
@@ -1,5 +1,5 @@
 /* Initialization code for TLS in statically linked application.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,25 +21,30 @@
 #include <ldsodefs.h>
 #include <tls.h>
 #include <unistd.h>
+#include <stdio.h>
+#include <sys/param.h>
 
 
+#ifdef SHARED
+ #error makefile bug, this file is for static only
+#endif
+
 #ifdef USE_TLS
 extern ElfW(Phdr) *_dl_phdr;
 extern size_t _dl_phnum;
 
 
-/* DTV with just one element plus overhead.  */
-static dtv_t static_dtv[3];
+static dtv_t static_dtv[2 + TLS_SLOTINFO_SURPLUS];
 
 
 static struct
 {
   struct dtv_slotinfo_list si;
   /* The dtv_slotinfo_list data structure does not include the actual
-     informatin since it is defined as an array of size zero.  We
-     define here the necessary entries.  Not that it is not important
-     whether there is padding or not since we will always access the
-     informatin through the 'si' element.  */
+     information since it is defined as an array of size zero.  We define
+     here the necessary entries.  Note that it is not important whether
+     there is padding or not since we will always access the information
+     through the 'si' element.  */
   struct dtv_slotinfo info[2 + TLS_SLOTINFO_SURPLUS];
 } static_slotinfo;
 
@@ -47,11 +52,59 @@
 static struct link_map static_map;
 
 
+/* Highest dtv index currently needed.  */
+size_t _dl_tls_max_dtv_idx;
+/* Flag signalling whether there are gaps in the module ID allocation.  */
+bool _dl_tls_dtv_gaps;
+/* Information about the dtv slots.  */
+struct dtv_slotinfo_list *_dl_tls_dtv_slotinfo_list;
+/* Number of modules in the static TLS block.  */
+size_t _dl_tls_static_nelem;
+/* Size of the static TLS block.  */
+size_t _dl_tls_static_size;
+/* Size actually allocated in the static TLS block.  */
+size_t _dl_tls_static_used;
+/* Alignment requirement of the static TLS block.  */
+size_t _dl_tls_static_align;
+
+/* Generation counter for the dtv.  */
+size_t _dl_tls_generation;
+
+
 /* Additional definitions needed by TLS initialization.  */
 #ifdef TLS_INIT_HELPER
 TLS_INIT_HELPER
 #endif
 
+static inline void
+init_slotinfo (void)
+{
+  /* Create the slotinfo list.  */
+  static_slotinfo.si.len = (((char *) (&static_slotinfo + 1)
+			     - (char *) &static_slotinfo.si.slotinfo[0])
+			    / sizeof static_slotinfo.si.slotinfo[0]);
+  // static_slotinfo.si.next = NULL;	already zero
+
+  /* The slotinfo list.  Will be extended by the code doing dynamic
+     linking.  */
+  GL(dl_tls_max_dtv_idx) = 1;
+  GL(dl_tls_dtv_slotinfo_list) = &static_slotinfo.si;
+}
+
+static inline void
+init_static_tls (size_t memsz, size_t align)
+{
+  /* That is the size of the TLS memory for this object.  The initialized
+     value of _dl_tls_static_size is provided by dl-open.c to request some
+     surplus that permits dynamic loading of modules with IE-model TLS.  */
+  GL(dl_tls_static_size) = roundup (memsz + GL(dl_tls_static_size),
+				    TLS_TCB_ALIGN);
+  GL(dl_tls_static_used) = memsz;
+  /* The alignment requirement for the static TLS block.  */
+  GL(dl_tls_static_align) = align;
+  /* Number of elements in the static TLS block.  */
+  GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);
+}
 
 void
 __libc_setup_tls (size_t tcbsize, size_t tcbalign)
@@ -80,19 +133,34 @@
 	  break;
 	}
 
-  if (memsz == 0 && tcbsize == 0)
-    /* We do not need a TLS block and no thread descriptor.  */
-    return;
+#ifdef TLS_INIT_TP_EXPENSIVE
+  if (memsz == 0 && tcbsize <= TLS_INIT_TCB_SIZE)
+    {
+      /* We do not need a TLS block and no thread descriptor.  */
+# ifdef NONTLS_INIT_TP
+      NONTLS_INIT_TP;
+# endif
+      return;
+    }
+#endif
 
   /* We have to set up the TCB block which also (possibly) contains
      'errno'.  Therefore we avoid 'malloc' which might touch 'errno'.
      Instead we use 'sbrk' which would only uses 'errno' if it fails.
      In this case we are right away out of memory and the user gets
-     what she/he deserves.  */
+     what she/he deserves.
+
+     The initialized value of _dl_tls_static_size is provided by dl-open.c
+     to request some surplus that permits dynamic loading of modules with
+     IE-model TLS.  */
 # if TLS_TCB_AT_TP
-  tlsblock = __sbrk (roundup (memsz, tcbalign) + tcbsize + max_align);
+  tcb_offset = roundup (memsz + GL(dl_tls_static_size), tcbalign);
+  tlsblock = __sbrk (tcb_offset + tcbsize + max_align);
 # elif TLS_DTV_AT_TP
-  tlsblock = __sbrk (roundup (tcbsize, align) + memsz + max_align);
+  tcb_offset = roundup (tcbsize, align ?: 1);
+  tlsblock = __sbrk (tcb_offset + memsz + max_align
+		     + TLS_PRE_TCB_SIZE + GL(dl_tls_static_size));
+  tlsblock += TLS_PRE_TCB_SIZE;
 # else
   /* In case a model with a different layout for the TCB and DTV
      is defined add another #elif here and in the following #ifs.  */
@@ -104,69 +172,80 @@
 		       & ~(max_align - 1));
 
   /* Initialize the dtv.  [0] is the length, [1] the generation counter.  */
-  static_dtv[0].counter = 1;
+  static_dtv[0].counter = (sizeof (static_dtv) / sizeof (static_dtv[0])) - 2;
   // static_dtv[1].counter = 0;		would be needed if not already done
 
   /* Initialize the TLS block.  */
 # if TLS_TCB_AT_TP
-  static_dtv[2].pointer = tlsblock;
+  static_dtv[2].pointer = ((char *) tlsblock + tcb_offset
+			   - roundup (memsz, align ?: 1));
+  static_map.l_tls_offset = roundup (memsz, align ?: 1);
 # elif TLS_DTV_AT_TP
-  tcb_offset = roundup (tcbsize, align);
   static_dtv[2].pointer = (char *) tlsblock + tcb_offset;
+  static_map.l_tls_offset = tcb_offset;
 # else
 #  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
 # endif
-  memset (__mempcpy (static_dtv[2].pointer, initimage, filesz),
-	  '\0', memsz - filesz);
+  /* sbrk gives us zero'd memory, so we don't need to clear the remainder.  */
+  memcpy (static_dtv[2].pointer, initimage, filesz);
 
   /* Install the pointer to the dtv.  */
 
   /* Initialize the thread pointer.  */
 # if TLS_TCB_AT_TP
-  tcb_offset = roundup (memsz, tcbalign);
-
   INSTALL_DTV ((char *) tlsblock + tcb_offset, static_dtv);
 
-  TLS_INIT_TP ((char *) tlsblock + tcb_offset, 0);
+  const char *lossage = TLS_INIT_TP ((char *) tlsblock + tcb_offset, 0);
 # elif TLS_DTV_AT_TP
   INSTALL_DTV (tlsblock, static_dtv);
-  TLS_INIT_TP (tlsblock, 0);
+  const char *lossage = TLS_INIT_TP (tlsblock, 0);
 # else
 #  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
 # endif
+  if (__builtin_expect (lossage != NULL, 0))
+    __libc_fatal (lossage);
 
   /* We have to create a fake link map which normally would be created
      by the dynamic linker.  It just has to have enough information to
      make the TLS routines happy.  */
   static_map.l_tls_align = align;
   static_map.l_tls_blocksize = memsz;
+  static_map.l_tls_initimage = initimage;
   static_map.l_tls_initimage_size = filesz;
-  static_map.l_tls_offset = tcb_offset;
   static_map.l_type = lt_executable;
   static_map.l_tls_modid = 1;
 
-  /* Create the slotinfo list.  */
-  static_slotinfo.si.len = 1;	/* Only one element.  */
-  // static_slotinfo.si.next = NULL;	already zero
-
-  static_slotinfo.si.slotinfo[1].gen = 0;
+  init_slotinfo ();
+  // static_slotinfo.si.slotinfo[1].gen = 0; already zero
   static_slotinfo.si.slotinfo[1].map = &static_map;
 
-  /* The slotinfo list.  Will be extended by the code doing dynamic
-     linking.  */
-  GL(dl_tls_max_dtv_idx) = 1;
-  GL(dl_tls_dtv_slotinfo_list) = &static_slotinfo.si;
+  memsz = roundup (memsz, align ?: 1);
 
-  /* That is the size of the TLS memory for this object.  */
-  GL(dl_tls_static_size) = (roundup (memsz, align ?: 1)
 # if TLS_TCB_AT_TP
-			    + tcbsize
+  memsz += tcbsize;
+# elif TLS_DTV_AT_TP
+  memsz += tcb_offset;
 # endif
-			    );
-  /* The alignment requirement for the static TLS block.  */
-  GL(dl_tls_static_align) = MAX (TLS_TCB_ALIGN, max_align);
-  /* Number of elements in the static TLS block.  */
-  GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);
+
+  init_static_tls (memsz, MAX (TLS_TCB_ALIGN, max_align));
+}
+
+/* This is called only when the data structure setup was skipped at startup,
+   when there was no need for it then.  Now we have dynamically loaded
+   something needing TLS, or libpthread needs it.  */
+int
+internal_function
+_dl_tls_setup (void)
+{
+  init_slotinfo ();
+  init_static_tls (
+# if TLS_TCB_AT_TP
+		   TLS_TCB_SIZE,
+# else
+		   0,
+# endif
+		   TLS_TCB_ALIGN);
+  return 0;
 }
 
 
@@ -178,4 +257,16 @@
 {
   __libc_setup_tls (TLS_INIT_TCB_SIZE, TLS_INIT_TCB_ALIGN);
 }
+
+#elif defined NONTLS_INIT_TP
+
+/* This is the minimal initialization function used when libpthread is
+   not used.  */
+void
+__attribute__ ((weak))
+__pthread_initialize_minimal (void)
+{
+  NONTLS_INIT_TP;
+}
+
 #endif
diff -Nur sysdeps/generic/lockf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lockf.c
--- sysdeps/generic/lockf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lockf.c	2003-06-15 23:11:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1994, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1994,1996,1997,1998,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -67,5 +67,8 @@
       return -1;
     }
 
+  /* lockf() is a cancellation point but so is fcntl() if F_SETLKW is
+     used.  Therefore we don't have to care about cancellation here,
+     the fcntl() function will take care of it.  */
   return __fcntl (fd, cmd, &fl);
 }
diff -Nur sysdeps/generic/lockfile.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lockfile.c
--- sysdeps/generic/lockfile.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lockfile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/* lockfile - Handle locking and unlocking of stream.  Singlethreaded version.
-   Copyright (C) 1996,97,2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <stdio.h>
-
-#undef _IO_flockfile
-#undef _IO_funlockfile
-#undef _IO_ftrylockfile
-
-void
-__flockfile (FILE *stream)
-{
-  /* Do nothing.  Using this version does not do any locking.  */
-}
-weak_alias (__flockfile, flockfile);
-#ifdef USE_IN_LIBIO
-weak_alias (__flockfile, _IO_flockfile)
-#endif
-
-
-void
-__funlockfile (FILE *stream)
-{
-  /* Do nothing.  Using this version does not do any locking.  */
-}
-#ifdef USE_IN_LIBIO
-weak_alias (__funlockfile, _IO_funlockfile)
-#endif
-weak_alias (__funlockfile, funlockfile);
-
-
-int
-__ftrylockfile (FILE *stream)
-{
-  /* Do nothing.  Using this version does not do any locking.  */
-  return 1;
-}
-weak_alias (__ftrylockfile, ftrylockfile);
-#ifdef USE_IN_LIBIO
-weak_alias (__ftrylockfile, _IO_ftrylockfile)
-#endif
diff -Nur sysdeps/generic/longjmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/longjmp.c
--- sysdeps/generic/longjmp.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/longjmp.c	2002-12-31 10:45:38.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 94, 95, 97, 98, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,94,95,97,98,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -40,6 +40,7 @@
 }
 
 strong_alias (__libc_siglongjmp, __libc_longjmp)
+libc_hidden_def (__libc_longjmp)
 weak_alias (__libc_siglongjmp, _longjmp)
 weak_alias (__libc_siglongjmp, longjmp)
 weak_alias (__libc_siglongjmp, siglongjmp)
diff -Nur sysdeps/generic/lseek.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lseek.c
--- sysdeps/generic/lseek.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/lseek.c	2002-12-31 21:40:17.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,6 +47,7 @@
   return -1;
 }
 stub_warning (lseek)
+libc_hidden_def (__lseek)
 
 weak_alias (__lseek, lseek)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/madvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/madvise.c
--- sysdeps/generic/madvise.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/madvise.c	2003-08-16 08:11:50.000000000 +0200
@@ -24,11 +24,10 @@
    for the region starting at ADDR and extending LEN bytes.  */
 
 int
-posix_madvise (__ptr_t addr, size_t len, int advice)
+madvise (__ptr_t addr, size_t len, int advice)
 {
   __set_errno (ENOSYS);
   return -1;
 }
-weak_alias (posix_madvise, madvise)
 stub_warning (madvise)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/Makefile
--- sysdeps/generic/Makefile	2002-03-29 00:41:40.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/Makefile	2004-03-10 11:02:11.000000000 +0100
@@ -38,7 +38,7 @@
 ifeq ($(subdir),elf)
 ifeq (yes:yes,$(build-shared):$(unwind-find-fde))
 # This is needed to support g++ v2 and v3.
-sysdep_routines += framestate
-shared-only-routines += framestate
+sysdep_routines += framestate unwind-pe
+shared-only-routines += framestate unwind-pe
 endif
 endif
diff -Nur sysdeps/generic/malloc-machine.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/malloc-machine.h
--- sysdeps/generic/malloc-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/malloc-machine.h	2003-09-30 04:07:42.000000000 +0200
@@ -0,0 +1,68 @@
+/* Basic platform-independent macro definitions for mutexes,
+   thread-specific data and parameters for malloc.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _GENERIC_MALLOC_MACHINE_H
+#define _GENERIC_MALLOC_MACHINE_H
+
+#include <atomic.h>
+
+#ifndef mutex_init /* No threads, provide dummy macros */
+
+# define NO_THREADS
+
+/* The mutex functions used to do absolutely nothing, i.e. lock,
+   trylock and unlock would always just return 0.  However, even
+   without any concurrently active threads, a mutex can be used
+   legitimately as an `in use' flag.  To make the code that is
+   protected by a mutex async-signal safe, these macros would have to
+   be based on atomic test-and-set operations, for example. */
+typedef int mutex_t;
+
+# define mutex_init(m)              (*(m) = 0)
+# define mutex_lock(m)              ((*(m) = 1), 0)
+# define mutex_trylock(m)           (*(m) ? 1 : ((*(m) = 1), 0))
+# define mutex_unlock(m)            (*(m) = 0)
+
+typedef void *tsd_key_t;
+# define tsd_key_create(key, destr) do {} while(0)
+# define tsd_setspecific(key, data) ((key) = (data))
+# define tsd_getspecific(key, vptr) (vptr = (key))
+
+# define thread_atfork(prepare, parent, child) do {} while(0)
+
+#endif /* !defined mutex_init */
+
+#ifndef atomic_full_barrier
+# define atomic_full_barrier() __asm ("" ::: "memory")
+#endif
+
+#ifndef atomic_read_barrier
+# define atomic_read_barrier() atomic_full_barrier ()
+#endif
+
+#ifndef atomic_write_barrier
+# define atomic_write_barrier() atomic_full_barrier ()
+#endif
+
+#ifndef DEFAULT_TOP_PAD
+# define DEFAULT_TOP_PAD 131072
+#endif
+
+#endif /* !defined(_GENERIC_MALLOC_MACHINE_H) */
diff -Nur sysdeps/generic/memchr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memchr.c
--- sysdeps/generic/memchr.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memchr.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,93,96,97,99,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991,93,96,97,99,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
    with help from Dan Sahlin (dan@sics.se) and
@@ -212,3 +212,4 @@
 #ifdef weak_alias
 weak_alias (__memchr, BP_SYM (memchr))
 #endif
+libc_hidden_builtin_def (memchr)
diff -Nur sysdeps/generic/memcmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcmp.c
--- sysdeps/generic/memcmp.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcmp.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991, 1993, 1995, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1993,1995,1997,1998,2003,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -30,14 +31,6 @@
 # define __ptr_t	char *
 #endif /* C++ or ANSI C.  */
 
-#ifndef __P
-# if defined __GNUC__ || (defined __STDC__ && __STDC__)
-#  define __P(args) args
-# else
-#  define __P(args) ()
-# endif  /* GCC.  */
-#endif  /* Not __P.  */
-
 #if defined HAVE_STRING_H || defined _LIBC
 # include <string.h>
 #endif
@@ -101,7 +94,7 @@
    A and B are known to be different.
    This is needed only on little-endian machines.  */
 
-static int memcmp_bytes __P((op_t, op_t));
+static int memcmp_bytes (op_t, op_t) __THROW;
 
 # ifdef  __GNUC__
 __inline
@@ -126,14 +119,11 @@
 }
 #endif
 
-static int memcmp_common_alignment __P((long, long, size_t));
+static int memcmp_common_alignment (long, long, size_t) __THROW;
 
 /* memcmp_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN `op_t'
    objects (not LEN bytes!).  Both SRCP1 and SRCP2 should be aligned for
    memory operations on `op_t's.  */
-#ifdef	__GNUC__
-__inline
-#endif
 static int
 memcmp_common_alignment (srcp1, srcp2, len)
      long int srcp1;
@@ -216,14 +206,11 @@
   return 0;
 }
 
-static int memcmp_not_common_alignment __P((long, long, size_t));
+static int memcmp_not_common_alignment (long, long, size_t) __THROW;
 
 /* memcmp_not_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN
    `op_t' objects (not LEN bytes!).  SRCP2 should be aligned for memory
    operations on `op_t', but SRCP1 *should be unaligned*.  */
-#ifdef	__GNUC__
-__inline
-#endif
 static int
 memcmp_not_common_alignment (srcp1, srcp2, len)
      long int srcp1;
@@ -387,7 +374,7 @@
 
   return 0;
 }
-
+libc_hidden_builtin_def(memcmp)
 #ifdef weak_alias
 # undef bcmp
 weak_alias (memcmp, bcmp)
diff -Nur sysdeps/generic/memcopy.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcopy.h
--- sysdeps/generic/memcopy.h	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcopy.h	2004-09-14 06:24:48.000000000 +0200
@@ -1,5 +1,5 @@
 /* memcopy.h -- definitions for memory copy functions.  Generic C version.
-   Copyright (C) 1991, 1992, 1993, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1993, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -111,8 +111,8 @@
    the assumption that DST_BP is aligned on an OPSIZ multiple.  If
    not all bytes could be easily copied, store remaining number of bytes
    in NBYTES_LEFT, otherwise store 0.  */
-extern void _wordcopy_fwd_aligned __P ((long int, long int, size_t));
-extern void _wordcopy_fwd_dest_aligned __P ((long int, long int, size_t));
+extern void _wordcopy_fwd_aligned (long int, long int, size_t) __THROW;
+extern void _wordcopy_fwd_dest_aligned (long int, long int, size_t) __THROW;
 #define WORD_COPY_FWD(dst_bp, src_bp, nbytes_left, nbytes)		      \
   do									      \
     {									      \
@@ -131,8 +131,8 @@
    DST_END_PTR is aligned on an OPSIZ multiple.  If not all bytes could be
    easily copied, store remaining number of bytes in NBYTES_REMAINING,
    otherwise store 0.  */
-extern void _wordcopy_bwd_aligned __P ((long int, long int, size_t));
-extern void _wordcopy_bwd_dest_aligned __P ((long int, long int, size_t));
+extern void _wordcopy_bwd_aligned (long int, long int, size_t) __THROW;
+extern void _wordcopy_bwd_dest_aligned (long int, long int, size_t) __THROW;
 #define WORD_COPY_BWD(dst_ep, src_ep, nbytes_left, nbytes)		      \
   do									      \
     {									      \
diff -Nur sysdeps/generic/memcpy.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcpy.c
--- sysdeps/generic/memcpy.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcpy.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* Copy memory to memory until the specified number of bytes
    has been copied.  Overlap is NOT handled correctly.
-   Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -62,3 +62,4 @@
 
   return dstpp;
 }
+libc_hidden_builtin_def (memcpy)
diff -Nur sysdeps/generic/memcpy_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcpy_chk.c
--- sysdeps/generic/memcpy_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memcpy_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,66 @@
+/* Copy memory to memory until the specified number of bytes
+   has been copied with error checking.  Overlap is NOT handled correctly.
+   Copyright (C) 1991, 1997, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Torbjorn Granlund (tege@sics.se).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+#include <pagecopy.h>
+
+void *
+__memcpy_chk (dstpp, srcpp, len, dstlen)
+     void *dstpp;
+     const void *srcpp;
+     size_t len;
+     size_t dstlen;
+{
+  if (__builtin_expect (dstlen < len, 0))
+    __chk_fail ();
+
+  unsigned long int dstp = (long int) dstpp;
+  unsigned long int srcp = (long int) srcpp;
+
+  /* Copy from the beginning to the end.  */
+
+  /* If there not too few bytes to copy, use word copy.  */
+  if (len >= OP_T_THRES)
+    {
+      /* Copy just a few bytes to make DSTP aligned.  */
+      len -= (-dstp) % OPSIZ;
+      BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);
+
+      /* Copy whole pages from SRCP to DSTP by virtual address manipulation,
+	 as much as possible.  */
+
+      PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);
+
+      /* Copy from SRCP to DSTP taking advantage of the known alignment of
+	 DSTP.  Number of bytes remaining is put in the third argument,
+	 i.e. in LEN.  This number may vary from machine to machine.  */
+
+      WORD_COPY_FWD (dstp, srcp, len, len);
+
+      /* Fall out and copy the tail.  */
+    }
+
+  /* There are just a few bytes to copy.  Use byte memory operations.  */
+  BYTE_COPY_FWD (dstp, srcp, len);
+
+  return dstpp;
+}
diff -Nur sysdeps/generic/memmem.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmem.c
--- sysdeps/generic/memmem.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmem.c	2004-10-02 00:49:36.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,92,93,94,96,97,98,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,94,96,97,98,2000,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,6 +19,10 @@
 #include <stddef.h>
 #include <string.h>
 
+#ifndef _LIBC
+# define __builtin_expect(expr, val)   (expr)
+#endif
+
 #undef memmem
 
 /* Return the first occurrence of NEEDLE in HAYSTACK.  */
diff -Nur sysdeps/generic/memmove.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmove.c
--- sysdeps/generic/memmove.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmove.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* Copy memory to memory until the specified number of bytes
    has been copied.  Overlap is handled correctly.
-   Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -107,3 +107,6 @@
 
   RETURN (dest);
 }
+#ifndef memmove
+libc_hidden_builtin_def (memmove)
+#endif
diff -Nur sysdeps/generic/memmove_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmove_chk.c
--- sysdeps/generic/memmove_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memmove_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,98 @@
+/* Copy memory to memory until the specified number of bytes
+   has been copied with error checking.  Overlap is handled correctly.
+   Copyright (C) 1991,1995,1996,1997,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Torbjorn Granlund (tege@sics.se).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+#include <pagecopy.h>
+
+void *
+__memmove_chk (dest, src, len, destlen)
+     void *dest;
+     const void *src;
+     size_t len;
+     size_t destlen;
+{
+  if (__builtin_expect (destlen < len, 0))
+    __chk_fail ();
+
+  unsigned long int dstp = (long int) dest;
+  unsigned long int srcp = (long int) src;
+
+  /* This test makes the forward copying code be used whenever possible.
+     Reduces the working set.  */
+  if (dstp - srcp >= len)	/* *Unsigned* compare!  */
+    {
+      /* Copy from the beginning to the end.  */
+
+      /* If there not too few bytes to copy, use word copy.  */
+      if (len >= OP_T_THRES)
+	{
+	  /* Copy just a few bytes to make DSTP aligned.  */
+	  len -= (-dstp) % OPSIZ;
+	  BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);
+
+	  /* Copy whole pages from SRCP to DSTP by virtual address
+	     manipulation, as much as possible.  */
+
+	  PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);
+
+	  /* Copy from SRCP to DSTP taking advantage of the known
+	     alignment of DSTP.  Number of bytes remaining is put
+	     in the third argument, i.e. in LEN.  This number may
+	     vary from machine to machine.  */
+
+	  WORD_COPY_FWD (dstp, srcp, len, len);
+
+	  /* Fall out and copy the tail.  */
+	}
+
+      /* There are just a few bytes to copy.  Use byte memory operations.  */
+      BYTE_COPY_FWD (dstp, srcp, len);
+    }
+  else
+    {
+      /* Copy from the end to the beginning.  */
+      srcp += len;
+      dstp += len;
+
+      /* If there not too few bytes to copy, use word copy.  */
+      if (len >= OP_T_THRES)
+	{
+	  /* Copy just a few bytes to make DSTP aligned.  */
+	  len -= dstp % OPSIZ;
+	  BYTE_COPY_BWD (dstp, srcp, dstp % OPSIZ);
+
+	  /* Copy from SRCP to DSTP taking advantage of the known
+	     alignment of DSTP.  Number of bytes remaining is put
+	     in the third argument, i.e. in LEN.  This number may
+	     vary from machine to machine.  */
+
+	  WORD_COPY_BWD (dstp, srcp, len, len);
+
+	  /* Fall out and copy the tail.  */
+	}
+
+      /* There are just a few bytes to copy.  Use byte memory operations.  */
+      BYTE_COPY_BWD (dstp, srcp, len);
+    }
+
+  return dest;
+}
diff -Nur sysdeps/generic/mempcpy.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mempcpy.c
--- sysdeps/generic/mempcpy.c	2002-08-03 18:57:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mempcpy.c	2004-05-28 08:39:37.000000000 +0200
@@ -1,7 +1,7 @@
 /* Copy memory to memory until the specified number of bytes
    has been copied, return pointer to following byte.
    Overlap is NOT handled correctly.
-   Copyright (C) 1991, 1997, 1998, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1997, 1998, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -66,3 +66,4 @@
 }
 libc_hidden_def (__mempcpy)
 weak_alias (__mempcpy, mempcpy)
+libc_hidden_builtin_def (mempcpy)
diff -Nur sysdeps/generic/mempcpy_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mempcpy_chk.c
--- sysdeps/generic/mempcpy_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mempcpy_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,67 @@
+/* Copy memory to memory until the specified number of bytes
+   has been copied, return pointer to following byte, with error checking.
+   Overlap is NOT handled correctly.
+   Copyright (C) 1991, 1997, 1998, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Torbjorn Granlund (tege@sics.se).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+#include <pagecopy.h>
+
+void *
+__mempcpy_chk (dstpp, srcpp, len, dstlen)
+     void *dstpp;
+     const void *srcpp;
+     size_t len;
+     size_t dstlen;
+{
+  if (__builtin_expect (dstlen < len, 0))
+    __chk_fail ();
+
+  unsigned long int dstp = (long int) dstpp;
+  unsigned long int srcp = (long int) srcpp;
+
+  /* Copy from the beginning to the end.  */
+
+  /* If there not too few bytes to copy, use word copy.  */
+  if (len >= OP_T_THRES)
+    {
+      /* Copy just a few bytes to make DSTP aligned.  */
+      len -= (-dstp) % OPSIZ;
+      BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);
+
+      /* Copy whole pages from SRCP to DSTP by virtual address manipulation,
+	 as much as possible.  */
+
+      PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);
+
+      /* Copy from SRCP to DSTP taking advantage of the known alignment of
+	 DSTP.  Number of bytes remaining is put in the third argument,
+	 i.e. in LEN.  This number may vary from machine to machine.  */
+
+      WORD_COPY_FWD (dstp, srcp, len, len);
+
+      /* Fall out and copy the tail.  */
+    }
+
+  /* There are just a few bytes to copy.  Use byte memory operations.  */
+  BYTE_COPY_FWD (dstp, srcp, len);
+
+  return (void *) dstp;
+}
diff -Nur sysdeps/generic/memset.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memset.c
--- sysdeps/generic/memset.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memset.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -88,3 +88,4 @@
 
   return dstpp;
 }
+libc_hidden_builtin_def (memset)
diff -Nur sysdeps/generic/memset_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memset_chk.c
--- sysdeps/generic/memset_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/memset_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,92 @@
+/* Copyright (C) 1991, 1997, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+
+void *
+__memset_chk (dstpp, c, len, dstlen)
+     void *dstpp;
+     int c;
+     size_t len;
+     size_t dstlen;
+{
+  if (__builtin_expect (dstlen < len, 0))
+    __chk_fail ();
+
+  long int dstp = (long int) dstpp;
+
+  if (len >= 8)
+    {
+      size_t xlen;
+      op_t cccc;
+
+      cccc = (unsigned char) c;
+      cccc |= cccc << 8;
+      cccc |= cccc << 16;
+      if (OPSIZ > 4)
+	/* Do the shift in two steps to avoid warning if long has 32 bits.  */
+	cccc |= (cccc << 16) << 16;
+
+      /* There are at least some bytes to set.
+	 No need to test for LEN == 0 in this alignment loop.  */
+      while (dstp % OPSIZ != 0)
+	{
+	  ((byte *) dstp)[0] = c;
+	  dstp += 1;
+	  len -= 1;
+	}
+
+      /* Write 8 `op_t' per iteration until less than 8 `op_t' remain.  */
+      xlen = len / (OPSIZ * 8);
+      while (xlen > 0)
+	{
+	  ((op_t *) dstp)[0] = cccc;
+	  ((op_t *) dstp)[1] = cccc;
+	  ((op_t *) dstp)[2] = cccc;
+	  ((op_t *) dstp)[3] = cccc;
+	  ((op_t *) dstp)[4] = cccc;
+	  ((op_t *) dstp)[5] = cccc;
+	  ((op_t *) dstp)[6] = cccc;
+	  ((op_t *) dstp)[7] = cccc;
+	  dstp += 8 * OPSIZ;
+	  xlen -= 1;
+	}
+      len %= OPSIZ * 8;
+
+      /* Write 1 `op_t' per iteration until less than OPSIZ bytes remain.  */
+      xlen = len / OPSIZ;
+      while (xlen > 0)
+	{
+	  ((op_t *) dstp)[0] = cccc;
+	  dstp += OPSIZ;
+	  xlen -= 1;
+	}
+      len %= OPSIZ;
+    }
+
+  /* Write the last few bytes.  */
+  while (len > 0)
+    {
+      ((byte *) dstp)[0] = c;
+      dstp += 1;
+      len -= 1;
+    }
+
+  return dstpp;
+}
diff -Nur sysdeps/generic/mknod.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mknod.c
--- sysdeps/generic/mknod.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mknod.c	2004-08-16 06:50:53.000000000 +0200
@@ -6,6 +6,23 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
diff -Nur sysdeps/generic/morecore.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/morecore.c
--- sysdeps/generic/morecore.c	2002-08-10 20:09:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/morecore.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 94, 95, 97, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,94,95,97,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,7 +31,7 @@
 
 #include <stddef.h>
 #include <stdlib.h>
-extern __malloc_ptr_t __sbrk __P ((ptrdiff_t increment));
+extern __malloc_ptr_t __sbrk (ptrdiff_t increment) __THROW;
 libc_hidden_proto (__sbrk)
 #endif
 
diff -Nur sysdeps/generic/mq_close.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_close.c
--- sysdeps/generic/mq_close.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_close.c	2004-04-13 04:09:31.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Removes the association between message queue descriptor MQDES and its
+   message queue.  */
+int
+mq_close (mqd_t mqdes)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_close)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_getattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_getattr.c
--- sysdeps/generic/mq_getattr.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_getattr.c	2004-04-13 04:09:42.000000000 +0200
@@ -0,0 +1,30 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Query status and attributes of message queue MQDES.  */
+int
+mq_getattr (mqd_t mqdes, struct mq_attr *mqstat)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_getattr)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_notify.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_notify.c
--- sysdeps/generic/mq_notify.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_notify.c	2004-04-13 04:09:54.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Register notification upon message arrival to an empty message queue
+   MQDES.  */
+int
+mq_notify (mqd_t mqdes, const struct sigevent *notification)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_notify)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_open.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_open.c
--- sysdeps/generic/mq_open.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_open.c	2004-04-13 04:10:04.000000000 +0200
@@ -0,0 +1,36 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Establish connection between a process and a message queue NAME and
+   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines
+   the type of access used.  If O_CREAT is on OFLAG, the third argument is
+   taken as a `mode_t', the mode of the created message queue, and the fourth
+   argument is taken as `struct mq_attr *', pointer to message queue
+   attributes.  If the fourth argument is NULL, default attributes are
+   used.  */
+mqd_t
+mq_open (const char *name, int oflag, ...)
+{
+  __set_errno (ENOSYS);
+  return (mqd_t) -1;
+}
+stub_warning (mq_open)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_receive.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_receive.c
--- sysdeps/generic/mq_receive.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_receive.c	2004-04-13 04:10:14.000000000 +0200
@@ -0,0 +1,32 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Receive the oldest from highest priority messages in message queue
+   MQDES.  */
+ssize_t
+mq_receive (mqd_t mqdes, char *msg_ptr, size_t msg_len,
+	    unsigned int *msg_prio)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_receive)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_send.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_send.c
--- sysdeps/generic/mq_send.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_send.c	2004-04-13 04:10:25.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Add message pointed by MSG_PTR to message queue MQDES.  */
+int
+mq_send (mqd_t mqdes, const char *msg_ptr, size_t msg_len,
+	 unsigned int msg_prio)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_send)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_setattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_setattr.c
--- sysdeps/generic/mq_setattr.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_setattr.c	2004-04-13 04:10:39.000000000 +0200
@@ -0,0 +1,33 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Set attributes associated with message queue MQDES and if OMQSTAT is
+   not NULL also query its old attributes.  */
+int
+mq_setattr (mqd_t mqdes, const struct mq_attr *__restrict mqstat,
+	    struct mq_attr *__restrict omqstat)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+hidden_def (mq_setattr)
+stub_warning (mq_setattr)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_timedreceive.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_timedreceive.c
--- sysdeps/generic/mq_timedreceive.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_timedreceive.c	2004-04-13 04:10:51.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Receive the oldest from highest priority messages in message queue
+   MQDES, stop waiting if ABS_TIMEOUT expires.  */
+ssize_t
+mq_timedreceive (mqd_t mqdes, char *__restrict msg_ptr, size_t msg_len,
+		 unsigned int *__restrict msg_prio,
+		 const struct timespec *__restrict abs_timeout)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+hidden_def (mq_timedreceive)
+stub_warning (mq_timedreceive)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_timedsend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_timedsend.c
--- sysdeps/generic/mq_timedsend.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_timedsend.c	2004-04-13 04:11:02.000000000 +0200
@@ -0,0 +1,33 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Add message pointed by MSG_PTR to message queue MQDES, stop blocking
+   on full message queue if ABS_TIMEOUT expires.  */
+int
+mq_timedsend (mqd_t mqdes, const char *msg_ptr, size_t msg_len,
+	      unsigned int msg_prio, const struct timespec *abs_timeout)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+hidden_def (mq_timedsend)
+stub_warning (mq_timedsend)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/mq_unlink.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_unlink.c
--- sysdeps/generic/mq_unlink.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/mq_unlink.c	2004-04-13 04:11:13.000000000 +0200
@@ -0,0 +1,30 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+
+/* Remove message queue named NAME.  */
+int
+mq_unlink (const char *name)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (mq_unlink)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/nanosleep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/nanosleep.c
--- sysdeps/generic/nanosleep.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/nanosleep.c	2002-12-31 11:22:40.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,5 +31,6 @@
 stub_warning (nanosleep)
 
 weak_alias (__libc_nanosleep, __nanosleep)
+libc_hidden_def (__nanosleep)
 weak_alias (__libc_nanosleep, nanosleep)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/not-cancel.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/not-cancel.h
--- sysdeps/generic/not-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/not-cancel.h	2003-09-04 16:05:35.000000000 +0200
@@ -0,0 +1,39 @@
+/* Uncancelable versions of cancelable interfaces.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* By default we have none.  Map the name to the normal functions.  */
+#define open_not_cancel(name, flags, mode) \
+  __libc_open (name, flags, mode)
+#define open_not_cancel_2(name, flags) \
+  __libc_open (name, flags)
+#define close_not_cancel(fd) \
+  __close (fd)
+#define close_not_cancel_no_status(fd) \
+  (void) __close (fd)
+#define read_not_cancel(fd, buf, n) \
+  __read (fd, buf, n)
+#define write_not_cancel(fd, buf, n) \
+  __write (fd, buf, n)
+#define writev_not_cancel_no_status(fd, iov, n) \
+  (void) __writev (fd, iov, n)
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl (fd, cmd, val)
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  __waitpid (pid, stat_loc, options)
diff -Nur sysdeps/generic/nscd_setup_thread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/nscd_setup_thread.c
--- sysdeps/generic/nscd_setup_thread.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/nscd_setup_thread.c	2004-09-08 19:51:49.000000000 +0200
@@ -0,0 +1,28 @@
+/* Setup of nscd worker threads.  Stub verison.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <nscd.h>
+
+
+void
+setup_thread (struct database_dyn *db)
+{
+  /* Nothing.  */
+}
diff -Nur sysdeps/generic/posix_fadvise64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fadvise64.c
--- sysdeps/generic/posix_fadvise64.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fadvise64.c	2003-08-16 18:12:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,10 +23,9 @@
    respect to the file associated with FD.  */
 
 int
-posix_fadvise64 (int fd, __off64_t offset, size_t len, int advise)
+posix_fadvise64 (int fd, __off64_t offset, __off64_t len, int advise)
 {
-  __set_errno (ENOSYS);
-  return -1;
+  return ENOSYS;
 }
 stub_warning (posix_fadvise64)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/posix_fadvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fadvise.c
--- sysdeps/generic/posix_fadvise.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fadvise.c	2003-08-16 18:12:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,10 +23,9 @@
    respect to the file associated with FD.  */
 
 int
-posix_fadvise (int fd, __off_t offset, size_t len, int advise)
+posix_fadvise (int fd, __off_t offset, __off_t len, int advise)
 {
-  __set_errno (ENOSYS);
-  return -1;
+  return ENOSYS;
 }
 stub_warning (posix_fadvise)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/posix_fallocate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fallocate64.c
--- sysdeps/generic/posix_fallocate64.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fallocate64.c	2003-08-22 20:08:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,7 +22,7 @@
 /* Reserve storage for the data of the file associated with FD.  */
 
 int
-posix_fallocate64 (int fd, __off64_t offset, size_t len)
+posix_fallocate64 (int fd, __off64_t offset, __off64_t len)
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/posix_fallocate.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fallocate.c
--- sysdeps/generic/posix_fallocate.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_fallocate.c	2003-08-22 20:08:29.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,7 +22,7 @@
 /* Reserve storage for the data of the file associated with FD.  */
 
 int
-posix_fallocate (int fd, __off_t offset, size_t len)
+posix_fallocate (int fd, __off_t offset, __off_t len)
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/posix_madvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_madvise.c
--- sysdeps/generic/posix_madvise.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/posix_madvise.c	2003-08-16 08:12:22.000000000 +0200
@@ -0,0 +1,32 @@
+/* Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <errno.h>
+
+/* Advise the system about particular usage patterns the program follows
+   for the region starting at ADDR and extending LEN bytes.  */
+
+int
+posix_madvise (__ptr_t addr, size_t len, int advice)
+{
+  return ENOSYS;
+}
+stub_warning (posix_madvise)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/printf_fphex.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/printf_fphex.c
--- sysdeps/generic/printf_fphex.c	2002-09-10 02:37:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/printf_fphex.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,5 +1,5 @@
 /* Print floating point number in hexadecimal notation according to ISO C99.
-   Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1997-2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -49,7 +49,7 @@
 #else	/* ! USE_IN_LIBIO */
 # define PUT(f, s, n) fwrite (s, 1, n, f)
 # define PAD(f, c, n) __printf_pad (f, c, n)
-ssize_t __printf_pad __P ((FILE *, char pad, int n)); /* In vfprintf.c.  */
+ssize_t __printf_pad (FILE *, char pad, int n) __THROW; /* In vfprintf.c.  */
 #endif	/* USE_IN_LIBIO */
 
 /* Macros for doing the actual output.  */
@@ -338,8 +338,8 @@
   /* Look for trailing zeroes.  */
   if (! zero_mantissa)
     {
-      wnumend = wnumbuf + sizeof wnumbuf;
-      numend = numbuf + sizeof numbuf;
+      wnumend = &wnumbuf[sizeof wnumbuf / sizeof wnumbuf[0]];
+      numend = &numbuf[sizeof numbuf / sizeof numbuf[0]];
       while (wnumend[-1] == L'0')
 	{
 	  --wnumend;
@@ -433,17 +433,13 @@
 	    + ((expbuf + sizeof expbuf) - expstr));
 	    /* Exponent.  */
 
-  /* Count the decimal point.  */
+  /* Count the decimal point.
+     A special case when the mantissa or the precision is zero and the `#'
+     is not given.  In this case we must not print the decimal point.  */
   if (precision > 0 || info->alt)
     width -= wide ? 1 : strlen (decimal);
 
-  /* A special case when the mantissa or the precision is zero and the `#'
-     is not given.  In this case we must not print the decimal point.  */
-  if (precision == 0 && !info->alt)
-    ++width;		/* This nihilates the +1 for the decimal-point
-			   character in the following equation.  */
-
-  if (!info->left && width > 0)
+  if (!info->left && info->pad != '0' && width > 0)
     PADN (' ', width);
 
   if (negative)
@@ -458,6 +454,10 @@
     outchar (info->spec + ('x' - 'a'));
   else
     outchar (info->spec == 'A' ? 'X' : 'x');
+
+  if (!info->left && info->pad == '0' && width > 0)
+    PADN ('0', width);
+
   outchar (leading);
 
   if (precision > 0 || info->alt)
@@ -474,9 +474,6 @@
 	PADN ('0', tofill);
     }
 
-  if (info->left && info->pad == '0' && width > 0)
-    PADN ('0', width);
-
   if ('P' - 'A' == 'p' - 'a')
     outchar (info->spec + ('p' - 'a'));
   else
diff -Nur sysdeps/generic/pselect.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/pselect.c
--- sysdeps/generic/pselect.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/pselect.c	2003-06-15 23:11:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1998, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1996,1997,1998,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -22,6 +22,7 @@
 #include <stddef.h>	/* For NULL.  */
 #include <sys/time.h>
 #include <sys/select.h>
+#include <sysdep-cancel.h>
 
 /* Check the first NFDS descriptors each in READFDS (if not NULL) for read
    readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
@@ -29,20 +30,15 @@
    after waiting the interval specified therein.  Additionally set the sigmask
    SIGMASK for this call.  Returns the number of ready descriptors, or -1 for
    errors.  */
-int
-__pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask)
-     int nfds;
-     fd_set *readfds;
-     fd_set *writefds;
-     fd_set *exceptfds;
-     const struct timespec *timeout;
-     const sigset_t *sigmask;
+static int
+do_pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	    const struct timespec *timeout, const sigset_t *sigmask)
 {
   struct timeval tval;
   int retval;
   sigset_t savemask;
 
-  /* Change nanosecond number to microseconds.  This may loose
+  /* Change nanosecond number to microseconds.  This might mean losing
      precision and therefore the `pselect` should be available.  But
      for now it is hardly found.  */
   if (timeout != NULL)
@@ -51,11 +47,42 @@
   /* The setting and restoring of the signal mask and the select call
      should be an atomic operation.  This can't be done without kernel
      help.  */
-  __sigprocmask (SIG_SETMASK, sigmask, &savemask);
+  if (sigmask != NULL)
+    __sigprocmask (SIG_SETMASK, sigmask, &savemask);
+
+  /* Note the pselect() is a cancellation point.  But since we call
+     select() which itself is a cancellation point we do not have
+     to do anything here.  */
   retval = __select (nfds, readfds, writefds, exceptfds,
 		     timeout != NULL ? &tval : NULL);
-  __sigprocmask (SIG_SETMASK, &savemask, NULL);
+
+  if (sigmask != NULL)
+    __sigprocmask (SIG_SETMASK, &savemask, NULL);
 
   return retval;
 }
+
+
+int
+__pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask)
+     int nfds;
+     fd_set *readfds;
+     fd_set *writefds;
+     fd_set *exceptfds;
+     const struct timespec *timeout;
+     const sigset_t *sigmask;
+{
+  if (SINGLE_THREAD_P)
+    return do_pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_pselect (nfds, readfds, writefds, exceptfds, timeout,
+			   sigmask);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
 weak_alias (__pselect, pselect)
+strong_alias (__pselect, __libc_pselect)
diff -Nur sysdeps/generic/readelflib.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readelflib.c
--- sysdeps/generic/readelflib.c	2002-08-30 09:05:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readelflib.c	2002-12-28 21:40:31.000000000 +0100
@@ -100,7 +100,7 @@
       switch (segment->p_type)
 	{
 	case PT_LOAD:
-	  if (loadaddr == -1)
+	  if (loadaddr == (ElfW(Addr)) -1)
 	    loadaddr = segment->p_vaddr - segment->p_offset;
 	  break;
 
@@ -145,7 +145,7 @@
 	}
 
     }
-  if (loadaddr == -1)
+  if (loadaddr == (ElfW(Addr)) -1)
     {
       /* Very strange. */
       loadaddr = 0;
diff -Nur sysdeps/generic/readonly-area.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readonly-area.c
--- sysdeps/generic/readonly-area.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readonly-area.c	2004-10-19 23:44:30.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+
+/* Return 1 if the whole area PTR .. PTR+SIZE is not writable.
+   Return -1 if it is writable.  */
+
+int
+__readonly_area (const void *ptr, size_t size)
+{
+  /* We cannot determine in general whether memory is writable or not.
+     This must be handled in a system-dependent manner.  to not
+     unconditionally break code we need to return here a positive
+     answer.  This disables this security measure but that is the
+     price people have to pay for using systems without a real
+     implementation of this interface.  */
+  return 1;
+}
diff -Nur sysdeps/generic/readv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readv.c
--- sysdeps/generic/readv.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/readv.c	2002-10-09 11:25:28.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1997,1998,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,7 +26,7 @@
    Operates just like `read' (see <unistd.h>) except that data are
    put in VECTOR instead of a contiguous buffer.  */
 ssize_t
-__readv (fd, vector, count)
+__libc_readv (fd, vector, count)
      int fd;
      const struct iovec *vector;
      int count;
@@ -34,7 +34,8 @@
   __set_errno (ENOSYS);
   return -1;
 }
-weak_alias (__readv, readv)
+strong_alias (__libc_readv, __readv)
+weak_alias (__libc_readv, readv)
 
 stub_warning (readv)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/remap_file_pages.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/remap_file_pages.c
--- sysdeps/generic/remap_file_pages.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/remap_file_pages.c	2003-03-03 10:44:55.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mman.h>
+#include <errno.h>
+
+/* Remap arbitrary pages of a shared backing store within an existing
+   VMA.  */
+
+int
+__remap_file_pages (void *start, size_t size, int prot, size_t pgoff,
+		    int flags)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+stub_warning (remap_file_pages)
+#include <stub-tag.h>
+weak_alias (__remap_file_pages, remap_file_pages)
diff -Nur sysdeps/generic/res-state.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/res-state.c
--- sysdeps/generic/res-state.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/res-state.c	2003-07-23 01:09:28.000000000 +0200
@@ -0,0 +1,45 @@
+/* Copyright (C) 1996, 97, 98, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <resolv.h>
+#include <tls.h>
+
+#if ! USE___THREAD
+
+# undef _res
+extern struct __res_state _res;
+
+/* When threaded, _res may be a per-thread variable.  */
+struct __res_state *
+weak_const_function
+__res_state (void)
+{
+  return &_res;
+}
+
+#else
+
+struct __res_state *
+__res_state (void)
+{
+  return __resp;
+}
+
+#endif
+
+libc_hidden_def (__res_state)
diff -Nur sysdeps/generic/s_cacosf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cacosf.c
--- sysdeps/generic/s_cacosf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cacosf.c	2004-01-13 10:08:04.000000000 +0100
@@ -34,4 +34,6 @@
 
   return res;
 }
+#ifndef __cacosf
 weak_alias (__cacosf, cacosf)
+#endif
diff -Nur sysdeps/generic/s_cacoshf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cacoshf.c
--- sysdeps/generic/s_cacoshf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cacoshf.c	2004-01-13 10:08:04.000000000 +0100
@@ -96,4 +96,6 @@
 
   return res;
 }
+#ifndef __cacoshf
 weak_alias (__cacoshf, cacoshf)
+#endif
diff -Nur sysdeps/generic/s_casinf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_casinf.c
--- sysdeps/generic/s_casinf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_casinf.c	2004-01-13 10:08:04.000000000 +0100
@@ -59,4 +59,6 @@
 
   return res;
 }
+#ifndef __casinf
 weak_alias (__casinf, casinf)
+#endif
diff -Nur sysdeps/generic/s_casinhf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_casinhf.c
--- sysdeps/generic/s_casinhf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_casinhf.c	2004-01-13 10:08:04.000000000 +0100
@@ -77,4 +77,6 @@
 
   return res;
 }
+#ifndef __casinhf
 weak_alias (__casinhf, casinhf)
+#endif
diff -Nur sysdeps/generic/s_catanf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_catanf.c
--- sysdeps/generic/s_catanf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_catanf.c	2004-01-13 10:08:04.000000000 +0100
@@ -82,4 +82,6 @@
 
   return res;
 }
+#ifndef __catanf
 weak_alias (__catanf, catanf)
+#endif
diff -Nur sysdeps/generic/s_catanhf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_catanhf.c
--- sysdeps/generic/s_catanhf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_catanhf.c	2004-01-13 10:08:04.000000000 +0100
@@ -77,4 +77,6 @@
 
   return res;
 }
+#ifndef __catanhf
 weak_alias (__catanhf, catanhf)
+#endif
diff -Nur sysdeps/generic/s_ccosf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ccosf.c
--- sysdeps/generic/s_ccosf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ccosf.c	2004-01-13 10:08:04.000000000 +0100
@@ -73,4 +73,6 @@
 
   return res;
 }
+#ifndef __ccosf
 weak_alias (__ccosf, ccosf)
+#endif
diff -Nur sysdeps/generic/s_ccoshf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ccoshf.c
--- sysdeps/generic/s_ccoshf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ccoshf.c	2004-01-13 10:08:04.000000000 +0100
@@ -98,4 +98,6 @@
 
   return retval;
 }
+#ifndef __ccoshf
 weak_alias (__ccoshf, ccoshf)
+#endif
diff -Nur sysdeps/generic/s_cexpf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cexpf.c
--- sysdeps/generic/s_cexpf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cexpf.c	2004-01-13 10:08:04.000000000 +0100
@@ -120,4 +120,6 @@
 
   return retval;
 }
+#ifndef __cexpf
 weak_alias (__cexpf, cexpf)
+#endif
diff -Nur sysdeps/generic/sched_getaffinity.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sched_getaffinity.c
--- sysdeps/generic/sched_getaffinity.c	2002-08-08 09:16:11.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sched_getaffinity.c	2004-03-19 01:12:47.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,16 +17,16 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/types.h>
 #include <sched.h>
+#include <sys/types.h>
 
 
 /* Retrieve the CPU affinity mask for a particular process.  */
 int
-sched_getaffinity (pid, len, mask)
+sched_getaffinity (pid, cpusetsize, cpuset)
      pid_t pid;
-     unsigned long int len;
-     unsigned long int *mask;
+     size_t cpusetsize;
+     cpu_set_t *cpuset;
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/sched_setaffinity.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sched_setaffinity.c
--- sysdeps/generic/sched_setaffinity.c	2002-08-08 09:16:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sched_setaffinity.c	2004-03-19 01:12:47.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,10 +23,10 @@
 
 /* Retrieve the CPU affinity mask for a particular process.  */
 int
-sched_setaffinity (pid, len, mask)
+sched_setaffinity (pid, cpusetsize, cpuset)
      pid_t pid;
-     unsigned long int len;
-     unsigned long int *mask;
+     size_t cpusetsize;
+     const cpu_set_t *cpuset;
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/s_clog10f.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_clog10f.c
--- sysdeps/generic/s_clog10f.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_clog10f.c	2004-01-13 10:08:04.000000000 +0100
@@ -58,4 +58,6 @@
 
   return result;
 }
+#ifndef __clog10f
 weak_alias (__clog10f, clog10f)
+#endif
diff -Nur sysdeps/generic/s_clogf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_clogf.c
--- sysdeps/generic/s_clogf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_clogf.c	2004-01-13 10:08:04.000000000 +0100
@@ -58,4 +58,6 @@
 
   return result;
 }
+#ifndef __clogf
 weak_alias (__clogf, clogf)
+#endif
diff -Nur sysdeps/generic/s_cpowf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cpowf.c
--- sysdeps/generic/s_cpowf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cpowf.c	2004-01-13 10:08:04.000000000 +0100
@@ -27,4 +27,6 @@
 {
   return __cexpf (c * __clogf (x));
 }
+#ifndef __cpowf
 weak_alias (__cpowf, cpowf)
+#endif
diff -Nur sysdeps/generic/s_cprojf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cprojf.c
--- sysdeps/generic/s_cprojf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_cprojf.c	2004-01-13 10:08:04.000000000 +0100
@@ -44,4 +44,6 @@
 
   return res;
 }
+#ifndef __cprojf
 weak_alias (__cprojf, cprojf)
+#endif
diff -Nur sysdeps/generic/s_csinf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csinf.c
--- sysdeps/generic/s_csinf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csinf.c	2004-01-13 10:08:04.000000000 +0100
@@ -124,4 +124,6 @@
 
   return retval;
 }
+#ifndef __csinf
 weak_alias (__csinf, csinf)
+#endif
diff -Nur sysdeps/generic/s_csinhf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csinhf.c
--- sysdeps/generic/s_csinhf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csinhf.c	2004-01-13 10:08:04.000000000 +0100
@@ -119,4 +119,6 @@
 
   return retval;
 }
+#ifndef __csinhf
 weak_alias (__csinhf, csinhf)
+#endif
diff -Nur sysdeps/generic/s_csqrtf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csqrtf.c
--- sysdeps/generic/s_csqrtf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_csqrtf.c	2004-01-13 10:08:04.000000000 +0100
@@ -107,4 +107,6 @@
 
   return res;
 }
+#ifndef __csqrtf
 weak_alias (__csqrtf, csqrtf)
+#endif
diff -Nur sysdeps/generic/s_ctanf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ctanf.c
--- sysdeps/generic/s_ctanf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ctanf.c	2004-01-13 10:08:04.000000000 +0100
@@ -67,4 +67,6 @@
 
   return res;
 }
+#ifndef __ctanf
 weak_alias (__ctanf, ctanf)
+#endif
diff -Nur sysdeps/generic/s_ctanhf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ctanhf.c
--- sysdeps/generic/s_ctanhf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_ctanhf.c	2004-01-13 10:08:04.000000000 +0100
@@ -67,4 +67,6 @@
 
   return res;
 }
+#ifndef __ctanhf
 weak_alias (__ctanhf, ctanhf)
+#endif
diff -Nur sysdeps/generic/segfault.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/segfault.c
--- sysdeps/generic/segfault.c	2001-07-12 20:27:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/segfault.c	2004-10-14 04:22:13.000000000 +0200
@@ -1,5 +1,6 @@
 /* Catch segmentation faults and print backtrace.
-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -18,22 +19,22 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <alloca.h>
 #include <ctype.h>
 #include <errno.h>
 #include <execinfo.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <stdio-common/_itoa.h>
+#include <ldsodefs.h>
 
 #include <bp-checks.h>
 
-/* Get the definition of "struct layout".  */
-#include <frame.h>
-
 /* This file defines macros to access the content of the sigcontext element
    passed up by the signal handler.  */
 #include <sigcontextinfo.h>
@@ -41,40 +42,6 @@
 /* Get code to possibly dump the content of all registers.  */
 #include <register-dump.h>
 
-/* This is a global variable set at program start time.  It marks the
-   highest used stack address.  */
-extern void *__libc_stack_end;
-
-
-/* This implementation assumes a stack layout that matches the defaults
-   used by gcc's `__builtin_frame_address' and `__builtin_return_address'
-   (FP is the frame pointer register):
-
-	  +-----------------+     +-----------------+
-    FP -> | previous FP --------> | previous FP ------>...
-	  |                 |     |                 |
-	  | return address  |     | return address  |
-	  +-----------------+     +-----------------+
-
-  */
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#ifndef CURRENT_STACK_FRAME
-# define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })
-#endif
-
-/* By default we assume that the stack grows downward.  */
-#ifndef INNER_THAN
-# define INNER_THAN <
-#endif
-
-/* By default assume the `next' pointer in struct layout points to the
-   next struct layout.  */
-#ifndef ADVANCE_STACK_FRAME
-# define ADVANCE_STACK_FRAME(next) BOUNDED_1 ((struct layout *) (next))
-#endif
-
 /* We'll use tis a lot.  */
 #define WRITE_STRING(s) write (fd, s, strlen (s))
 
@@ -105,13 +72,10 @@
 static void
 catch_segfault (int signal, SIGCONTEXT ctx)
 {
-  struct layout *current;
-  void *__unbounded top_frame;
-  void *__unbounded top_stack;
-  int fd;
+  int fd, cnt, i;
   void **arr;
-  size_t cnt;
   struct sigaction sa;
+  uintptr_t pc;
 
   /* This is the name of the file we are writing to.  If none is given
      or we cannot write to this file write to stderr.  */
@@ -133,41 +97,43 @@
 
   WRITE_STRING ("\nBacktrace:\n");
 
-  top_frame = GET_FRAME (ctx);
-  top_stack = GET_STACK (ctx);
-
-  /* First count how many entries we'll have.  */
-  cnt = 1;
-  current = BOUNDED_1 ((struct layout *) top_frame);
-  while (!((void *) current INNER_THAN top_stack
-	   || !((void *) current INNER_THAN __libc_stack_end)))
-    {
-      ++cnt;
+  /* Get the backtrace.  */
+  arr = alloca (256 * sizeof (void *));
+  cnt = backtrace (arr, 256);
+
+  /* Now try to locate the PC from signal context in the backtrace.
+     Normally it will be found at arr[2], but it might appear later
+     if there were some signal handler wrappers.  Allow a few bytes
+     difference to cope with as many arches as possible.  */
+  pc = (uintptr_t) GET_PC (ctx);
+  for (i = 0; i < cnt; ++i)
+    if ((uintptr_t) arr[i] >= pc - 16 && (uintptr_t) arr[i] <= pc + 16)
+      break;
+
+  /* If we haven't found it, better dump full backtrace even including
+     the signal handler frames instead of not dumping anything.  */
+  if (i == cnt)
+    i = 0;
 
-      current = ADVANCE_STACK_FRAME (current->next);
-    }
-
-  arr = alloca (cnt * sizeof (void *));
-
-  /* First handle the program counter from the structure.  */
-  arr[0] = GET_PC (ctx);
+  /* Now generate nicely formatted output.  */
+  __backtrace_symbols_fd (arr + i, cnt - i, fd);
 
-  current = BOUNDED_1 ((struct layout *) top_frame);
-  cnt = 1;
-  while (!((void *) current INNER_THAN top_stack
-	   || !((void *) current INNER_THAN __libc_stack_end)))
+#ifdef HAVE_PROC_SELF
+  /* Now the link map.  */
+  int mapfd = open ("/proc/self/maps", O_RDONLY);
+  if (mapfd != -1)
     {
-      arr[cnt++] = current->return_address;
+      write (fd, "\nMemory map:\n\n", 14);
 
-      current = ADVANCE_STACK_FRAME (current->next);
-    }
+      char buf[256];
+      ssize_t n;
 
-  /* If the last return address was NULL, assume that it doesn't count.  */
-  if (arr[cnt-1] == NULL)
-    cnt--;
+      while ((n = TEMP_FAILURE_RETRY (read (mapfd, buf, sizeof (buf)))) > 0)
+	TEMP_FAILURE_RETRY (write (fd, buf, n));
 
-  /* Now generate nicely formatted output.  */
-  __backtrace_symbols_fd (arr, cnt, fd);
+      close (mapfd);
+    }
+#endif
 
   /* Pass on the signal (so that a core file is produced).  */
   sa.sa_handler = SIG_DFL;
diff -Nur sysdeps/generic/semtimedop.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/semtimedop.c
--- sysdeps/generic/semtimedop.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/semtimedop.c	2003-04-03 01:44:57.000000000 +0200
@@ -0,0 +1,37 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sem.h>
+#include <errno.h>
+
+/* Perform user-defined atomical operation of array of semaphores.  */
+
+int
+semtimedop (semid, sops, nsops, timeout)
+     int semid;
+     struct sembuf *sops;
+     size_t nsops;
+     const struct timespec *timeout;
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+stub_warning (semtimedop)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/setenv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setenv.c
--- sysdeps/generic/setenv.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setenv.c	2004-06-09 20:33:30.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1992,1995-2001,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -134,12 +134,9 @@
 	  ++size;
     }
 
-  if (ep == NULL || *ep == NULL)
+  if (ep == NULL || __builtin_expect (*ep == NULL, 1))
     {
       char **new_environ;
-#ifdef USE_TSEARCH
-      char *new_value;
-#endif
 
       /* We allocated this space; we can extend it.  */
       new_environ = (char **) realloc (last_environ,
@@ -159,7 +156,11 @@
 	{
 	  /* See whether the value is already known.  */
 #ifdef USE_TSEARCH
-	  new_value = (char *) alloca (namelen + 1 + vallen);
+# ifdef __GNUC__
+	  char new_value[namelen + 1 + vallen];
+# else
+	  char *new_value = (char *) alloca (namelen + 1 + vallen);
+# endif
 # ifdef _LIBC
 	  __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), "=", 1),
 		     value, vallen);
@@ -170,11 +171,11 @@
 # endif
 
 	  new_environ[size] = KNOWN_VALUE (new_value);
-	  if (new_environ[size] == NULL)
+	  if (__builtin_expect (new_environ[size] == NULL, 1))
 #endif
 	    {
 	      new_environ[size] = (char *) malloc (namelen + 1 + vallen);
-	      if (new_environ[size] == NULL)
+	      if (__builtin_expect (new_environ[size] == NULL, 0))
 		{
 		  __set_errno (ENOMEM);
 		  UNLOCK;
@@ -213,7 +214,11 @@
       else
 	{
 #ifdef USE_TSEARCH
-	  char *new_value = alloca (namelen + 1 + vallen);
+# ifdef __GNUC__
+	  char new_value[namelen + 1 + vallen];
+# else
+	  char *new_value = (char *) alloca (namelen + 1 + vallen);
+# endif
 # ifdef _LIBC
 	  __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), "=", 1),
 		     value, vallen);
@@ -224,11 +229,11 @@
 # endif
 
 	  np = KNOWN_VALUE (new_value);
-	  if (np == NULL)
+	  if (__builtin_expect (np == NULL, 1))
 #endif
 	    {
 	      np = malloc (namelen + 1 + vallen);
-	      if (np == NULL)
+	      if (__builtin_expect (np == NULL, 0))
 		{
 		  UNLOCK;
 		  return -1;
@@ -260,6 +265,12 @@
      const char *value;
      int replace;
 {
+  if (name == NULL || *name == '\0' || strchr (name, '=') != NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
   return __add_to_environ (name, value, NULL, replace);
 }
 
@@ -323,8 +334,7 @@
   return 0;
 }
 #ifdef _LIBC
-static void
-free_mem (void)
+libc_freeres_fn (free_mem)
 {
   /* Remove all traces.  */
   clearenv ();
@@ -333,8 +343,6 @@
   __tdestroy (known_values, free);
   known_values = NULL;
 }
-text_set_element (__libc_subfreeres, free_mem);
-
 
 # undef setenv
 # undef unsetenv
diff -Nur sysdeps/generic/setipv4sourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setipv4sourcefilter.c
--- sysdeps/generic/setipv4sourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setipv4sourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,33 @@
+/* Set source filter.  Stub version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <netinet/in.h>
+
+
+int
+setipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,
+		     uint32_t fmode, uint32_t numsrc,
+		     const struct in_addr *slist)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (setipv4sourcefilter)
diff -Nur sysdeps/generic/setresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setresgid.c
--- sysdeps/generic/setresgid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setresgid.c	2002-10-14 03:03:00.000000000 +0200
@@ -0,0 +1,35 @@
+/* setresgid -- set effective group ID, real group ID, and saved-set group ID
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+/* Set the effective group ID, real group ID, and saved-set group ID,
+   of the calling process to EGID, RGID, and SGID, respectively.  */
+int
+__setresgid (gid_t egid, gid_t rgid, gid_t sgid)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (__setresgid)
+stub_warning (setresgid)
+
+weak_alias (__setresgid, setresgid)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/setresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setresuid.c
--- sysdeps/generic/setresuid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setresuid.c	2002-10-14 03:03:00.000000000 +0200
@@ -0,0 +1,35 @@
+/* setresuid -- set effective user ID, real user ID, and saved-set user ID
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+/* Set the effective user ID, real user ID, and saved-set user ID,
+   of the calling process to EUID, RUID, and SUID, respectively.  */
+int
+__setresuid (uid_t euid, uid_t ruid, uid_t suid)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (__setresuid)
+stub_warning (setresuid)
+
+weak_alias (__setresuid, setresuid)
+#include <stub-tag.h>
diff -Nur sysdeps/generic/setsourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setsourcefilter.c
--- sysdeps/generic/setsourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/setsourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,33 @@
+/* Set source filter.  Stub version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <netinet/in.h>
+
+
+int
+setsourcefilter (int s, uint32_t interface, const struct sockaddr *group,
+		 socklen_t grouplen, uint32_t fmode, uint32_t numsrc,
+		 const struct sockaddr_storage *slist)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (setsourcefilter)
diff -Nur sysdeps/generic/s_fdim.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdim.c
--- sysdeps/generic/s_fdim.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdim.c	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return positive difference between arguments.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -31,7 +31,7 @@
     /* Raise invalid flag.  */
     return x - y;
 
-  return x < y ? 0 : x - y;
+  return x <= y ? 0 : x - y;
 }
 weak_alias (__fdim, fdim)
 #ifdef NO_LONG_DOUBLE
diff -Nur sysdeps/generic/s_fdimf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdimf.c
--- sysdeps/generic/s_fdimf.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdimf.c	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return positive difference between arguments.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -31,6 +31,6 @@
     /* Raise invalid flag.  */
     return x - y;
 
-  return x < y ? 0 : x - y;
+  return x <= y ? 0 : x - y;
 }
 weak_alias (__fdimf, fdimf)
diff -Nur sysdeps/generic/s_fdiml.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdiml.c
--- sysdeps/generic/s_fdiml.c	2001-07-07 21:21:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_fdiml.c	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return positive difference between arguments.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -31,6 +31,6 @@
     /* Raise invalid flag.  */
     return x - y;
 
-  return x < y ? 0 : x - y;
+  return x <= y ? 0 : x - y;
 }
 weak_alias (__fdiml, fdiml)
diff -Nur sysdeps/generic/sigfillset.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigfillset.c
--- sysdeps/generic/sigfillset.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigfillset.c	2004-09-29 00:32:30.000000000 +0200
@@ -0,0 +1,47 @@
+/* Copyright (C) 1991,96,97,2002,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+/* Set all signals in SET.  */
+int
+sigfillset (set)
+     sigset_t *set;
+{
+  if (set == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  memset (set, 0xff, sizeof (sigset_t));
+
+  /* If the implementation uses a cancellation signal don't set the bit.  */
+#ifdef SIGCANCEL
+  __sigdelset (set, SIGCANCEL);
+#endif
+  /* Likewise for the signal to implement setxid.  */
+#ifdef SIGSETXID
+  __sigdelset (set, SIGSETXID);
+#endif
+
+  return 0;
+}
+libc_hidden_def (sigfillset)
diff -Nur sysdeps/generic/siglist.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/siglist.c
--- sysdeps/generic/siglist.c	2002-08-05 00:09:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/siglist.c	2002-12-16 03:05:08.000000000 +0100
@@ -23,7 +23,7 @@
 
 const char *const _sys_siglist[NSIG] =
 {
-#define init_sig(sig, abbrev, desc)   [sig] desc,
+#define init_sig(sig, abbrev, desc)   [sig] = desc,
 #include <siglist.h>
 #undef init_sig
 };
@@ -32,7 +32,7 @@
 
 const char *const _sys_sigabbrev[NSIG] =
 {
-#define init_sig(sig, abbrev, desc)   [sig] abbrev,
+#define init_sig(sig, abbrev, desc)   [sig] = abbrev,
 #include <siglist.h>
 #undef init_sig
 };
diff -Nur sysdeps/generic/sigpause.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigpause.c
--- sysdeps/generic/sigpause.c	2002-08-04 04:20:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigpause.c	2004-05-10 06:49:36.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,95,96,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1991,95,96,2000,02,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,8 +16,10 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#define sigpause __rename_sigpause
 #include <errno.h>
 #include <signal.h>
+#undef sigpause
 
 int
 __sigpause (sig_or_mask, is_sig)
@@ -31,6 +33,7 @@
 libc_hidden_def (__sigpause)
 
 int
+__attribute__ ((weak))
 __default_sigpause (int mask)
 {
   __set_errno (ENOSYS);
@@ -42,7 +45,8 @@
 
 
 int
-__xpg_sigpause (int sig)
+__attribute ((weak))
+__xpg___sigpause (int sig)
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/sigtimedwait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigtimedwait.c
--- sysdeps/generic/sigtimedwait.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigtimedwait.c	2002-11-25 00:56:42.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of sigtimedwait function from POSIX.1b.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -27,6 +27,7 @@
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (__sigtimedwait)
 weak_alias (__sigtimedwait, sigtimedwait)
 
 stub_warning (sigtimedwait)
diff -Nur sysdeps/generic/sigwaitinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigwaitinfo.c
--- sysdeps/generic/sigwaitinfo.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sigwaitinfo.c	2002-11-25 00:56:42.000000000 +0100
@@ -26,6 +26,7 @@
   __set_errno (ENOSYS);
   return -1;
 }
+libc_hidden_def (__sigwaitinfo)
 weak_alias (__sigwaitinfo, sigwaitinfo)
 
 stub_warning (sigwaitinfo)
diff -Nur sysdeps/generic/s_nextafter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_nextafter.c
--- sysdeps/generic/s_nextafter.c	2001-04-06 10:59:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_nextafter.c	2003-12-07 21:53:42.000000000 +0100
@@ -27,6 +27,7 @@
 
 #include "math.h"
 #include "math_private.h"
+#include <float.h>
 
 #ifdef __STDC__
 	double __nextafter(double x, double y)
@@ -70,7 +71,12 @@
 	    }
 	}
 	hy = hx&0x7ff00000;
-	if(hy>=0x7ff00000) return x+x;	/* overflow  */
+	if(hy>=0x7ff00000) {
+	  x = x+x;	/* overflow  */
+	  if (FLT_EVAL_METHOD != 0 && FLT_EVAL_METHOD != 1)
+	    asm ("" : "=m"(x) : "m"(x));
+	  return x;	/* overflow  */
+	}
 	if(hy<0x00100000) {		/* underflow */
 	    y = x*x;
 	    if(y!=x) {		/* raise underflow flag */
diff -Nur sysdeps/generic/s_nexttowardf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_nexttowardf.c
--- sysdeps/generic/s_nexttowardf.c	2001-06-16 05:30:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/s_nexttowardf.c	2003-12-10 23:52:08.000000000 +0100
@@ -22,6 +22,7 @@
 
 #include "math.h"
 #include "math_private.h"
+#include <float.h>
 
 #ifdef __STDC__
 	float __nexttowardf(float x, long double y)
@@ -65,7 +66,13 @@
 		hx += 1;
 	}
 	hy = hx&0x7f800000;
-	if(hy>=0x7f800000) return x+x;	/* overflow  */
+	if(hy>=0x7f800000) {
+	  x = x+x;	/* overflow  */
+	  if (FLT_EVAL_METHOD != 0)
+	    /* Force conversion to float.  */
+	    asm ("" : "=m"(x) : "m"(x));
+	  return x;
+	}
 	if(hy<0x00800000) {		/* underflow */
 	    float x2 = x*x;
 	    if(x2!=x) {		/* raise underflow flag */
diff -Nur sysdeps/generic/sstk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sstk.c
--- sysdeps/generic/sstk.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sstk.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,7 +21,7 @@
 /* Increase the size of the stack by INCREMENT,
    and return the address of the bottom of the stack.  */
 
-void *sstk __P ((int increment));
+void *sstk (int increment) __THROW;
 
 void *
 sstk (increment)
diff -Nur sysdeps/generic/start.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/start.c
--- sysdeps/generic/start.c	1997-10-13 05:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/start.c	2002-10-11 12:51:23.000000000 +0200
@@ -11,6 +11,3 @@
 #ifdef HAVE_WEAK_SYMBOLS
 weak_alias (__data_start, data_start)
 #endif
-
-volatile int __errno;
-strong_alias (__errno, errno)
diff -Nur sysdeps/generic/stpcpy.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/stpcpy.c
--- sysdeps/generic/stpcpy.c	2002-08-04 01:28:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/stpcpy.c	2004-05-28 08:39:37.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1995, 1997, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -50,3 +50,6 @@
 #ifdef weak_alias
 weak_alias (__stpcpy, stpcpy)
 #endif
+#ifdef libc_hidden_builtin_def
+libc_hidden_builtin_def (stpcpy)
+#endif
diff -Nur sysdeps/generic/stpcpy_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/stpcpy_chk.c
--- sysdeps/generic/stpcpy_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/stpcpy_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,45 @@
+/* Copyright (C) 1992, 1995, 1997, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <string.h>
+
+
+/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+char *
+__stpcpy_chk (dest, src, destlen)
+     char *dest;
+     const char *src;
+     size_t destlen;
+{
+  register char *d = dest;
+  register const char *s = src;
+
+  do
+    {
+      if (__builtin_expect (destlen-- == 0, 0))
+	__chk_fail ();
+      *d++ = *s;
+    }
+  while (*s++ != '\0');
+
+  return d - 1;
+}
diff -Nur sysdeps/generic/strcasecmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcasecmp.c
--- sysdeps/generic/strcasecmp.c	2002-08-02 23:46:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcasecmp.c	2004-03-14 21:13:23.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,1992,1995,1996,1997,2001,2002
+/* Copyright (C) 1991,1992,1995,1996,1997,2001,2002, 2004
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -24,16 +24,15 @@
 #include <ctype.h>
 #include <string.h>
 
-#ifndef weak_alias
+#ifndef _LIBC
 # define __strcasecmp strcasecmp
 # define TOLOWER(Ch) tolower (Ch)
 #else
+# include <locale/localeinfo.h>
 # ifdef USE_IN_EXTENDED_LOCALE_MODEL
 #  define __strcasecmp __strcasecmp_l
-#  define TOLOWER(Ch) __tolower_l ((Ch), loc)
-# else
-#  define TOLOWER(Ch) tolower (Ch)
 # endif
+# define TOLOWER(Ch) __tolower_l ((Ch), loc)
 #endif
 
 #ifdef USE_IN_EXTENDED_LOCALE_MODEL
@@ -53,6 +52,9 @@
      const char *s2;
      LOCALE_PARAM_DECL
 {
+#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL
+  __locale_t loc = _NL_CURRENT_LOCALE;
+#endif
   const unsigned char *p1 = (const unsigned char *) s1;
   const unsigned char *p2 = (const unsigned char *) s2;
   int result;
diff -Nur sysdeps/generic/strcasestr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcasestr.c
--- sysdeps/generic/strcasestr.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcasestr.c	2004-03-25 00:47:46.000000000 +0100
@@ -1,5 +1,5 @@
 /* Return the offset of one string within another.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1996-2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,6 +36,13 @@
 # include <string.h>
 #endif
 
+#ifdef _LIBC
+# include <locale/localeinfo.h>
+# define TOLOWER(c) __tolower_l ((unsigned char) c, loc)
+#else
+# define TOLOWER(c) _tolower (c)
+#endif
+
 typedef unsigned chartype;
 
 #undef strcasestr
@@ -48,11 +55,14 @@
 {
   register const unsigned char *haystack, *needle;
   register chartype b, c;
+#ifdef _LIBC
+  __locale_t loc = _NL_CURRENT_LOCALE;
+#endif
 
   haystack = (const unsigned char *) phaystack;
   needle = (const unsigned char *) pneedle;
 
-  b = _tolower (*needle);
+  b = TOLOWER (*needle);
   if (b != '\0')
     {
       haystack--;				/* possible ANSI violation */
@@ -62,9 +72,9 @@
 	  if (c == '\0')
 	    goto ret0;
 	}
-      while (_tolower (c) != (int) b);
+      while (TOLOWER (c) != (int) b);
 
-      c = _tolower (*++needle);
+      c = TOLOWER (*++needle);
       if (c == '\0')
 	goto foundneedle;
       ++needle;
@@ -80,7 +90,7 @@
 	      a = *++haystack;
 	      if (a == '\0')
 		goto ret0;
-	      if (_tolower (a) == (int) b)
+	      if (TOLOWER (a) == (int) b)
 		break;
 	      a = *++haystack;
 	      if (a == '\0')
@@ -88,34 +98,34 @@
 shloop:
 	      ;
 	    }
-          while (_tolower (a) != (int) b);
+          while (TOLOWER (a) != (int) b);
 
 jin:	  a = *++haystack;
 	  if (a == '\0')
 	    goto ret0;
 
-	  if (_tolower (a) != (int) c)
+	  if (TOLOWER (a) != (int) c)
 	    goto shloop;
 
 	  rhaystack = haystack-- + 1;
 	  rneedle = needle;
-	  a = _tolower (*rneedle);
+	  a = TOLOWER (*rneedle);
 
-	  if (_tolower (*rhaystack) == (int) a)
+	  if (TOLOWER (*rhaystack) == (int) a)
 	    do
 	      {
 		if (a == '\0')
 		  goto foundneedle;
 		++rhaystack;
-		a = _tolower (*++needle);
-		if (_tolower (*rhaystack) != (int) a)
+		a = TOLOWER (*++needle);
+		if (TOLOWER (*rhaystack) != (int) a)
 		  break;
 		if (a == '\0')
 		  goto foundneedle;
 		++rhaystack;
-		a = _tolower (*++needle);
+		a = TOLOWER (*++needle);
 	      }
-	    while (_tolower (*rhaystack) == (int) a);
+	    while (TOLOWER (*rhaystack) == (int) a);
 
 	  needle = rneedle;		/* took the register-poor approach */
 
diff -Nur sysdeps/generic/strcat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcat.c
--- sysdeps/generic/strcat.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcat.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -49,3 +49,4 @@
 
   return dest;
 }
+libc_hidden_builtin_def (strcat)
diff -Nur sysdeps/generic/strcat_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcat_chk.c
--- sysdeps/generic/strcat_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcat_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,58 @@
+/* Copyright (C) 1991, 1997, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+
+
+/* Append SRC on the end of DEST.  */
+char *
+__strcat_chk (dest, src, destlen)
+     char *dest;
+     const char *src;
+     size_t destlen;
+{
+  char *s1 = dest;
+  const char *s2 = src;
+  reg_char c;
+
+  /* Find the end of the string.  */
+  do
+    {
+      if (__builtin_expect (destlen-- == 0, 0))
+	__chk_fail ();
+      c = *s1++;
+    }
+  while (c != '\0');
+
+  /* Make S1 point before the next character, so we can increment
+     it while memory is read (wins on pipelined cpus).  */
+  ++destlen;
+  s1 -= 2;
+
+  do
+    {
+      if (__builtin_expect (destlen-- == 0, 0))
+	__chk_fail ();
+      c = *s2++;
+      *++s1 = c;
+    }
+  while (c != '\0');
+
+  return dest;
+}
diff -Nur sysdeps/generic/strchr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strchr.c
--- sysdeps/generic/strchr.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strchr.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,93,94,95,96,97,99,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991,93,94,95,96,97,99,2000,03 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
    with help from Dan Sahlin (dan@sics.se) and
@@ -187,3 +187,4 @@
 #undef index
 weak_alias (strchr, index)
 #endif
+libc_hidden_builtin_def (strchr)
diff -Nur sysdeps/generic/strcmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcmp.c
--- sysdeps/generic/strcmp.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcmp.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -44,3 +44,4 @@
 
   return c1 - c2;
 }
+libc_hidden_builtin_def (strcmp)
diff -Nur sysdeps/generic/strcpy.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcpy.c
--- sysdeps/generic/strcpy.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcpy.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,3 +47,4 @@
 
   return dest;
 }
+libc_hidden_builtin_def (strcpy)
diff -Nur sysdeps/generic/strcpy_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcpy_chk.c
--- sysdeps/generic/strcpy_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcpy_chk.c	2004-10-19 23:21:03.000000000 +0200
@@ -0,0 +1,68 @@
+/* Copyright (C) 1991, 1997, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <string.h>
+#include <memcopy.h>
+
+#undef strcpy
+
+/* Copy SRC to DEST with checking of destination buffer overflow.  */
+char *
+__strcpy_chk (dest, src, destlen)
+     char *dest;
+     const char *src;
+     size_t destlen;
+{
+  reg_char c;
+  char *s = (char *) src;
+  const ptrdiff_t off = dest - s;
+
+  while (__builtin_expect (destlen >= 4, 0))
+    {
+      c = s[0];
+      s[off] = c;
+      if (c == '\0')
+        return dest;
+      c = s[1];
+      s[off + 1] = c;
+      if (c == '\0')
+        return dest;
+      c = s[2];
+      s[off + 2] = c;
+      if (c == '\0')
+        return dest;
+      c = s[3];
+      s[off + 3] = c;
+      if (c == '\0')
+        return dest;
+      destlen -= 4;
+      s += 4;
+    }
+
+  do
+    {
+      if (__builtin_expect (destlen-- == 0, 0))
+        __chk_fail ();
+      c = *s;
+      *(s++ + off) = c;
+    }
+  while (c != '\0');
+
+  return dest;
+}
diff -Nur sysdeps/generic/strcspn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcspn.c
--- sysdeps/generic/strcspn.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strcspn.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1994, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1994, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -48,3 +48,4 @@
 
   return count;
 }
+libc_hidden_builtin_def (strcspn)
diff -Nur sysdeps/generic/string-inlines.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/string-inlines.c
--- sysdeps/generic/string-inlines.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/string-inlines.c	2003-04-30 00:49:00.000000000 +0200
@@ -0,0 +1,35 @@
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  <bits/string.h> and <bits/string2.h> declare some extern inline
+    functions.  These functions are declared additionally here if
+    inlining is not possible.  */
+
+#undef __USE_STRING_INLINES
+#define __USE_STRING_INLINES
+#define _FORCE_INLINES
+#define __STRING_INLINE /* empty */
+#define __NO_INLINE__
+
+#include <string.h>
+#undef index
+#undef rindex
+
+#undef __NO_INLINE__
+#include <bits/string.h>
+#include <bits/string2.h>
diff -Nur sysdeps/generic/strlen.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strlen.c
--- sysdeps/generic/strlen.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strlen.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1993, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1993, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Written by Torbjorn Granlund (tege@sics.se),
    with help from Dan Sahlin (dan@sics.se);
@@ -150,3 +150,4 @@
 	}
     }
 }
+libc_hidden_builtin_def (strlen)
diff -Nur sysdeps/generic/strncase.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncase.c
--- sysdeps/generic/strncase.c	2001-12-06 06:07:58.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncase.c	2004-03-14 21:13:23.000000000 +0100
@@ -1,6 +1,6 @@
 /* Compare at most N characters of two strings without taking care for
    the case.
-   Copyright (C) 1992, 1996, 1997, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1992, 1996, 1997, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,12 +29,11 @@
 # define __strncasecmp strncasecmp
 # define TOLOWER(Ch) tolower (Ch)
 #else
+# include <locale/localeinfo.h>
 # ifdef USE_IN_EXTENDED_LOCALE_MODEL
 #  define __strncasecmp __strncasecmp_l
-#  define TOLOWER(Ch) __tolower_l ((Ch), loc)
-# else
-#  define TOLOWER(Ch) tolower (Ch)
 # endif
+# define TOLOWER(Ch) __tolower_l ((Ch), loc)
 #endif
 
 #ifdef USE_IN_EXTENDED_LOCALE_MODEL
@@ -56,6 +55,9 @@
      size_t n;
      LOCALE_PARAM_DECL
 {
+#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL
+  __locale_t loc = _NL_CURRENT_LOCALE;
+#endif
   const unsigned char *p1 = (const unsigned char *) s1;
   const unsigned char *p2 = (const unsigned char *) s2;
   int result;
diff -Nur sysdeps/generic/strncat_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncat_chk.c
--- sysdeps/generic/strncat_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncat_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,100 @@
+/* Copyright (C) 1991, 1997, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+
+#include <memcopy.h>
+
+
+char *
+__strncat_chk (s1, s2, n, s1len)
+     char *s1;
+     const char *s2;
+     size_t n;
+     size_t s1len;
+{
+  reg_char c;
+  char *s = s1;
+
+  /* Find the end of S1.  */
+  do
+    {
+      if (__builtin_expect (s1len-- == 0, 0))
+	__chk_fail ();
+      c = *s1++;
+    }
+  while (c != '\0');
+
+  /* Make S1 point before next character, so we can increment
+     it while memory is read (wins on pipelined cpus).  */
+  ++s1len;
+  s1 -= 2;
+
+  if (n >= 4)
+    {
+      size_t n4 = n >> 2;
+      do
+	{
+	  if (__builtin_expect (s1len-- == 0, 0))
+	    __chk_fail ();
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    return s;
+	  if (__builtin_expect (s1len-- == 0, 0))
+	    __chk_fail ();
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    return s;
+	  if (__builtin_expect (s1len-- == 0, 0))
+	    __chk_fail ();
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    return s;
+	  if (__builtin_expect (s1len-- == 0, 0))
+	    __chk_fail ();
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    return s;
+	} while (--n4 > 0);
+      n &= 3;
+    }
+
+  while (n > 0)
+    {
+      if (__builtin_expect (s1len-- == 0, 0))
+	__chk_fail ();
+      c = *s2++;
+      *++s1 = c;
+      if (c == '\0')
+	return s;
+      n--;
+    }
+
+  if (c != '\0')
+    {
+      if (__builtin_expect (s1len-- == 0, 0))
+	__chk_fail ();
+      *++s1 = '\0';
+    }
+
+  return s;
+}
diff -Nur sysdeps/generic/strncmp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncmp.c
--- sysdeps/generic/strncmp.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncmp.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -70,3 +70,4 @@
 
   return c1 - c2;
 }
+libc_hidden_builtin_def (strncmp)
diff -Nur sysdeps/generic/strncpy.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncpy.c
--- sysdeps/generic/strncpy.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncpy.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -84,3 +84,4 @@
 
   return s;
 }
+libc_hidden_builtin_def (strncpy)
diff -Nur sysdeps/generic/strncpy_chk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncpy_chk.c
--- sysdeps/generic/strncpy_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strncpy_chk.c	2004-10-18 06:17:12.000000000 +0200
@@ -0,0 +1,89 @@
+/* Copyright (C) 1991, 1997, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <memcopy.h>
+
+
+char *
+__strncpy_chk (s1, s2, n, s1len)
+     char *s1;
+     const char *s2;
+     size_t n;
+     size_t s1len;
+{
+  reg_char c;
+  char *s = s1;
+
+  if (__builtin_expect (s1len < n, 0))
+    __chk_fail ();
+
+  --s1;
+
+  if (n >= 4)
+    {
+      size_t n4 = n >> 2;
+
+      for (;;)
+	{
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    break;
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    break;
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    break;
+	  c = *s2++;
+	  *++s1 = c;
+	  if (c == '\0')
+	    break;
+	  if (--n4 == 0)
+	    goto last_chars;
+	}
+      n = n - (s1 - s) - 1;
+      if (n == 0)
+	return s;
+      goto zero_fill;
+    }
+
+ last_chars:
+  n &= 3;
+  if (n == 0)
+    return s;
+
+  do
+    {
+      c = *s2++;
+      *++s1 = c;
+      if (--n == 0)
+	return s;
+    }
+  while (c != '\0');
+
+ zero_fill:
+  do
+    *++s1 = '\0';
+  while (--n > 0);
+
+  return s;
+}
diff -Nur sysdeps/generic/strpbrk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strpbrk.c
--- sysdeps/generic/strpbrk.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strpbrk.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1994, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1994, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -43,3 +43,4 @@
 
   return NULL;
 }
+libc_hidden_builtin_def (strpbrk)
diff -Nur sysdeps/generic/strrchr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strrchr.c
--- sysdeps/generic/strrchr.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strrchr.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,3 +47,4 @@
 #undef rindex
 weak_alias (strrchr, rindex)
 #endif
+libc_hidden_builtin_def (strrchr)
diff -Nur sysdeps/generic/strsep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strsep.c
--- sysdeps/generic/strsep.c	2002-02-03 03:30:28.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strsep.c	2004-07-10 21:53:36.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 93, 96, 97, 98, 99 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 93, 96, 97, 98, 99, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -67,3 +67,4 @@
 }
 weak_alias (__strsep, strsep)
 strong_alias (__strsep, __strsep_g)
+libc_hidden_def (__strsep_g)
diff -Nur sysdeps/generic/strspn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strspn.c
--- sysdeps/generic/strspn.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strspn.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -44,3 +44,4 @@
 
   return count;
 }
+libc_hidden_builtin_def (strspn)
diff -Nur sysdeps/generic/strstr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strstr.c
--- sysdeps/generic/strstr.c	2001-12-24 10:10:05.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strstr.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return the offset of one string within another.
-   Copyright (C) 1994, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1994,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -120,3 +120,4 @@
 ret0:
   return 0;
 }
+libc_hidden_builtin_def (strstr)
diff -Nur sysdeps/generic/strtok_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtok_r.c
--- sysdeps/generic/strtok_r.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtok_r.c	2004-11-11 23:15:46.000000000 +0100
@@ -1,5 +1,5 @@
 /* Reentrant string tokenizer.  Generic version.
-   Copyright (C) 1991, 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1991,1996-1999,2001,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,11 +17,22 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
 #include <string.h>
 
 #undef strtok_r
 #undef __strtok_r
 
+#ifndef _LIBC
+/* Get specification.  */
+# include "strtok_r.h"
+# define __strtok_r strtok_r
+# define __rawmemchr strchr
+#endif
+
 /* Parse S into tokens separated by characters in DELIM.
    If S is NULL, the saved pointer in SAVE_PTR is used as
    the next starting point.  For example:
@@ -33,10 +44,7 @@
 		// s = "abc\0-def\0"
 */
 char *
-__strtok_r (s, delim, save_ptr)
-     char *s;
-     const char *delim;
-     char **save_ptr;
+__strtok_r (char *s, const char *delim, char **save_ptr)
 {
   char *token;
 
@@ -65,4 +73,7 @@
     }
   return token;
 }
+#ifdef weak_alias
+libc_hidden_def (__strtok_r)
 weak_alias (__strtok_r, strtok_r)
+#endif
diff -Nur sysdeps/generic/strtol.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtol.c
--- sysdeps/generic/strtol.c	2002-08-28 12:14:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtol.c	2004-03-14 21:54:14.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representation of a number into an integer value.
-   Copyright (C) 1991,92,94,95,96,97,98,99,2000,01,02
+   Copyright (C) 1991,92,94,95,96,97,98,99,2000,2001,2002,2003,2004
    	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -18,46 +18,10 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#ifdef _LIBC
-# define USE_NUMBER_GROUPING
-# define STDC_HEADERS
-# define HAVE_LIMITS_H
-#endif
-
-#include <ctype.h>
-#include <errno.h>
-#ifndef errno
-extern int errno;
-#endif
-#ifndef __set_errno
-# define __set_errno(Val) errno = (Val)
-#endif
-
-#ifdef HAVE_LIMITS_H
-# include <limits.h>
-#endif
-
-#ifdef STDC_HEADERS
-# include <stddef.h>
-# include <stdlib.h>
-# include <string.h>
-# include <locale.h>
-#else
-# ifndef NULL
-#  define NULL 0
-# endif
-#endif
-
-#ifdef USE_NUMBER_GROUPING
-# include "../locale/localeinfo.h"
-#endif
+#include <stdlib.h>
+#include <wchar.h>
+#include <locale/localeinfo.h>
 
-/* Nonzero if we are defining `strtoul' or `strtoull', operating on
-   unsigned integers.  */
 #ifndef UNSIGNED
 # define UNSIGNED 0
 # define INT LONG int
@@ -65,504 +29,83 @@
 # define INT unsigned LONG int
 #endif
 
-/* Determine the name.  */
-#ifdef USE_IN_EXTENDED_LOCALE_MODEL
-# if UNSIGNED
-#  ifdef USE_WIDE_CHAR
-#   ifdef QUAD
-#    define strtol __wcstoull_l
-#   else
-#    define strtol __wcstoul_l
-#   endif
+#if UNSIGNED
+# ifdef USE_WIDE_CHAR
+#  ifdef QUAD
+#   define strtol wcstoull
+#   define __strtol_l __wcstoull_l
 #  else
-#   ifdef QUAD
-#    define strtol __strtoull_l
-#   else
-#    define strtol __strtoul_l
-#   endif
+#   define strtol wcstoul
+#   define __strtol_l __wcstoul_l
 #  endif
 # else
-#  ifdef USE_WIDE_CHAR
-#   ifdef QUAD
-#    define strtol __wcstoll_l
-#   else
-#    define strtol __wcstol_l
-#   endif
+#  ifdef QUAD
+#   define strtol strtoull
+#   define __strtol_l __strtoull_l
 #  else
-#   ifdef QUAD
-#    define strtol __strtoll_l
-#   else
-#    define strtol __strtol_l
-#   endif
+#   define strtol strtoul
+#   define __strtol_l __strtoul_l
 #  endif
 # endif
 #else
-# if UNSIGNED
-#  ifdef USE_WIDE_CHAR
-#   ifdef QUAD
-#    define strtol wcstoull
-#   else
-#    define strtol wcstoul
-#   endif
+# ifdef USE_WIDE_CHAR
+#  ifdef QUAD
+#   define strtol wcstoll
+#   define __strtol_l __wcstoll_l
 #  else
-#   ifdef QUAD
-#    define strtol strtoull
-#   else
-#    define strtol strtoul
-#   endif
+#   define strtol wcstol
+#   define __strtol_l __wcstol_l
 #  endif
 # else
-#  ifdef USE_WIDE_CHAR
-#   ifdef QUAD
-#    define strtol wcstoll
-#   else
-#    define strtol wcstol
-#   endif
-#  else
-#   ifdef QUAD
-#    define strtol strtoll
-#   endif
+#  ifdef QUAD
+#   define strtol strtoll
+#   define __strtol_l __strtoll_l
 #  endif
 # endif
 #endif
 
+
 /* If QUAD is defined, we are defining `strtoll' or `strtoull',
    operating on `long long int's.  */
 #ifdef QUAD
 # define LONG long long
-# define STRTOL_LONG_MIN LONG_LONG_MIN
-# define STRTOL_LONG_MAX LONG_LONG_MAX
-# define STRTOL_ULONG_MAX ULONG_LONG_MAX
-# if __GNUC__ == 2 && __GNUC_MINOR__ < 7
-   /* Work around gcc bug with using this constant.  */
-   static const unsigned long long int maxquad = ULONG_LONG_MAX;
-#  undef STRTOL_ULONG_MAX
-#  define STRTOL_ULONG_MAX maxquad
-# endif
 #else
 # define LONG long
-
-# ifndef ULONG_MAX
-#  define ULONG_MAX ((unsigned long) ~(unsigned long) 0)
-# endif
-# ifndef LONG_MAX
-#  define LONG_MAX ((long int) (ULONG_MAX >> 1))
-# endif
-# define STRTOL_LONG_MIN LONG_MIN
-# define STRTOL_LONG_MAX LONG_MAX
-# define STRTOL_ULONG_MAX ULONG_MAX
-#endif
-
-
-/* We use this code also for the extended locale handling where the
-   function gets as an additional argument the locale which has to be
-   used.  To access the values we have to redefine the _NL_CURRENT
-   macro.  */
-#ifdef USE_IN_EXTENDED_LOCALE_MODEL
-# undef _NL_CURRENT
-# define _NL_CURRENT(category, item) \
-  (current->values[_NL_ITEM_INDEX (item)].string)
-# define LOCALE_PARAM , loc
-# define LOCALE_PARAM_DECL __locale_t loc;
-#else
-# define LOCALE_PARAM
-# define LOCALE_PARAM_DECL
 #endif
 
-#if defined _LIBC || defined HAVE_WCHAR_H
-# include <wchar.h>
-#endif
 
 #ifdef USE_WIDE_CHAR
-# include <wctype.h>
-# define L_(Ch) L##Ch
-# define UCHAR_TYPE wint_t
 # define STRING_TYPE wchar_t
-# ifdef USE_IN_EXTENDED_LOCALE_MODEL
-#  define ISSPACE(Ch) __iswspace_l ((Ch), loc)
-#  define ISALPHA(Ch) __iswalpha_l ((Ch), loc)
-#  define TOUPPER(Ch) __towupper_l ((Ch), loc)
-# else
-#  define ISSPACE(Ch) iswspace (Ch)
-#  define ISALPHA(Ch) iswalpha (Ch)
-#  define TOUPPER(Ch) towupper (Ch)
-# endif
-# else
-#  if defined _LIBC \
-   || defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
-#   define IN_CTYPE_DOMAIN(c) 1
-#  else
-#   define IN_CTYPE_DOMAIN(c) isascii(c)
-#  endif
-#  define L_(Ch) Ch
-#  define UCHAR_TYPE unsigned char
-#  define STRING_TYPE char
-# ifdef USE_IN_EXTENDED_LOCALE_MODEL
-#  define ISSPACE(Ch) __isspace_l ((Ch), loc)
-#  define ISALPHA(Ch) __isalpha_l ((Ch), loc)
-#  define TOUPPER(Ch) __toupper_l ((Ch), loc)
-# else
-#  define ISSPACE(Ch) (IN_CTYPE_DOMAIN (Ch) && isspace (Ch))
-#  define ISALPHA(Ch) (IN_CTYPE_DOMAIN (Ch) && isalpha (Ch))
-#  define TOUPPER(Ch) (IN_CTYPE_DOMAIN (Ch) ? toupper (Ch) : (Ch))
-# endif
-#endif
-
-#ifdef __STDC__
-# define INTERNAL(X) INTERNAL1(X)
-# define INTERNAL1(X) __##X##_internal
-# define WEAKNAME(X) WEAKNAME1(X)
 #else
-# define INTERNAL(X) __/**/X/**/_internal
+# define STRING_TYPE char
 #endif
 
-#ifdef USE_NUMBER_GROUPING
-/* This file defines a function to check for correct grouping.  */
-# include "grouping.h"
-#endif
 
+#define INTERNAL(X) INTERNAL1(X)
+#define INTERNAL1(X) __##X##_internal
 
 
-/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.
-   If BASE is 0 the base is determined by the presence of a leading
-   zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
-   If BASE is < 2 or > 36, it is reset to 10.
-   If ENDPTR is not NULL, a pointer to the character after the last
-   one converted is stored in *ENDPTR.  */
+extern INT INTERNAL (__strtol_l) (const STRING_TYPE *, STRING_TYPE **, int,
+				  int, __locale_t);
+
 
 INT
-INTERNAL (strtol) (nptr, endptr, base, group LOCALE_PARAM)
+INTERNAL (strtol) (nptr, endptr, base, group)
      const STRING_TYPE *nptr;
      STRING_TYPE **endptr;
      int base;
      int group;
-     LOCALE_PARAM_DECL
 {
-  int negative;
-  register unsigned LONG int cutoff;
-  register unsigned int cutlim;
-  register unsigned LONG int i;
-  register const STRING_TYPE *s;
-  register UCHAR_TYPE c;
-  const STRING_TYPE *save, *end;
-  int overflow;
-#ifndef USE_WIDE_CHAR
-  size_t cnt;
-#endif
-
-#ifdef USE_NUMBER_GROUPING
-# ifdef USE_IN_EXTENDED_LOCALE_MODEL
-  struct locale_data *current = loc->__locales[LC_NUMERIC];
-# endif
-  /* The thousands character of the current locale.  */
-# ifdef USE_WIDE_CHAR
-  wchar_t thousands = L'\0';
-# else
-  const char *thousands = NULL;
-  size_t thousands_len = 0;
-# endif
-  /* The numeric grouping specification of the current locale,
-     in the format described in <locale.h>.  */
-  const char *grouping;
-
-  if (__builtin_expect (group, 0))
-    {
-      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);
-      if (*grouping <= 0 || *grouping == CHAR_MAX)
-	grouping = NULL;
-      else
-	{
-	  /* Figure out the thousands separator character.  */
-# ifdef USE_WIDE_CHAR
-#  ifdef _LIBC
-	  thousands = _NL_CURRENT_WORD (LC_NUMERIC,
-					_NL_NUMERIC_THOUSANDS_SEP_WC);
-#  endif
-	  if (thousands == L'\0')
-	    grouping = NULL;
-# else
-#  ifdef _LIBC
-	  thousands = _NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP);
-#  endif
-	  if (*thousands == '\0')
-	    {
-	      thousands = NULL;
-	      grouping = NULL;
-	    }
-# endif
-	}
-    }
-  else
-    grouping = NULL;
-#endif
-
-  if (base < 0 || base == 1 || base > 36)
-    {
-      __set_errno (EINVAL);
-      return 0;
-    }
-
-  save = s = nptr;
-
-  /* Skip white space.  */
-  while (ISSPACE (*s))
-    ++s;
-  if (__builtin_expect (*s == L_('\0'), 0))
-    goto noconv;
-
-  /* Check for a sign.  */
-  negative = 0;
-  if (*s == L_('-'))
-    {
-      negative = 1;
-      ++s;
-    }
-  else if (*s == L_('+'))
-    ++s;
-
-  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
-  if (*s == L_('0'))
-    {
-      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))
-	{
-	  s += 2;
-	  base = 16;
-	}
-      else if (base == 0)
-	base = 8;
-    }
-  else if (base == 0)
-    base = 10;
-
-  /* Save the pointer so we can check later if anything happened.  */
-  save = s;
-
-#ifdef USE_NUMBER_GROUPING
-  if (base != 10)
-    grouping = NULL;
-
-  if (__builtin_expect (grouping != NULL, 0))
-    {
-# ifndef USE_WIDE_CHAR
-      thousands_len = strlen (thousands);
-# endif
-
-      /* Find the end of the digit string and check its grouping.  */
-      end = s;
-      if (
-# ifdef USE_WIDE_CHAR
-	  *s != thousands
-# else
-	  ({ for (cnt = 0; cnt < thousands_len; ++cnt)
-	       if (thousands[cnt] != end[cnt])
-		 break;
-	     cnt < thousands_len; })
-# endif
-	  )
-	{
-	  for (c = *end; c != L_('\0'); c = *++end)
-	    if (((STRING_TYPE) c < L_('0') || (STRING_TYPE) c > L_('9'))
-# ifdef USE_WIDE_CHAR
-		&& (wchar_t) c != thousands
-# else
-		&& ({ for (cnt = 0; cnt < thousands_len; ++cnt)
-		      if (thousands[cnt] != end[cnt])
-			break;
-		      cnt < thousands_len; })
-# endif
-		&& (!ISALPHA (c)
-		    || (int) (TOUPPER (c) - L_('A') + 10) >= base))
-	      break;
-
-	  end = correctly_grouped_prefix (s, end, thousands, grouping);
-	}
-    }
-  else
-#endif
-    end = NULL;
-
-  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
-  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;
-
-  overflow = 0;
-  i = 0;
-  c = *s;
-  if (sizeof (long int) != sizeof (LONG int))
-    {
-      unsigned long int j = 0;
-      unsigned long int jmax = ULONG_MAX / base;
-
-      for (;c != L_('\0'); c = *++s)
-	{
-	  if (s == end)
-	    break;
-	  if (c >= L_('0') && c <= L_('9'))
-	    c -= L_('0');
-#ifdef USE_NUMBER_GROUPING
-# ifdef USE_WIDE_CHAR
-	  else if (grouping && (wchar_t) c == thousands)
-	    continue;
-# else
-	  else if (thousands_len)
-	    {
-	      for (cnt = 0; cnt < thousands_len; ++cnt)
-		if (thousands[cnt] != s[cnt])
-		  break;
-	      if (cnt == thousands_len)
-		{
-		  s += thousands_len - 1;
-		  continue;
-		}
-	      if (ISALPHA (c))
-		c = TOUPPER (c) - L_('A') + 10;
-	      else
-		break;
-	    }
-# endif
-#endif
-	  else if (ISALPHA (c))
-	    c = TOUPPER (c) - L_('A') + 10;
-	  else
-	    break;
-	  if ((int) c >= base)
-	    break;
-	  /* Note that we never can have an overflow.  */
-	  else if (j >= jmax)
-	    {
-	      /* We have an overflow.  Now use the long representation.  */
-	      i = (unsigned LONG int) j;
-	      goto use_long;
-	    }
-	  else
-	    j = j * (unsigned long int) base + c;
-	}
-
-      i = (unsigned LONG int) j;
-    }
-  else
-    for (;c != L_('\0'); c = *++s)
-      {
-	if (s == end)
-	  break;
-	if (c >= L_('0') && c <= L_('9'))
-	  c -= L_('0');
-#ifdef USE_NUMBER_GROUPING
-# ifdef USE_WIDE_CHAR
-	else if (grouping && (wchar_t) c == thousands)
-	  continue;
-# else
-	else if (thousands_len)
-	  {
-	    for (cnt = 0; cnt < thousands_len; ++cnt)
-	      if (thousands[cnt] != s[cnt])
-		break;
-	    if (cnt == thousands_len)
-	      {
-		s += thousands_len - 1;
-		continue;
-	      }
-	    if (ISALPHA (c))
-	      c = TOUPPER (c) - L_('A') + 10;
-	    else
-	      break;
-	  }
-# endif
-#endif
-	else if (ISALPHA (c))
-	  c = TOUPPER (c) - L_('A') + 10;
-	else
-	  break;
-	if ((int) c >= base)
-	  break;
-	/* Check for overflow.  */
-	if (i > cutoff || (i == cutoff && c > cutlim))
-	  overflow = 1;
-	else
-	  {
-	  use_long:
-	    i *= (unsigned LONG int) base;
-	    i += c;
-	  }
-      }
-
-  /* Check if anything actually happened.  */
-  if (s == save)
-    goto noconv;
-
-  /* Store in ENDPTR the address of one character
-     past the last character we converted.  */
-  if (endptr != NULL)
-    *endptr = (STRING_TYPE *) s;
-
-#if !UNSIGNED
-  /* Check for a value that is within the range of
-     `unsigned LONG int', but outside the range of `LONG int'.  */
-  if (overflow == 0
-      && i > (negative
-	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
-	      : (unsigned LONG int) STRTOL_LONG_MAX))
-    overflow = 1;
-#endif
-
-  if (__builtin_expect (overflow, 0))
-    {
-      __set_errno (ERANGE);
-#if UNSIGNED
-      return STRTOL_ULONG_MAX;
-#else
-      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
-#endif
-    }
-
-  /* Return the result of the appropriate sign.  */
-  return negative ? -i : i;
-
-noconv:
-  /* We must handle a special case here: the base is 0 or 16 and the
-     first two characters are '0' and 'x', but the rest are no
-     hexadecimal digits.  This is no error case.  We return 0 and
-     ENDPTR points to the `x`.  */
-  if (endptr != NULL)
-    {
-      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')
-	  && save[-2] == L_('0'))
-	*endptr = (STRING_TYPE *) &save[-1];
-      else
-	/*  There was no number to convert.  */
-	*endptr = (STRING_TYPE *) nptr;
-    }
-
-  return 0L;
+  return INTERNAL (__strtol_l) (nptr, endptr, base, group, _NL_CURRENT_LOCALE);
 }
-#if defined _LIBC \
-    && !(defined USE_IN_EXTENDED_LOCALE_MODEL && defined USE_WIDE_CHAR)
 libc_hidden_def (INTERNAL (strtol))
-#endif
-
-/* External user entry point.  */
-
-#if _LIBC - 0 == 0
-# undef PARAMS
-# if defined (__STDC__) && __STDC__
-#  define PARAMS(Args) Args
-# else
-#  define PARAMS(Args) ()
-# endif
-
-/* Prototype.  */
-INT strtol PARAMS ((const STRING_TYPE *nptr, STRING_TYPE **endptr, int base));
-#endif
 
 
 INT
-#ifdef weak_function
-weak_function
-#endif
-strtol (nptr, endptr, base LOCALE_PARAM)
+strtol (nptr, endptr, base)
      const STRING_TYPE *nptr;
      STRING_TYPE **endptr;
      int base;
-     LOCALE_PARAM_DECL
 {
-  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);
+  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, _NL_CURRENT_LOCALE);
 }
diff -Nur sysdeps/generic/strtold.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtold.c
--- sysdeps/generic/strtold.c	2002-08-14 21:25:51.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtold.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-#include <stdlib.h>
-
-/* There is no `long double' type, use the `double' implementations.  */
-long double
-__strtold_internal (const char *nptr, char **endptr, int group)
-{
-  return __strtod_internal (nptr, endptr, group);
-}
-libc_hidden_def (__strtold_internal)
-
-long double
-strtold (const char *nptr, char **endptr)
-{
-  return __strtod_internal (nptr, endptr, 0);
-}
diff -Nur sysdeps/generic/strtold_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtold_l.c
--- sysdeps/generic/strtold_l.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtold_l.c	2004-03-16 01:03:19.000000000 +0100
@@ -0,0 +1,58 @@
+/* Copyright (C) 1999, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <math.h>
+#include <stdlib.h>
+#include <xlocale.h>
+
+#ifdef USE_WIDE_CHAR
+# define STRING_TYPE	wchar_t
+# define STRTOLD	wcstold_l
+# define __STRTOLD	__wcstold_l
+# define __STRTOD	__wcstod_l
+#else
+# define STRING_TYPE	char
+# define STRTOLD	strtold_l
+# define __STRTOLD	__strtold_l
+# define __STRTOD	__strtod_l
+#endif
+
+#define INTERNAL(x) INTERNAL1(x)
+#define INTERNAL1(x) __##x##_internal
+
+extern double INTERNAL (__STRTOD) (const STRING_TYPE *, STRING_TYPE **,
+				   int, __locale_t);
+
+/* There is no `long double' type, use the `double' implementations.  */
+long double
+INTERNAL (__STRTOLD) (const STRING_TYPE *nptr, STRING_TYPE **endptr,
+		      int group, __locale_t loc)
+{
+  return INTERNAL (__STRTOD) (nptr, endptr, group, loc);
+}
+#ifndef USE_WIDE_CHAR
+libc_hidden_def (INTERNAL (__STRTOLD))
+#endif
+
+long double
+weak_function
+__STRTOLD (const STRING_TYPE *nptr, STRING_TYPE **endptr, __locale_t loc)
+{
+  return INTERNAL (__STRTOD) (nptr, endptr, 0, loc);
+}
+weak_alias (__STRTOLD, STRTOLD)
diff -Nur sysdeps/generic/strtol_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtol_l.c
--- sysdeps/generic/strtol_l.c	2002-08-28 03:04:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtol_l.c	2004-06-15 21:54:57.000000000 +0200
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,13 +18,540 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
 
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define USE_NUMBER_GROUPING
+# define STDC_HEADERS
+# define HAVE_LIMITS_H
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#ifndef __set_errno
+# define __set_errno(Val) errno = (Val)
+#endif
+
+#ifdef HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
 #include <xlocale.h>
+#include <bits/wordsize.h>
+
+#ifdef USE_NUMBER_GROUPING
+# include "../locale/localeinfo.h"
+#endif
+
+/* Nonzero if we are defining `strtoul' or `strtoull', operating on
+   unsigned integers.  */
+#ifndef UNSIGNED
+# define UNSIGNED 0
+# define INT LONG int
+#else
+# define INT unsigned LONG int
+#endif
+
+/* Determine the name.  */
+#if UNSIGNED
+# ifdef USE_WIDE_CHAR
+#  ifdef QUAD
+#   define strtol_l wcstoull_l
+#  else
+#   define strtol_l wcstoul_l
+#  endif
+# else
+#  ifdef QUAD
+#   define strtol_l strtoull_l
+#  else
+#   define strtol_l strtoul_l
+#  endif
+# endif
+#else
+# ifdef USE_WIDE_CHAR
+#  ifdef QUAD
+#   define strtol_l wcstoll_l
+#  else
+#   define strtol_l wcstol_l
+#  endif
+# else
+#  ifdef QUAD
+#   define strtol_l strtoll_l
+#  else
+#   define strtol_l strtol_l
+#  endif
+# endif
+#endif
+
+#define __strtol_l __strtol_l2(strtol_l)
+#define __strtol_l2(name) __strtol_l3(name)
+#define __strtol_l3(name) __##name
+
+
+/* If QUAD is defined, we are defining `strtoll' or `strtoull',
+   operating on `long long int's.  */
+#ifdef QUAD
+# define LONG long long
+# define STRTOL_LONG_MIN LONG_LONG_MIN
+# define STRTOL_LONG_MAX LONG_LONG_MAX
+# define STRTOL_ULONG_MAX ULONG_LONG_MAX
+#else
+# define LONG long
+
+# ifndef ULONG_MAX
+#  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
+# endif
+# ifndef LONG_MAX
+#  define LONG_MAX ((long int) (ULONG_MAX >> 1))
+# endif
+# define STRTOL_LONG_MIN LONG_MIN
+# define STRTOL_LONG_MAX LONG_MAX
+# define STRTOL_ULONG_MAX ULONG_MAX
+#endif
+
+
+/* We use this code for the extended locale handling where the
+   function gets as an additional argument the locale which has to be
+   used.  To access the values we have to redefine the _NL_CURRENT and
+   _NL_CURRENT_WORD macros.  */
+#undef _NL_CURRENT
+#define _NL_CURRENT(category, item) \
+  (current->values[_NL_ITEM_INDEX (item)].string)
+#undef _NL_CURRENT_WORD
+#define _NL_CURRENT_WORD(category, item) \
+  ((uint32_t) current->values[_NL_ITEM_INDEX (item)].word)
+
+#if defined _LIBC || defined HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
+#ifdef USE_WIDE_CHAR
+# include <wctype.h>
+# define L_(Ch) L##Ch
+# define UCHAR_TYPE wint_t
+# define STRING_TYPE wchar_t
+# define ISSPACE(Ch) __iswspace_l ((Ch), loc)
+# define ISALPHA(Ch) __iswalpha_l ((Ch), loc)
+# define TOUPPER(Ch) __towupper_l ((Ch), loc)
+#else
+# if defined _LIBC \
+   || defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
+#  define IN_CTYPE_DOMAIN(c) 1
+# else
+#  define IN_CTYPE_DOMAIN(c) isascii(c)
+# endif
+# define L_(Ch) Ch
+# define UCHAR_TYPE unsigned char
+# define STRING_TYPE char
+# define ISSPACE(Ch) __isspace_l ((Ch), loc)
+# define ISALPHA(Ch) __isalpha_l ((Ch), loc)
+# define TOUPPER(Ch) __toupper_l ((Ch), loc)
+#endif
+
+#define INTERNAL(X) INTERNAL1(X)
+#define INTERNAL1(X) __##X##_internal
+#define WEAKNAME(X) WEAKNAME1(X)
+
+#ifdef USE_NUMBER_GROUPING
+/* This file defines a function to check for correct grouping.  */
+# include "grouping.h"
+#endif
+
+
+/* Define tables of maximum values and remainders in order to detect
+   overflow.  Do this at compile-time in order to avoid the runtime
+   overhead of the division.  */
+
+#define DEF(TYPE, NAME)							   \
+  const TYPE NAME[] attribute_hidden					   \
+	__attribute__((section(".gnu.linkonce.r." #NAME))) =		   \
+  {									   \
+    F(2), F(3), F(4), F(5), F(6), F(7), F(8), F(9), F(10), 		   \
+    F(11), F(12), F(13), F(14), F(15), F(16), F(17), F(18), F(19), F(20),  \
+    F(21), F(22), F(23), F(24), F(25), F(26), F(27), F(28), F(29), F(30),  \
+    F(31), F(32), F(33), F(34), F(35), F(36)				   \
+  }
+
+#define F(X)	ULONG_MAX / X
+  DEF (unsigned long, __strtol_ul_max_tab);
+#undef F
+#if defined(QUAD) && __WORDSIZE == 32
+# define F(X)	ULONG_LONG_MAX / X
+  DEF (unsigned long long, __strtol_ull_max_tab);
+# undef F
+# define F(X)	ULONG_LONG_MAX % X
+  DEF (unsigned char, __strtol_ull_rem_tab);
+# undef F
+#else
+# define F(X)	ULONG_MAX % X
+  DEF (unsigned char, __strtol_ul_rem_tab);
+# undef F
+#endif
+#undef DEF
+
+/* Define some more readable aliases for these arrays which correspond
+   to how they'll be used in the function below.  */
+#define jmax_tab	__strtol_ul_max_tab
+#if defined(QUAD) && __WORDSIZE == 32
+# define cutoff_tab	__strtol_ull_max_tab
+# define cutlim_tab	__strtol_ull_rem_tab
+#else
+# define cutoff_tab	__strtol_ul_max_tab
+# define cutlim_tab	__strtol_ul_rem_tab
+#endif
+
+
+/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.
+   If BASE is 0 the base is determined by the presence of a leading
+   zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
+   If BASE is < 2 or > 36, it is reset to 10.
+   If ENDPTR is not NULL, a pointer to the character after the last
+   one converted is stored in *ENDPTR.  */
+
+INT
+INTERNAL (__strtol_l) (nptr, endptr, base, group, loc)
+     const STRING_TYPE *nptr;
+     STRING_TYPE **endptr;
+     int base;
+     int group;
+     __locale_t loc;
+{
+  int negative;
+  register unsigned LONG int cutoff;
+  register unsigned int cutlim;
+  register unsigned LONG int i;
+  register const STRING_TYPE *s;
+  register UCHAR_TYPE c;
+  const STRING_TYPE *save, *end;
+  int overflow;
+#ifndef USE_WIDE_CHAR
+  size_t cnt;
+#endif
+
+#ifdef USE_NUMBER_GROUPING
+  struct locale_data *current = loc->__locales[LC_NUMERIC];
+  /* The thousands character of the current locale.  */
+# ifdef USE_WIDE_CHAR
+  wchar_t thousands = L'\0';
+# else
+  const char *thousands = NULL;
+  size_t thousands_len = 0;
+# endif
+  /* The numeric grouping specification of the current locale,
+     in the format described in <locale.h>.  */
+  const char *grouping;
+
+  if (__builtin_expect (group, 0))
+    {
+      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);
+      if (*grouping <= 0 || *grouping == CHAR_MAX)
+	grouping = NULL;
+      else
+	{
+	  /* Figure out the thousands separator character.  */
+# ifdef USE_WIDE_CHAR
+#  ifdef _LIBC
+	  thousands = _NL_CURRENT_WORD (LC_NUMERIC,
+					_NL_NUMERIC_THOUSANDS_SEP_WC);
+#  endif
+	  if (thousands == L'\0')
+	    grouping = NULL;
+# else
+#  ifdef _LIBC
+	  thousands = _NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP);
+#  endif
+	  if (*thousands == '\0')
+	    {
+	      thousands = NULL;
+	      grouping = NULL;
+	    }
+# endif
+	}
+    }
+  else
+    grouping = NULL;
+#endif
+
+  if (base < 0 || base == 1 || base > 36)
+    {
+      __set_errno (EINVAL);
+      return 0;
+    }
+
+  save = s = nptr;
+
+  /* Skip white space.  */
+  while (ISSPACE (*s))
+    ++s;
+  if (__builtin_expect (*s == L_('\0'), 0))
+    goto noconv;
+
+  /* Check for a sign.  */
+  negative = 0;
+  if (*s == L_('-'))
+    {
+      negative = 1;
+      ++s;
+    }
+  else if (*s == L_('+'))
+    ++s;
+
+  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
+  if (*s == L_('0'))
+    {
+      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))
+	{
+	  s += 2;
+	  base = 16;
+	}
+      else if (base == 0)
+	base = 8;
+    }
+  else if (base == 0)
+    base = 10;
+
+  /* Save the pointer so we can check later if anything happened.  */
+  save = s;
+
+#ifdef USE_NUMBER_GROUPING
+  if (base != 10)
+    grouping = NULL;
+
+  if (__builtin_expect (grouping != NULL, 0))
+    {
+# ifndef USE_WIDE_CHAR
+      thousands_len = strlen (thousands);
+# endif
+
+      /* Find the end of the digit string and check its grouping.  */
+      end = s;
+      if (
+# ifdef USE_WIDE_CHAR
+	  *s != thousands
+# else
+	  ({ for (cnt = 0; cnt < thousands_len; ++cnt)
+	       if (thousands[cnt] != end[cnt])
+		 break;
+	     cnt < thousands_len; })
+# endif
+	  )
+	{
+	  for (c = *end; c != L_('\0'); c = *++end)
+	    if (((STRING_TYPE) c < L_('0') || (STRING_TYPE) c > L_('9'))
+# ifdef USE_WIDE_CHAR
+		&& (wchar_t) c != thousands
+# else
+		&& ({ for (cnt = 0; cnt < thousands_len; ++cnt)
+		      if (thousands[cnt] != end[cnt])
+			break;
+		      cnt < thousands_len; })
+# endif
+		&& (!ISALPHA (c)
+		    || (int) (TOUPPER (c) - L_('A') + 10) >= base))
+	      break;
+
+# ifdef USE_WIDE_CHAR
+	  end = __correctly_grouped_prefixwc (s, end, thousands, grouping);
+# else
+	  end = __correctly_grouped_prefixmb (s, end, thousands, grouping);
+# endif
+	}
+    }
+  else
+#endif
+    end = NULL;
+
+  /* Avoid runtime division; lookup cutoff and limit.  */
+  cutoff = cutoff_tab[base - 2];
+  cutlim = cutlim_tab[base - 2];
+
+  overflow = 0;
+  i = 0;
+  c = *s;
+  if (sizeof (long int) != sizeof (LONG int))
+    {
+      unsigned long int j = 0;
+      unsigned long int jmax = jmax_tab[base - 2];
+
+      for (;c != L_('\0'); c = *++s)
+	{
+	  if (s == end)
+	    break;
+	  if (c >= L_('0') && c <= L_('9'))
+	    c -= L_('0');
+#ifdef USE_NUMBER_GROUPING
+# ifdef USE_WIDE_CHAR
+	  else if (grouping && (wchar_t) c == thousands)
+	    continue;
+# else
+	  else if (thousands_len)
+	    {
+	      for (cnt = 0; cnt < thousands_len; ++cnt)
+		if (thousands[cnt] != s[cnt])
+		  break;
+	      if (cnt == thousands_len)
+		{
+		  s += thousands_len - 1;
+		  continue;
+		}
+	      if (ISALPHA (c))
+		c = TOUPPER (c) - L_('A') + 10;
+	      else
+		break;
+	    }
+# endif
+#endif
+	  else if (ISALPHA (c))
+	    c = TOUPPER (c) - L_('A') + 10;
+	  else
+	    break;
+	  if ((int) c >= base)
+	    break;
+	  /* Note that we never can have an overflow.  */
+	  else if (j >= jmax)
+	    {
+	      /* We have an overflow.  Now use the long representation.  */
+	      i = (unsigned LONG int) j;
+	      goto use_long;
+	    }
+	  else
+	    j = j * (unsigned long int) base + c;
+	}
+
+      i = (unsigned LONG int) j;
+    }
+  else
+    for (;c != L_('\0'); c = *++s)
+      {
+	if (s == end)
+	  break;
+	if (c >= L_('0') && c <= L_('9'))
+	  c -= L_('0');
+#ifdef USE_NUMBER_GROUPING
+# ifdef USE_WIDE_CHAR
+	else if (grouping && (wchar_t) c == thousands)
+	  continue;
+# else
+	else if (thousands_len)
+	  {
+	    for (cnt = 0; cnt < thousands_len; ++cnt)
+	      if (thousands[cnt] != s[cnt])
+		break;
+	    if (cnt == thousands_len)
+	      {
+		s += thousands_len - 1;
+		continue;
+	      }
+	    if (ISALPHA (c))
+	      c = TOUPPER (c) - L_('A') + 10;
+	    else
+	      break;
+	  }
+# endif
+#endif
+	else if (ISALPHA (c))
+	  c = TOUPPER (c) - L_('A') + 10;
+	else
+	  break;
+	if ((int) c >= base)
+	  break;
+	/* Check for overflow.  */
+	if (i > cutoff || (i == cutoff && c > cutlim))
+	  overflow = 1;
+	else
+	  {
+	  use_long:
+	    i *= (unsigned LONG int) base;
+	    i += c;
+	  }
+      }
+
+  /* Check if anything actually happened.  */
+  if (s == save)
+    goto noconv;
+
+  /* Store in ENDPTR the address of one character
+     past the last character we converted.  */
+  if (endptr != NULL)
+    *endptr = (STRING_TYPE *) s;
+
+#if !UNSIGNED
+  /* Check for a value that is within the range of
+     `unsigned LONG int', but outside the range of `LONG int'.  */
+  if (overflow == 0
+      && i > (negative
+	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
+	      : (unsigned LONG int) STRTOL_LONG_MAX))
+    overflow = 1;
+#endif
+
+  if (__builtin_expect (overflow, 0))
+    {
+      __set_errno (ERANGE);
+#if UNSIGNED
+      return STRTOL_ULONG_MAX;
+#else
+      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
+#endif
+    }
+
+  /* Return the result of the appropriate sign.  */
+  return negative ? -i : i;
+
+noconv:
+  /* We must handle a special case here: the base is 0 or 16 and the
+     first two characters are '0' and 'x', but the rest are no
+     hexadecimal digits.  This is no error case.  We return 0 and
+     ENDPTR points to the `x`.  */
+  if (endptr != NULL)
+    {
+      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')
+	  && save[-2] == L_('0'))
+	*endptr = (STRING_TYPE *) &save[-1];
+      else
+	/*  There was no number to convert.  */
+	*endptr = (STRING_TYPE *) nptr;
+    }
+
+  return 0L;
+}
+#if defined _LIBC && !defined USE_WIDE_CHAR
+libc_hidden_def (INTERNAL (__strtol_l))
+#endif
+
+/* External user entry point.  */
+
+#if _LIBC - 0 == 0
+# undef PARAMS
+# if defined (__STDC__) && __STDC__
+#  define PARAMS(Args) Args
+# else
+#  define PARAMS(Args) ()
+# endif
 
-extern long int ____strtol_l_internal (const char *, char **, int, int,
-				       __locale_t);
+/* Prototype.  */
+extern INT __strtol_l PARAMS ((const STRING_TYPE *nptr, STRING_TYPE **endptr,
+			       int base));
+#endif
 
-#include "strtol.c"
 
+INT
+#ifdef weak_function
+weak_function
+#endif
+__strtol_l (nptr, endptr, base, loc)
+     const STRING_TYPE *nptr;
+     STRING_TYPE **endptr;
+     int base;
+     __locale_t loc;
+{
+  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, loc);
+}
 weak_alias (__strtol_l, strtol_l)
diff -Nur sysdeps/generic/strtoll_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoll_l.c
--- sysdeps/generic/strtoll_l.c	2002-08-28 03:04:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoll_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,13 +18,11 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define QUAD	1
 
 #include <xlocale.h>
 
 extern long long int ____strtoll_l_internal (const char *, char **, int, int,
 					     __locale_t);
 
-#include <strtoll.c>
-
-weak_alias (__strtoll_l, strtoll_l)
+#include <strtol_l.c>
diff -Nur sysdeps/generic/strtoul_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoul_l.c
--- sysdeps/generic/strtoul_l.c	2002-08-28 03:04:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoul_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,13 +18,11 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define UNSIGNED	1
 
 #include <xlocale.h>
 
 extern unsigned long int ____strtoul_l_internal (const char *, char **, int,
 						 int, __locale_t);
 
-#include "strtoul.c"
-
-weak_alias (__strtoul_l, strtoul_l)
+#include "strtol_l.c"
diff -Nur sysdeps/generic/strtoull_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoull_l.c
--- sysdeps/generic/strtoull_l.c	2002-08-28 03:04:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/strtoull_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,13 +18,12 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define QUAD		1
+#define UNSIGNED	1
 
 #include <xlocale.h>
 
 extern unsigned long long int ____strtoull_l_internal (const char *, char **,
 						       int, int, __locale_t);
 
-#include <strtoull.c>
-
-weak_alias (__strtoull_l, strtoull_l)
+#include <strtol_l.c>
diff -Nur sysdeps/generic/symbol-hacks.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/symbol-hacks.h
--- sysdeps/generic/symbol-hacks.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/symbol-hacks.h	2004-03-08 21:58:29.000000000 +0100
@@ -0,0 +1 @@
+/* Fortunately nothing to do.  */
diff -Nur sysdeps/generic/sysconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysconf.c
--- sysdeps/generic/sysconf.c	2002-08-04 09:28:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysconf.c	2004-11-03 02:55:22.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,1993,1995-1997,2001,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1993,1995-1997,2001,2002,2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,6 +18,8 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#include <grp.h>
+#include <pwd.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <time.h>
@@ -142,6 +145,12 @@
     case _SC_USHRT_MAX:
       return USHRT_MAX;
 
+    case _SC_GETGR_R_SIZE_MAX:
+      return NSS_BUFLEN_GROUP;
+
+    case _SC_GETPW_R_SIZE_MAX:
+      return NSS_BUFLEN_PASSWD;
+
     case _SC_ARG_MAX:
     case _SC_CHILD_MAX:
     case _SC_CLK_TCK:
@@ -211,8 +220,6 @@
 
     case _SC_THREADS:
     case _SC_THREAD_SAFE_FUNCTIONS:
-    case _SC_GETGR_R_SIZE_MAX:
-    case _SC_GETPW_R_SIZE_MAX:
     case _SC_LOGIN_NAME_MAX:
     case _SC_TTY_NAME_MAX:
     case _SC_THREAD_DESTRUCTOR_ITERATIONS:
diff -Nur sysdeps/generic/sysdep-cancel.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysdep-cancel.h
--- sysdeps/generic/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysdep-cancel.h	2003-01-07 01:12:06.000000000 +0100
@@ -0,0 +1,7 @@
+#include <sysdep.h>
+
+/* No multi-thread handling enabled.  */
+#define SINGLE_THREAD_P (1)
+#define LIBC_CANCEL_ASYNC()	0 /* Just a dummy value.  */
+#define LIBC_CANCEL_RESET(val)	((void)(val)) /* Nothing, but evaluate it.  */
+#define LIBC_CANCEL_HANDLED()	/* Nothing.  */
diff -Nur sysdeps/generic/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysdep.h
--- sysdeps/generic/sysdep.h	2002-08-02 07:00:57.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/sysdep.h	2003-08-31 19:21:03.000000000 +0200
@@ -1,5 +1,5 @@
 /* Generic asm macros used on many machines.
-   Copyright (C) 1991,92,93,96,98,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,93,96,98,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -42,4 +42,94 @@
 #ifndef END
 #define END(sym)
 #endif
+
+#ifndef JUMPTARGET
+#define JUMPTARGET(sym)		sym
+#endif
+
+/* Makros to generate eh_frame unwind information.  */
+# ifdef HAVE_ASM_CFI_DIRECTIVES
+#  define cfi_startproc			.cfi_startproc
+#  define cfi_endproc			.cfi_endproc
+#  define cfi_def_cfa(reg, off)		.cfi_def_cfa reg, off
+#  define cfi_def_cfa_register(reg)	.cfi_def_cfa_register reg
+#  define cfi_def_cfa_offset(off)	.cfi_def_cfa_offset off
+#  define cfi_adjust_cfa_offset(off)	.cfi_adjust_cfa_offset off
+#  define cfi_offset(reg, off)		.cfi_offset reg, off
+#  define cfi_rel_offset(reg, off)	.cfi_rel_offset reg, off
+#  define cfi_register(r1, r2)		.cfi_register r1, r2
+#  define cfi_return_column(reg)	.cfi_return_column reg
+#  define cfi_restore(reg)		.cfi_restore reg
+#  define cfi_undefined(reg)		.cfi_undefined reg
+#  define cfi_remember_state		.cfi_remember_state
+#  define cfi_restore_state		.cfi_restore_state
+#  define cfi_window_save		.cfi_window_save
+# else
+#  define cfi_startproc
+#  define cfi_endproc
+#  define cfi_def_cfa(reg, off)
+#  define cfi_def_cfa_register(reg)
+#  define cfi_def_cfa_offset(off)
+#  define cfi_adjust_cfa_offset(off)
+#  define cfi_offset(reg, off)
+#  define cfi_rel_offset(reg, off)
+#  define cfi_register(r1, r2)
+#  define cfi_return_column(reg)
+#  define cfi_restore(reg)
+#  define cfi_undefined(reg)
+#  define cfi_remember_state
+#  define cfi_restore_state
+#  define cfi_window_save
+# endif
+
+#else /* ! ASSEMBLER */
+# ifdef HAVE_ASM_CFI_DIRECTIVES
+#  define CFI_STRINGIFY(Name) CFI_STRINGIFY2 (Name)
+#  define CFI_STRINGIFY2(Name) #Name
+#  define CFI_STARTPROC	".cfi_startproc"
+#  define CFI_ENDPROC	".cfi_endproc"
+#  define CFI_DEF_CFA(reg, off)	\
+   ".cfi_def_cfa " CFI_STRINGIFY(reg) "," CFI_STRINGIFY(off)
+#  define CFI_DEF_CFA_REGISTER(reg) \
+   ".cfi_def_cfa_register " CFI_STRINGIFY(reg)
+#  define CFI_DEF_CFA_OFFSET(off) \
+   ".cfi_def_cfa_offset " CFI_STRINGIFY(off)
+#  define CFI_ADJUST_CFA_OFFSET(off) \
+   ".cfi_adjust_cfa_offset " CFI_STRINGIFY(off)
+#  define CFI_OFFSET(reg, off) \
+   ".cfi_offset " CFI_STRINGIFY(reg) "," CFI_STRINGIFY(off)
+#  define CFI_REL_OFFSET(reg, off) \
+   ".cfi_rel_offset " CFI_STRINGIFY(reg) "," CFI_STRINGIFY(off)
+#  define CFI_REGISTER(r1, r2) \
+   ".cfi_register " CFI_STRINGIFY(r1) "," CFI_STRINGIFY(r2)
+#  define CFI_RETURN_COLUMN(reg) \
+   ".cfi_return_column " CFI_STRINGIFY(reg)
+#  define CFI_RESTORE(reg) \
+   ".cfi_restore " CFI_STRINGIFY(reg)
+#  define CFI_UNDEFINED(reg) \
+   ".cfi_undefined " CFI_STRINGIFY(reg)
+#  define CFI_REMEMBER_STATE \
+   ".cfi_remember_state"
+#  define CFI_RESTORE_STATE \
+   ".cfi_restore_state"
+#  define CFI_WINDOW_SAVE \
+   ".cfi_window_save"
+# else
+#  define CFI_STARTPROC
+#  define CFI_ENDPROC
+#  define CFI_DEF_CFA(reg, off)
+#  define CFI_DEF_CFA_REGISTER(reg)
+#  define CFI_DEF_CFA_OFFSET(off)
+#  define CFI_ADJUST_CFA_OFFSET(off)
+#  define CFI_OFFSET(reg, off)
+#  define CFI_REL_OFFSET(reg, off)
+#  define CFI_REGISTER(r1, r2)
+#  define CFI_RETURN_COLUMN(reg)
+#  define CFI_RESTORE(reg)
+#  define CFI_UNDEFINED(reg)
+#  define CFI_REMEMBER_STATE
+#  define CFI_RESTORE_STATE
+#  define CFI_WINDOW_SAVE
+# endif
+
 #endif /* __ASSEMBLER__ */
diff -Nur sysdeps/generic/syslog.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/syslog.c
--- sysdeps/generic/syslog.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/syslog.c	2005-02-16 12:00:08.000000000 +0100
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 1983, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)syslog.c	8.4 (Berkeley) 3/18/94";
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/syslog.h>
+#include <sys/uio.h>
+#include <netdb.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <bits/libc-lock.h>
+#include <signal.h>
+#include <locale.h>
+
+#if __STDC__
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+#include <libio/iolibio.h>
+#define ftell(s) INTUSE(_IO_ftell) (s)
+
+static int	LogType = SOCK_DGRAM;	/* type of socket connection */
+static int	LogFile = -1;		/* fd for log */
+static int	connected;		/* have done connect */
+static int	LogStat;		/* status bits, set by openlog() */
+static const char *LogTag;		/* string to tag the entry with */
+static int	LogFacility = LOG_USER;	/* default facility code */
+static int	LogMask = 0xff;		/* mask of priorities to be logged */
+extern char	*__progname;		/* Program name, from crt0. */
+
+/* Define the lock.  */
+__libc_lock_define_initialized (static, syslog_lock)
+
+static void openlog_internal(const char *, int, int) internal_function;
+static void closelog_internal(void);
+#ifndef NO_SIGPIPE
+static void sigpipe_handler (int);
+#endif
+
+#ifndef send_flags
+# define send_flags 0
+#endif
+
+struct cleanup_arg
+{
+  void *buf;
+  struct sigaction *oldaction;
+};
+
+static void
+cancel_handler (void *ptr)
+{
+#ifndef NO_SIGPIPE
+  /* Restore the old signal handler.  */
+  struct cleanup_arg *clarg = (struct cleanup_arg *) ptr;
+
+  if (clarg != NULL && clarg->oldaction != NULL)
+    __sigaction (SIGPIPE, clarg->oldaction, NULL);
+#endif
+
+  /* Free the lock.  */
+  __libc_lock_unlock (syslog_lock);
+}
+
+
+/*
+ * syslog, vsyslog --
+ *	print message on log file; output is intended for syslogd(8).
+ */
+void
+#if __STDC__
+syslog(int pri, const char *fmt, ...)
+#else
+syslog(pri, fmt, va_alist)
+	int pri;
+	char *fmt;
+	va_dcl
+#endif
+{
+	va_list ap;
+
+#if __STDC__
+	va_start(ap, fmt);
+#else
+	va_start(ap);
+#endif
+	vsyslog(pri, fmt, ap);
+	va_end(ap);
+}
+libc_hidden_def (syslog)
+
+void
+vsyslog(pri, fmt, ap)
+	int pri;
+	register const char *fmt;
+	va_list ap;
+{
+	struct tm now_tm;
+	time_t now;
+	int fd;
+	FILE *f;
+	char *buf = 0;
+	size_t bufsize = 0;
+	size_t prioff, msgoff;
+#ifndef NO_SIGPIPE
+ 	struct sigaction action, oldaction;
+ 	int sigpipe;
+#endif
+	int saved_errno = errno;
+	char failbuf[3 * sizeof (pid_t) + sizeof "out of memory []"];
+
+#define	INTERNALLOG	LOG_ERR|LOG_CONS|LOG_PERROR|LOG_PID
+	/* Check for invalid bits. */
+	if (pri & ~(LOG_PRIMASK|LOG_FACMASK)) {
+		syslog(INTERNALLOG,
+		    "syslog: unknown facility/priority: %x", pri);
+		pri &= LOG_PRIMASK|LOG_FACMASK;
+	}
+
+	/* Check priority against setlogmask values. */
+	if ((LOG_MASK (LOG_PRI (pri)) & LogMask) == 0)
+		return;
+
+	/* Set default facility if none specified. */
+	if ((pri & LOG_FACMASK) == 0)
+		pri |= LogFacility;
+
+	/* Build the message in a memory-buffer stream.  */
+	f = open_memstream (&buf, &bufsize);
+	if (f == NULL)
+	  {
+	    /* We cannot get a stream.  There is not much we can do but
+	       emitting an error messages.  */
+	    char numbuf[3 * sizeof (pid_t)];
+	    char *nump;
+	    char *endp = __stpcpy (failbuf, "out of memory [");
+	    pid_t pid = __getpid ();
+
+	    nump = numbuf + sizeof (numbuf);
+	    /* The PID can never be zero.  */
+	    do
+	      *--nump = '0' + pid % 10;
+	    while ((pid /= 10) != 0);
+
+	    endp = __mempcpy (endp, nump, (numbuf + sizeof (numbuf)) - nump);
+	    *endp++ = ']';
+	    *endp = '\0';
+	    buf = failbuf;
+	    bufsize = endp - failbuf;
+	    msgoff = 0;
+	  }
+	else
+	  {
+	    __fsetlocking (f, FSETLOCKING_BYCALLER);
+	    prioff = fprintf (f, "<%d>", pri);
+	    (void) time (&now);
+	    f->_IO_write_ptr += __strftime_l (f->_IO_write_ptr,
+					      f->_IO_write_end
+					      - f->_IO_write_ptr,
+					      "%h %e %T ",
+					      __localtime_r (&now, &now_tm),
+					      &_nl_C_locobj);
+	    msgoff = ftell (f);
+	    if (LogTag == NULL)
+	      LogTag = __progname;
+	    if (LogTag != NULL)
+	      fputs_unlocked (LogTag, f);
+	    if (LogStat & LOG_PID)
+	      fprintf (f, "[%d]", (int) __getpid ());
+	    if (LogTag != NULL)
+	      {
+		putc_unlocked (':', f);
+		putc_unlocked (' ', f);
+	      }
+
+	    /* Restore errno for %m format.  */
+	    __set_errno (saved_errno);
+
+	    /* We have the header.  Print the user's format into the
+               buffer.  */
+	    vfprintf (f, fmt, ap);
+
+	    /* Close the memory stream; this will finalize the data
+	       into a malloc'd buffer in BUF.  */
+	    fclose (f);
+	  }
+
+	/* Output to stderr if requested. */
+	if (LogStat & LOG_PERROR) {
+		struct iovec iov[2];
+		register struct iovec *v = iov;
+
+		v->iov_base = buf + msgoff;
+		v->iov_len = bufsize - msgoff;
+		/* Append a newline if necessary.  */
+		if (buf[bufsize - 1] != '\n')
+		  {
+		    ++v;
+		    v->iov_base = (char *) "\n";
+		    v->iov_len = 1;
+		  }
+
+		__libc_cleanup_push (free, buf == failbuf ? NULL : buf);
+
+		/* writev is a cancellation point.  */
+		(void)__writev(STDERR_FILENO, iov, v - iov + 1);
+
+		__libc_cleanup_pop (0);
+	}
+
+	/* Prepare for multiple users.  We have to take care: open and
+	   write are cancellation points.  */
+	struct cleanup_arg clarg;
+	clarg.buf = buf;
+	clarg.oldaction = NULL;
+	__libc_cleanup_push (cancel_handler, &clarg);
+	__libc_lock_lock (syslog_lock);
+
+#ifndef NO_SIGPIPE
+	/* Prepare for a broken connection.  */
+ 	memset (&action, 0, sizeof (action));
+ 	action.sa_handler = sigpipe_handler;
+ 	sigemptyset (&action.sa_mask);
+ 	sigpipe = __sigaction (SIGPIPE, &action, &oldaction);
+	if (sigpipe == 0)
+	  clarg.oldaction = &oldaction;
+#endif
+
+	/* Get connected, output the message to the local logger. */
+	if (!connected)
+		openlog_internal(LogTag, LogStat | LOG_NDELAY, 0);
+
+	/* If we have a SOCK_STREAM connection, also send ASCII NUL as
+	   a record terminator.  */
+	if (LogType == SOCK_STREAM)
+	  ++bufsize;
+
+	if (!connected || __send(LogFile, buf, bufsize, send_flags) < 0)
+	  {
+	    if (connected)
+	      {
+		/* Try to reopen the syslog connection.  Maybe it went
+		   down.  */
+		closelog_internal ();
+		openlog_internal(LogTag, LogStat | LOG_NDELAY, 0);
+	      }
+
+	    if (!connected || __send(LogFile, buf, bufsize, send_flags) < 0)
+	      {
+		closelog_internal ();	/* attempt re-open next time */
+		/*
+		 * Output the message to the console; don't worry
+		 * about blocking, if console blocks everything will.
+		 * Make sure the error reported is the one from the
+		 * syslogd failure.
+		 */
+		if (LogStat & LOG_CONS &&
+		    (fd = __open(_PATH_CONSOLE, O_WRONLY|O_NOCTTY, 0)) >= 0)
+		  {
+		    dprintf (fd, "%s\r\n", buf + msgoff);
+		    (void)__close(fd);
+		  }
+	      }
+	  }
+
+#ifndef NO_SIGPIPE
+	if (sigpipe == 0)
+		__sigaction (SIGPIPE, &oldaction, (struct sigaction *) NULL);
+#endif
+
+	/* End of critical section.  */
+	__libc_cleanup_pop (0);
+	__libc_lock_unlock (syslog_lock);
+
+	if (buf != failbuf)
+		free (buf);
+}
+libc_hidden_def (vsyslog)
+
+static struct sockaddr SyslogAddr;	/* AF_UNIX address of local logger */
+
+
+static void
+internal_function
+openlog_internal(const char *ident, int logstat, int logfac)
+{
+	if (ident != NULL)
+		LogTag = ident;
+	LogStat = logstat;
+	if (logfac != 0 && (logfac &~ LOG_FACMASK) == 0)
+		LogFacility = logfac;
+
+	int retry = 0;
+	while (retry < 2) {
+		if (LogFile == -1) {
+			SyslogAddr.sa_family = AF_UNIX;
+			(void)strncpy(SyslogAddr.sa_data, _PATH_LOG,
+				      sizeof(SyslogAddr.sa_data));
+			if (LogStat & LOG_NDELAY) {
+				if ((LogFile = __socket(AF_UNIX, LogType, 0))
+				    == -1)
+					return;
+				(void)__fcntl(LogFile, F_SETFD, 1);
+			}
+		}
+		if (LogFile != -1 && !connected)
+		{
+			int old_errno = errno;
+			if (__connect(LogFile, &SyslogAddr, sizeof(SyslogAddr))
+			    == -1)
+			{
+				int saved_errno = errno;
+				int fd = LogFile;
+				LogFile = -1;
+				(void)__close(fd);
+				__set_errno (old_errno);
+				if (saved_errno == EPROTOTYPE)
+				{
+					/* retry with the other type: */
+					LogType = (LogType == SOCK_DGRAM
+						   ? SOCK_STREAM : SOCK_DGRAM);
+					++retry;
+					continue;
+				}
+			} else
+				connected = 1;
+		}
+		break;
+	}
+}
+
+void
+openlog (const char *ident, int logstat, int logfac)
+{
+  /* Protect against multiple users and cancellation.  */
+  __libc_cleanup_push (cancel_handler, NULL);
+  __libc_lock_lock (syslog_lock);
+
+  openlog_internal (ident, logstat, logfac);
+
+  __libc_cleanup_pop (1);
+}
+
+#ifndef NO_SIGPIPE
+static void
+sigpipe_handler (int signo)
+{
+  closelog_internal ();
+}
+#endif
+
+static void
+closelog_internal()
+{
+  if (!connected)
+    return;
+
+  __close (LogFile);
+  LogFile = -1;
+  connected = 0;
+}
+
+void
+closelog ()
+{
+  /* Protect against multiple users and cancellation.  */
+  __libc_cleanup_push (cancel_handler, NULL);
+  __libc_lock_lock (syslog_lock);
+
+  closelog_internal ();
+  LogTag = NULL;
+  LogType = SOCK_DGRAM; /* this is the default */
+
+  /* Free the lock.  */
+  __libc_cleanup_pop (1);
+}
+
+/* setlogmask -- set the log mask level */
+int
+setlogmask(pmask)
+	int pmask;
+{
+	int omask;
+
+	omask = LogMask;
+	if (pmask != 0)
+		LogMask = pmask;
+	return (omask);
+}
diff -Nur sysdeps/generic/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/system.c
--- sysdeps/generic/system.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/system.c	2003-12-17 10:24:19.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1993, 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,7 +28,7 @@
   if (line == NULL)
     return 0;			/* This indicates no command processor.  */
 
-  __sys_errno (ENOSYS);
+  __set_errno (ENOSYS);
   return -1;
 }
 weak_alias (__libc_system, system)
diff -Nur sysdeps/generic/tempname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tempname.c
--- sysdeps/generic/tempname.c	2002-03-11 09:32:01.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tempname.c	2004-11-03 02:51:44.000000000 +0100
@@ -25,11 +25,12 @@
    template suitable for use in __gen_tempname into TMPL, bounded
    by TMPL_LEN. */
 int
-__path_search (tmpl, tmpl_len, dir, pfx)
+__path_search (tmpl, tmpl_len, dir, pfx, try_tmpdir)
      char *tmpl;
      size_t tmpl_len;
      const char *dir;
      const char *pfx;
+     int try_tmpdir;
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/generic/tmpfile.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tmpfile.c
--- sysdeps/generic/tmpfile.c	2002-06-12 22:57:46.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tmpfile.c	2003-09-02 09:13:21.000000000 +0200
@@ -1,5 +1,5 @@
 /* Open a stdio stream on an anonymous temporary file.  Generic/POSIX version.
-   Copyright (C) 1991,93,96,97,98,99,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,93,1996-2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -51,7 +51,7 @@
 
   /* Note that this relies on the Unix semantics that
      a file is not really removed until it is closed.  */
-  (void) remove (buf);
+  (void) __unlink (buf);
 
   if ((f = __fdopen (fd, "w+b")) == NULL)
     __close (fd);
diff -Nur sysdeps/generic/truncate.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/truncate.c
--- sysdeps/generic/truncate.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/truncate.c	2004-06-30 09:37:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995, 1996, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,13 +21,14 @@
 
 /* Truncate PATH to LENGTH bytes.  */
 int
-truncate (path, length)
+__truncate (path, length)
      const char *path;
      off_t length;
 {
   __set_errno (ENOSYS);
   return -1;
 }
+weak_alias (__truncate, truncate)
 
 stub_warning (truncate)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/tst-stack-align.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tst-stack-align.h
--- sysdeps/generic/tst-stack-align.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/tst-stack-align.h	2003-09-17 10:37:25.000000000 +0200
@@ -0,0 +1,35 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdint.h>
+
+#define TEST_STACK_ALIGN() \
+  ({									     \
+    double _d = 12.0;							     \
+    long double _ld = 15.0;						     \
+    int _ret = 0;							     \
+    printf ("double:  %g %p %zu\n", _d, &_d, __alignof (double));	     \
+    if ((((uintptr_t) &_d) & (__alignof (double) - 1)) != 0)		     \
+      _ret = 1;								     \
+									     \
+    printf ("ldouble: %Lg %p %zu\n", _ld, &_ld, __alignof (long double));    \
+    if ((((uintptr_t) &_ld) & (__alignof (long double) - 1)) != 0)	     \
+      _ret = 1;								     \
+    _ret;								     \
+    })
diff -Nur sysdeps/generic/unsecvars.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unsecvars.h
--- sysdeps/generic/unsecvars.h	2001-11-06 00:42:49.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unsecvars.h	2004-12-07 07:54:31.000000000 +0100
@@ -5,9 +5,14 @@
   "LD_PRELOAD\0"							      \
   "LD_LIBRARY_PATH\0"							      \
   "LD_ORIGIN_PATH\0"							      \
+  "LD_DEBUG\0"								      \
   "LD_DEBUG_OUTPUT\0"							      \
   "LD_PROFILE\0"							      \
+  "LD_USE_LOAD_BIAS\0"							      \
+  "LD_DYNAMIC_WEAK\0"							      \
+  "LD_SHOW_AUXV\0"							      \
   "GCONV_PATH\0"							      \
+  "GETCONF_DIR\0"							      \
   "HOSTALIASES\0"							      \
   "LOCALDOMAIN\0"							      \
   "LOCPATH\0"								      \
diff -Nur sysdeps/generic/unwind-dw2.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2.c
--- sysdeps/generic/unwind-dw2.c	2002-01-08 07:14:10.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2.c	2004-05-18 23:18:51.000000000 +0200
@@ -1,22 +1,23 @@
 /* DWARF2 exception handling and frame unwind runtime interface routines.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
 
-   This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-   GNU CC is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   GNU CC is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License
-   along with GNU CC; see the file COPYING.  If not, write to
-   the Free Software Foundation, 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 #ifdef _LIBC
 #include <stdlib.h>
@@ -37,7 +38,7 @@
 #include "gthr.h"
 #endif
 
-#if !USING_SJLJ_EXCEPTIONS
+
 
 #ifndef STACK_GROWS_DOWNWARD
 #define STACK_GROWS_DOWNWARD 0
@@ -52,7 +53,14 @@
 #define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER
 #endif
 
-/* This is the register and unwind state for a particular frame.  */
+/* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */
+#ifndef PRE_GCC3_DWARF_FRAME_REGISTERS
+#define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS
+#endif
+
+/* This is the register and unwind state for a particular frame.  This
+   provides the information necessary to unwind up past a frame and return
+   to its caller.  */
 struct _Unwind_Context
 {
   void *reg[DWARF_FRAME_REGISTERS+1];
@@ -80,7 +88,7 @@
   {
     struct {
       union {
-	unsigned int reg;
+	_Unwind_Word reg;
 	_Unwind_Sword offset;
 	const unsigned char *exp;
       } loc;
@@ -112,8 +120,8 @@
 
   /* The information we care about from the CIE/FDE.  */
   _Unwind_Personality_Fn personality;
-  signed int data_align;
-  unsigned int code_align;
+  _Unwind_Sword data_align;
+  _Unwind_Word code_align;
   unsigned char retaddr_column;
   unsigned char fde_encoding;
   unsigned char lsda_encoding;
@@ -138,10 +146,10 @@
 read_pointer (const void *p) { const union unaligned *up = p; return up->p; }
 
 static inline int
-read_1u (const void *p) { return *(const unsigned char *)p; }
+read_1u (const void *p) { return *(const unsigned char *) p; }
 
 static inline int
-read_1s (const void *p) { return *(const signed char *)p; }
+read_1s (const void *p) { return *(const signed char *) p; }
 
 static inline int
 read_2u (const void *p) { const union unaligned *up = p; return up->u2; }
@@ -170,6 +178,14 @@
   return * (_Unwind_Word *) context->reg[index];
 }
 
+/* Get the value of the CFA as saved in CONTEXT.  */
+
+_Unwind_Word
+_Unwind_GetCFA (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->cfa;
+}
+
 /* Overwrite the saved value for register REG in CONTEXT with VAL.  */
 
 inline void
@@ -206,6 +222,17 @@
   return (_Unwind_Ptr) context->bases.func;
 }
 
+void *
+_Unwind_FindEnclosingFunction (void *pc)
+{
+  struct dwarf_eh_bases bases;
+  struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, &bases);
+  if (fde)
+    return bases.func;
+  else
+    return NULL;
+}
+
 #ifndef __ia64__
 _Unwind_Ptr
 _Unwind_GetDataRelBase (struct _Unwind_Context *context)
@@ -231,7 +258,7 @@
   const unsigned char *aug = cie->augmentation;
   const unsigned char *p = aug + strlen (aug) + 1;
   const unsigned char *ret = NULL;
-  _Unwind_Ptr tmp;
+  _Unwind_Word utmp;
 
   /* g++ v2 "eh" has pointer immediately following augmentation string,
      so it must be handled first.  */
@@ -244,8 +271,8 @@
 
   /* Immediately following the augmentation are the code and
      data alignment and return address column.  */
-  p = read_uleb128 (p, &tmp); fs->code_align = tmp;
-  p = read_sleb128 (p, &tmp); fs->data_align = (saddr) tmp;
+  p = read_uleb128 (p, &fs->code_align);
+  p = read_sleb128 (p, &fs->data_align);
   fs->retaddr_column = *p++;
   fs->lsda_encoding = DW_EH_PE_omit;
 
@@ -254,8 +281,8 @@
      the size.  */
   if (*aug == 'z')
     {
-      p = read_uleb128 (p, &tmp);
-      ret = p + tmp;
+      p = read_uleb128 (p, &utmp);
+      ret = p + utmp;
 
       fs->saw_z = 1;
       ++aug;
@@ -303,7 +330,7 @@
 execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,
 		  struct _Unwind_Context *context, _Unwind_Word initial)
 {
-  _Unwind_Word stack[64];	/* ??? Assume this is enough. */
+  _Unwind_Word stack[64];	/* ??? Assume this is enough.  */
   int stack_elt;
 
   stack[0] = initial;
@@ -312,9 +339,8 @@
   while (op_ptr < op_end)
     {
       enum dwarf_location_atom op = *op_ptr++;
-      _Unwind_Word result = 0, reg;
-      _Unwind_Sword offset;
-      _Unwind_Ptr ptrtmp;
+      _Unwind_Word result, reg, utmp;
+      _Unwind_Sword offset, stmp;
 
       switch (op)
 	{
@@ -391,12 +417,11 @@
 	  op_ptr += 8;
 	  break;
 	case DW_OP_constu:
-	  op_ptr = read_uleb128 (op_ptr, &ptrtmp);
-	  result = ptrtmp;
+	  op_ptr = read_uleb128 (op_ptr, &result);
 	  break;
 	case DW_OP_consts:
-	  op_ptr = read_sleb128 (op_ptr, &ptrtmp);
-	  result = (saddr)ptrtmp;
+	  op_ptr = read_sleb128 (op_ptr, &stmp);
+	  result = stmp;
 	  break;
 
 	case DW_OP_reg0:
@@ -434,7 +459,7 @@
 	  result = _Unwind_GetGR (context, op - DW_OP_reg0);
 	  break;
 	case DW_OP_regx:
-	  op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;
+	  op_ptr = read_uleb128 (op_ptr, &reg);
 	  result = _Unwind_GetGR (context, reg);
 	  break;
 
@@ -470,12 +495,12 @@
 	case DW_OP_breg29:
 	case DW_OP_breg30:
 	case DW_OP_breg31:
-	  op_ptr = read_sleb128 (op_ptr, &ptrtmp); offset = (saddr)ptrtmp;
+	  op_ptr = read_sleb128 (op_ptr, &offset);
 	  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;
 	  break;
 	case DW_OP_bregx:
-	  op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;
-	  op_ptr = read_sleb128 (op_ptr, &ptrtmp); offset = (saddr)ptrtmp;
+	  op_ptr = read_uleb128 (op_ptr, &reg);
+	  op_ptr = read_sleb128 (op_ptr, &offset);
 	  result = _Unwind_GetGR (context, reg) + offset;
 	  break;
 
@@ -533,14 +558,14 @@
 	    {
 	    case DW_OP_deref:
 	      {
-		void *ptr = (void *)(_Unwind_Ptr) result;
+		void *ptr = (void *) (_Unwind_Ptr) result;
 		result = (_Unwind_Ptr) read_pointer (ptr);
 	      }
 	      break;
 
 	    case DW_OP_deref_size:
 	      {
-		void *ptr = (void *)(_Unwind_Ptr) result;
+		void *ptr = (void *) (_Unwind_Ptr) result;
 		switch (*op_ptr++)
 		  {
 		  case 1:
@@ -572,12 +597,12 @@
 	      result = ~result;
 	      break;
 	    case DW_OP_plus_uconst:
-	      op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;
-	      result += reg;
+	      op_ptr = read_uleb128 (op_ptr, &utmp);
+	      result += utmp;
 	      break;
-	    /* Avoid warnings.  */
+
 	    default:
-	      break;
+	      abort ();
 	    }
 	  break;
 
@@ -597,68 +622,68 @@
 	  {
 	    /* Binary operations.  */
 	    _Unwind_Word first, second;
-	  if ((stack_elt -= 2) < 0)
-	    abort ();
-	  second = stack[stack_elt];
-	  first = stack[stack_elt + 1];
+	    if ((stack_elt -= 2) < 0)
+	      abort ();
+	    second = stack[stack_elt];
+	    first = stack[stack_elt + 1];
 
-	  switch (op)
-	    {
-	    case DW_OP_and:
-	      result = second & first;
-	      break;
-	    case DW_OP_div:
-	      result = (_Unwind_Sword)second / (_Unwind_Sword)first;
-	      break;
-	    case DW_OP_minus:
-	      result = second - first;
-	      break;
-	    case DW_OP_mod:
-	      result = (_Unwind_Sword)second % (_Unwind_Sword)first;
-	      break;
-	    case DW_OP_mul:
-	      result = second * first;
-	      break;
-	    case DW_OP_or:
-	      result = second | first;
-	      break;
-	    case DW_OP_plus:
-	      result = second + first;
-	      break;
-	    case DW_OP_shl:
-	      result = second << first;
-	      break;
-	    case DW_OP_shr:
-	      result = second >> first;
-	      break;
-	    case DW_OP_shra:
-	      result = (_Unwind_Sword)second >> first;
-	      break;
-	    case DW_OP_xor:
-	      result = second ^ first;
-	      break;
-	    case DW_OP_le:
-	      result = (_Unwind_Sword)first <= (_Unwind_Sword)second;
-	      break;
-	    case DW_OP_ge:
-	      result = (_Unwind_Sword)first >= (_Unwind_Sword)second;
-	      break;
-	    case DW_OP_eq:
-	      result = (_Unwind_Sword)first == (_Unwind_Sword)second;
-	      break;
-	    case DW_OP_lt:
-	      result = (_Unwind_Sword)first < (_Unwind_Sword)second;
-	      break;
-	    case DW_OP_gt:
-	      result = (_Unwind_Sword)first > (_Unwind_Sword)second;
-	      break;
-	    case DW_OP_ne:
-	      result = (_Unwind_Sword)first != (_Unwind_Sword)second;
-	      break;
-	    default:
-	      /* Avoid warnings.  */
-	      break;
-	    }
+	    switch (op)
+	      {
+	      case DW_OP_and:
+		result = second & first;
+		break;
+	      case DW_OP_div:
+		result = (_Unwind_Sword) second / (_Unwind_Sword) first;
+		break;
+	      case DW_OP_minus:
+		result = second - first;
+		break;
+	      case DW_OP_mod:
+		result = (_Unwind_Sword) second % (_Unwind_Sword) first;
+		break;
+	      case DW_OP_mul:
+		result = second * first;
+		break;
+	      case DW_OP_or:
+		result = second | first;
+		break;
+	      case DW_OP_plus:
+		result = second + first;
+		break;
+	      case DW_OP_shl:
+		result = second << first;
+		break;
+	      case DW_OP_shr:
+		result = second >> first;
+		break;
+	      case DW_OP_shra:
+		result = (_Unwind_Sword) second >> first;
+		break;
+	      case DW_OP_xor:
+		result = second ^ first;
+		break;
+	      case DW_OP_le:
+		result = (_Unwind_Sword) first <= (_Unwind_Sword) second;
+		break;
+	      case DW_OP_ge:
+		result = (_Unwind_Sword) first >= (_Unwind_Sword) second;
+		break;
+	      case DW_OP_eq:
+		result = (_Unwind_Sword) first == (_Unwind_Sword) second;
+		break;
+	      case DW_OP_lt:
+		result = (_Unwind_Sword) first < (_Unwind_Sword) second;
+		break;
+	      case DW_OP_gt:
+		result = (_Unwind_Sword) first > (_Unwind_Sword) second;
+		break;
+	      case DW_OP_ne:
+		result = (_Unwind_Sword) first != (_Unwind_Sword) second;
+		break;
+
+	      default:
+		abort ();
+	      }
 	  }
 	  break;
 
@@ -687,7 +712,7 @@
       /* Most things push a result value.  */
       if ((size_t) stack_elt >= sizeof(stack)/sizeof(*stack))
 	abort ();
-      stack[++stack_elt] = result;
+      stack[stack_elt++] = result;
     no_push:;
     }
 
@@ -714,20 +739,26 @@
   /* Don't allow remember/restore between CIE and FDE programs.  */
   fs->regs.prev = NULL;
 
+  /* The comparison with the return address uses < rather than <= because
+     we are only interested in the effects of code before the call; for a
+     noreturn function, the return address may point to unrelated code with
+     a different stack configuration that we are not interested in.  We
+     assume that the call itself is unwind info-neutral; if not, or if
+     there are delay instructions that adjust the stack, these must be
+     reflected at the point immediately before the call insn.  */
   while (insn_ptr < insn_end && fs->pc < context->ra)
     {
       unsigned char insn = *insn_ptr++;
-      _Unwind_Word reg;
-      _Unwind_Sword offset;
-      _Unwind_Ptr ptrtmp;
+      _Unwind_Word reg, utmp;
+      _Unwind_Sword offset, stmp;
 
       if ((insn & 0xc0) == DW_CFA_advance_loc)
 	fs->pc += (insn & 0x3f) * fs->code_align;
       else if ((insn & 0xc0) == DW_CFA_offset)
 	{
 	  reg = insn & 0x3f;
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  offset = ptrtmp * fs->data_align;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Sword) utmp * fs->data_align;
 	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[reg].loc.offset = offset;
 	}
@@ -757,33 +788,36 @@
 	  break;
 
 	case DW_CFA_offset_extended:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  offset = ptrtmp * fs->data_align;
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Sword) utmp * fs->data_align;
 	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[reg].loc.offset = offset;
 	  break;
 
 	case DW_CFA_restore_extended:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
 	  fs->regs.reg[reg].how = REG_UNSAVED;
 	  break;
 
 	case DW_CFA_undefined:
 	case DW_CFA_same_value:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  break;
+
 	case DW_CFA_nop:
 	  break;
 
 	case DW_CFA_register:
 	  {
 	    _Unwind_Word reg2;
-	    insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
-	    insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg2 = ptrtmp;
+	    insn_ptr = read_uleb128 (insn_ptr, &reg);
+	    insn_ptr = read_uleb128 (insn_ptr, &reg2);
 	    fs->regs.reg[reg].how = REG_SAVED_REG;
 	    fs->regs.reg[reg].loc.reg = reg2;
 	  }
 	  break;
-      
+
 	case DW_CFA_remember_state:
 	  {
 	    struct frame_state_reg_info *new_rs;
@@ -793,7 +827,7 @@
 		unused_rs = unused_rs->prev;
 	      }
 	    else
-	      new_rs = alloca (sizeof (struct frame_state_reg_info));
+	      new_rs = __builtin_alloca (sizeof (struct frame_state_reg_info));
 
 	    *new_rs = fs->regs;
 	    fs->regs.prev = new_rs;
@@ -810,60 +844,55 @@
 	  break;
 
 	case DW_CFA_def_cfa:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_reg = ptrtmp;
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_offset = ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  fs->cfa_offset = utmp;
 	  fs->cfa_how = CFA_REG_OFFSET;
 	  break;
 
 	case DW_CFA_def_cfa_register:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_reg = ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
 	  fs->cfa_how = CFA_REG_OFFSET;
 	  break;
 
 	case DW_CFA_def_cfa_offset:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_offset = ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  fs->cfa_offset = utmp;
 	  /* cfa_how deliberately not set.  */
 	  break;
 
 	case DW_CFA_def_cfa_expression:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
 	  fs->cfa_exp = insn_ptr;
 	  fs->cfa_how = CFA_EXP;
-	  insn_ptr += ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  insn_ptr += utmp;
 	  break;
 
 	case DW_CFA_expression:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
 	  fs->regs.reg[reg].how = REG_SAVED_EXP;
 	  fs->regs.reg[reg].loc.exp = insn_ptr;
-	  insn_ptr += ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  insn_ptr += utmp;
 	  break;
 
 	  /* From the 2.1 draft.  */
 	case DW_CFA_offset_extended_sf:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
-	  insn_ptr = read_sleb128 (insn_ptr, &ptrtmp);
-	  offset = (saddr)ptrtmp * fs->data_align;
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_sleb128 (insn_ptr, &stmp);
+	  offset = stmp * fs->data_align;
 	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[reg].loc.offset = offset;
 	  break;
-	  
+
 	case DW_CFA_def_cfa_sf:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_reg = ptrtmp;
-	  insn_ptr = read_sleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_offset = (saddr)ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
+	  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);
 	  fs->cfa_how = CFA_REG_OFFSET;
 	  break;
 
 	case DW_CFA_def_cfa_offset_sf:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  fs->cfa_offset = ptrtmp;
+	  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);
 	  /* cfa_how deliberately not set.  */
 	  break;
 
@@ -877,16 +906,15 @@
 	  break;
 
 	case DW_CFA_GNU_args_size:
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  context->args_size = ptrtmp;
+	  insn_ptr = read_uleb128 (insn_ptr, &context->args_size);
 	  break;
 
 	case DW_CFA_GNU_negative_offset_extended:
 	  /* Obsoleted by DW_CFA_offset_extended_sf, but used by
 	     older PowerPC code.  */
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;
-	  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);
-	  offset = ptrtmp * fs->data_align;
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Word) utmp * fs->data_align;
 	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[reg].loc.offset = -offset;
 	  break;
@@ -897,6 +925,11 @@
     }
 }
 
+/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for
+   its caller and decode it into FS.  This function also sets the
+   args_size and lsda members of CONTEXT, as they are really information
+   about the caller's frame.  */
+
 static _Unwind_Reason_Code
 uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 {
@@ -913,7 +946,7 @@
     {
       /* Couldn't find frame unwind info for this function.  Try a
 	 target-specific fallback mechanism.  This will necessarily
-	 not profide a personality routine or LSDA.  */
+	 not provide a personality routine or LSDA.  */
 #ifdef MD_FALLBACK_FRAME_STATE_FOR
       MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);
       return _URC_END_OF_STACK;
@@ -937,12 +970,12 @@
   execute_cfa_program (insn, end, context, fs);
 
   /* Locate augmentation for the fde.  */
-  aug = (unsigned char *)fde + sizeof (*fde);
+  aug = (unsigned char *) fde + sizeof (*fde);
   aug += 2 * size_of_encoded_value (fs->fde_encoding);
   insn = NULL;
   if (fs->saw_z)
     {
-      _Unwind_Ptr i;
+      _Unwind_Word i;
       aug = read_uleb128 (aug, &i);
       insn = aug + i;
     }
@@ -965,18 +998,24 @@
   void *eh_ptr;
   long cfa_offset;
   long args_size;
-  long reg_or_offset[DWARF_FRAME_REGISTERS+1];
+  long reg_or_offset[PRE_GCC3_DWARF_FRAME_REGISTERS+1];
   unsigned short cfa_reg;
   unsigned short retaddr_column;
-  char saved[DWARF_FRAME_REGISTERS+1];
+  char saved[PRE_GCC3_DWARF_FRAME_REGISTERS+1];
 } frame_state;
 
+#ifndef STATIC
+# define STATIC
+#endif
+
+STATIC
 struct frame_state * __frame_state_for (void *, struct frame_state *);
 
 /* Called from pre-G++ 3.0 __throw to find the registers to restore for
    a given PC_TARGET.  The caller should allocate a local variable of
    `struct frame_state' and pass its address to STATE_IN.  */
 
+STATIC
 struct frame_state *
 __frame_state_for (void *pc_target, struct frame_state *state_in)
 {
@@ -995,7 +1034,7 @@
   if (fs.cfa_how == CFA_EXP)
     return 0;
 
-  for (reg = 0; reg < DWARF_FRAME_REGISTERS + 1; reg++)
+  for (reg = 0; reg < PRE_GCC3_DWARF_FRAME_REGISTERS + 1; reg++)
     {
       state_in->saved[reg] = fs.regs.reg[reg].how;
       switch (state_in->saved[reg])
@@ -1030,34 +1069,48 @@
   void *cfa;
   long i;
 
+#ifdef EH_RETURN_STACKADJ_RTX
+  /* Special handling here: Many machines do not use a frame pointer,
+     and track the CFA only through offsets from the stack pointer from
+     one frame to the next.  In this case, the stack pointer is never
+     stored, so it has no saved address in the context.  What we do
+     have is the CFA from the previous stack frame.
+
+     In very special situations (such as unwind info for signal return),
+     there may be location expressions that use the stack pointer as well.
+
+     Do this conditionally for one frame.  This allows the unwind info
+     for one frame to save a copy of the stack pointer from the previous
+     frame, and be able to use much easier CFA mechanisms to do it.
+     Always zap the saved stack pointer value for the next frame; carrying
+     the value over from one frame to another doesn't make sense.  */
+
+  _Unwind_Word tmp_sp;
+
+  if (!orig_context.reg[__builtin_dwarf_sp_column ()])
+    {
+      tmp_sp = (_Unwind_Ptr) context->cfa;
+      orig_context.reg[__builtin_dwarf_sp_column ()] = &tmp_sp;
+    }
+  context->reg[__builtin_dwarf_sp_column ()] = NULL;
+#endif
+
   /* Compute this frame's CFA.  */
   switch (fs->cfa_how)
     {
     case CFA_REG_OFFSET:
-      /* Special handling here: Many machines do not use a frame pointer,
-	 and track the CFA only through offsets from the stack pointer from
-	 one frame to the next.  In this case, the stack pointer is never
-	 stored, so it has no saved address in the context.  What we do 
-	 have is the CFA from the previous stack frame.  */
-      if (context->reg[fs->cfa_reg] == NULL)
-	cfa = context->cfa;
-      else
-	cfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (context, fs->cfa_reg);
+      cfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (&orig_context, fs->cfa_reg);
       cfa += fs->cfa_offset;
       break;
 
     case CFA_EXP:
-      /* ??? No way of knowing what register number is the stack pointer
-	 to do the same sort of handling as above.  Assume that if the
-	 CFA calculation is so complicated as to require a stack program
-	 that this will not be a problem.  */
       {
 	const unsigned char *exp = fs->cfa_exp;
-	_Unwind_Ptr len;
+	_Unwind_Word len;
 
 	exp = read_uleb128 (exp, &len);
 	cfa = (void *) (_Unwind_Ptr)
-	  execute_stack_op (exp, exp + len, context, 0);
+	  execute_stack_op (exp, exp + len, &orig_context, 0);
 	break;
       }
 
@@ -1072,16 +1125,19 @@
       {
       case REG_UNSAVED:
 	break;
+
       case REG_SAVED_OFFSET:
 	context->reg[i] = cfa + fs->regs.reg[i].loc.offset;
 	break;
+
       case REG_SAVED_REG:
 	context->reg[i] = orig_context.reg[fs->regs.reg[i].loc.reg];
 	break;
+
       case REG_SAVED_EXP:
 	{
 	  const unsigned char *exp = fs->regs.reg[i].loc.exp;
-	  _Unwind_Ptr len;
+	  _Unwind_Word len;
 	  _Unwind_Ptr val;
 
 	  exp = read_uleb128 (exp, &len);
@@ -1093,6 +1149,11 @@
       }
 }
 
+/* CONTEXT describes the unwind state for a frame, and FS describes the FDE
+   of its caller.  Update CONTEXT to refer to the caller as well.  Note
+   that the args_size and lsda members are not updated here, but later in
+   uw_frame_state_for.  */
+
 static void
 uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 {
@@ -1106,15 +1167,17 @@
 
 /* Fill in CONTEXT for top-of-stack.  The only valid registers at this
    level will be the return address and the CFA.  */
-   
-#define uw_init_context(CONTEXT)					\
-do {									\
-  /* Do any necessary initialization to access arbitrary stack frames.	\
-     On the SPARC, this means flushing the register windows.  */	\
-  __builtin_unwind_init ();						\
-  uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),			\
-		     __builtin_return_address (0));			\
-} while (0)
+
+#define uw_init_context(CONTEXT)					   \
+  do									   \
+    {									   \
+      /* Do any necessary initialization to access arbitrary stack frames. \
+	 On the SPARC, this means flushing the register windows.  */	   \
+      __builtin_unwind_init ();						   \
+      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
+			 __builtin_return_address (0));			   \
+    }									   \
+  while (0)
 
 static void
 uw_init_context_1 (struct _Unwind_Context *context,
@@ -1122,6 +1185,7 @@
 {
   void *ra = __builtin_extract_return_addr (__builtin_return_address (0));
   _Unwind_FrameState fs;
+  _Unwind_Word sp_slot;
 
   memset (context, 0, sizeof (struct _Unwind_Context));
   context->ra = ra;
@@ -1130,9 +1194,10 @@
     abort ();
 
   /* Force the frame state to use the known cfa value.  */
-  context->cfa = outer_cfa;
+  sp_slot = (_Unwind_Ptr) outer_cfa;
+  context->reg[__builtin_dwarf_sp_column ()] = &sp_slot;
   fs.cfa_how = CFA_REG_OFFSET;
-  fs.cfa_reg = 0;
+  fs.cfa_reg = __builtin_dwarf_sp_column ();
   fs.cfa_offset = 0;
 
   uw_update_context_1 (context, &fs);
@@ -1148,12 +1213,14 @@
    macro because __builtin_eh_return must be invoked in the context of
    our caller.  */
 
-#define uw_install_context(CURRENT, TARGET)				\
-do {									\
-  long offset = uw_install_context_1 ((CURRENT), (TARGET));		\
-  void *handler = __builtin_frob_return_addr ((TARGET)->ra);		\
-  __builtin_eh_return (offset, handler);				\
-} while (0)
+#define uw_install_context(CURRENT, TARGET)				 \
+  do									 \
+    {									 \
+      long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \
+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \
+      __builtin_eh_return (offset, handler);				 \
+    }									 \
+  while (0)
 
 static inline void
 init_dwarf_reg_size_table (void)
@@ -1187,11 +1254,26 @@
 	memcpy (c, t, dwarf_reg_size_table[i]);
     }
 
-  /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
-  if (STACK_GROWS_DOWNWARD)
-    return target->cfa - current->cfa + target->args_size;
-  else
-    return current->cfa - target->cfa - target->args_size;
+#ifdef EH_RETURN_STACKADJ_RTX
+  {
+    void *target_cfa;
+
+    /* If the last frame records a saved stack pointer, use it.  */
+    if (target->reg[__builtin_dwarf_sp_column ()])
+      target_cfa = (void *)(_Unwind_Ptr)
+        _Unwind_GetGR (target, __builtin_dwarf_sp_column ());
+    else
+      target_cfa = target->cfa;
+
+    /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
+    if (STACK_GROWS_DOWNWARD)
+      return target_cfa - current->cfa + target->args_size;
+    else
+      return current->cfa - target_cfa - target->args_size;
+  }
+#else
+  return 0;
+#endif
 }
 
 static inline _Unwind_Ptr
@@ -1204,4 +1286,3 @@
 #include "unwind.inc"
 
 #endif /* _LIBC */
-#endif /* !USING_SJLJ_EXCEPTIONS */
diff -Nur sysdeps/generic/unwind-dw2-fde.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde.c
--- sysdeps/generic/unwind-dw2-fde.c	2002-05-15 01:46:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde.c	2004-05-18 23:18:52.000000000 +0200
@@ -1,32 +1,24 @@
 /* Subroutines needed for unwinding stack frames for exception handling.  */
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
    Contributed by Jason Merrill <jason@cygnus.com>.
 
-This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-GNU CC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GNU CC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 59 Temple Place - Suite 330,
-Boston, MA 02111-1307, USA.  */
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 #ifdef _LIBC
 # include <shlib-compat.h>
@@ -44,6 +36,7 @@
 #include <unwind-pe.h>
 #include <unwind-dw2-fde.h>
 #else
+#ifndef _Unwind_Find_FDE
 #include "tconfig.h"
 #include "tsystem.h"
 #include "dwarf2.h"
@@ -53,6 +46,7 @@
 #include "unwind-dw2-fde.h"
 #include "gthr.h"
 #endif
+#endif
 
 /* The unseen_objects list contains objects that have been registered
    but not yet categorized in any way.  The seen_objects list has had
@@ -109,7 +103,7 @@
 			     void *tbase, void *dbase)
 {
   /* If .eh_frame is empty, don't register at all.  */
-  if (*(uword *)begin == 0)
+  if (*(uword *) begin == 0)
     return;
 
   ob->pc_begin = (void *)-1;
@@ -118,6 +112,9 @@
   ob->u.single = begin;
   ob->s.i = 0;
   ob->s.b.encoding = DW_EH_PE_omit;
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  ob->fde_end = NULL;
+#endif
 
   init_object_mutex_once ();
   __gthread_mutex_lock (&object_mutex);
@@ -141,7 +138,7 @@
   struct object *ob;
 
   /* If .eh_frame is empty, don't register at all.  */
-  if (*(uword *)begin == 0)
+  if (*(uword *) begin == 0)
     return;
 
   ob = (struct object *) malloc (sizeof (struct object));
@@ -206,7 +203,7 @@
   struct object *ob = 0;
 
   /* If .eh_frame is empty, we haven't registered.  */
-  if (*(uword *)begin == 0)
+  if (*(uword *) begin == 0)
     return ob;
 
   init_object_mutex_once ();
@@ -260,7 +257,7 @@
 __deregister_frame (void *begin)
 {
   /* If .eh_frame is empty, we haven't registered.  */
-  if (*(uword *)begin != 0)
+  if (*(uword *) begin != 0)
     free (INTUSE(__deregister_frame_info_bases) (begin));
 }
 
@@ -297,18 +294,20 @@
 {
   const unsigned char *aug, *p;
   _Unwind_Ptr dummy;
+  _Unwind_Word utmp;
+  _Unwind_Sword stmp;
 
   aug = cie->augmentation;
   if (aug[0] != 'z')
     return DW_EH_PE_absptr;
 
   p = aug + strlen (aug) + 1;		/* Skip the augmentation string.  */
-  p = read_uleb128 (p, &dummy);		/* Skip code alignment.  */
-  p = read_sleb128 (p, &dummy);		/* Skip data alignment.  */
+  p = read_uleb128 (p, &utmp);		/* Skip code alignment.  */
+  p = read_sleb128 (p, &stmp);		/* Skip data alignment.  */
   p++;					/* Skip return address column.  */
 
   aug++;				/* Skip 'z' */
-  p = read_uleb128 (p, &dummy);		/* Skip augmentation length.  */
+  p = read_uleb128 (p, &utmp);		/* Skip augmentation length.  */
   while (1)
     {
       /* This is what we're looking for.  */
@@ -345,14 +344,21 @@
 
 /* Comparison routines.  Three variants of increasing complexity.  */
 
-static saddr
+static int
 fde_unencoded_compare (struct object *ob __attribute__((unused)),
 		       fde *x, fde *y)
 {
-  return *(saddr *)x->pc_begin - *(saddr *)y->pc_begin;
+  _Unwind_Ptr x_ptr = *(_Unwind_Ptr *) x->pc_begin;
+  _Unwind_Ptr y_ptr = *(_Unwind_Ptr *) y->pc_begin;
+
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
 }
 
-static saddr
+static int
 fde_single_encoding_compare (struct object *ob, fde *x, fde *y)
 {
   _Unwind_Ptr base, x_ptr, y_ptr;
@@ -361,10 +367,14 @@
   read_encoded_value_with_base (ob->s.b.encoding, base, x->pc_begin, &x_ptr);
   read_encoded_value_with_base (ob->s.b.encoding, base, y->pc_begin, &y_ptr);
 
-  return x_ptr - y_ptr;
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
 }
 
-static saddr
+static int
 fde_mixed_encoding_compare (struct object *ob, fde *x, fde *y)
 {
   int x_encoding, y_encoding;
@@ -378,10 +388,14 @@
   read_encoded_value_with_base (y_encoding, base_from_object (y_encoding, ob),
 				y->pc_begin, &y_ptr);
 
-  return x_ptr - y_ptr;
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
 }
 
-typedef saddr (*fde_compare_t) (struct object *, fde *, fde *);
+typedef int (*fde_compare_t) (struct object *, fde *, fde *);
 
 
 /* This is a special mix of insertion sort and heap sort, optimized for
@@ -401,7 +415,7 @@
   struct fde_vector *erratic;
 };
 
-static inline int
+static int
 start_fde_sort (struct fde_accumulator *accu, size_t count)
 {
   size_t size;
@@ -439,7 +453,7 @@
    chain to determine what should be placed in the ERRATIC array, and
    what is the linear sequence.  This overlay is safe from aliasing.  */
 
-static inline void
+static void
 fde_split (struct object *ob, fde_compare_t fde_compare,
 	   struct fde_vector *linear, struct fde_vector *erratic)
 {
@@ -459,13 +473,13 @@
       fde **probe;
 
       for (probe = chain_end;
-           probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;
-           probe = chain_end)
-        {
-          chain_end = (fde **)erratic->array[probe - linear->array];
-          erratic->array[probe - linear->array] = NULL;
-        }
-      erratic->array[i] = (fde *)chain_end;
+	   probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;
+	   probe = chain_end)
+	{
+	  chain_end = (fde **) erratic->array[probe - linear->array];
+	  erratic->array[probe - linear->array] = NULL;
+	}
+      erratic->array[i] = (fde *) chain_end;
       chain_end = &linear->array[i];
     }
 
@@ -490,11 +504,11 @@
 {
   /* For a description of this algorithm, see:
      Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,
-     p. 60-61. */
+     p. 60-61.  */
   fde ** a = erratic->array;
   /* A portion of the array is called a "heap" if for all i>=0:
      If i and 2i+1 are valid indices, then a[i] >= a[2i+1].
-     If i and 2i+2 are valid indices, then a[i] >= a[2i+2]. */
+     If i and 2i+2 are valid indices, then a[i] >= a[2i+2].  */
 #define SWAP(x,y) do { fde * tmp = x; x = y; y = tmp; } while (0)
   size_t n = erratic->count;
   size_t m = n;
@@ -502,54 +516,54 @@
 
   while (m > 0)
     {
-      /* Invariant: a[m..n-1] is a heap. */
+      /* Invariant: a[m..n-1] is a heap.  */
       m--;
       for (i = m; 2*i+1 < n; )
-        {
-          if (2*i+2 < n
-              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0
-              && fde_compare (ob, a[2*i+2], a[i]) > 0)
-            {
-              SWAP (a[i], a[2*i+2]);
-              i = 2*i+2;
-            }
-          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)
-            {
-              SWAP (a[i], a[2*i+1]);
-              i = 2*i+1;
-            }
-          else
-            break;
-        }
+	{
+	  if (2*i+2 < n
+	      && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0
+	      && fde_compare (ob, a[2*i+2], a[i]) > 0)
+	    {
+	      SWAP (a[i], a[2*i+2]);
+	      i = 2*i+2;
+	    }
+	  else if (fde_compare (ob, a[2*i+1], a[i]) > 0)
+	    {
+	      SWAP (a[i], a[2*i+1]);
+	      i = 2*i+1;
+	    }
+	  else
+	    break;
+	}
     }
   while (n > 1)
     {
-      /* Invariant: a[0..n-1] is a heap. */
+      /* Invariant: a[0..n-1] is a heap.  */
       n--;
       SWAP (a[0], a[n]);
       for (i = 0; 2*i+1 < n; )
-        {
-          if (2*i+2 < n
-              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0
-              && fde_compare (ob, a[2*i+2], a[i]) > 0)
-            {
-              SWAP (a[i], a[2*i+2]);
-              i = 2*i+2;
-            }
-          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)
-            {
-              SWAP (a[i], a[2*i+1]);
-              i = 2*i+1;
-            }
-          else
-            break;
-        }
+	{
+	  if (2*i+2 < n
+	      && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0
+	      && fde_compare (ob, a[2*i+2], a[i]) > 0)
+	    {
+	      SWAP (a[i], a[2*i+2]);
+	      i = 2*i+2;
+	    }
+	  else if (fde_compare (ob, a[2*i+1], a[i]) > 0)
+	    {
+	      SWAP (a[i], a[2*i+1]);
+	      i = 2*i+1;
+	    }
+	  else
+	    break;
+	}
     }
 #undef SWAP
 }
 
-/* Merge V1 and V2, both sorted, and put the result into V1. */
-static inline void
+/* Merge V1 and V2, both sorted, and put the result into V1.  */
+static void
 fde_merge (struct object *ob, fde_compare_t fde_compare,
 	   struct fde_vector *v1, struct fde_vector *v2)
 {
@@ -560,21 +574,23 @@
   if (i2 > 0)
     {
       i1 = v1->count;
-      do {
-        i2--;
-        fde2 = v2->array[i2];
-        while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)
-          {
-            v1->array[i1+i2] = v1->array[i1-1];
-            i1--;
-          }
-        v1->array[i1+i2] = fde2;
-      } while (i2 > 0);
+      do
+	{
+	  i2--;
+	  fde2 = v2->array[i2];
+	  while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)
+	    {
+	      v1->array[i1+i2] = v1->array[i1-1];
+	      i1--;
+	    }
+	  v1->array[i1+i2] = fde2;
+	}
+      while (i2 > 0);
       v1->count += v2->count;
     }
 }
 
-static inline void
+static void
 end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)
 {
   fde_compare_t fde_compare;
@@ -619,7 +635,7 @@
   int encoding = DW_EH_PE_absptr;
   _Unwind_Ptr base = 0;
 
-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
     {
       struct dwarf_cie *this_cie;
       _Unwind_Ptr mask, pc_begin;
@@ -659,8 +675,8 @@
 	continue;
 
       count += 1;
-      if ((void *)pc_begin < ob->pc_begin)
-	ob->pc_begin = (void *)pc_begin;
+      if ((void *) pc_begin < ob->pc_begin)
+	ob->pc_begin = (void *) pc_begin;
     }
 
   return count;
@@ -673,7 +689,7 @@
   int encoding = ob->s.b.encoding;
   _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);
 
-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
     {
       struct dwarf_cie *this_cie;
 
@@ -696,7 +712,7 @@
 
       if (encoding == DW_EH_PE_absptr)
 	{
-	  if (*(_Unwind_Ptr *)this_fde->pc_begin == 0)
+	  if (*(_Unwind_Ptr *) this_fde->pc_begin == 0)
 	    continue;
 	}
       else
@@ -729,7 +745,7 @@
    be faster.  We can be called multiple times, should we have failed to
    allocate a sorted fde array on a previous occasion.  */
 
-static inline void
+static void
 init_object (struct object* ob)
 {
   struct fde_accumulator accu;
@@ -764,7 +780,7 @@
     {
       fde **p;
       for (p = ob->u.array; *p; ++p)
-        add_fdes (ob, &accu, *p);
+	add_fdes (ob, &accu, *p);
     }
   else
     add_fdes (ob, &accu, ob->u.single);
@@ -790,7 +806,7 @@
   int encoding = ob->s.b.encoding;
   _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);
 
-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
     {
       struct dwarf_cie *this_cie;
       _Unwind_Ptr pc_begin, pc_range;
@@ -814,8 +830,8 @@
 
       if (encoding == DW_EH_PE_absptr)
 	{
-	  pc_begin = ((_Unwind_Ptr *)this_fde->pc_begin)[0];
-	  pc_range = ((_Unwind_Ptr *)this_fde->pc_begin)[1];
+	  pc_begin = ((_Unwind_Ptr *) this_fde->pc_begin)[0];
+	  pc_range = ((_Unwind_Ptr *) this_fde->pc_begin)[1];
 	  if (pc_begin == 0)
 	    continue;
 	}
@@ -842,8 +858,8 @@
 	    continue;
 	}
 
-      if ((_Unwind_Ptr)pc - pc_begin < pc_range)
-        return this_fde;
+      if ((_Unwind_Ptr) pc - pc_begin < pc_range)
+	return this_fde;
     }
 
   return NULL;
@@ -852,7 +868,7 @@
 /* Binary search for an FDE containing the given PC.  Here are three
    implementations of increasing complexity.  */
 
-static inline fde *
+static fde *
 binary_search_unencoded_fdes (struct object *ob, void *pc)
 {
   struct fde_vector *vec = ob->u.sort;
@@ -865,8 +881,8 @@
       void *pc_begin;
       uaddr pc_range;
 
-      pc_begin = ((void **)f->pc_begin)[0];
-      pc_range = ((uaddr *)f->pc_begin)[1];
+      pc_begin = ((void **) f->pc_begin)[0];
+      pc_range = ((uaddr *) f->pc_begin)[1];
 
       if (pc < pc_begin)
 	hi = i;
@@ -879,7 +895,7 @@
   return NULL;
 }
 
-static inline fde *
+static fde *
 binary_search_single_encoding_fdes (struct object *ob, void *pc)
 {
   struct fde_vector *vec = ob->u.sort;
@@ -898,9 +914,9 @@
 					&pc_begin);
       read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);
 
-      if ((_Unwind_Ptr)pc < pc_begin)
+      if ((_Unwind_Ptr) pc < pc_begin)
 	hi = i;
-      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)
+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)
 	lo = i + 1;
       else
 	return f;
@@ -909,7 +925,7 @@
   return NULL;
 }
 
-static inline fde *
+static fde *
 binary_search_mixed_encoding_fdes (struct object *ob, void *pc)
 {
   struct fde_vector *vec = ob->u.sort;
@@ -929,9 +945,9 @@
 					f->pc_begin, &pc_begin);
       read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);
 
-      if ((_Unwind_Ptr)pc < pc_begin)
+      if ((_Unwind_Ptr) pc < pc_begin)
 	hi = i;
-      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)
+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)
 	lo = i + 1;
       else
 	return f;
@@ -969,14 +985,14 @@
     {
       /* Long slow labourious linear search, cos we've no memory.  */
       if (ob->s.b.from_array)
-        {
-          fde **p;
+	{
+	  fde **p;
 	  for (p = ob->u.array; *p ; p++)
 	    {
 	      fde *f = linear_search_fdes (ob, *p, pc);
-              if (f)
+	      if (f)
 		return f;
-            }
+	    }
 	  return NULL;
 	}
       else
diff -Nur sysdeps/generic/unwind-dw2-fde-glibc.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde-glibc.c
--- sysdeps/generic/unwind-dw2-fde-glibc.c	2002-08-08 04:08:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde-glibc.c	2004-05-25 20:48:24.000000000 +0200
@@ -1,29 +1,22 @@
 /* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
    Contributed by Jakub Jelinek <jakub@redhat.com>.
 
-   This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-   GNU CC is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   GNU CC is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License
-   along with GNU CC; see the file COPYING.  If not, write to
-   the Free Software Foundation, 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, if you link this library with other files,
-   some of which are compiled with GCC, to produce an executable,
-   this library does not by itself cause the resulting executable
-   to be covered by the GNU General Public License.
-   This exception does not however invalidate any other reasons why
-   the executable file might be covered by the GNU General Public License.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 /* Locate the FDE entry for a given address, using PT_GNU_EH_FRAME ELF
    segment and dl_iterate_phdr to avoid register/deregister calls at
diff -Nur sysdeps/generic/unwind-dw2-fde.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde.h
--- sysdeps/generic/unwind-dw2-fde.h	2001-11-16 00:09:20.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-dw2-fde.h	2004-05-18 23:18:51.000000000 +0200
@@ -1,32 +1,24 @@
 /* Subroutines needed for unwinding stack frames for exception handling.  */
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
    Contributed by Jason Merrill <jason@cygnus.com>.
 
-This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-GNU CC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GNU CC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 59 Temple Place - Suite 330,
-Boston, MA 02111-1307, USA.  */
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 
 struct fde_vector
@@ -57,12 +49,16 @@
       unsigned long mixed_encoding : 1;
       unsigned long encoding : 8;
       /* ??? Wish there was an easy way to detect a 64-bit host here;
-	 we've got 32 bits left to play with... */
+	 we've got 32 bits left to play with...  */
       unsigned long count : 21;
     } b;
     size_t i;
   } s;
 
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  char *fde_end;
+#endif
+
   struct object *next;
 };
 #endif
@@ -116,7 +112,7 @@
    is located, and what the register lifetimes and stack layout are
    within the function.
 
-   The data structures are defined in the DWARF specfication, although
+   The data structures are defined in the DWARF specification, although
    not in a very readable way (see LITERATURE).
 
    Every time an exception is thrown, the code needs to locate the FDE
@@ -125,7 +121,7 @@
    a) in a linear search, find the shared image (i.e. DLL) containing
       the PC
    b) using the FDE table for that shared object, locate the FDE using
-      binary search (which requires the sorting).  */   
+      binary search (which requires the sorting).  */
 
 /* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,
    to distinguish it from a valid FDE.  FDEs are aligned to an addressing
@@ -159,7 +155,17 @@
 static inline fde *
 next_fde (fde *f)
 {
-  return (fde *)((char *)f + f->length + sizeof (f->length));
+  return (fde *) ((char *) f + f->length + sizeof (f->length));
 }
 
 extern fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
+
+static inline int
+last_fde (struct object *obj __attribute__ ((__unused__)), fde *f)
+{
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  return (char *)f == obj->fde_end || f->length == 0;
+#else
+  return f->length == 0;
+#endif
+}
diff -Nur sysdeps/generic/unwind.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind.h
--- sysdeps/generic/unwind.h	2001-11-16 00:09:20.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind.h	2004-05-18 23:18:51.000000000 +0200
@@ -1,26 +1,29 @@
 /* Exception handling and frame unwind runtime interface routines.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
 
-   This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-   GNU CC is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   GNU CC is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License
-   along with GNU CC; see the file COPYING.  If not, write to
-   the Free Software Foundation, 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 /* This is derived from the C++ ABI for IA-64.  Where we diverge
    for cross-architecture compatibility are noted with "@@@".  */
 
+#ifndef _UNWIND_H
+#define _UNWIND_H	1
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -31,7 +34,12 @@
    inefficient for 32-bit and smaller machines.  */
 typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));
 typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));
+#if defined(__ia64__) && defined(__hpux__)
+typedef unsigned _Unwind_Ptr __attribute__((__mode__(__word__)));
+#else
 typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));
+#endif
+typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));
 
 /* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and
    consumer of an exception.  We'll go along with this for now even on
@@ -87,6 +95,7 @@
 #define _UA_CLEANUP_PHASE	2
 #define _UA_HANDLER_FRAME	4
 #define _UA_FORCE_UNWIND	8
+#define _UA_END_OF_STACK	16
 
 /* This is an opaque type used to refer to a system-specific data
    structure used by the system unwinder. This context is created and
@@ -114,6 +123,14 @@
    e.g. executing cleanup code, and not to implement rethrowing.  */
 extern void _Unwind_Resume (struct _Unwind_Exception *);
 
+/* @@@ Use unwind data to perform a stack backtrace.  The trace callback
+   is called for every stack frame in the call chain, but no cleanup
+   actions are performed.  */
+typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)
+     (struct _Unwind_Context *, void *);
+
+extern _Unwind_Reason_Code _Unwind_Backtrace (_Unwind_Trace_Fn, void *);
+
 /* These functions are used for communicating information about the unwind
    context (i.e. the unwind descriptors and the user register state) between
    the unwind library and the personality routine and landing pad.  Only
@@ -125,6 +142,9 @@
 extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);
 extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);
 
+/* @@@ Retrieve the CFA of the given context.  */
+extern _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);
+
 extern void *_Unwind_GetLanguageSpecificData (struct _Unwind_Context *);
 
 extern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);
@@ -135,15 +155,15 @@
    library and language-specific exception handling semantics.  It is
    specific to the code fragment described by an unwind info block, and
    it is always referenced via the pointer in the unwind info block, and
-   hence it has no ABI-specified name. 
+   hence it has no ABI-specified name.
 
    Note that this implies that two different C++ implementations can
    use different names, and have different contents in the language
-   specific data area.  Moreover, that the language specific data 
+   specific data area.  Moreover, that the language specific data
    area contains no version info because name of the function invoked
    provides more effective versioning by detecting at link time the
    lack of code to handle the different data format.  */
-   
+
 typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)
      (int, _Unwind_Action, _Unwind_Exception_Class,
       struct _Unwind_Exception *, struct _Unwind_Context *);
@@ -181,11 +201,20 @@
   abort ();
   return 0;
 }
+
+/* @@@ Retrieve the Backing Store Pointer of the given context.  */
+extern _Unwind_Word _Unwind_GetBSP (struct _Unwind_Context *);
 #else
 extern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);
 extern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);
 #endif
 
+/* @@@ Given an address, return the entry point of the function that
+   contains it.  */
+extern void * _Unwind_FindEnclosingFunction (void *pc);
+
 #ifdef __cplusplus
 }
 #endif
+
+#endif	/* unwind.h */
diff -Nur sysdeps/generic/unwind-pe.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-pe.c
--- sysdeps/generic/unwind-pe.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-pe.c	2004-03-10 11:02:31.000000000 +0100
@@ -0,0 +1,5 @@
+#include <stdlib.h>
+#include <unwind.h>
+
+#define _LIBC_DEFINITIONS
+#include "unwind-pe.h"
diff -Nur sysdeps/generic/unwind-pe.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-pe.h
--- sysdeps/generic/unwind-pe.h	2002-03-18 23:19:28.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/unwind-pe.h	2004-05-18 23:18:51.000000000 +0200
@@ -1,28 +1,28 @@
 /* Exception handling and frame unwind runtime interface routines.
    Copyright (C) 2001, 2002 Free Software Foundation, Inc.
 
-   This file is part of GNU CC.
+   This file is part of the GNU C Library.
 
-   GNU CC is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   GNU CC is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License
-   along with GNU CC; see the file COPYING.  If not, write to
-   the Free Software Foundation, 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 /* @@@ Really this should be out of line, but this also causes link
    compatibility problems with the base ABI.  This is slightly better
    than duplicating code, however.  */
 
-/* If using C++, references to abort have to be qualified with std::. */
+/* If using C++, references to abort have to be qualified with std::.  */
 #if __cplusplus
 #define __gxx_abort std::abort
 #else
@@ -52,28 +52,44 @@
 #define DW_EH_PE_indirect	0x80
 
 
-#ifdef _LIBC
+#if defined(_LIBC)
+
 /* Prototypes.  */
-extern unsigned int size_of_encoded_value (unsigned char encoding);
+extern unsigned int size_of_encoded_value (unsigned char encoding)
+  attribute_hidden;
+
 extern const unsigned char *read_encoded_value_with_base
   (unsigned char encoding, _Unwind_Ptr base,
-   const unsigned char *p, _Unwind_Ptr *val);
-#endif
+   const unsigned char *p, _Unwind_Ptr *val)
+  attribute_hidden;
 
+extern const unsigned char * read_encoded_value
+  (struct _Unwind_Context *context, unsigned char encoding,
+   const unsigned char *p, _Unwind_Ptr *val)
+  attribute_hidden;
+
+extern const unsigned char * read_uleb128 (const unsigned char *p,
+					   _Unwind_Word *val)
+  attribute_hidden;
+extern const unsigned char * read_sleb128 (const unsigned char *p,
+					   _Unwind_Sword *val)
+  attribute_hidden;
 
+#endif
+#if defined(_LIBC) && defined(_LIBC_DEFINITIONS)
+
+#ifdef _LIBC
+#define STATIC
+#else
+#define STATIC static
+#endif
 
 /* Given an encoding, return the number of bytes the format occupies.
    This is only defined for fixed-size encodings, and so does not
    include leb128.  */
 
-#ifndef _LIBC
-static
-#endif
-unsigned int
+STATIC unsigned int
 size_of_encoded_value (unsigned char encoding)
-#if defined(_LIBC) && !defined(NO_BASE_OF_ENCODED_VALUE)
-;
-#else
 {
   if (encoding == DW_EH_PE_omit)
     return 0;
@@ -91,7 +107,6 @@
     }
   __gxx_abort ();
 }
-#endif
 
 #ifndef NO_BASE_OF_ENCODED_VALUE
 
@@ -100,7 +115,7 @@
    read_encoded_value_with_base for use when the _Unwind_Context is
    not available.  */
 
-static _Unwind_Ptr
+STATIC _Unwind_Ptr
 base_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)
 {
   if (encoding == DW_EH_PE_omit)
@@ -125,19 +140,64 @@
 
 #endif
 
+/* Read an unsigned leb128 value from P, store the value in VAL, return
+   P incremented past the value.  We assume that a word is large enough to
+   hold any value so encoded; if it is smaller than a pointer on some target,
+   pointers should not be leb128 encoded on that target.  */
+
+STATIC const unsigned char *
+read_uleb128 (const unsigned char *p, _Unwind_Word *val)
+{
+  unsigned int shift = 0;
+  unsigned char byte;
+  _Unwind_Word result;
+
+  result = 0;
+  do
+    {
+      byte = *p++;
+      result |= (byte & 0x7f) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  *val = result;
+  return p;
+}
+
+/* Similar, but read a signed leb128 value.  */
+
+STATIC const unsigned char *
+read_sleb128 (const unsigned char *p, _Unwind_Sword *val)
+{
+  unsigned int shift = 0;
+  unsigned char byte;
+  _Unwind_Word result;
+
+  result = 0;
+  do
+    {
+      byte = *p++;
+      result |= (byte & 0x7f) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  /* Sign-extend a negative value.  */
+  if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)
+    result |= -(1L << shift);
+
+  *val = (_Unwind_Sword) result;
+  return p;
+}
+
 /* Load an encoded value from memory at P.  The value is returned in VAL;
    The function returns P incremented past the value.  BASE is as given
    by base_of_encoded_value for this encoding in the appropriate context.  */
 
-#ifndef _LIBC
-static
-#endif
-const unsigned char *
+STATIC const unsigned char *
 read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,
 			      const unsigned char *p, _Unwind_Ptr *val)
-#if defined(_LIBC) && !defined(NO_BASE_OF_ENCODED_VALUE)
-;
-#else
 {
   union unaligned
     {
@@ -151,56 +211,37 @@
     } __attribute__((__packed__));
 
   union unaligned *u = (union unaligned *) p;
-  _Unwind_Ptr result;
+  _Unwind_Internal_Ptr result;
 
   if (encoding == DW_EH_PE_aligned)
     {
-      _Unwind_Ptr a = (_Unwind_Ptr)p;
+      _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;
       a = (a + sizeof (void *) - 1) & - sizeof(void *);
-      result = *(_Unwind_Ptr *) a;
-      p = (const unsigned char *)(a + sizeof (void *));
+      result = *(_Unwind_Internal_Ptr *) a;
+      p = (const unsigned char *) (a + sizeof (void *));
     }
   else
     {
       switch (encoding & 0x0f)
 	{
 	case DW_EH_PE_absptr:
-	  result = (_Unwind_Ptr) u->ptr;
+	  result = (_Unwind_Internal_Ptr) u->ptr;
 	  p += sizeof (void *);
 	  break;
 
 	case DW_EH_PE_uleb128:
 	  {
-	    unsigned int shift = 0;
-	    unsigned char byte;
-
-	    result = 0;
-	    do
-	      {
-		byte = *p++;
-		result |= (_Unwind_Ptr)(byte & 0x7f) << shift;
-		shift += 7;
-	      }
-	    while (byte & 0x80);
+	    _Unwind_Word tmp;
+	    p = read_uleb128 (p, &tmp);
+	    result = (_Unwind_Internal_Ptr) tmp;
 	  }
 	  break;
 
 	case DW_EH_PE_sleb128:
 	  {
-	    unsigned int shift = 0;
-	    unsigned char byte;
-
-	    result = 0;
-	    do
-	      {
-		byte = *p++;
-		result |= (_Unwind_Ptr)(byte & 0x7f) << shift;
-		shift += 7;
-	      }
-	    while (byte & 0x80);
-
-	    if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)
-	      result |= -(1L << shift);
+	    _Unwind_Sword tmp;
+	    p = read_sleb128 (p, &tmp);
+	    result = (_Unwind_Internal_Ptr) tmp;
 	  }
 	  break;
 
@@ -237,23 +278,22 @@
       if (result != 0)
 	{
 	  result += ((encoding & 0x70) == DW_EH_PE_pcrel
-		     ? (_Unwind_Ptr)u : base);
+		     ? (_Unwind_Internal_Ptr) u : base);
 	  if (encoding & DW_EH_PE_indirect)
-	    result = *(_Unwind_Ptr *)result;
+	    result = *(_Unwind_Internal_Ptr *) result;
 	}
     }
 
   *val = result;
   return p;
 }
-#endif
 
 #ifndef NO_BASE_OF_ENCODED_VALUE
 
 /* Like read_encoded_value_with_base, but get the base from the context
    rather than providing it directly.  */
 
-static inline const unsigned char *
+STATIC const unsigned char *
 read_encoded_value (struct _Unwind_Context *context, unsigned char encoding,
 		    const unsigned char *p, _Unwind_Ptr *val)
 {
@@ -263,20 +303,4 @@
 }
 
 #endif
-
-/* Read an unsigned leb128 value from P, store the value in VAL, return
-   P incremented past the value.  */
-
-static inline const unsigned char *
-read_uleb128 (const unsigned char *p, _Unwind_Ptr *val)
-{
-  return read_encoded_value_with_base (DW_EH_PE_uleb128, 0, p, val);
-}
-
-/* Similar, but read a signed leb128 value.  */
-
-static inline const unsigned char *
-read_sleb128 (const unsigned char *p, _Unwind_Ptr *val)
-{
-  return read_encoded_value_with_base (DW_EH_PE_sleb128, 0, p, val);
-}
+#endif /* _LIBC */
diff -Nur sysdeps/generic/utime.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/utime.c
--- sysdeps/generic/utime.c	2002-08-04 04:20:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/utime.c	2004-11-03 03:53:02.000000000 +0100
@@ -17,6 +17,7 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#include <stddef.h>
 #include <utime.h>
 
 
diff -Nur sysdeps/generic/utmp_file.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/utmp_file.c
--- sysdeps/generic/utmp_file.c	2002-10-01 00:26:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/utmp_file.c	2004-01-14 19:40:02.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996,97,98,99,2000,01,02 Free Software Foundation, Inc.
+/* Copyright (C) 1996-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>
    and Paul Janzen <pcj@primenet.com>, 1996.
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <utmp.h>
+#include <not-cancel.h>
 
 #include "utmp-private.h"
 #include "utmp-equal.h"
@@ -57,47 +58,47 @@
      LOCK_FILE.
  */
 #define LOCK_FILE(fd, type) \
-{                                                                       \
-  struct flock fl;                                                      \
-  struct sigaction action, old_action;                                  \
-  unsigned int old_timeout;                                             \
-                                                                        \
-  /* Cancel any existing alarm.  */                                     \
-  old_timeout = alarm (0);                                              \
-                                                                        \
-  /* Establish signal handler.  */                                      \
-  action.sa_handler = timeout_handler;                                  \
-  __sigemptyset (&action.sa_mask);                                      \
-  action.sa_flags = 0;                                                  \
-  __sigaction (SIGALRM, &action, &old_action);                          \
-                                                                        \
-  alarm (TIMEOUT);                                                      \
-                                                                        \
-  /* Try to get the lock.  */                                           \
-  memset (&fl, '\0', sizeof (struct flock));                            \
-  fl.l_type = (type);                                                   \
-  fl.l_whence = SEEK_SET;                                               \
-  if (__fcntl ((fd), F_SETLKW, &fl) < 0)
+{									      \
+  struct flock fl;							      \
+  struct sigaction action, old_action;					      \
+  unsigned int old_timeout;						      \
+									      \
+  /* Cancel any existing alarm.  */					      \
+  old_timeout = alarm (0);						      \
+									      \
+  /* Establish signal handler.  */					      \
+  action.sa_handler = timeout_handler;					      \
+  __sigemptyset (&action.sa_mask);					      \
+  action.sa_flags = 0;							      \
+  __sigaction (SIGALRM, &action, &old_action);				      \
+									      \
+  alarm (TIMEOUT);							      \
+									      \
+  /* Try to get the lock.  */						      \
+  memset (&fl, '\0', sizeof (struct flock));				      \
+  fl.l_type = (type);							      \
+  fl.l_whence = SEEK_SET;						      \
+  if (fcntl_not_cancel ((fd), F_SETLKW, &fl) < 0)
 
 #define LOCKING_FAILED() \
   goto unalarm_return
 
 #define UNLOCK_FILE(fd) \
-  /* Unlock the file.  */                                               \
-  fl.l_type = F_UNLCK;                                                  \
-  __fcntl ((fd), F_SETLKW, &fl);                                        \
-                                                                        \
- unalarm_return:							\
-  /* Reset the signal handler and alarm.  We must reset the alarm	\
-     before resetting the handler so our alarm does not generate a	\
-     spurious SIGALRM seen by the user.  However, we cannot just set	\
-     the user's old alarm before restoring the handler, because then	\
-     it's possible our handler could catch the user alarm's SIGARLM	\
-     and then the user would never see the signal he expected.  */	\
-  alarm (0);								\
-  __sigaction (SIGALRM, &old_action, NULL);                             \
-  if (old_timeout != 0)							\
-    alarm (old_timeout);                                                \
+  /* Unlock the file.  */						      \
+  fl.l_type = F_UNLCK;							      \
+  fcntl_not_cancel ((fd), F_SETLKW, &fl);				      \
+									      \
+ unalarm_return:							      \
+  /* Reset the signal handler and alarm.  We must reset the alarm	      \
+     before resetting the handler so our alarm does not generate a	      \
+     spurious SIGALRM seen by the user.  However, we cannot just set	      \
+     the user's old alarm before restoring the handler, because then	      \
+     it's possible our handler could catch the user alarm's SIGARLM	      \
+     and then the user would never see the signal he expected.  */	      \
+  alarm (0);								      \
+  __sigaction (SIGALRM, &old_action, NULL);				      \
+  if (old_timeout != 0)							      \
+    alarm (old_timeout);						      \
 } while (0)
 
 
@@ -113,7 +114,7 @@
 static int updwtmp_file (const char *file, const struct utmp *utmp);
 
 /* Jump table for file functions.  */
-struct utfuncs __libc_utmp_file_functions =
+const struct utfuncs __libc_utmp_file_functions =
 {
   setutent_file,
   getutent_r_file,
@@ -139,22 +140,22 @@
 
       file_name = TRANSFORM_UTMP_FILE_NAME (__libc_utmp_file_name);
 
-      file_fd = __open (file_name, O_RDWR);
+      file_fd = open_not_cancel_2 (file_name, O_RDWR);
       if (file_fd == -1)
 	{
 	  /* Hhm, read-write access did not work.  Try read-only.  */
-	  file_fd = __open (file_name, O_RDONLY);
+	  file_fd = open_not_cancel_2 (file_name, O_RDONLY);
 	  if (file_fd == -1)
 	    return 0;
 	}
 
       /* We have to make sure the file is `closed on exec'.  */
-      result = __fcntl (file_fd, F_GETFD, 0);
+      result = fcntl_not_cancel (file_fd, F_GETFD, 0);
       if (result >= 0)
-	result = __fcntl (file_fd, F_SETFD, result | FD_CLOEXEC);
+	result = fcntl_not_cancel (file_fd, F_SETFD, result | FD_CLOEXEC);
       if (result == -1)
 	{
-	  __close (file_fd);
+	  close_not_cancel_no_status (file_fd);
 	  return 0;
 	}
     }
@@ -197,7 +198,7 @@
     }
 
   /* Read the next entry.  */
-  nbytes = __read (file_fd, &last_entry, sizeof (struct utmp));
+  nbytes = read_not_cancel (file_fd, &last_entry, sizeof (struct utmp));
 
   UNLOCK_FILE (file_fd);
 
@@ -237,7 +238,7 @@
       while (1)
 	{
 	  /* Read the next entry.  */
-	  if (__read (file_fd, buffer, sizeof (struct utmp))
+	  if (read_not_cancel (file_fd, buffer, sizeof (struct utmp))
 	      != sizeof (struct utmp))
 	    {
 	      __set_errno (ESRCH);
@@ -259,7 +260,7 @@
       while (1)
 	{
 	  /* Read the next entry.  */
-	  if (__read (file_fd, buffer, sizeof (struct utmp))
+	  if (read_not_cancel (file_fd, buffer, sizeof (struct utmp))
 	      != sizeof (struct utmp))
 	    {
 	      __set_errno (ESRCH);
@@ -332,7 +333,7 @@
   while (1)
     {
       /* Read the next entry.  */
-      if (__read (file_fd, &last_entry, sizeof (struct utmp))
+      if (read_not_cancel (file_fd, &last_entry, sizeof (struct utmp))
 	  != sizeof (struct utmp))
 	{
 	  __set_errno (ESRCH);
@@ -418,7 +419,8 @@
     }
 
   /* Write the new data.  */
-  if (__write (file_fd, data, sizeof (struct utmp)) != sizeof (struct utmp))
+  if (write_not_cancel (file_fd, data, sizeof (struct utmp))
+      != sizeof (struct utmp))
     {
       /* If we appended a new record this is only partially written.
 	 Remove it.  */
@@ -444,7 +446,7 @@
 {
   assert (file_fd >= 0);
 
-  __close (file_fd);
+  close_not_cancel_no_status (file_fd);
   file_fd = -1;
 }
 
@@ -457,7 +459,7 @@
   int fd;
 
   /* Open WTMP file.  */
-  fd = __open (file, O_WRONLY);
+  fd = open_not_cancel_2 (file, O_WRONLY);
   if (fd < 0)
     return -1;
 
@@ -478,7 +480,8 @@
   /* Write the entry.  If we can't write all the bytes, reset the file
      size back to the original size.  That way, no partial entries
      will remain.  */
-  if (__write (fd, utmp, sizeof (struct utmp)) != sizeof (struct utmp))
+  if (write_not_cancel (fd, utmp, sizeof (struct utmp))
+      != sizeof (struct utmp))
     {
       __ftruncate64 (fd, offset);
       goto unlock_return;
@@ -490,7 +493,7 @@
   UNLOCK_FILE (fd);
 
   /* Close WTMP file.  */
-  __close (fd);
+  close_not_cancel_no_status (fd);
 
   return result;
 }
diff -Nur sysdeps/generic/vfork.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/vfork.c
--- sysdeps/generic/vfork.c	2002-08-05 00:45:41.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/vfork.c	2002-12-31 12:03:42.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1995, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,5 +26,6 @@
 {
   return __fork ();
 }
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/generic/waitid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/waitid.c
--- sysdeps/generic/waitid.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/waitid.c	2002-10-09 11:28:57.000000000 +0200
@@ -1,5 +1,5 @@
 /* Stub version of waitid.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -23,7 +23,7 @@
 #include <sys/wait.h>
 
 int
-waitid (idtype, id, infop, options)
+__waitid (idtype, id, infop, options)
      idtype_t idtype;
      id_t id;
      siginfo_t *infop;
@@ -32,3 +32,4 @@
   __set_errno (ENOSYS);
   return -1;
 }
+weak_alias (__waitid, waitid)
diff -Nur sysdeps/generic/wcstol_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstol_l.c
--- sysdeps/generic/wcstol_l.c	2002-08-08 04:08:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstol_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,11 +22,9 @@
 #include <stddef.h>
 #include <locale.h>
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define	USE_WIDE_CHAR	1
 
 extern long int ____wcstol_l_internal (const wchar_t *, wchar_t **, int, int,
 				       __locale_t);
 
-#include "wcstol.c"
-
-weak_alias (__wcstol_l, wcstol_l)
+#include "strtol_l.c"
diff -Nur sysdeps/generic/wcstoll_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoll_l.c
--- sysdeps/generic/wcstoll_l.c	2002-08-08 04:08:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoll_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,11 +22,9 @@
 #include <stddef.h>
 #include <locale.h>
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define QUAD	1
 
 extern long long int ____wcstoll_l_internal (const wchar_t *, wchar_t **,
 					     int, int, __locale_t);
 
-#include <wcstoll.c>
-
-weak_alias (__wcstoll_l, wcstoll_l)
+#include <wcstol_l.c>
diff -Nur sysdeps/generic/wcstoul_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoul_l.c
--- sysdeps/generic/wcstoul_l.c	2002-08-08 04:08:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoul_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,11 +22,9 @@
 #include <stddef.h>
 #include <locale.h>
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define UNSIGNED	1
 
 extern unsigned long int ____wcstoul_l_internal (const wchar_t *, wchar_t **,
 						 int, int, __locale_t);
 
-#include <wcstoul.c>
-
-weak_alias (__wcstoul_l, wcstoul_l)
+#include <wcstol_l.c>
diff -Nur sysdeps/generic/wcstoull_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoull_l.c
--- sysdeps/generic/wcstoull_l.c	2002-08-08 04:08:25.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wcstoull_l.c	2004-03-14 21:58:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* Convert string representing a number to integer value, using given locale.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,12 +22,10 @@
 #include <stddef.h>
 #include <locale.h>
 
-#define USE_IN_EXTENDED_LOCALE_MODEL	1
+#define UNSIGNED	1
 
 extern unsigned long long int ____wcstoull_l_internal (const wchar_t *,
 						       wchar_t **, int, int,
 						       __locale_t);
 
-#include <wcstoull.c>
-
-weak_alias (__wcstoull_l, wcstoull_l)
+#include <wcstoll_l.c>
diff -Nur sysdeps/generic/wordexp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wordexp.c
--- sysdeps/generic/wordexp.c	2002-09-24 07:12:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/wordexp.c	2005-02-16 11:56:31.000000000 +0100
@@ -1,5 +1,5 @@
 /* POSIX.2 wordexp implementation.
-   Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Tim Waugh <tim@cyberelk.demon.co.uk>.
 
@@ -18,6 +18,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <alloca.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -42,6 +43,7 @@
 #endif
 #include <wordexp.h>
 
+#include <bits/libc-lock.h>
 #include <stdio-common/_itoa.h>
 
 /* Undefine the following line for the production version.  */
@@ -89,19 +91,18 @@
   return NULL;
 }
 
-static inline char *
+static char *
 w_addchar (char *buffer, size_t *actlen, size_t *maxlen, char ch)
      /* (lengths exclude trailing zero) */
 {
-  /* Add a character to the buffer, allocating room for it if needed.
-   */
+  /* Add a character to the buffer, allocating room for it if needed.  */
 
   if (*actlen == *maxlen)
     {
       char *old_buffer = buffer;
       assert (buffer == NULL || *maxlen != 0);
       *maxlen += W_CHUNK;
-      buffer = realloc (buffer, 1 + *maxlen);
+      buffer = (char *) realloc (buffer, 1 + *maxlen);
 
       if (buffer == NULL)
 	free (old_buffer);
@@ -328,10 +329,7 @@
 
 	  while ((result = __getpwuid_r (uid, &pwd, buffer, buflen, &tpwd)) != 0
 		 && errno == ERANGE)
-	    {
-	      buflen += 1000;
-	      buffer = __alloca (buflen);
-	    }
+	    buffer = extend_alloca (buffer, buflen, buflen + 1000);
 
 	  if (result == 0 && tpwd != NULL && pwd.pw_dir != NULL)
 	    {
@@ -358,10 +356,7 @@
 
       while ((result = __getpwnam_r (user, &pwd, buffer, buflen, &tpwd)) != 0
 	     && errno == ERANGE)
-	{
-	  buflen += 1000;
-	  buffer = __alloca (buflen);
-	}
+	buffer = extend_alloca (buffer, buflen, buflen + 1000);
 
       if (result == 0 && tpwd != NULL && pwd.pw_dir)
 	*word = w_addstr (*word, word_length, max_length, pwd.pw_dir);
@@ -559,16 +554,13 @@
 internal_function
 eval_expr_val (char **expr, long int *result)
 {
-  int sgn = +1;
   char *digit;
 
   /* Skip white space */
   for (digit = *expr; digit && *digit && isspace (*digit); ++digit);
 
-  switch (*digit)
+  if (*digit == '(')
     {
-    case '(':
-
       /* Scan for closing paren */
       for (++digit; **expr && **expr != ')'; ++(*expr));
 
@@ -582,27 +574,14 @@
 	return WRDE_SYNTAX;
 
       return 0;
-
-    case '+':	/* Positive value */
-      ++digit;
-      break;
-
-    case '-':	/* Negative value */
-      ++digit;
-      sgn = -1;
-      break;
-
-    default:
-      if (!isdigit (*digit))
-	return WRDE_SYNTAX;
     }
 
-  *result = 0;
-  for (; *digit && isdigit (*digit); ++digit)
-    *result = (*result * 10) + (*digit - '0');
+  /* POSIX requires that decimal, octal, and hexadecimal constants are
+     recognized.  Therefore we pass 0 as the third parameter to strtol.  */
+  *result = strtol (digit, expr, 0);
+  if (digit == *expr)
+    return WRDE_SYNTAX;
 
-  *expr = digit;
-  *result *= sgn;
   return 0;
 }
 
@@ -831,7 +810,7 @@
 
 /* Function called by child process in exec_comm() */
 static void
-internal_function
+internal_function __attribute__ ((always_inline))
 exec_comm_child (char *comm, int *fildes, int showerr, int noexec)
 {
   const char *args[4] = { _PATH_BSHELL, "-c", comm, NULL };
@@ -841,7 +820,7 @@
     args[1] = "-nc";
 
   /* Redirect output.  */
-  __dup2 (fildes[1], 1);
+  __dup2 (fildes[1], STDOUT_FILENO);
   __close (fildes[1]);
 
   /* Redirect stderr to /dev/null if we have to.  */
@@ -853,12 +832,12 @@
       fd = __open (_PATH_DEVNULL, O_WRONLY);
       if (fd >= 0 && fd != 2)
 	{
-	  __dup2 (fd, 2);
+	  __dup2 (fd, STDERR_FILENO);
 	  __close (fd);
 	}
       /* Be paranoid.  Check that we actually opened the /dev/null
          device.  */
-      if (__builtin_expect (__fxstat64 (_STAT_VER, 2, &st), 0) != 0
+      if (__builtin_expect (__fxstat64 (_STAT_VER, STDERR_FILENO, &st), 0) != 0
 	  || __builtin_expect (S_ISCHR (st.st_mode), 1) == 0
 #if defined DEV_NULL_MAJOR && defined DEV_NULL_MINOR
 	  || st.st_rdev != makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR)
@@ -889,13 +868,14 @@
 	   const char *ifs_white)
 {
   int fildes[2];
-  int bufsize = 128;
+#define bufsize 128
   int buflen;
   int i;
   int status = 0;
   size_t maxnewlines = 0;
-  char *buffer;
+  char buffer[bufsize];
   pid_t pid;
+  int noexec = 0;
 
   /* Don't fork() unless necessary */
   if (!comm || !*comm)
@@ -905,32 +885,42 @@
     /* Bad */
     return WRDE_NOSPACE;
 
+ again:
   if ((pid = __fork ()) < 0)
     {
       /* Bad */
-      __close (fildes[0]);
-      __close (fildes[1]);
+      if (fildes[0] != -1)
+	__close (fildes[0]);
+      if (fildes[1] != -1)
+	__close (fildes[1]);
       return WRDE_NOSPACE;
     }
 
   if (pid == 0)
-    exec_comm_child(comm, fildes, (flags & WRDE_SHOWERR), 0);
+    exec_comm_child (comm, fildes, noexec ? 0 : flags & WRDE_SHOWERR, noexec);
 
   /* Parent */
 
+  /* If we are just testing the syntax, only wait.  */
+  if (noexec)
+    return (TEMP_FAILURE_RETRY (__waitpid (pid, &status, 0)) == pid
+	    && status != 0) ? WRDE_SYNTAX : 0;
+
   __close (fildes[1]);
-  buffer = __alloca (bufsize);
+  fildes[1] = -1;
 
   if (!pwordexp)
     /* Quoted - no field splitting */
     {
       while (1)
 	{
-	  if ((buflen = __read (fildes[0], buffer, bufsize)) < 1)
+	  if ((buflen = TEMP_FAILURE_RETRY (__read (fildes[0], buffer,
+						    bufsize))) < 1)
 	    {
-	      if (__waitpid (pid, &status, WNOHANG) == 0)
+	      if (TEMP_FAILURE_RETRY (__waitpid (pid, &status, WNOHANG)) == 0)
 		continue;
-	      if ((buflen = __read (fildes[0], buffer, bufsize)) < 1)
+	      if ((buflen = TEMP_FAILURE_RETRY (__read (fildes[0], buffer,
+							bufsize))) < 1)
 		break;
 	    }
 
@@ -954,11 +944,13 @@
 
       while (1)
 	{
-	  if ((buflen = __read (fildes[0], buffer, bufsize)) < 1)
+	  if ((buflen = TEMP_FAILURE_RETRY (__read (fildes[0], buffer,
+						    bufsize))) < 1)
 	    {
-	      if (__waitpid (pid, &status, WNOHANG) == 0)
+	      if (TEMP_FAILURE_RETRY (__waitpid (pid, &status, WNOHANG)) == 0)
 		continue;
-	      if ((buflen = __read (fildes[0], buffer, bufsize)) < 1)
+	      if ((buflen = TEMP_FAILURE_RETRY (__read (fildes[0], buffer,
+							bufsize))) < 1)
 		break;
 	    }
 
@@ -1074,31 +1066,20 @@
     }
 
   __close (fildes[0]);
+  fildes[0] = -1;
 
   /* Check for syntax error (re-execute but with "-n" flag) */
   if (buflen < 1 && status != 0)
     {
-      if ((pid = __fork ()) < 0)
-	{
-	  /* Bad */
-	  return WRDE_NOSPACE;
-	}
-
-      if (pid == 0)
-	{
-          fildes[0] = fildes[1] = -1;
-	  exec_comm_child(comm, fildes, 0, 1);
-	}
-
-      if (__waitpid (pid, &status, 0) == pid && status != 0)
-	return WRDE_SYNTAX;
+      noexec = 1;
+      goto again;
     }
 
   return 0;
 
 no_space:
   __kill (pid, SIGKILL);
-  __waitpid (pid, NULL, 0);
+  TEMP_FAILURE_RETRY (__waitpid (pid, NULL, 0));
   __close (fildes[0]);
   return WRDE_NOSPACE;
 }
@@ -1143,8 +1124,25 @@
 	      /* Go -- give script to the shell */
 	      if (comm)
 		{
+#ifdef __libc_ptf_call
+		  /* We do not want the exec_comm call to be cut short
+		     by a thread cancellation since cleanup is very
+		     ugly.  Therefore disable cancellation for
+		     now.  */
+		  // XXX Ideally we do want the thread being cancelable.
+		  // XXX If demand is there we'll change it.
+		  int state = PTHREAD_CANCEL_ENABLE;
+		  __libc_ptf_call (pthread_setcancelstate,
+				   (PTHREAD_CANCEL_DISABLE, &state), 0);
+#endif
+
 		  error = exec_comm (comm, word, word_length, max_length,
 				     flags, pwordexp, ifs, ifs_white);
+
+#ifdef __libc_ptf_call
+		  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);
+#endif
+
 		  free (comm);
 		}
 
diff -Nur sysdeps/generic/writev.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/writev.c
--- sysdeps/generic/writev.c	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/writev.c	2002-10-09 11:34:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1997,1998,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,7 +26,7 @@
    Operates just like `write' (see <unistd.h>) except that the data
    are taken from VECTOR instead of a contiguous buffer.  */
 ssize_t
-__writev (fd, vector, count)
+__libc_writev (fd, vector, count)
      int fd;
      const struct iovec *vector;
      int count;
@@ -34,7 +34,8 @@
   __set_errno (ENOSYS);
   return -1;
 }
-weak_alias (__writev, writev)
+strong_alias (__libc_writev, __writev)
+weak_alias (__libc_writev, writev)
 
 stub_warning (writev)
 #include <stub-tag.h>
diff -Nur sysdeps/generic/w_tgamma.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgamma.c
--- sysdeps/generic/w_tgamma.c	1999-07-14 05:43:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgamma.c	2004-11-21 20:56:22.000000000 +0100
@@ -39,8 +39,10 @@
 	if(_LIB_VERSION == _IEEE_) return y;
 
 	if(!__finite(y)&&__finite(x)) {
-	  if(__floor(x)==x&&x<=0.0)
-	    return __kernel_standard(x,x,41); /* tgamma pole */
+	  if (x == 0.0)
+	    return __kernel_standard(x,x,50); /* tgamma pole */
+	  else if(__floor(x)==x&&x<0.0)
+	    return __kernel_standard(x,x,41); /* tgamma domain */
 	  else
 	    return __kernel_standard(x,x,40); /* tgamma overflow */
 	}
diff -Nur sysdeps/generic/w_tgammaf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgammaf.c
--- sysdeps/generic/w_tgammaf.c	1999-07-14 05:43:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgammaf.c	2004-11-21 20:56:22.000000000 +0100
@@ -37,8 +37,11 @@
 	if(_LIB_VERSION == _IEEE_) return y;
 
 	if(!__finitef(y)&&__finitef(x)) {
-	  if(__floorf(x)==x&&x<=(float)0.0)
+	  if (x == (float)0.0)
 	    /* tgammaf pole */
+	    return (float)__kernel_standard((double)x,(double)x,150);
+	  else if(__floorf(x)==x&&x<(float)0.0)
+	    /* tgammaf domain */
 	    return (float)__kernel_standard((double)x,(double)x,141);
 	  else
 	    /* tgammaf overflow */
diff -Nur sysdeps/generic/w_tgammal.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgammal.c
--- sysdeps/generic/w_tgammal.c	2001-03-16 21:52:48.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/w_tgammal.c	2004-11-21 20:56:22.000000000 +0100
@@ -42,8 +42,10 @@
 	if(_LIB_VERSION == _IEEE_) return y;
 
 	if(!__finitel(y)&&__finitel(x)) {
-	  if(__floorl(x)==x&&x<=0.0)
-	    return __kernel_standard(x,x,241); /* tgamma pole */
+	  if(x==0.0)
+	    return __kernel_standard(x,x,250); /* tgamma pole */
+	  else if(__floorl(x)==x&&x<0.0)
+	    return __kernel_standard(x,x,241); /* tgamma domain */
 	  else
 	    return __kernel_standard(x,x,240); /* tgamma overflow */
 	}
diff -Nur sysdeps/generic/xpg-strerror.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/xpg-strerror.c
--- sysdeps/generic/xpg-strerror.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/generic/xpg-strerror.c	2004-03-22 20:48:10.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (C) 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2002, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <libintl.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/param.h>
+#include <stdio-common/_itoa.h>
+
+/* It is critical here that we always use the `dcgettext' function for
+   the message translation.  Since <libintl.h> only defines the macro
+   `dgettext' to use `dcgettext' for optimizing programs this is not
+   always guaranteed.  */
+#ifndef dgettext
+# include <locale.h>		/* We need LC_MESSAGES.  */
+# define dgettext(domainname, msgid) dcgettext (domainname, msgid, LC_MESSAGES)
+#endif
+
+/* Fill buf with a string describing the errno code in ERRNUM.  */
+int
+__xpg_strerror_r (int errnum, char *buf, size_t buflen)
+{
+  if (errnum < 0 || errnum >= _sys_nerr_internal
+      || _sys_errlist_internal[errnum] == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  const char *estr = (const char *) _(_sys_errlist_internal[errnum]);
+  size_t estrlen = strlen (estr) + 1;
+
+  if (buflen < estrlen)
+    {
+      __set_errno (ERANGE);
+      return -1;
+    }
+
+  memcpy (buf, estr, estrlen);
+  return 0;
+}
diff -Nur sysdeps/gnu/bits/msq.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/msq.h
--- sysdeps/gnu/bits/msq.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/msq.h	2002-10-24 01:49:02.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,7 @@
 #endif
 
 #include <bits/types.h>
+#include <bits/ipctypes.h>
 
 /* Define options for message queue functions.  */
 #define MSG_NOERROR	010000	/* no error if message is too big */
diff -Nur sysdeps/gnu/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/shm.h
--- sysdeps/gnu/bits/shm.h	2002-08-24 00:18:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/shm.h	2004-08-12 19:27:21.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +22,7 @@
 #endif
 
 #include <bits/types.h>
+#include <bits/ipctypes.h>
 
 /* Permission flag for shmget.  */
 #define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
@@ -35,6 +37,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -89,3 +93,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/gnu/bits/utmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/utmp.h
--- sysdeps/gnu/bits/utmp.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/utmp.h	2002-10-16 03:02:31.000000000 +0200
@@ -1,5 +1,6 @@
 /* The `struct utmp' type, describing entries in the utmp file.  GNU version.
-   Copyright (C) 1993, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,6 +25,7 @@
 #include <paths.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#include <bits/wordsize.h>
 
 
 #define UT_LINESIZE	32
@@ -35,7 +37,11 @@
    previous logins.  */
 struct lastlog
   {
+#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
+    int32_t ll_time;
+#else
     __time_t ll_time;
+#endif
     char ll_line[UT_LINESIZE];
     char ll_host[UT_HOSTSIZE];
   };
@@ -61,8 +67,21 @@
   char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
   struct exit_status ut_exit;	/* Exit status of a process marked
 				   as DEAD_PROCESS.  */
+/* The ut_session and ut_tv fields must be the same size when compiled
+   32- and 64-bit.  This allows data files and shared memory to be
+   shared between 32- and 64-bit applications.  */
+#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
+  int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    int32_t tv_sec;		/* Seconds.  */
+    int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
   long int ut_session;		/* Session ID, used for windowing.  */
   struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+
   int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
   char __unused[20];		/* Reserved for future use.  */
 };
diff -Nur sysdeps/gnu/bits/utmpx.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/utmpx.h
--- sysdeps/gnu/bits/utmpx.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/bits/utmpx.h	2002-10-16 03:02:31.000000000 +0200
@@ -1,5 +1,5 @@
 /* Structures and definitions for the user accounting database.  GNU version.
-   Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,6 +23,7 @@
 
 #include <bits/types.h>
 #include <sys/time.h>
+#include <bits/wordsize.h>
 
 
 #ifdef __USE_GNU
@@ -62,8 +63,21 @@
   char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
   struct __exit_status ut_exit;	/* Exit status of a process marked
 				   as DEAD_PROCESS.  */
+
+/* The fields ut_session and ut_tv must be the same size when compiled
+   32- and 64-bit.  This allows files and shared memory to be shared
+   between 32- and 64-bit applications.  */
+#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
+  __int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    __int32_t tv_sec;		/* Seconds.  */
+    __int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
   long int ut_session;		/* Session ID, used for windowing.  */
   struct timeval ut_tv;		/* Time entry was made.  */
+#endif
   __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
   char __unused[20];		/* Reserved for future use.  */
 };
diff -Nur sysdeps/gnu/errlist.awk /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist.awk
--- sysdeps/gnu/errlist.awk	2002-08-29 01:39:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist.awk	2004-10-20 12:04:57.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (C) 1991-1999, 2002 Free Software Foundation, Inc.
+# Copyright (C) 1991-1999,2002,2004 Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -47,7 +47,16 @@
     print "#endif";
     print "";
 
-    print "const char *const _sys_errlist_internal[] =";
+    print "#if !defined EMIT_ERR_MAX && !defined ERRLIST_NO_COMPAT";
+    print "# include <errlist-compat.h>";
+    print "#endif";
+    print "#ifdef ERR_MAX";
+    print "# define ERRLIST_SIZE ERR_MAX + 1";
+    print "#else"
+    print "# define ERRLIST_SIZE";
+    print "#endif";
+
+    print "const char *const _sys_errlist_internal[ERRLIST_SIZE] =";
     print "  {";
     print "    [0] = N_(\"Success\"),"
   }
diff -Nur sysdeps/gnu/errlist.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist.c
--- sysdeps/gnu/errlist.c	2002-08-29 01:39:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist.c	2004-11-06 01:28:49.000000000 +0100
@@ -7,7 +7,15 @@
 # define ERR_REMAP(n) n
 #endif
 
-const char *const _sys_errlist_internal[] =
+#if !defined EMIT_ERR_MAX && !defined ERRLIST_NO_COMPAT
+# include <errlist-compat.h>
+#endif
+#ifdef ERR_MAX
+# define ERRLIST_SIZE ERR_MAX + 1
+#else
+# define ERRLIST_SIZE
+#endif
+const char *const _sys_errlist_internal[ERRLIST_SIZE] =
   {
     [0] = N_("Success"),
 #ifdef EPERM
diff -Nur sysdeps/gnu/errlist-compat.awk /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist-compat.awk
--- sysdeps/gnu/errlist-compat.awk	2002-08-31 02:31:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/errlist-compat.awk	2004-10-20 12:04:57.000000000 +0200
@@ -1,5 +1,5 @@
 # awk script to generate errlist-compat.c
-# Copyright (C) 2002 Free Software Foundation, Inc.
+# Copyright (C) 2002, 2004 Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -59,7 +59,7 @@
 
   count = maxerr + 1;
 
-  if (highest != count) {
+  if (highest < count) {
     printf "*** errlist.c count %d vs Versions sys_errlist@%s count %d\n", \
       count, highest_version, highest > "/dev/stderr";
     exit 1;
@@ -79,6 +79,12 @@
   print "/* This file was generated by errlist-compat.awk; DO NOT EDIT!  */\n";
   print "#include <shlib-compat.h>\n";
 
+  if (highest > count) {
+    printf "*** errlist.c count %d inflated to %s count %d (old errno.h?)\n", \
+      count, highest_version, highest > "/dev/stderr";
+    printf "#define ERR_MAX %d\n\n", highest;
+  }
+
   for (old in compat) {
     new = compat[old];
     n = vcount[old];
diff -Nur sysdeps/gnu/_G_config.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/_G_config.h
--- sysdeps/gnu/_G_config.h	2002-01-03 04:13:31.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/_G_config.h	2004-11-09 00:15:48.000000000 +0100
@@ -69,6 +69,7 @@
 
 #define _G_HAVE_PRINTF_FP 1
 #define _G_HAVE_MMAP 1
+#define _G_HAVE_MREMAP 1
 #define _G_HAVE_LONG_DOUBLE_IO 1
 #define _G_HAVE_IO_FILE_OPEN 1
 #define _G_HAVE_IO_GETLINE_INFO 1
diff -Nur sysdeps/gnu/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/glob64.c
--- sysdeps/gnu/glob64.c	2002-08-05 02:30:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/glob64.c	2004-07-01 19:39:25.000000000 +0200
@@ -21,4 +21,5 @@
 
 #include <sysdeps/generic/glob.c>
 
+libc_hidden_def (glob64)
 libc_hidden_def (globfree64)
diff -Nur sysdeps/gnu/ifaddrs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/ifaddrs.c
--- sysdeps/gnu/ifaddrs.c	2002-09-21 02:28:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/ifaddrs.c	2003-04-25 01:40:31.000000000 +0200
@@ -1,5 +1,5 @@
 /* getifaddrs -- get names and addresses of all network interfaces
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -79,11 +79,9 @@
       ifr = ifreqs;
       do
 	{
-	  /* Fill in all pointers to the storage we've already allocated.  */
+	  /* Fill in pointers to the storage we've already allocated.  */
 	  storage[i].ia.ifa_next = &storage[i + 1].ia;
 	  storage[i].ia.ifa_addr = &storage[i].addr;
-	  storage[i].ia.ifa_netmask = &storage[i].netmask;
-	  storage[i].ia.ifa_broadaddr = &storage[i].broadaddr; /* & dstaddr */
 
 	  /* Now copy the information we already have from SIOCGIFCONF.  */
 	  storage[i].ia.ifa_name = strncpy (storage[i].name, ifr->ifr_name,
@@ -100,26 +98,36 @@
 	  ifr->ifr_addr = storage[i].addr;
 
 	  if (__ioctl (fd, SIOCGIFNETMASK, ifr) < 0)
-	    break;
-	  storage[i].netmask = ifr->ifr_netmask;
+	    storage[i].ia.ifa_netmask = NULL;
+	  else
+	    {
+	      storage[i].ia.ifa_netmask = &storage[i].netmask;
+	      storage[i].netmask = ifr->ifr_netmask;
+	    }
 
 	  if (ifr->ifr_flags & IFF_BROADCAST)
 	    {
 	      ifr->ifr_addr = storage[i].addr;
 	      if (__ioctl (fd, SIOCGIFBRDADDR, ifr) < 0)
-		break;
-	      storage[i].broadaddr = ifr->ifr_broadaddr;
+		storage[i].ia.ifa_broadaddr = NULL;
+	      {
+		storage[i].ia.ifa_broadaddr = &storage[i].broadaddr;
+		storage[i].broadaddr = ifr->ifr_broadaddr;
+	      }
 	    }
 	  else if (ifr->ifr_flags & IFF_POINTOPOINT)
 	    {
 	      ifr->ifr_addr = storage[i].addr;
 	      if (__ioctl (fd, SIOCGIFDSTADDR, ifr) < 0)
-		break;
-	      storage[i].broadaddr = ifr->ifr_dstaddr;
+		storage[i].ia.ifa_broadaddr = NULL;
+	      else
+		{
+		  storage[i].ia.ifa_broadaddr = &storage[i].broadaddr;
+		  storage[i].broadaddr = ifr->ifr_dstaddr;
+		}
 	    }
 	  else
-	    /* Just 'cause.  */
-	    memset (&storage[i].broadaddr, 0, sizeof storage[i].broadaddr);
+	    storage[i].ia.ifa_broadaddr = NULL;
 
 	  storage[i].ia.ifa_data = NULL; /* Nothing here for now.  */
 
@@ -143,9 +151,13 @@
 
   return 0;
 }
+#ifndef getifaddrs
+libc_hidden_def (getifaddrs)
+#endif
 
 void
 freeifaddrs (struct ifaddrs *ifa)
 {
   free (ifa);
 }
+libc_hidden_def (freeifaddrs)
diff -Nur sysdeps/gnu/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/Makefile
--- sysdeps/gnu/Makefile	2002-08-31 20:44:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/Makefile	2004-12-01 20:44:33.000000000 +0100
@@ -1,4 +1,5 @@
-# Copyright (C) 1996,97,98,99,2001,02 Free Software Foundation, Inc.
+# Copyright (C) 1996,1997,1998,1999,2001,2002,2003,2004
+#	Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -34,10 +35,12 @@
 vpath errlist.c $(full_config_sysdirs)
 ifeq ($(versioning),yes)
 $(objpfx)errlist-compat.c: errlist.c $(..)sysdeps/gnu/errlist-compat.awk \
-			   $(common-objpfx)Versions.v.i
+			   $(common-objpfx)Versions.v.i $(before-compile)
 else
-$(objpfx)errlist-compat.c: errlist.c $(..)sysdeps/gnu/errlist-compat.awk
+$(objpfx)errlist-compat.c: errlist.c $(..)sysdeps/gnu/errlist-compat.awk \
+			   $(before-compile)
 endif
+	$(make-target-directory)
 	$(AWK) -v maxerr=`\
 	  $(CC) -S $(CPPFLAGS) $(CFLAGS) -DNOT_IN_libc -DEMIT_ERR_MAX $< -o - \
 	  | sed -n 's/^.*@@@[^0-9]*\([0-9]*\)[^0-9]*@@@.*$$/\1/p'` \
@@ -47,9 +50,14 @@
 # Make it unwritable so noone will edit it by mistake.
 	-chmod a-w $@T
 	mv -f $@T $@
+$(objpfx)errlist-compat.h: $(objpfx)errlist-compat.c
+	sed -n '1p;/ERR_MAX/p' $< > $@T
+	-chmod a-w $@T
+	mv -f $@T $@
+generated += errlist-compat.c errlist-compat.h
 
 # This will force the generation above to happy if need be.
-$(objpfx)errlist.d: $(objpfx)errlist-compat.c
+$(foreach o,.d $(object-suffixes),$(objpfx)errlist$o):$(objpfx)errlist-compat.h
 endif
 
 ifeq ($(subdir),login)
@@ -68,8 +76,3 @@
 ifeq ($(subdir),misc)
 sysdep_headers += sys/mtio.h
 endif
-
-
-ifeq ($(subdir),dlfcn)
-libdl-sysdep_routines += eval
-endif
diff -Nur sysdeps/gnu/netinet/udp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/netinet/udp.h
--- sysdeps/gnu/netinet/udp.h	2002-07-10 09:24:33.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/netinet/udp.h	2004-10-26 20:11:19.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 95, 96, 97 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 92, 93, 95, 96, 97, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,7 +18,7 @@
 
 /*
  * Copyright (C) 1982, 1986 Regents of the University of California.
- * All rights reserved. 
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -48,31 +48,32 @@
 #ifndef __NETINET_UDP_H
 #define __NETINET_UDP_H    1
 
-#include <sys/cdefs.h>
+#include <features.h>
 #include <sys/types.h>
 
-__BEGIN_DECLS
 
 /* UDP header as specified by RFC 768, August 1980. */
 #ifdef __FAVOR_BSD
-struct udphdr {
-         u_int16_t uh_sport;           /* source port */
-         u_int16_t uh_dport;           /* destination port */
-         u_int16_t uh_ulen;            /* udp length */
-         u_int16_t uh_sum;             /* udp checksum */
+
+struct udphdr
+{
+  u_int16_t uh_sport;		/* source port */
+  u_int16_t uh_dport;		/* destination port */
+  u_int16_t uh_ulen;		/* udp length */
+  u_int16_t uh_sum;		/* udp checksum */
 };
+
 #else
 
-struct udphdr {
-  u_int16_t	source;
-  u_int16_t	dest;
-  u_int16_t	len;
-  u_int16_t	check;
+struct udphdr
+{
+  u_int16_t source;
+  u_int16_t dest;
+  u_int16_t len;
+  u_int16_t check;
 };
 #endif
 
 #define SOL_UDP            17      /* sockopt level for UDP */
 
-__END_DECLS
-
 #endif /* netinet/udp.h */
diff -Nur sysdeps/gnu/siglist.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/siglist.c
--- sysdeps/gnu/siglist.c	2002-08-05 00:09:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/siglist.c	2003-04-01 07:51:02.000000000 +0200
@@ -1,5 +1,5 @@
 /* Define list of all signal numbers and their names.
-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997-2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,49 +21,30 @@
 #include <signal.h>
 #include <libintl.h>
 #include <shlib-compat.h>
-
 #include <bits/wordsize.h>
-#if	__WORDSIZE == 32
-#define PTR_SIZE_STR "4"
-#elif	__WORDSIZE == 64
-#define PTR_SIZE_STR "8"
-#else
-#error	unexpected wordsize __WORDSIZE
-#endif
-
-
-#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
-asm (".data\n\t.globl __old_sys_siglist\n__old_sys_siglist:");
-#endif
 
 const char *const __new_sys_siglist[NSIG] =
 {
-#define init_sig(sig, abbrev, desc)   [sig] desc,
+#define init_sig(sig, abbrev, desc)   [sig] = desc,
 #include <siglist.h>
 #undef init_sig
 };
 strong_alias (__new_sys_siglist, _sys_siglist_internal)
 
-#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
-asm (".type __old_sys_siglist,@object\n\t.size __old_sys_siglist,"
-        OLD_SIGLIST_SIZE_STR "*" PTR_SIZE_STR);
-
-asm (".data\n\t.globl __old_sys_sigabbrev\n__old_sys_sigabbrev:");
-#endif
-
 const char *const __new_sys_sigabbrev[NSIG] =
 {
-#define init_sig(sig, abbrev, desc)   [sig] abbrev,
+#define init_sig(sig, abbrev, desc)   [sig] = abbrev,
 #include <siglist.h>
 #undef init_sig
 };
+strong_alias (__new_sys_sigabbrev, _sys_sigabbrev_internal)
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
-asm (".type __old_sys_sigabbrev,@object\n\t.size __old_sys_sigabbrev,"
-        OLD_SIGLIST_SIZE_STR "*" PTR_SIZE_STR);
+strong_alias (_sys_siglist_internal, __old_sys_siglist)
+declare_symbol (__old_sys_siglist, object, OLD_SIGLIST_SIZE * __WORDSIZE / 8)
 
-extern const char *const *__old_sys_siglist;
-extern const char *const *__old_sys_sigabbrev;
+strong_alias (_sys_sigabbrev_internal, __old_sys_sigabbrev)
+declare_symbol (__old_sys_sigabbrev, object, OLD_SIGLIST_SIZE * __WORDSIZE / 8)
 
 strong_alias (__old_sys_siglist, _old_sys_siglist)
 compat_symbol (libc, __old_sys_siglist, _sys_siglist, GLIBC_2_0);
@@ -71,7 +52,26 @@
 compat_symbol (libc, __old_sys_sigabbrev, sys_sigabbrev, GLIBC_2_0);
 #endif
 
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_3_3) && defined OLD2_SIGLIST_SIZE
+strong_alias (_sys_siglist_internal, __old2_sys_siglist)
+declare_symbol (__old2_sys_siglist, object, OLD2_SIGLIST_SIZE * __WORDSIZE / 8)
+
+strong_alias (_sys_sigabbrev_internal, __old2_sys_sigabbrev)
+declare_symbol (__old2_sys_sigabbrev, object,
+		OLD2_SIGLIST_SIZE * __WORDSIZE / 8)
+
+strong_alias (__old2_sys_siglist, _old2_sys_siglist)
+compat_symbol (libc, __old2_sys_siglist, _sys_siglist, GLIBC_2_1);
+compat_symbol (libc, _old2_sys_siglist, sys_siglist, GLIBC_2_1);
+compat_symbol (libc, __old2_sys_sigabbrev, sys_sigabbrev, GLIBC_2_1);
+
+strong_alias (__new_sys_siglist, _new_sys_siglist)
+versioned_symbol (libc, __new_sys_siglist, _sys_siglist, GLIBC_2_3_3);
+versioned_symbol (libc, _new_sys_siglist, sys_siglist, GLIBC_2_3_3);
+versioned_symbol (libc, __new_sys_sigabbrev, sys_sigabbrev, GLIBC_2_3_3);
+#else
 strong_alias (__new_sys_siglist, _new_sys_siglist)
 versioned_symbol (libc, __new_sys_siglist, _sys_siglist, GLIBC_2_1);
 versioned_symbol (libc, _new_sys_siglist, sys_siglist, GLIBC_2_1);
 versioned_symbol (libc, __new_sys_sigabbrev, sys_sigabbrev, GLIBC_2_1);
+#endif
diff -Nur sysdeps/gnu/utmpx.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/utmpx.h
--- sysdeps/gnu/utmpx.h	2001-07-07 21:21:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/gnu/utmpx.h	2003-04-19 18:48:35.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,41 +47,79 @@
 
 __BEGIN_DECLS
 
-/* Open user accounting database.  */
-extern void setutxent (void) __THROW;
+/* Open user accounting database.
 
-/* Close user accounting database.  */
-extern void endutxent (void) __THROW;
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setutxent (void);
 
-/* Get the next entry from the user accounting database.  */
-extern struct utmpx *getutxent (void) __THROW;
+/* Close user accounting database.
 
-/* Get the user accounting database entry corresponding to ID.  */
-extern struct utmpx *getutxid (__const struct utmpx *__id) __THROW;
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endutxent (void);
 
-/* Get the user accounting database entry corresponding to LINE.  */
-extern struct utmpx *getutxline (__const struct utmpx *__line) __THROW;
+/* Get the next entry from the user accounting database.
 
-/* Write the entry UTMPX into the user accounting database.  */
-extern struct utmpx *pututxline (__const struct utmpx *__utmpx) __THROW;
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxent (void);
+
+/* Get the user accounting database entry corresponding to ID.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxid (__const struct utmpx *__id);
+
+/* Get the user accounting database entry corresponding to LINE.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxline (__const struct utmpx *__line);
+
+/* Write the entry UTMPX into the user accounting database.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *pututxline (__const struct utmpx *__utmpx);
 
 
 #ifdef __USE_GNU
-/* Change name of the utmpx file to be examined.  */
-extern int utmpxname (__const char *__file) __THROW;
+/* Change name of the utmpx file to be examined.
 
-/* Append entry UTMP to the wtmpx-like file WTMPX_FILE.  */
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int utmpxname (__const char *__file);
+
+/* Append entry UTMP to the wtmpx-like file WTMPX_FILE.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
 extern void updwtmpx (__const char *__wtmpx_file,
-		      __const struct utmpx *__utmpx) __THROW;
+		      __const struct utmpx *__utmpx);
 
 
-/* Copy the information in UTMPX to UTMP. */
+/* Copy the information in UTMPX to UTMP.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
 extern void getutmp (__const struct utmpx *__utmpx,
-		     struct utmp *__utmp) __THROW;
+		     struct utmp *__utmp);
+
+/* Copy the information in UTMP to UTMPX.
 
-/* Copy the information in UTMP to UTMPX. */
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
 extern void getutmpx (__const struct utmp *__utmp,
-		      struct utmpx *__utmpx) __THROW;
+		      struct utmpx *__utmpx);
 #endif
 
 __END_DECLS
diff -Nur sysdeps/i386/backtrace.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/backtrace.c
--- sysdeps/i386/backtrace.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/backtrace.c	2004-10-22 23:05:47.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return backtrace of current program state.
-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -18,8 +18,64 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <bits/libc-lock.h>
+#include <dlfcn.h>
 #include <execinfo.h>
-#include <bp-checks.h>
+#include <stdlib.h>
+#include <unwind.h>
+
+struct trace_arg
+{
+  void **array;
+  int cnt, size;
+  void *lastebp, *lastesp;
+};
+
+#ifdef SHARED
+static _Unwind_Reason_Code (*unwind_backtrace) (_Unwind_Trace_Fn, void *);
+static _Unwind_Ptr (*unwind_getip) (struct _Unwind_Context *);
+static _Unwind_Ptr (*unwind_getcfa) (struct _Unwind_Context *);
+static _Unwind_Ptr (*unwind_getgr) (struct _Unwind_Context *, int);
+
+static void
+init (void)
+{
+  void *handle = __libc_dlopen ("libgcc_s.so.1");
+
+  if (handle == NULL)
+    return;
+
+  unwind_backtrace = __libc_dlsym (handle, "_Unwind_Backtrace");
+  unwind_getip = __libc_dlsym (handle, "_Unwind_GetIP");
+  unwind_getcfa = __libc_dlsym (handle, "_Unwind_GetCFA");
+  unwind_getgr = __libc_dlsym (handle, "_Unwind_GetGR");
+  if (unwind_getip == NULL || unwind_getgr == NULL || unwind_getcfa == NULL)
+    unwind_backtrace = NULL;
+}
+#else
+# define unwind_backtrace _Unwind_Backtrace
+# define unwind_getip _Unwind_GetIP
+# define unwind_getcfa _Unwind_GetCFA
+# define unwind_getgr _Unwind_GetGR
+#endif
+
+static _Unwind_Reason_Code
+backtrace_helper (struct _Unwind_Context *ctx, void *a)
+{
+  struct trace_arg *arg = a;
+
+  /* We are first called with address in the __backtrace function.
+     Skip it.  */
+  if (arg->cnt != -1)
+    arg->array[arg->cnt] = (void *) unwind_getip (ctx);
+  if (++arg->cnt == arg->size)
+    return _URC_END_OF_STACK;
+
+  /* %ebp is DWARF2 register 5 on IA-32.  */
+  arg->lastebp = (void *) unwind_getgr (ctx, 5);
+  arg->lastesp = (void *) unwind_getcfa (ctx);
+  return _URC_NO_REASON;
+}
 
 
 /* This is a global variable set at program start time.  It marks the
@@ -27,46 +83,61 @@
 extern void *__libc_stack_end;
 
 
-/* This is the stack alyout we see with every stack frame.
+/* This is the stack layout we see with every stack frame
+   if not compiled without frame pointer.
 
             +-----------------+        +-----------------+
     %ebp -> | %ebp last frame--------> | %ebp last frame--->...
             |                 |        |                 |
             | return address  |        | return address  |
             +-----------------+        +-----------------+
-*/
+
+   First try as far to get as far as possible using
+   _Unwind_Backtrace which handles -fomit-frame-pointer
+   as well, but requires .eh_frame info.  Then fall back to
+   walking the stack manually.  */
+
 struct layout
 {
-  struct layout *__unbounded next;
-  void *__unbounded return_address;
+  struct layout *ebp;
+  void *ret;
 };
 
+
 int
 __backtrace (array, size)
      void **array;
      int size;
 {
-  /* We assume that all the code is generated with frame pointers set.  */
-  register void *ebp __asm__ ("ebp");
-  register void *esp __asm__ ("esp");
-  struct layout *current;
-  int cnt = 0;
-
-  /* We skip the call to this function, it makes no sense to record it.  */
-  current = BOUNDED_1 ((struct layout *) ebp);
-  while (cnt < size)
+  struct trace_arg arg = { .array = array, .size = size, .cnt = -1 };
+#ifdef SHARED
+  __libc_once_define (static, once);
+
+  __libc_once (once, init);
+  if (unwind_backtrace == NULL)
+    return 0;
+#endif
+
+  if (size >= 1)
+    unwind_backtrace (backtrace_helper, &arg);
+
+  if (arg.cnt > 1 && arg.array[arg.cnt - 1] == NULL)
+    --arg.cnt;
+  else if (arg.cnt < size)
     {
-      if ((void *) current < esp || (void *) current > __libc_stack_end)
-	/* This means the address is out of range.  Note that for the
-	   toplevel we see a frame pointer with value NULL which clearly is
-	   out of range.  */
-	break;
+      struct layout *ebp = (struct layout *) arg.lastebp;
 
-      array[cnt++] = current->return_address;
-
-      current = current->next;
+      while (arg.cnt < size)
+	{
+	  /* Check for out of range.  */
+	  if ((void *) ebp < arg.lastesp || (void *) ebp > __libc_stack_end
+	      || ((long) ebp & 3))
+	    break;
+
+	  array[arg.cnt++] = ebp->ret;
+	  ebp = ebp->ebp;
+	}
     }
-
-  return cnt;
+  return arg.cnt != -1 ? arg.cnt : 0;
 }
 weak_alias (__backtrace, backtrace)
diff -Nur sysdeps/i386/bits/byteswap.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/byteswap.h
--- sysdeps/i386/bits/byteswap.h	2002-08-12 10:53:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/byteswap.h	2003-06-12 03:34:36.000000000 +0200
@@ -1,5 +1,5 @@
 /* Macros to swap the order of bytes in integer values.
-   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,8 +28,9 @@
 #define __bswap_constant_16(x) \
      ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))
 
-#if defined __GNUC__ && __GNUC__ >= 2
-# define __bswap_16(x) \
+#ifdef __GNUC__
+# if __GNUC__ >= 2
+#  define __bswap_16(x) \
      (__extension__							      \
       ({ register unsigned short int __v, __x = (x);			      \
 	 if (__builtin_constant_p (__x))				      \
@@ -40,24 +41,32 @@
  		    : "0" (__x)						      \
  		    : "cc");						      \
 	 __v; }))
-#else
+# else
 /* This is better than nothing.  */
-# define __bswap_16(x) \
+#  define __bswap_16(x) \
      (__extension__							      \
       ({ register unsigned short int __x = (x); __bswap_constant_16 (__x); }))
+# endif
+#else
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+  return __bswap_constant_16 (__bsx);
+}
 #endif
 
-
 /* Swap bytes in 32 bit value.  */
 #define __bswap_constant_32(x) \
      ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
       (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
-#if defined __GNUC__ && __GNUC__ >= 2
+#ifdef __GNUC__
+# if __GNUC__ >= 2
 /* To swap the bytes in a word the i486 processors and up provide the
    `bswap' opcode.  On i386 we have to use three instructions.  */
-# if !defined __i486__ && !defined __pentium__ && !defined __pentiumpro__
-#  define __bswap_32(x)							      \
+#  if !defined __i486__ && !defined __pentium__ && !defined __pentiumpro__ \
+      && !defined __pentium4__
+#   define __bswap_32(x)						      \
      (__extension__							      \
       ({ register unsigned int __v, __x = (x);				      \
 	 if (__builtin_constant_p (__x))				      \
@@ -70,8 +79,8 @@
 		    : "0" (__x)						      \
 		    : "cc");						      \
 	 __v; }))
-# else
-#  define __bswap_32(x) \
+#  else
+#   define __bswap_32(x) \
      (__extension__							      \
       ({ register unsigned int __v, __x = (x);				      \
 	 if (__builtin_constant_p (__x))				      \
@@ -79,11 +88,18 @@
 	 else								      \
 	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
 	 __v; }))
-# endif
-#else
-# define __bswap_16(x) \
+#  endif
+# else
+#  define __bswap_32(x) \
      (__extension__							      \
       ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
+# endif
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return __bswap_constant_32 (__bsx);
+}
 #endif
 
 
@@ -103,11 +119,11 @@
      (__extension__							      \
       ({ union { __extension__ unsigned long long int __ll;		      \
 		 unsigned long int __l[2]; } __w, __r;			      \
-	 __w.__ll = (x);						      \
-         if (__builtin_constant_p (__w.__ll))				      \
-	   __r.__ll = __bswap_constant_64 (__w.__ll);			      \
+         if (__builtin_constant_p (x))					      \
+	   __r.__ll = __bswap_constant_64 (x);				      \
 	 else								      \
 	   {								      \
+	     __w.__ll = (x);						      \
 	     __r.__l[0] = __bswap_32 (__w.__l[1]);			      \
 	     __r.__l[1] = __bswap_32 (__w.__l[0]);			      \
 	   }								      \
diff -Nur sysdeps/i386/bits/huge_val.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/huge_val.h
--- sysdeps/i386/bits/huge_val.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/huge_val.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/* `HUGE_VAL' constants for ix86 (where it is infinity).
-   Used by <stdlib.h> and <math.h> functions for overflow.
-   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _MATH_H
-# error "Never use <bits/huge_val.h> directly; include <math.h> instead."
-#endif
-
-#include <features.h>
-
-/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
-
-#if __GNUC_PREREQ(2,96)
-# define HUGE_VAL	(__extension__ 0x1.0p2047)
-#else
-# define __HUGE_VAL_bytes	{ 0, 0, 0, 0, 0, 0, 0xf0, 0x7f }
-
-# define __huge_val_t	union { unsigned char __c[8]; double __d; }
-# ifdef	__GNUC__
-#  define HUGE_VAL	(__extension__ \
-			 ((__huge_val_t) { __c: __HUGE_VAL_bytes }).__d)
-# else	/* Not GCC.  */
-static __huge_val_t __huge_val = { __HUGE_VAL_bytes };
-#  define HUGE_VAL	(__huge_val.__d)
-# endif	/* GCC.  */
-#endif /* GCC 2.95 */
-
-
-/* ISO C99 extensions: (float) HUGE_VALF and (long double) HUGE_VALL.  */
-
-#ifdef __USE_ISOC99
-
-# if __GNUC_PREREQ(2,96)
-
-#  define HUGE_VALF (__extension__ 0x1.0p255f)
-#  define HUGE_VALL (__extension__ 0x1.0p32767L)
-
-# else
-
-#  define __HUGE_VALF_bytes	{ 0, 0, 0x80, 0x7f }
-
-#  define __huge_valf_t	union { unsigned char __c[4]; float __f; }
-#  ifdef	__GNUC__
-#   define HUGE_VALF	(__extension__ \
-			 ((__huge_valf_t) { __c: __HUGE_VALF_bytes }).__f)
-#  else	/* Not GCC.  */
-static __huge_valf_t __huge_valf = { __HUGE_VALF_bytes };
-#   define HUGE_VALF	(__huge_valf.__f)
-#  endif	/* GCC.  */
-
-
-#  define __HUGE_VALL_bytes	{ 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }
-
-#  define __huge_vall_t	union { unsigned char __c[12]; long double __ld; }
-#  ifdef __GNUC__
-#   define HUGE_VALL	(__extension__ \
-			 ((__huge_vall_t) { __c: __HUGE_VALL_bytes }).__ld)
-#  else	/* Not GCC.  */
-static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
-#   define HUGE_VALL	(__huge_vall.__ld)
-#  endif /* GCC.  */
-
-# endif /* GCC 2.95 */
-
-#endif	/* __USE_ISOC99.  */
diff -Nur sysdeps/i386/bits/huge_vall.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/huge_vall.h
--- sysdeps/i386/bits/huge_vall.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/huge_vall.h	2004-03-15 22:44:09.000000000 +0100
@@ -0,0 +1,43 @@
+/* `HUGE_VALL' constant for ix86 (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
+#endif
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALL	(__builtin_huge_vall())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VALL	(__extension__ 0x1.0p32767L)
+#else
+
+# define __HUGE_VALL_bytes	{ 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }
+
+# define __huge_vall_t	union { unsigned char __c[12]; long double __ld; }
+# ifdef __GNUC__
+#  define HUGE_VALL	(__extension__ \
+			 ((__huge_vall_t) { __c: __HUGE_VALL_bytes }).__ld)
+# else	/* Not GCC.  */
+static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
+#  define HUGE_VALL	(__huge_vall.__ld)
+#  endif /* GCC.  */
+
+#endif /* GCC 2.95 */
diff -Nur sysdeps/i386/bits/setjmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/setjmp.h
--- sysdeps/i386/bits/setjmp.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/setjmp.h	2003-04-12 02:50:00.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,8 +17,10 @@
    02111-1307 USA.  */
 
 /* Define the machine-dependent type `jmp_buf'.  Intel 386 version.  */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
 
-#ifndef _SETJMP_H
+#if !defined _SETJMP_H && !defined _PTHREAD_H
 # error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
 #endif
 
@@ -40,3 +42,5 @@
    containing a local variable at ADDRESS.  */
 #define _JMPBUF_UNWINDS(jmpbuf, address) \
   ((void *) (address) < (void *) (jmpbuf)[JB_SP])
+
+#endif	/* bits/setjmp.h */
diff -Nur sysdeps/i386/bits/string.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/string.h
--- sysdeps/i386/bits/string.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bits/string.h	2004-06-15 22:11:53.000000000 +0200
@@ -1,5 +1,5 @@
 /* Optimized, inlined string functions.  i386 version.
-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -43,8 +43,8 @@
 #define _HAVE_STRING_ARCH_memcpy 1
 #define memcpy(dest, src, n) \
   (__extension__ (__builtin_constant_p (n)				      \
-		  ? __memcpy_c (dest, src, n)				      \
-		  : memcpy (dest, src, n)))
+		  ? __memcpy_c ((dest), (src), (n))			      \
+		  : memcpy ((dest), (src), (n))))
 /* This looks horribly ugly, but the compiler can optimize it totally,
    as the count is constant.  */
 __STRING_INLINE void *__memcpy_c (void *__dest, __const void *__src,
@@ -301,7 +301,8 @@
      "movl $1,%0\n"
      "1:"
      : "=D" (__res), "=&c" (__d0)
-     : "a" (__c), "0" (__s), "1" (__n)
+     : "a" (__c), "0" (__s), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
      : "cc");
   return __res - 1;
 }
@@ -321,11 +322,13 @@
      "repne; scasb\n\t"
      "je 1f\n\t"
      "orl $-1,%0\n"
-     "1:\tcld"
+     "1:\tcld\n\t"
+     "incl %0"
      : "=D" (__res), "=&c" (__d0)
-     : "a" (__c), "0" (__s + __n - 1), "1" (__n)
+     : "a" (__c), "0" (__s + __n - 1), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
      : "cc");
-  return __res + 1;
+  return __res;
 }
 # ifdef __USE_GNU
 #  define memrchr(s, c, n) __memrchr (s, c, n)
@@ -345,7 +348,8 @@
      "repne; scasb\n\t"
      "notl %0"
      : "=c" (__res), "=&D" (__d0)
-     : "1" (__str), "a" (0), "0" (0xffffffff)
+     : "1" (__str), "a" (0), "0" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__str)
      : "cc");
   return __res - 1;
 }
@@ -474,7 +478,9 @@
      "orb	$1,%%al\n"
      "3:"
      : "=a" (__res), "=&S" (__d0), "=&D" (__d1)
-     : "1" (__s1), "2" (__s2)
+     : "1" (__s1), "2" (__s2),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s1),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s2)
      : "cc");
   return __res;
 }
@@ -506,7 +512,9 @@
      "orb	$1,%%al\n"
      "4:"
      : "=a" (__res), "=&S" (__d0), "=&D" (__d1), "=&c" (__d2)
-     : "1" (__s1), "2" (__s2), "3" (__n)
+     : "1" (__s1), "2" (__s2), "3" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s2)
      : "cc");
   return __res;
 }
@@ -540,7 +548,8 @@
      "2:\n\t"
      "movl	%1,%0"
      : "=a" (__res), "=&S" (__d0)
-     : "0" (__c), "1" (__s)
+     : "0" (__c), "1" (__s),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res - 1;
 }
@@ -564,7 +573,8 @@
      "2:\n\t"
      "movl	%1,%0"
      : "=a" (__res), "=&S" (__d0)
-     : "0" (__c), "1" (__s)
+     : "0" (__c), "1" (__s),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res - 1;
 }
@@ -598,7 +608,8 @@
      "2:\n\t"
      "movl	%1,%0"
      : "=a" (__res), "=&S" (__d0)
-     : "0" (__c), "1" (__s)
+     : "0" (__c), "1" (__s),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res - 1;
 }
@@ -621,7 +632,8 @@
      "2:\n\t"
      "movl	%1,%0"
      : "=a" (__res), "=&S" (__d0)
-     : "0" (__c), "1" (__s)
+     : "0" (__c), "1" (__s),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res - 1;
 }
@@ -659,7 +671,8 @@
      "2:\n\t"
      "popl	%%ebx"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
-     : "d" (__reject), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "d" (__reject), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return (__res - 1) - __s;
 }
@@ -686,7 +699,8 @@
      "jne	1b\n"
      "2:"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&d" (__d2), "=&D" (__d3)
-     : "g" (__reject), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "g" (__reject), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return (__res - 1) - __s;
 }
@@ -723,7 +737,8 @@
      "2:\n\t"
      "popl	%%ebx"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
-     : "r" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "r" (__accept), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return (__res - 1) - __s;
 }
@@ -750,7 +765,8 @@
      "je	1b\n"
      "2:"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&d" (__d2), "=&D" (__d3)
-     : "g" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "g" (__accept), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return (__res - 1) - __s;
 }
@@ -790,7 +806,8 @@
      "3:\n\t"
      "popl	%%ebx"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
-     : "r" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "r" (__accept), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res;
 }
@@ -821,7 +838,8 @@
      "xorl	%0,%0\n"
      "3:"
      : "=&S" (__res), "=&a" (__d0), "=&c" (__d1), "=&d" (__d2), "=&D" (__d3)
-     : "g" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "g" (__accept), "0" (__s), "1" (0), "2" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
      : "cc");
   return __res;
 }
@@ -861,7 +879,7 @@
      "popl	%%ebx"
      : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&D" (__d2)
      : "r" (__needle), "0" (0), "1" (0xffffffff), "2" (__haystack)
-     : "cc");
+     : "memory", "cc");
   return __res;
 }
 # else
@@ -891,7 +909,7 @@
      "2:"
      : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&d" (__d2), "=&D" (__d3)
      : "g" (__needle), "0" (0), "1" (0xffffffff), "2" (__haystack)
-     : "cc");
+     : "memory", "cc");
   return __res;
 }
 # endif
diff -Nur sysdeps/i386/bsd-_setjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bsd-_setjmp.S
--- sysdeps/i386/bsd-_setjmp.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/bsd-_setjmp.S	2002-12-31 21:37:23.000000000 +0100
@@ -1,5 +1,5 @@
 /* BSD `_setjmp' entry point to `sigsetjmp (..., 0)'.  i386 version.
-   Copyright (C) 1994,1995,1996,1997,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1994-1997,2000,2001,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -53,3 +53,4 @@
 	movl %eax, JB_SIZE(%edx) /* No signal mask set.  */
 	ret
 END (BP_SYM (_setjmp))
+libc_hidden_def (_setjmp)
diff -Nur sysdeps/i386/dl-lookupcfg.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-lookupcfg.h
--- sysdeps/i386/dl-lookupcfg.h	2002-02-05 07:23:06.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-lookupcfg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/* Configuration of lookup functions.  i386 version.
-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <tls.h>
-
-/* Some platforms need more information from the symbol lookup function
-   than just the address.  For x86 we need it when we support TLS.  */
-#ifdef USE_TLS
-# define DL_LOOKUP_RETURNS_MAP
-#else
-# undef DL_LOOKUP_RETURNS_MAP
-#endif
diff -Nur sysdeps/i386/dl-machine.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-machine.h
--- sysdeps/i386/dl-machine.h	2002-09-18 03:28:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-machine.h	2005-02-16 11:58:03.000000000 +0100
@@ -1,5 +1,5 @@
 /* Machine-dependent ELF dynamic relocation inline functions.  i386 version.
-   Copyright (C) 1995,96,97,98,99,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,7 +23,7 @@
 #define ELF_MACHINE_NAME "i386"
 
 #include <sys/param.h>
-
+#include <sysdep.h>
 #include <tls.h>
 
 /* Return nonzero iff ELF header is compatible with the running host.  */
@@ -95,7 +95,7 @@
 /* Set up the loaded object described by L so its unrelocated PLT
    entries will jump to the on-demand fixup code in dl-runtime.c.  */
 
-static inline int __attribute__ ((unused))
+static inline int __attribute__ ((unused, always_inline))
 elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 {
   Elf32_Addr *got;
@@ -129,7 +129,7 @@
 	{
 	  got[2] = (Elf32_Addr) &_dl_runtime_profile;
 
-	  if (_dl_name_match_p (GL(dl_profile), l))
+	  if (_dl_name_match_p (GLRO(dl_profile), l))
 	    /* This is the object we are looking for.  Say that we really
 	       want profiling and the timers are started.  */
 	    GL(dl_profile_map) = l;
@@ -154,11 +154,14 @@
    destroys the passed register information.  */
 /* GKM FIXME: Fix trampoline to pass bounds so we can do
    without the `__unbounded' qualifier.  */
-static ElfW(Addr) fixup (struct link_map *__unbounded l, ElfW(Word) reloc_offset)
-     __attribute__ ((regparm (2), unused));
+#define ARCH_FIXUP_ATTRIBUTE __attribute__ ((regparm (3), unused))
+
+static ElfW(Addr) fixup (struct link_map *__unbounded l,
+			 ElfW(Word) reloc_offset)
+     ARCH_FIXUP_ATTRIBUTE;
 static ElfW(Addr) profile_fixup (struct link_map *l, ElfW(Word) reloc_offset,
 				 ElfW(Addr) retaddr)
-     __attribute__ ((regparm (3), unused));
+     ARCH_FIXUP_ATTRIBUTE;
 # endif
 
 /* This code is used in dl-runtime.c to call the `fixup' function
@@ -168,62 +171,90 @@
 	.text\n\
 	.globl _dl_runtime_resolve\n\
 	.type _dl_runtime_resolve, @function\n\
+	" CFI_STARTPROC "\n\
 	.align 16\n\
 _dl_runtime_resolve:\n\
+	" CFI_ADJUST_CFA_OFFSET (8) "\n\
 	pushl %eax		# Preserve registers otherwise clobbered.\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %edx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	movl 16(%esp), %edx	# Copy args pushed by PLT in register.  Note\n\
 	movl 12(%esp), %eax	# that `fixup' takes its parameters in regs.\n\
 	call fixup		# Call resolver.\n\
 	popl %edx		# Get register content back.\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	popl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	xchgl %eax, (%esp)	# Get %eax contents end store function address.\n\
 	ret $8			# Jump to function address.\n\
+	" CFI_ENDPROC "\n\
 	.size _dl_runtime_resolve, .-_dl_runtime_resolve\n\
 \n\
 	.globl _dl_runtime_profile\n\
 	.type _dl_runtime_profile, @function\n\
+	" CFI_STARTPROC "\n\
 	.align 16\n\
 _dl_runtime_profile:\n\
+	" CFI_ADJUST_CFA_OFFSET (8) "\n\
 	pushl %eax		# Preserve registers otherwise clobbered.\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %edx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	movl 20(%esp), %ecx	# Load return address\n\
 	movl 16(%esp), %edx	# Copy args pushed by PLT in register.  Note\n\
 	movl 12(%esp), %eax	# that `fixup' takes its parameters in regs.\n\
 	call profile_fixup	# Call resolver.\n\
 	popl %edx		# Get register content back.\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	popl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	xchgl %eax, (%esp)	# Get %eax contents end store function address.\n\
 	ret $8			# Jump to function address.\n\
+	" CFI_ENDPROC "\n\
 	.size _dl_runtime_profile, .-_dl_runtime_profile\n\
 	.previous\n\
 ");
 # else
-# define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\n\
+#  define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\n\
 	.text\n\
 	.globl _dl_runtime_resolve\n\
 	.globl _dl_runtime_profile\n\
 	.type _dl_runtime_resolve, @function\n\
 	.type _dl_runtime_profile, @function\n\
+	" CFI_STARTPROC "\n\
 	.align 16\n\
 _dl_runtime_resolve:\n\
 _dl_runtime_profile:\n\
+	" CFI_ADJUST_CFA_OFFSET (8) "\n\
 	pushl %eax		# Preserve registers otherwise clobbered.\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %edx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	movl 16(%esp), %edx	# Push the arguments for `fixup'\n\
 	movl 12(%esp), %eax\n\
 	pushl %edx\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	pushl %eax\n\
+	" CFI_ADJUST_CFA_OFFSET (4) "\n\
 	call fixup		# Call resolver.\n\
 	popl %edx		# Pop the parameters\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	popl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	popl %edx		# Get register content back.\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	popl %ecx\n\
+	" CFI_ADJUST_CFA_OFFSET (-4) "\n\
 	xchgl %eax, (%esp)	# Get %eax contents end store function address.\n\
 	ret $8			# Jump to function address.\n\
+	" CFI_ENDPROC "\n\
 	.size _dl_runtime_resolve, .-_dl_runtime_resolve\n\
 	.size _dl_runtime_profile, .-_dl_runtime_profile\n\
 	.previous\n\
@@ -257,9 +288,6 @@
 	# Point %ebx at the GOT.\n\
 	call 0b\n\
 	addl $_GLOBAL_OFFSET_TABLE_, %ebx\n\
-	# Store the highest stack address\n\
-	movl __libc_stack_end@GOT(%ebx), %eax\n\
-	movl %esp, (%eax)\n\
 	# See if we were run as a command with the executable file\n\
 	# name as an extra leading argument.\n\
 	movl _dl_skip_args@GOTOFF(%ebx), %eax\n\
@@ -280,11 +308,21 @@
 	movl _rtld_local@GOTOFF(%ebx), %eax\n\
 	leal 8(%esp,%edx,4), %esi\n\
 	leal 4(%esp), %ecx\n\
+	movl %esp, %ebp\n\
+	# Make sure _dl_init is run with 16 byte aligned stack.\n\
+	andl $-16, %esp\n\
+	pushl %eax\n\
+	pushl %eax\n\
+	pushl %ebp\n\
 	pushl %esi\n\
+	# Clear %ebp, so that even constructors have terminated backchain.\n\
+	xorl %ebp, %ebp\n\
 	# Call the function to run the initializers.\n\
 	call _dl_init_internal@PLT\n\
 	# Pass our finalizer function to the user in %edx, as per ELF ABI.\n\
 	leal _dl_fini@GOTOFF(%ebx), %edx\n\
+	# Restore %esp _start expects.\n\
+	movl (%esp), %esp\n\
 	# Jump to the user's entry point.\n\
 	jmp *%edi\n\
 	.previous\n\
@@ -299,7 +337,7 @@
    define the value.
    ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
    of the main executable's symbols, as for a COPY reloc.  */
-#ifdef USE_TLS
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
 # define elf_machine_type_class(type) \
   ((((type) == R_386_JMP_SLOT || (type) == R_386_TLS_DTPMOD32		      \
      || (type) == R_386_TLS_DTPOFF32 || (type) == R_386_TLS_TPOFF32	      \
@@ -326,9 +364,9 @@
 static inline void __attribute__ ((unused))
 dl_platform_init (void)
 {
-  if (GL(dl_platform) != NULL && *GL(dl_platform) == '\0')
+  if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
     /* Avoid an empty string which would disturb us.  */
-    GL(dl_platform) = NULL;
+    GLRO(dl_platform) = NULL;
 }
 
 static inline Elf32_Addr
@@ -360,11 +398,13 @@
 /* Perform the relocation specified by RELOC and SYM (which is fully resolved).
    MAP is the object containing the reloc.  */
 
-static inline void
+auto inline void
+__attribute ((always_inline))
 elf_machine_rel (struct link_map *map, const Elf32_Rel *reloc,
 		 const Elf32_Sym *sym, const struct r_found_version *version,
-		 Elf32_Addr *const reloc_addr)
+		 void *const reloc_addr_arg)
 {
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
   const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
 
 #if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
@@ -389,7 +429,7 @@
     return;
 # endif
   else
-#endif
+#endif	/* !RTLD_BOOTSTRAP and have no -z combreloc */
     {
       const Elf32_Sym *const refsym = sym;
 #if defined USE_TLS && !defined RTLD_BOOTSTRAP
@@ -402,7 +442,7 @@
       if (sym != NULL)
 # endif
 	value += sym->st_value;
-#endif
+#endif	/* use TLS and !RTLD_BOOTSTRAP */
 
       switch (r_type)
 	{
@@ -411,7 +451,7 @@
 	  *reloc_addr = value;
 	  break;
 
-#ifdef USE_TLS
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
 	case R_386_TLS_DTPMOD32:
 # ifdef RTLD_BOOTSTRAP
 	  /* During startup the dynamic linker is always the module
@@ -444,7 +484,10 @@
 	     thread pointer.  To get the variable position in the TLS
 	     block we subtract the offset from that of the TLS block.  */
 	  if (sym != NULL)
-	    *reloc_addr += sym_map->l_tls_offset - sym->st_value;
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr += sym_map->l_tls_offset - sym->st_value;
+	    }
 # endif
 	  break;
 	case R_386_TLS_TPOFF:
@@ -456,7 +499,10 @@
 	     It is a negative value which will be added to the
 	     thread pointer.  */
 	  if (sym != NULL)
-	    *reloc_addr += sym->st_value - sym_map->l_tls_offset;
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr += sym->st_value - sym_map->l_tls_offset;
+	    }
 # endif
 	  break;
 #endif	/* use TLS */
@@ -475,7 +521,7 @@
 	    break;
 	  if (__builtin_expect (sym->st_size > refsym->st_size, 0)
 	      || (__builtin_expect (sym->st_size < refsym->st_size, 0)
-		  && GL(dl_verbose)))
+		  && GLRO(dl_verbose)))
 	    {
 	      const char *strtab;
 
@@ -485,37 +531,42 @@
 				rtld_progname ?: "<program name unknown>",
 				strtab + refsym->st_name);
 	    }
-	  memcpy (reloc_addr, (void *) value, MIN (sym->st_size,
-						   refsym->st_size));
+	  memcpy (reloc_addr_arg, (void *) value,
+		  MIN (sym->st_size, refsym->st_size));
 	  break;
 	default:
 	  _dl_reloc_bad_type (map, r_type, 0);
 	  break;
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 	}
     }
 }
 
 #ifndef RTLD_BOOTSTRAP
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
 		  const Elf32_Sym *sym, const struct r_found_version *version,
-		  Elf32_Addr *const reloc_addr)
+		  void *const reloc_addr_arg)
 {
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
   const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
 
   if (ELF32_R_TYPE (reloc->r_info) == R_386_RELATIVE)
     *reloc_addr = map->l_addr + reloc->r_addend;
   else if (r_type != R_386_NONE)
     {
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+      const Elf32_Sym *const refsym = sym;
+# endif
 # ifdef USE_TLS
       struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
       Elf32_Addr value = sym == NULL ? 0 : sym_map->l_addr + sym->st_value;
 # else
-      Elf32_Addr value = RESOLVE (&sym, version, ELF32_R_TYPE (reloc->r_info));
+      Elf32_Addr value = RESOLVE (&sym, version, r_type);
       if (sym != NULL)
 	value += sym->st_value;
-#endif
+# endif
 
       switch (ELF32_R_TYPE (reloc->r_info))
 	{
@@ -524,11 +575,13 @@
 	case R_386_32:
 	  *reloc_addr = value + reloc->r_addend;
 	  break;
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+	  /* Not needed for dl-conflict.c.  */
 	case R_386_PC32:
 	  *reloc_addr = (value + reloc->r_addend - (Elf32_Addr) reloc_addr);
 	  break;
 
-#ifdef USE_TLS
+#  ifdef USE_TLS
 	case R_386_TLS_DTPMOD32:
 	  /* Get the information from the link map returned by the
 	     resolv function.  */
@@ -546,20 +599,47 @@
 	     It is a positive value which will be subtracted from the
 	     thread pointer.  To get the variable position in the TLS
 	     block we subtract the offset from that of the TLS block.  */
-	  *reloc_addr
-	    = (sym == NULL ? 0 : sym_map->l_tls_offset - sym->st_value)
-	      + reloc->r_addend;
+	  if (sym != NULL)
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr = sym_map->l_tls_offset - sym->st_value
+			    + reloc->r_addend;
+	    }
 	  break;
 	case R_386_TLS_TPOFF:
 	  /* The offset is negative, forward from the thread pointer.  */
 	  /* We know the offset of object the symbol is contained in.
 	     It is a negative value which will be added to the
 	     thread pointer.  */
-	  *reloc_addr
-	    = (sym == NULL ? 0 : sym->st_value - sym_map->l_tls_offset)
-	      + reloc->r_addend;
+	  if (sym != NULL)
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr = sym->st_value - sym_map->l_tls_offset
+			    + reloc->r_addend;
+	    }
 	  break;
-#endif	/* use TLS */
+#  endif	/* use TLS */
+	case R_386_COPY:
+	  if (sym == NULL)
+	    /* This can happen in trace mode if an object could not be
+	       found.  */
+	    break;
+	  if (__builtin_expect (sym->st_size > refsym->st_size, 0)
+	      || (__builtin_expect (sym->st_size < refsym->st_size, 0)
+		  && GLRO(dl_verbose)))
+	    {
+	      const char *strtab;
+
+	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
+	      _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	    }
+	  memcpy (reloc_addr_arg, (void *) value,
+		  MIN (sym->st_size, refsym->st_size));
+	  break;
+# endif /* !RESOLVE_CONFLICT_FIND_MAP */
 	default:
 	  /* We add these checks in the version to relocate ld.so only
 	     if we are still debugging.  */
@@ -568,26 +648,31 @@
 	}
     }
 }
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
-static inline void
+auto inline void
+__attribute ((always_inline))
 elf_machine_rel_relative (Elf32_Addr l_addr, const Elf32_Rel *reloc,
-			  Elf32_Addr *const reloc_addr)
+			  void *const reloc_addr_arg)
 {
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
   assert (ELF32_R_TYPE (reloc->r_info) == R_386_RELATIVE);
   *reloc_addr += l_addr;
 }
 
 #ifndef RTLD_BOOTSTRAP
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
-			   Elf32_Addr *const reloc_addr)
+			   void *const reloc_addr_arg)
 {
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
   *reloc_addr = l_addr + reloc->r_addend;
 }
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_lazy_rel (struct link_map *map,
 		      Elf32_Addr l_addr, const Elf32_Rel *reloc)
 {
@@ -608,12 +693,13 @@
 
 #ifndef RTLD_BOOTSTRAP
 
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_lazy_rela (struct link_map *map,
 		       Elf32_Addr l_addr, const Elf32_Rela *reloc)
 {
 }
 
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
 #endif /* RESOLVE */
diff -Nur sysdeps/i386/dl-procinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-procinfo.c
--- sysdeps/i386/dl-procinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-procinfo.c	2004-07-10 21:59:09.000000000 +0200
@@ -0,0 +1,83 @@
+/* Data for i386 version of processor capability information.
+   Copyright (C) 2001,2002,2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This information must be kept in sync with the _DL_HWCAP_COUNT and
+   _DL_PLATFORM_COUNT definitions in procinfo.h.
+
+   If anything should be added here check whether the size of each string
+   is still ok with the given array size.
+
+   All the #ifdefs in the definitions are quite irritating but
+   necessary if we want to avoid duplicating the information.  There
+   are three different modes:
+
+   - PROCINFO_DECL is defined.  This means we are only interested in
+     declarations.
+
+   - PROCINFO_DECL is not defined:
+
+     + if SHARED is defined the file is included in an array
+       initializer.  The .element = { ... } syntax is needed.
+
+     + if SHARED is not defined a normal array initialization is
+       needed.
+  */
+
+#ifndef PROCINFO_CLASS
+# define PROCINFO_CLASS
+#endif
+
+#if !defined PROCINFO_DECL && defined SHARED
+  ._dl_x86_cap_flags
+#else
+PROCINFO_CLASS const char _dl_x86_cap_flags[32][8]
+#endif
+#ifndef PROCINFO_DECL
+= {
+    "fpu", "vme", "de", "pse", "tsc", "msr", "pae", "mce",
+    "cx8", "apic", "10", "sep", "mtrr", "pge", "mca", "cmov",
+    "pat", "pse36", "pn", "clflush", "20", "dts", "acpi", "mmx",
+    "fxsr", "sse", "sse2", "ss", "ht", "tm", "ia64", "pbe"
+  }
+#endif
+#if !defined SHARED || defined PROCINFO_DECL
+;
+#else
+,
+#endif
+
+#if !defined PROCINFO_DECL && defined SHARED
+  ._dl_x86_platforms
+#else
+PROCINFO_CLASS const char _dl_x86_platforms[4][5]
+#endif
+#ifndef PROCINFO_DECL
+= {
+    "i386", "i486", "i586", "i686"
+  }
+#endif
+#if !defined SHARED || defined PROCINFO_DECL
+;
+#else
+,
+#endif
+
+#undef PROCINFO_DECL
+#undef PROCINFO_CLASS
diff -Nur sysdeps/i386/dl-procinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-procinfo.h
--- sysdeps/i386/dl-procinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-procinfo.h	2004-03-10 19:29:31.000000000 +0100
@@ -0,0 +1,110 @@
+/* i386 version of processor capability information handling macros.
+   Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DL_PROCINFO_H
+#define _DL_PROCINFO_H	1
+#include <ldsodefs.h>
+
+#define _DL_HWCAP_COUNT 32
+
+#define _DL_PLATFORMS_COUNT	4
+
+/* Start at 48 to reserve some space.  */
+#define _DL_FIRST_PLATFORM	48
+/* Mask to filter out platforms.  */
+#define _DL_HWCAP_PLATFORM	(((1ULL << _DL_PLATFORMS_COUNT) - 1) \
+				 << _DL_FIRST_PLATFORM)
+
+enum
+{
+  HWCAP_I386_FPU   = 1 << 0,
+  HWCAP_I386_VME   = 1 << 1,
+  HWCAP_I386_DE    = 1 << 2,
+  HWCAP_I386_PSE   = 1 << 3,
+  HWCAP_I386_TSC   = 1 << 4,
+  HWCAP_I386_MSR   = 1 << 5,
+  HWCAP_I386_PAE   = 1 << 6,
+  HWCAP_I386_MCE   = 1 << 7,
+  HWCAP_I386_CX8   = 1 << 8,
+  HWCAP_I386_APIC  = 1 << 9,
+  HWCAP_I386_SEP   = 1 << 11,
+  HWCAP_I386_MTRR  = 1 << 12,
+  HWCAP_I386_PGE   = 1 << 13,
+  HWCAP_I386_MCA   = 1 << 14,
+  HWCAP_I386_CMOV  = 1 << 15,
+  HWCAP_I386_FCMOV = 1 << 16,
+  HWCAP_I386_MMX   = 1 << 23,
+  HWCAP_I386_OSFXSR = 1 << 24,
+  HWCAP_I386_XMM   = 1 << 25,
+  HWCAP_I386_XMM2  = 1 << 26,
+  HWCAP_I386_AMD3D = 1 << 31,
+
+  /* XXX Which others to add here?  */
+  HWCAP_IMPORTANT = (HWCAP_I386_XMM2)
+
+};
+
+/* We cannot provide a general printing function.  */
+#define _dl_procinfo(word) -1
+
+static inline const char *
+__attribute__ ((unused))
+_dl_hwcap_string (int idx)
+{
+  return GLRO(dl_x86_cap_flags)[idx];
+};
+
+static inline const char *
+__attribute__ ((unused))
+_dl_platform_string (int idx)
+{
+  return GLRO(dl_x86_platforms)[idx - _DL_FIRST_PLATFORM];
+};
+
+static inline int
+__attribute__ ((unused, always_inline))
+_dl_string_hwcap (const char *str)
+{
+  int i;
+
+  for (i = 0; i < _DL_HWCAP_COUNT; i++)
+    {
+      if (strcmp (str, GLRO(dl_x86_cap_flags)[i]) == 0)
+	return i;
+    }
+  return -1;
+};
+
+static inline int
+__attribute__ ((unused, always_inline))
+_dl_string_platform (const char *str)
+{
+  int i;
+
+  if (str != NULL)
+    for (i = 0; i < _DL_PLATFORMS_COUNT; ++i)
+      {
+	if (strcmp (str, GLRO(dl_x86_platforms)[i]) == 0)
+	  return _DL_FIRST_PLATFORM + i;
+      }
+  return -1;
+};
+
+#endif /* dl-procinfo.h */
diff -Nur sysdeps/i386/dl-tls.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-tls.h
--- sysdeps/i386/dl-tls.h	2002-02-13 08:13:58.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/dl-tls.h	2004-03-06 09:12:40.000000000 +0100
@@ -1,5 +1,5 @@
 /* Thread-local storage handling in the ELF dynamic linker.  i386 version.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,8 +31,9 @@
 extern void *___tls_get_addr (tls_index *ti)
      __attribute__ ((__regparm__ (1)));
 extern void *___tls_get_addr_internal (tls_index *ti)
-     __attribute__ ((__regparm__ (1)));
+     __attribute__ ((__regparm__ (1))) attribute_hidden;
 
+# ifdef IS_IN_rtld
 /* The special thing about the x86 TLS ABI is that we have two
    variants of the __tls_get_addr function with different calling
    conventions.  The GNU version, which we are mostly concerned here,
@@ -50,5 +51,10 @@
    version of this file.  */
 # define __tls_get_addr __attribute__ ((__regparm__ (1))) ___tls_get_addr
 strong_alias (___tls_get_addr, ___tls_get_addr_internal)
-# define __TLS_GET_ADDR ___tls_get_addr
+#else
+
+/* Users should get the better interface.  */
+# define __tls_get_addr ___tls_get_addr
+
+# endif
 #endif
diff -Nur sysdeps/i386/elf/bsd-setjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/bsd-setjmp.S
--- sysdeps/i386/elf/bsd-setjmp.S	2002-04-07 11:38:15.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/bsd-setjmp.S	2003-10-03 22:29:03.000000000 +0200
@@ -1,5 +1,5 @@
 /* BSD `setjmp' entry point to `sigsetjmp (..., 1)'.  i386 version.
-   Copyright (C) 1995,1996,1997,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1997,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -56,7 +56,7 @@
            we can't save and restore our caller's value.  Instead, we do an
            indirect jump through the GOT, using for the temporary register
            %ecx, which is call-clobbered.  */
-	call 1f
+	call __i686.get_pc_thunk.cx
 	addl $_GLOBAL_OFFSET_TABLE_, %ecx
 	leal C_SYMBOL_NAME (BP_SYM (__sigjmp_save)@GOTOFF)(%ecx), %ecx
 	call *%ecx
@@ -66,8 +66,13 @@
 	popl %ecx
 	popl %edx
 	ret
-#ifdef PIC
-1:	movl (%esp), %ecx
-	ret
-#endif
 END (BP_SYM (setjmp))
+
+	.section .gnu.linkonce.t.__i686.get_pc_thunk.cx,"ax",@progbits
+	.globl __i686.get_pc_thunk.cx
+	.hidden __i686.get_pc_thunk.cx
+	.type __i686.get_pc_thunk.cx,@function
+__i686.get_pc_thunk.cx:
+	movl (%esp), %ecx
+	ret
+	.size __i686.get_pc_thunk.cx, . - __i686.get_pc_thunk.cx
diff -Nur sysdeps/i386/elf/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/configure
--- sysdeps/i386/elf/configure	2002-10-02 09:21:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,12 +1,13 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
  # Local configure fragment for sysdeps/i386/elf.
 
 if test "$usetls" != no; then
 # Check for support of thread-local storage handling in assembler and
 # linker.
-echo $ac_n "checking for i386 TLS support""... $ac_c" 1>&6
-echo "configure:8: checking for i386 TLS support" >&5
-if eval "test \"`echo '$''{'libc_cv_386_tls'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
+echo "$as_me:$LINENO: checking for i386 TLS support" >&5
+echo $ECHO_N "checking for i386 TLS support... $ECHO_C" >&6
+if test "${libc_cv_386_tls+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat > conftest.s <<\EOF
 	.section ".tdata", "awT", @progbits
@@ -24,24 +25,29 @@
 	movl	%gs:(%ecx), %eax
 	movl	%gs:bar@NTPOFF, %eax
 EOF
-if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'; { (eval echo configure:28: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; }; then
+if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   libc_cv_386_tls=yes
 else
   libc_cv_386_tls=no
 fi
 rm -f conftest*
 fi
-
-echo "$ac_t""$libc_cv_386_tls" 1>&6
+echo "$as_me:$LINENO: result: $libc_cv_386_tls" >&5
+echo "${ECHO_T}$libc_cv_386_tls" >&6
 if test $libc_cv_386_tls = yes; then
-  cat >> confdefs.h <<\EOF
+  cat >>confdefs.h <<\_ACEOF
 #define HAVE_TLS_SUPPORT 1
-EOF
+_ACEOF
 
 fi
 fi
 
-cat >> confdefs.h <<\EOF
+cat >>confdefs.h <<\_ACEOF
 #define PI_STATIC_AND_HIDDEN 1
-EOF
+_ACEOF
 
diff -Nur sysdeps/i386/elf/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/configure.in
--- sysdeps/i386/elf/configure.in	2002-10-01 00:02:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/configure.in	2002-10-18 22:27:53.000000000 +0200
@@ -1,4 +1,3 @@
-sinclude(./aclocal.m4)dnl Autoconf lossage
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 # Local configure fragment for sysdeps/i386/elf.
 
@@ -23,7 +22,7 @@
 	movl	%gs:bar@NTPOFF, %eax
 EOF
 dnl
-if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AC_FD_CC); then
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
   libc_cv_386_tls=yes
 else
   libc_cv_386_tls=no
diff -Nur sysdeps/i386/elf/setjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/setjmp.S
--- sysdeps/i386/elf/setjmp.S	2002-04-07 20:31:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/setjmp.S	2003-10-03 22:25:46.000000000 +0200
@@ -1,5 +1,5 @@
 /* setjmp for i386, ELF version.
-   Copyright (C) 1995,1996,1997,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1997,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -51,13 +51,20 @@
            we can't save and restore our caller's value.  Instead, we do an
            indirect jump through the GOT, using for the temporary register
            %ecx, which is call-clobbered.  */
-	call 1f
+	call __i686.get_pc_thunk.cx
 	addl $_GLOBAL_OFFSET_TABLE_, %ecx
 	leal C_SYMBOL_NAME (BP_SYM (__sigjmp_save)@GOTOFF)(%ecx), %ecx
 	jmp *%ecx
-1:	movl (%esp), %ecx
-	ret
 #else
 	jmp BP_SYM (__sigjmp_save)
 #endif
 END (BP_SYM (__sigsetjmp))
+
+	.section .gnu.linkonce.t.__i686.get_pc_thunk.cx,"ax",@progbits
+	.globl __i686.get_pc_thunk.cx
+	.hidden __i686.get_pc_thunk.cx
+	.type __i686.get_pc_thunk.cx,@function
+__i686.get_pc_thunk.cx:
+	movl (%esp), %ecx
+	ret
+	.size __i686.get_pc_thunk.cx, . - __i686.get_pc_thunk.cx
diff -Nur sysdeps/i386/elf/start.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/start.S
--- sysdeps/i386/elf/start.S	2001-10-19 04:09:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/elf/start.S	2004-08-16 06:51:01.000000000 +0200
@@ -1,5 +1,6 @@
 /* Startup code compliant to the ELF i386 ABI.
-   Copyright (C) 1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -7,6 +8,23 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -67,9 +85,29 @@
 	pushl %edx		/* Push address of the shared library
 				   termination function.  */
 
+#ifdef SHARED
+	/* Load PIC register.  */
+	call 1f
+	addl $_GLOBAL_OFFSET_TABLE_, %ebx
+
 	/* Push address of our own entry points to .fini and .init.  */
-	pushl $_fini
-	pushl $_init
+	leal __libc_csu_fini@GOTOFF(%ebx), %eax
+	pushl %eax
+	leal __libc_csu_init@GOTOFF(%ebx), %eax
+	pushl %eax
+
+	pushl %ecx		/* Push second argument: argv.  */
+	pushl %esi		/* Push first argument: argc.  */
+
+	pushl BP_SYM (main)@GOT(%ebx)
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.    */
+	call BP_SYM (__libc_start_main)@PLT
+#else
+	/* Push address of our own entry points to .fini and .init.  */
+	pushl $__libc_csu_fini
+	pushl $__libc_csu_init
 
 	pushl %ecx		/* Push second argument: argv.  */
 	pushl %esi		/* Push first argument: argc.  */
@@ -79,9 +117,15 @@
 	/* Call the user's main function, and exit with its value.
 	   But let the libc call main.    */
 	call BP_SYM (__libc_start_main)
+#endif
 
 	hlt			/* Crash if somehow `exit' does return.  */
 
+#ifdef SHARED
+1:	movl	(%esp), %ebx
+	ret
+#endif
+
 /* To fulfill the System V/i386 ABI we need this symbol.  Yuck, it's so
    meaningless since we don't support machines < 80386.  */
 	.section .rodata
diff -Nur sysdeps/i386/ffs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/ffs.c
--- sysdeps/i386/ffs.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/ffs.c	2004-07-05 19:36:12.000000000 +0200
@@ -1,7 +1,7 @@
 /* ffs -- find first set bit in a word, counted from least significant end.
    For Intel 80x86, x>=3.
    This file is part of the GNU C Library.
-   Copyright (C) 1991, 92, 93, 94, 97, 98 Free Software Foundation, Inc.
+   Copyright (C) 1991, 92, 93, 94, 97, 98, 2004 Free Software Foundation, Inc.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -42,6 +42,7 @@
   return cnt;
 }
 weak_alias (__ffs, ffs)
+libc_hidden_builtin_def (ffs)
 #undef ffsl
 weak_alias (__ffs, ffsl)
 
diff -Nur sysdeps/i386/fpu/bits/mathdef.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/bits/mathdef.h
--- sysdeps/i386/fpu/bits/mathdef.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/bits/mathdef.h	2004-11-05 00:37:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,6 +23,13 @@
 #if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
 # define _MATH_H_MATHDEF	1
 
+# if defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0
+/* When using -mfpmath=sse, values are computed with the precission of the
+   used type.  */
+typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+# else
 /* The ix87 FPUs evaluate all values in the 80 bit floating-point format
    which is also available for the user as `long double'.  Therefore we
    define:  */
@@ -30,9 +37,7 @@
 				   `long double'.  */
 typedef long double double_t;	/* `double' expressions are evaluated as
 				   `long double'.  */
-
-/* Define `INFINITY' as value of type `float'.  */
-# define INFINITY	HUGE_VALF
+# endif
 
 /* The values returned by `ilogb' for 0 and NaN respectively.  */
 # define FP_ILOGB0	(-2147483647 - 1)
diff -Nur sysdeps/i386/fpu/bits/mathinline.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/bits/mathinline.h
--- sysdeps/i386/fpu/bits/mathinline.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/bits/mathinline.h	2004-09-08 00:23:42.000000000 +0200
@@ -1,5 +1,6 @@
 /* Inline math functions for i387.
-   Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by John C. Bowman <bowman@math.ualberta.ca>, 1995.
 
@@ -30,19 +31,18 @@
 
 
 #if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
-# if __GNUC_PREREQ (2,97)
 /* GCC 2.97 and up have builtins that actually can be used.  */
-#  define isgreater(x, y) __builtin_isgreater (x, y)
-#  define isgreaterequal(x, y) __builtin_isgreaterequal (x, y)
-#  define isless(x, y) __builtin_isless (x, y)
-#  define islessequal(x, y) __builtin_islessequal (x, y)
-#  define islessgreater(x, y) __builtin_islessgreater (x, y)
-#  define isunordered(x, y) __builtin_isunordered (x, y)
-# else
+# if !__GNUC_PREREQ (2,97)
 /* ISO C99 defines some macros to perform unordered comparisons.  The
    ix87 FPU supports this with special opcodes and we should use them.
    These must not be inline functions since we have to be able to handle
    all floating-point types.  */
+#  undef isgreater
+#  undef isgreaterequal
+#  undef isless
+#  undef islessequal
+#  undef islessgreater
+#  undef isunordered
 #  ifdef __i686__
 /* For the PentiumPro and more recent processors we can provide
    better code.  */
@@ -125,19 +125,19 @@
 # if __GNUC_PREREQ (2, 8)
 /* Test for negative number.  Used in the signbit() macro.  */
 __MATH_INLINE int
-__signbitf (float __x) __THROW
+__NTH (__signbitf (float __x))
 {
   __extension__ union { float __f; int __i; } __u = { __f: __x };
   return __u.__i < 0;
 }
 __MATH_INLINE int
-__signbit (double __x) __THROW
+__NTH (__signbit (double __x))
 {
   __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
   return __u.__i[1] < 0;
 }
 __MATH_INLINE int
-__signbitl (long double __x) __THROW
+__NTH (__signbitl (long double __x))
 {
   __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
   return (__u.__i[2] & 0x8000) != 0;
@@ -203,7 +203,7 @@
   __inline_mathop_declNP_ (float_type, func, op, params)
 
 #define __inline_mathop_declNP_(float_type, func, op, params...) \
-  __MATH_INLINE float_type func (float_type __x) __THROW		      \
+  __MATH_INLINE float_type __NTH (func (float_type __x))		      \
   {									      \
     register float_type __result;					      \
     __asm __volatile__ (op : "=t" (__result) : params);			      \
@@ -217,7 +217,7 @@
   __inline_mathcode_ (float, __CONCAT(func,f), arg, code)		      \
   __inline_mathcode_ (long double, __CONCAT(func,l), arg, code)
 # define __inline_mathcodeNP(func, arg, code) \
-  __inline_mathcodeNP_ (double, func, arg, code)				      \
+  __inline_mathcodeNP_ (double, func, arg, code)			      \
   __inline_mathcodeNP_ (float, __CONCAT(func,f), arg, code)		      \
   __inline_mathcodeNP_ (long double, __CONCAT(func,l), arg, code)
 # define __inline_mathcode2(func, arg1, arg2, code) \
@@ -225,7 +225,7 @@
   __inline_mathcode2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
   __inline_mathcode2_ (long double, __CONCAT(func,l), arg1, arg2, code)
 # define __inline_mathcodeNP2(func, arg1, arg2, code) \
-  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)			      \
+  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)		      \
   __inline_mathcodeNP2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
   __inline_mathcodeNP2_ (long double, __CONCAT(func,l), arg1, arg2, code)
 # define __inline_mathcode3(func, arg1, arg2, arg3, code) \
@@ -234,7 +234,7 @@
   __inline_mathcode3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
 # define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
   __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)		      \
-  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)	      \
+  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)     \
   __inline_mathcodeNP3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
 #else
 # define __inline_mathcode(func, arg, code) \
@@ -256,7 +256,7 @@
   __inline_mathcodeNP_(float_type, func, arg, code)
 
 #define __inline_mathcodeNP_(float_type, func, arg, code) \
-  __MATH_INLINE float_type func (float_type arg) __THROW		      \
+  __MATH_INLINE float_type __NTH (func (float_type arg))		      \
   {									      \
     code;								      \
   }
@@ -267,7 +267,7 @@
   __inline_mathcodeNP2_ (float_type, func, arg1, arg2, code)
 
 #define __inline_mathcodeNP2_(float_type, func, arg1, arg2, code) \
-  __MATH_INLINE float_type func (float_type arg1, float_type arg2) __THROW    \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2))    \
   {									      \
     code;								      \
   }
@@ -277,8 +277,8 @@
   __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code)
 
 #define __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code) \
-  __MATH_INLINE float_type func (float_type arg1, float_type arg2,	      \
-				 float_type arg3) __THROW		      \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2,     \
+					float_type arg3))		      \
   {									      \
     code;								      \
   }
@@ -341,19 +341,19 @@
   *__cosx = __cosr
 
 __MATH_INLINE void
-__sincos (double __x, double *__sinx, double *__cosx) __THROW
+__NTH (__sincos (double __x, double *__sinx, double *__cosx))
 {
   __sincos_code;
 }
 
 __MATH_INLINE void
-__sincosf (float __x, float *__sinx, float *__cosx) __THROW
+__NTH (__sincosf (float __x, float *__sinx, float *__cosx))
 {
   __sincos_code;
 }
 
 __MATH_INLINE void
-__sincosl (long double __x, long double *__sinx, long double *__cosx) __THROW
+__NTH (__sincosl (long double __x, long double *__sinx, long double *__cosx))
 {
   __sincos_code;
 }
@@ -363,7 +363,13 @@
 /* Optimized inline implementation, sometimes with reduced precision
    and/or argument range.  */
 
-# define __expm1_code \
+# if __GNUC_PREREQ (3, 5)
+#  define __expm1_code \
+  register long double __temp;						      \
+  __temp = __builtin_expm1l (__x);					      \
+  return __temp ? __temp : __x
+# else
+#  define __expm1_code \
   register long double __value;						      \
   register long double __exponent;					      \
   register long double __temp;						      \
@@ -381,11 +387,15 @@
     ("fscale			# 2^int(x * log2(e))\n\t"		      \
      : "=t" (__temp) : "0" (1.0), "u" (__exponent));			      \
   __temp -= 1.0;							      \
-  return __temp + __value ?: __x
+  __temp += __value;							      \
+  return __temp ? __temp : __x
+# endif
 __inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
 
-
-# define __exp_code \
+# if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
+# else
+#  define __exp_code \
   register long double __value;						      \
   register long double __exponent;					      \
   __asm __volatile__							      \
@@ -404,8 +414,10 @@
   return __value
 __inline_mathcodeNP (exp, __x, __exp_code)
 __inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
+# endif
 
 
+# if !__GNUC_PREREQ (3, 5)
 __inline_mathcodeNP (tan, __x, \
   register long double __value;						      \
   register long double __value2 __attribute__ ((__unused__));		      \
@@ -413,19 +425,28 @@
     ("fptan"								      \
      : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
   return __value)
+# endif
 #endif /* __FAST_MATH__ */
 
 
-#define __atan2_code \
+#if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
+		       return __builtin_atan2l (__y, __x))
+#else
+# define __atan2_code \
   register long double __value;						      \
   __asm __volatile__							      \
     ("fpatan"								      \
      : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
   return __value
+# ifdef __FAST_MATH__
 __inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
+# endif
 __inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
+#endif
 
 
+#if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
 __inline_mathcodeNP2 (fmod, __x, __y, \
   register long double __value;						      \
   __asm __volatile__							      \
@@ -435,15 +456,25 @@
      "jp	1b"							      \
      : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
   return __value)
+#endif
 
 
+#ifdef __FAST_MATH__
+# if !__GNUC_PREREQ (3,3)
 __inline_mathopNP (sqrt, "fsqrt")
 __inline_mathopNP_ (long double, __sqrtl, "fsqrt")
+#  define __libc_sqrtl(n) __sqrtl (n)
+# else
+#  define __libc_sqrtl(n) __builtin_sqrtl (n)
+# endif
+#endif
 
 #if __GNUC_PREREQ (2, 8)
 __inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
+# if defined __USE_MISC || defined __USE_ISOC99
 __inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
 __inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
+# endif
 __inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
 #else
 __inline_mathop (fabs, "fabs")
@@ -451,19 +482,26 @@
 #endif
 
 #ifdef __FAST_MATH__
+# if !__GNUC_PREREQ (3, 4)
 /* The argument range of this inline version is reduced.  */
 __inline_mathopNP (sin, "fsin")
 /* The argument range of this inline version is reduced.  */
 __inline_mathopNP (cos, "fcos")
 
 __inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
+# endif
+
+# if !__GNUC_PREREQ (3, 5)
 __inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
 
-__inline_mathcodeNP (asin, __x, return __atan2l (__x, __sqrtl (1.0 - __x * __x)))
-__inline_mathcodeNP (acos, __x, return __atan2l (__sqrtl (1.0 - __x * __x), __x))
-#endif /* __FAST_MATH__ */
+__inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
+__inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
+# endif
 
+# if !__GNUC_PREREQ (3, 4)
 __inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
+# endif
+#endif /* __FAST_MATH__ */
 
 __inline_mathcode_ (long double, __sgn1l, __x, \
   __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
@@ -511,7 +549,8 @@
   __asm __volatile ("fldcw %0" : : "m" (__cw));				      \
   return __value)
 
-#define __ldexp_code \
+#ifdef __FAST_MATH__
+# define __ldexp_code \
   register long double __value;						      \
   __asm __volatile__							      \
     ("fscale"								      \
@@ -519,10 +558,11 @@
   return __value
 
 __MATH_INLINE double
-ldexp (double __x, int __y) __THROW
+__NTH (ldexp (double __x, int __y))
 {
   __ldexp_code;
 }
+#endif
 
 
 /* Optimized versions for some non-standardized functions.  */
@@ -530,12 +570,12 @@
 
 # ifdef __FAST_MATH__
 __inline_mathcodeNP (expm1, __x, __expm1_code)
-# endif
 
 /* We cannot rely on M_SQRT being defined.  So we do it for ourself
    here.  */
-# define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
+#  define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
 
+#  if !__GNUC_PREREQ (3, 5)
 __inline_mathcodeNP (log1p, __x, \
   register long double __value;						      \
   if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
@@ -547,24 +587,27 @@
        "fyl2xp1"							      \
        : "=t" (__value) : "0" (__x) : "st(1)");				      \
   return __value)
+#  endif
 
 
 /* The argument range of the inline version of asinhl is slightly reduced.  */
 __inline_mathcodeNP (asinh, __x, \
   register long double  __y = __fabsl (__x);				      \
-  return (log1pl (__y * __y / (__sqrtl (__y * __y + 1.0) + 1.0) + __y)	      \
+  return (log1pl (__y * __y / (__libc_sqrtl (__y * __y + 1.0) + 1.0) + __y)   \
 	  * __sgn1l (__x)))
 
 __inline_mathcodeNP (acosh, __x, \
-  return logl (__x + __sqrtl (__x - 1.0) * __sqrtl (__x + 1.0)))
+  return logl (__x + __libc_sqrtl (__x - 1.0) * __libc_sqrtl (__x + 1.0)))
 
 __inline_mathcodeNP (atanh, __x, \
   register long double __y = __fabsl (__x);				      \
   return -0.5 * log1pl (-(__y + __y) / (1.0 + __y)) * __sgn1l (__x))
 
 /* The argument range of the inline version of hypotl is slightly reduced.  */
-__inline_mathcodeNP2 (hypot, __x, __y, return __sqrtl (__x * __x + __y * __y))
+__inline_mathcodeNP2 (hypot, __x, __y,
+		      return __libc_sqrtl (__x * __x + __y * __y))
 
+#  if !__GNUC_PREREQ (3, 5)
 __inline_mathcodeNP(logb, __x, \
   register long double __value;						      \
   register long double __junk;						      \
@@ -572,83 +615,87 @@
     ("fxtract\n\t"							      \
      : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
   return __value)
+#  endif
 
+# endif
 #endif
 
 #ifdef __USE_ISOC99
-#ifdef __FAST_MATH__
+# ifdef __FAST_MATH__
+
+#  if !__GNUC_PREREQ (3, 5)
 __inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
-#endif /* __FAST_MATH__ */
+#  endif
 
 __MATH_INLINE float
-ldexpf (float __x, int __y) __THROW
+__NTH (ldexpf (float __x, int __y))
 {
   __ldexp_code;
 }
 
 __MATH_INLINE long double
-ldexpl (long double __x, int __y) __THROW
+__NTH (ldexpl (long double __x, int __y))
 {
   __ldexp_code;
 }
 
-#ifdef __FAST_MATH__
 __inline_mathcodeNP3 (fma, __x, __y, __z, return (__x * __y) + __z)
 
 __inline_mathopNP (rint, "frndint")
-#endif /* __FAST_MATH__ */
+# endif /* __FAST_MATH__ */
 
-#define __lrint_code \
+# define __lrint_code \
   long int __lrintres;							      \
   __asm__ __volatile__							      \
     ("fistpl %0"							      \
      : "=m" (__lrintres) : "t" (__x) : "st");				      \
   return __lrintres
 __MATH_INLINE long int
-lrintf (float __x) __THROW
+__NTH (lrintf (float __x))
 {
   __lrint_code;
 }
 __MATH_INLINE long int
-lrint (double __x) __THROW
+__NTH (lrint (double __x))
 {
   __lrint_code;
 }
 __MATH_INLINE long int
-lrintl (long double __x) __THROW
+__NTH (lrintl (long double __x))
 {
   __lrint_code;
 }
-#undef __lrint_code
+# undef __lrint_code
 
-#define __llrint_code \
+# define __llrint_code \
   long long int __llrintres;						      \
   __asm__ __volatile__							      \
     ("fistpll %0"							      \
      : "=m" (__llrintres) : "t" (__x) : "st");				      \
   return __llrintres
 __MATH_INLINE long long int
-llrintf (float __x) __THROW
+__NTH (llrintf (float __x))
 {
   __llrint_code;
 }
 __MATH_INLINE long long int
-llrint (double __x) __THROW
+__NTH (llrint (double __x))
 {
   __llrint_code;
 }
 __MATH_INLINE long long int
-llrintl (long double __x) __THROW
+__NTH (llrintl (long double __x))
 {
   __llrint_code;
 }
-#undef __llrint_code
+# undef __llrint_code
 
 #endif
 
 
 #ifdef __USE_MISC
 
+# if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
 __inline_mathcodeNP2 (drem, __x, __y, \
   register double __value;						      \
   register int __clobbered;						      \
@@ -659,11 +706,12 @@
      "jp	1b"							      \
      : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
   return __value)
+# endif
 
 
 /* This function is used in the `isfinite' macro.  */
 __MATH_INLINE int
-__finite (double __x) __THROW
+__NTH (__finite (double __x))
 {
   return (__extension__
 	  (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
@@ -671,15 +719,15 @@
 }
 
 /* Miscellaneous functions */
-#ifdef __FAST_MATH__
+# ifdef __FAST_MATH__
 __inline_mathcode (__coshm1, __x, \
   register long double __exm1 = __expm1l (__fabsl (__x));		      \
   return 0.5 * (__exm1 / (__exm1 + 1.0)) * __exm1)
 
 __inline_mathcode (__acosh1p, __x, \
-  return log1pl (__x + __sqrtl (__x) * __sqrtl (__x + 2.0)))
+  return log1pl (__x + __libc_sqrtl (__x) * __libc_sqrtl (__x + 2.0)))
 
-#endif /* __FAST_MATH__ */
+# endif /* __FAST_MATH__ */
 #endif /* __USE_MISC  */
 
 /* Undefine some of the large macros which are not used anymore.  */
diff -Nur sysdeps/i386/fpu/e_powf.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_powf.S
--- sysdeps/i386/fpu/e_powf.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_powf.S	2004-07-20 09:04:32.000000000 +0200
@@ -1,5 +1,5 @@
 /* ix87 specific implementation of pow function.
-   Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1999, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -48,6 +48,9 @@
 	ASM_TYPE_DIRECTIVE(limit,@object)
 limit:	.double 0.29
 	ASM_SIZE_DIRECTIVE(limit)
+	ASM_TYPE_DIRECTIVE(p31,@object)
+p31:	.byte 0, 0, 0, 0, 0, 0, 0xe0, 0x41
+	ASM_SIZE_DIRECTIVE(p31)
 
 #ifdef PIC
 #define MO(op) op##@GOTOFF(%ecx)
@@ -96,6 +99,14 @@
 
 	fxch			// y : x
 
+	/* fistpl raises invalid exception for |y| >= 1L<<31.  */
+	fld	%st		// y : y : x
+	fabs			// |y| : y : x
+	fcompl	MO(p31)		// y : x
+	fnstsw
+	sahf
+	jnc	2f
+
 	/* First see whether `y' is a natural number.  In this case we
 	   can use a more precise algorithm.  */
 	fld	%st		// y : y : x
diff -Nur sysdeps/i386/fpu/e_powl.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_powl.S
--- sysdeps/i386/fpu/e_powl.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_powl.S	2004-07-20 09:05:57.000000000 +0200
@@ -1,5 +1,6 @@
 /* ix87 specific implementation of pow function.
-   Copyright (C) 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 1999, 2001, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -48,6 +49,9 @@
 	ASM_TYPE_DIRECTIVE(limit,@object)
 limit:	.double 0.29
 	ASM_SIZE_DIRECTIVE(limit)
+	ASM_TYPE_DIRECTIVE(p63,@object)
+p63:	.byte 0, 0, 0, 0, 0, 0, 0xe0, 0x43
+	ASM_SIZE_DIRECTIVE(p63)
 
 #ifdef PIC
 #define MO(op) op##@GOTOFF(%ecx)
@@ -96,6 +100,14 @@
 
 	fxch			// y : x
 
+	/* fistpll raises invalid exception for |y| >= 1L<<63.  */
+	fld	%st		// y : y : x
+	fabs			// |y| : y : x
+	fcompl	MO(p63)		// y : x
+	fnstsw
+	sahf
+	jnc	2f
+
 	/* First see whether `y' is a natural number.  In this case we
 	   can use a more precise algorithm.  */
 	fld	%st		// y : y : x
@@ -161,6 +173,11 @@
 
 7:	fyl2x			// log2(x) : y
 8:	fmul	%st(1)		// y*log2(x) : y
+	fxam
+	fnstsw
+	andb	$0x45, %ah
+	cmpb	$0x05, %ah	// is y*log2(x) == inf ?
+	je	28f
 	fst	%st(1)		// y*log2(x) : y*log2(x)
 	frndint			// int(y*log2(x)) : y*log2(x)
 	fsubr	%st, %st(1)	// int(y*log2(x)) : fract(y*log2(x))
@@ -172,6 +189,12 @@
 	fstp	%st(1)		// 2^fract(y*log2(x))*2^int(y*log2(x))
 	ret
 
+28:	fstp	%st(1)		// y*log2(x)
+	fldl	MO(one)		// 1 : y*log2(x)
+	fscale			// 2^(y*log2(x)) : y*log2(x)
+	addl	$8, %esp
+	fstp	%st(1)		// 2^(y*log2(x))
+	ret
 
 	// pow(x,0) = 1
 	.align ALIGNARG(4)
diff -Nur sysdeps/i386/fpu/e_pow.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_pow.S
--- sysdeps/i386/fpu/e_pow.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/e_pow.S	2004-07-20 09:05:00.000000000 +0200
@@ -1,5 +1,6 @@
 /* ix87 specific implementation of pow function.
-   Copyright (C) 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 1999, 2001, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -48,6 +49,9 @@
 	ASM_TYPE_DIRECTIVE(limit,@object)
 limit:	.double 0.29
 	ASM_SIZE_DIRECTIVE(limit)
+	ASM_TYPE_DIRECTIVE(p63,@object)
+p63:	.byte 0, 0, 0, 0, 0, 0, 0xe0, 0x43
+	ASM_SIZE_DIRECTIVE(p63)
 
 #ifdef PIC
 #define MO(op) op##@GOTOFF(%ecx)
@@ -96,6 +100,14 @@
 
 	fxch			// y : x
 
+	/* fistpll raises invalid exception for |y| >= 1L<<63.  */
+	fld	%st		// y : y : x
+	fabs			// |y| : y : x
+	fcompl	MO(p63)		// y : x
+	fnstsw
+	sahf
+	jnc	2f
+
 	/* First see whether `y' is a natural number.  In this case we
 	   can use a more precise algorithm.  */
 	fld	%st		// y : y : x
diff -Nur sysdeps/i386/fpu/fclrexcpt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fclrexcpt.c
--- sysdeps/i386/fpu/fclrexcpt.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fclrexcpt.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Clear given exceptions in current floating-point environment.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1997,99,2000, 2001, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,6 +19,9 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 __feclearexcept (int excepts)
@@ -38,6 +41,21 @@
   /* Put the new data in effect.  */
   __asm__ ("fldenv %0" : : "m" (*&temp));
 
+  /* If the CPU supports SSE, we clear the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xnew_exc;
+
+      /* Get the current MXCSR.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xnew_exc));
+
+      /* Clear the relevant bits.  */
+      xnew_exc &= ~excepts;
+
+      /* Put the new data in effect.  */
+      __asm__ ("ldmxcsr %0" : : "m" (*&xnew_exc));
+    }
+
   /* Success.  */
   return 0;
 }
diff -Nur sysdeps/i386/fpu/fedisblxcpt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fedisblxcpt.c
--- sysdeps/i386/fpu/fedisblxcpt.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fedisblxcpt.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Disable floating-point exceptions.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 1999.
 
@@ -19,6 +19,9 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 fedisableexcept (int excepts)
@@ -35,5 +38,18 @@
   new_exc |= excepts;
   __asm__ ("fldcw %0" : : "m" (*&new_exc));
 
+  /* If the CPU supports SSE we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xnew_exc;
+
+      /* Get the current control word.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xnew_exc));
+
+      xnew_exc |= excepts << 7;
+
+      __asm__ ("ldmxcsr %0" : : "m" (*&xnew_exc));
+    }
+
   return old_exc;
 }
diff -Nur sysdeps/i386/fpu/feenablxcpt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/feenablxcpt.c
--- sysdeps/i386/fpu/feenablxcpt.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/feenablxcpt.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Enable floating-point exceptions.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 1999.
 
@@ -19,11 +19,15 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 feenableexcept (int excepts)
 {
-  unsigned short int new_exc, old_exc;
+  unsigned short int new_exc;
+  unsigned short int old_exc;
 
   /* Get the current control word.  */
   __asm__ ("fstcw %0" : "=m" (*&new_exc));
@@ -34,5 +38,18 @@
   new_exc &= ~excepts;
   __asm__ ("fldcw %0" : : "m" (*&new_exc));
 
+  /* If the CPU supports SSE we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xnew_exc;
+
+      /* Get the current control word.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xnew_exc));
+
+      xnew_exc &= ~(excepts << 7);
+
+      __asm__ ("ldmxcsr %0" : : "m" (*&xnew_exc));
+    }
+
   return old_exc;
 }
diff -Nur sysdeps/i386/fpu/fegetenv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fegetenv.c
--- sysdeps/i386/fpu/fegetenv.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fegetenv.c	2003-06-24 11:00:17.000000000 +0200
@@ -1,5 +1,5 @@
 /* Store current floating-point environment.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1997,1999,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -25,6 +25,10 @@
 __fegetenv (fenv_t *envp)
 {
   __asm__ ("fnstenv %0" : "=m" (*envp));
+  /* And load it right back since the processor changes the mask.
+     Intel thought this opcode to be used in interrupt handlers which
+     would block all exceptions.  */
+  __asm__ ("fldenv %0" : : "m" (*envp));
 
   /* Success.  */
   return 0;
diff -Nur sysdeps/i386/fpu/feholdexcpt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/feholdexcpt.c
--- sysdeps/i386/fpu/feholdexcpt.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/feholdexcpt.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Store current floating-point environment and clear exceptions.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,6 +19,9 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 feholdexcept (fenv_t *envp)
@@ -32,5 +35,19 @@
   work = envp->__control_word | 0x3f;
   __asm__ ("fldcw %0" : : "m" (*&work));
 
+  /* If the CPU supports SSE we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xwork;
+
+      /* Get the current control word.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xwork));
+
+      /* Set all exceptions to non-stop.  */
+      xwork |= 0x1f80;
+
+      __asm__ ("ldmxcsr %0" : : "m" (*&xwork));
+    }
+
   return 0;
 }
diff -Nur sysdeps/i386/fpu/fesetround.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fesetround.c
--- sysdeps/i386/fpu/fesetround.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fesetround.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Set current rounding direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,6 +19,9 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 fesetround (int round)
@@ -34,5 +37,16 @@
   cw |= round;
   __asm__ ("fldcw %0" : : "m" (*&cw));
 
+  /* If the CPU supports SSE we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xcw;
+
+      __asm__ ("stmxcsr %0" : "=m" (*&xcw));
+      xcw &= ~0x6000;
+      xcw |= round << 3;
+      __asm__ ("ldmxcsr %0" : : "m" (*&xcw));
+    }
+
   return 0;
 }
diff -Nur sysdeps/i386/fpu/fsetexcptflg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fsetexcptflg.c
--- sysdeps/i386/fpu/fsetexcptflg.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/fsetexcptflg.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Set floating-point environment exception handling.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1997,99,2000,01, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -21,6 +21,9 @@
 #include <fenv.h>
 #include <math.h>
 #include <bp-sym.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
 
 int
 __fesetexceptflag (const fexcept_t *flagp, int excepts)
@@ -39,6 +42,22 @@
      the next floating-point instruction.  */
   __asm__ ("fldenv %0" : : "m" (*&temp));
 
+  /* If the CPU supports SSE, we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xnew_exc;
+
+      /* Get the current MXCSR.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xnew_exc));
+
+      /* Set the relevant bits.  */
+      xnew_exc &= ~(excepts & FE_ALL_EXCEPT);
+      xnew_exc |= *flagp & excepts & FE_ALL_EXCEPT;
+
+      /* Put the new data in effect.  */
+      __asm__ ("ldmxcsr %0" : : "m" (*&xnew_exc));
+    }
+
   /* Success.  */
   return 0;
 }
diff -Nur sysdeps/i386/fpu/ftestexcept.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/ftestexcept.c
--- sysdeps/i386/fpu/ftestexcept.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/ftestexcept.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Test exception in current environment.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,14 +19,22 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <unistd.h>
+#include <dl-procinfo.h>
+#include <ldsodefs.h>
 
 int
 fetestexcept (int excepts)
 {
   int temp;
+  int xtemp = 0;
 
   /* Get current exceptions.  */
   __asm__ ("fnstsw %0" : "=a" (temp));
 
-  return temp & excepts & FE_ALL_EXCEPT;
+  /* If the CPU supports SSE we test the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    __asm__ ("stmxcsr %0" : "=m" (*&xtemp));
+
+  return (temp | xtemp) & excepts & FE_ALL_EXCEPT;
 }
diff -Nur sysdeps/i386/fpu/libm-test-ulps /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/libm-test-ulps
--- sysdeps/i386/fpu/libm-test-ulps	2002-08-28 14:09:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/libm-test-ulps	2004-07-01 03:43:14.000000000 +0200
@@ -121,7 +121,7 @@
 ldouble: 1
 
 # ccos
-Test "Imaginary part of: ccos (-2 - 3 i) == -4.1896256909688072301 - 9.1092278937553365979 i":
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
 float: 1
 ifloat: 1
 ildouble: 1
@@ -136,7 +136,7 @@
 ldouble: 1
 
 # ccosh
-Test "Imaginary part of: ccosh (-2 - 3 i) == -3.7245455049153225654 + 0.5118225699873846088 i":
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
 double: 1
 float: 1
 idouble: 1
@@ -181,7 +181,7 @@
 float: 1
 idouble: 1
 ifloat: 1
-Test "Imaginary part of: clog10 (-2 - 3 i) == 0.5569716761534183846 - 0.9375544629863747085 i":
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
 double: 1
 idouble: 1
 ildouble: 1
@@ -343,10 +343,10 @@
 ifloat: 1
 
 # csinh
-Test "Real part of: csinh (-2 - 3 i) == 3.5905645899857799520 - 0.5309210862485198052 i":
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
 double: 1
 idouble: 1
-Test "Imaginary part of: csinh (-2 - 3 i) == 3.5905645899857799520 - 0.5309210862485198052 i":
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
 double: 1
 float: 1
 idouble: 1
@@ -363,10 +363,12 @@
 ifloat: 1
 
 # ctan
-Test "Real part of: ctan (-2 - 3 i) == 0.0037640256415042482 - 1.0032386273536098014 i":
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+double: 1
+idouble: 1
 ildouble: 439
 ldouble: 439
-Test "Imaginary part of: ctan (-2 - 3 i) == 0.0037640256415042482 - 1.0032386273536098014 i":
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
 float: 1
 ifloat: 1
 ildouble: 2
@@ -381,10 +383,10 @@
 ldouble: 3
 
 # ctanh
-Test "Real part of: ctanh (-2 - 3 i) == -0.9653858790221331242 + 0.0098843750383224937 i":
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
 ildouble: 5
 ldouble: 5
-Test "Imaginary part of: ctanh (-2 - 3 i) == -0.9653858790221331242 + 0.0098843750383224937 i":
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
 float: 1
 ifloat: 1
 ildouble: 25
@@ -607,9 +609,9 @@
 ldouble: 1
 Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
 double: 1
-float: 1
+float: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ildouble: 1
 ldouble: 1
 Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
@@ -624,12 +626,12 @@
 idouble: 1
 ildouble: 1
 ldouble: 1
-Test "lgamma (0.7) == 0.26086724653166651439":
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
 float: 1
 ifloat: 1
 double: 1
 idouble: 1
-Test "lgamma (1.2) == -0.853740900033158497197e-1":
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
 double: 1
 float: 2
 idouble: 1
@@ -693,7 +695,7 @@
 Test "tgamma (0.5) == sqrt (pi)":
 float: 1
 ifloat: 1
-Test "tgamma (0.7) == 1.29805533264755778568":
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
 double: 1
 float: 1
 idouble: 1
@@ -841,6 +843,8 @@
 Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
 float: 3
 ifloat: 3
+double: 2
+idouble: 2
 Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
 ildouble: 1
 ldouble: 1
@@ -854,6 +858,8 @@
 Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
 float: 1
 ifloat: 1
+double: 1
+idouble: 1
 Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
 double: 1
 float: 1
@@ -1053,11 +1059,15 @@
 ldouble: 2
 
 Function: Real part of "ctan":
+double: 1
+idouble: 1
 ildouble: 439
 ldouble: 439
 
 Function: Imaginary part of "ctan":
+double: 1
 float: 1
+idouble: 1
 ifloat: 1
 ildouble: 3
 ldouble: 3
diff -Nur sysdeps/i386/fpu/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/Makefile
--- sysdeps/i386/fpu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/Makefile	2003-04-29 09:14:48.000000000 +0200
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+$(objpfx)libm.so: $(elfobjdir)/ld.so
+endif
diff -Nur sysdeps/i386/fpu/s_fdimf.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdimf.S
--- sysdeps/i386/fpu/s_fdimf.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdimf.S	2004-09-30 04:56:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -30,22 +30,23 @@
 	sahf
 	jp	1f
 
-	fsubrp	%st, %st(1)
-	jc	2f
+	jc	3f
 
-	fstp	%st(0)
+	fstp	%st(1)
 	fldz
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fxam
 	fnstsw
 	andb	$0x45, %ah
 	cmpb	$0x01, %ah
-	je	3f
+	je	2f
 
 	fxch
-3:	fstp	%st(1)
-
-2:	ret
+2:	fstp	%st(1)
+	ret
 END(__fdimf)
 weak_alias (__fdimf, fdimf)
diff -Nur sysdeps/i386/fpu/s_fdiml.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdiml.S
--- sysdeps/i386/fpu/s_fdiml.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdiml.S	2004-09-30 04:56:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -30,22 +30,23 @@
 	sahf
 	jp	1f
 
-	fsubrp	%st, %st(1)
-	jc	2f
+	jc	3f
 
-	fstp	%st(0)
+	fstp	%st(1)
 	fldz
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fxam
 	fnstsw
 	andb	$0x45, %ah
 	cmpb	$0x01, %ah
-	je	3f
+	je	2f
 
 	fxch
-3:	fstp	%st(1)
-
-2:	ret
+2:	fstp	%st(1)
+	ret
 END(__fdiml)
 weak_alias (__fdiml, fdiml)
diff -Nur sysdeps/i386/fpu/s_fdim.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdim.S
--- sysdeps/i386/fpu/s_fdim.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_fdim.S	2004-09-30 04:56:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -30,22 +30,23 @@
 	sahf
 	jp	1f
 
-	fsubrp	%st, %st(1)
-	jc	2f
+	jc	3f
 
-	fstp	%st(0)
+	fstp	%st(1)
 	fldz
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fxam
 	fnstsw
 	andb	$0x45, %ah
 	cmpb	$0x01, %ah
-	je	3f
+	je	2f
 
 	fxch
-3:	fstp	%st(1)
-
-2:	ret
+2:	fstp	%st(1)
+	ret
 END(__fdim)
 weak_alias (__fdim, fdim)
diff -Nur sysdeps/i386/fpu/s_nextafterl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nextafterl.c
--- sysdeps/i386/fpu/s_nextafterl.c	2001-06-25 10:04:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nextafterl.c	2003-02-15 06:22:58.000000000 +0100
@@ -61,9 +61,9 @@
 	      /* x > y, x -= ulp */
 		if(lx==0) {
 		    if (hx <= 0x80000000) {
-		      if (esx == 0)
-			hx = 0;
-		      else {
+		      if (esx == 0) {
+			--hx;
+		      } else {
 			esx -= 1;
 			hx = hx - 1;
 			if (esx > 0)
diff -Nur sysdeps/i386/fpu/s_nexttoward.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nexttoward.c
--- sysdeps/i386/fpu/s_nexttoward.c	2001-06-16 05:30:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nexttoward.c	2003-12-07 22:11:52.000000000 +0100
@@ -83,7 +83,12 @@
 	    }
 	}
 	hy = hx&0x7ff00000;
-	if(hy>=0x7ff00000) return x+x;	/* overflow  */
+	if(hy>=0x7ff00000) {
+	  x = x+x;	/* overflow  */
+	  /* Force conversion to double.  */
+	  asm ("" : "=m"(x) : "m"(x));
+	  return x;
+	}
 	if(hy<0x00100000) {		/* underflow */
 	    double x2 = x*x;
 	    if(x2!=x) {		/* raise underflow flag */
diff -Nur sysdeps/i386/fpu/s_nexttowardf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nexttowardf.c
--- sysdeps/i386/fpu/s_nexttowardf.c	2001-06-16 05:30:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_nexttowardf.c	2003-12-07 22:12:13.000000000 +0100
@@ -67,7 +67,12 @@
 	    }
 	}
 	hy = hx&0x7f800000;
-	if(hy>=0x7f800000) return x+x;	/* overflow  */
+	if(hy>=0x7f800000) {
+	  x = x+x;	/* overflow  */
+	  /* Force conversion to float.  */
+	  asm ("" : "=m"(x) : "m"(x));
+	  return x;
+	}
 	if(hy<0x00800000) {		/* underflow */
 	    float x2 = x*x;
 	    if(x2!=x) {		/* raise underflow flag */
diff -Nur sysdeps/i386/fpu/s_significandl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_significandl.c
--- sysdeps/i386/fpu/s_significandl.c	2001-09-18 16:13:02.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu/s_significandl.c	2003-01-07 08:42:11.000000000 +0100
@@ -12,7 +12,7 @@
   long double res;
 
   asm ("fxtract\n"
-       "fstp	%%st(0)" : "=t" (res) : "0" (x));
+       "fstp	%%st(1)" : "=t" (res) : "0" (x));
   return res;
 }
 
diff -Nur sysdeps/i386/fpu_control.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu_control.h
--- sysdeps/i386/fpu_control.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/fpu_control.h	2004-11-22 20:02:54.000000000 +0100
@@ -1,5 +1,5 @@
 /* FPU control word bits.  i387 version.
-   Copyright (C) 1993,1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1993,1995-1998,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Olaf Flebbe.
 
@@ -88,9 +88,13 @@
 /* Type of the control word.  */
 typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
 
-/* Macros for accessing the hardware control word.  */
-#define _FPU_GETCW(cw) __asm__ ("fnstcw %0" : "=m" (*&cw))
-#define _FPU_SETCW(cw) __asm__ ("fldcw %0" : : "m" (*&cw))
+/* Macros for accessing the hardware control word.
+
+   Note that the use of these macros is no sufficient anymore with
+   recent hardware.  Some floating point operations are executed in
+   the SSE/SSE2 engines which have their own control and status register.  */
+#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
+#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
 
 /* Default control word set at startup.  */
 extern fpu_control_t __fpu_control;
diff -Nur sysdeps/i386/i486/atomicity.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/atomicity.h
--- sysdeps/i386/i486/atomicity.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/atomicity.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/* Low-level functions for atomic operations.  ix86 version, x >= 4.
-   Copyright (C) 1997, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _ATOMICITY_H
-#define _ATOMICITY_H	1
-
-#include <inttypes.h>
-
-
-static inline uint32_t
-__attribute__ ((unused))
-exchange_and_add (volatile uint32_t *mem, uint32_t val)
-{
-  register uint32_t result;
-  __asm__ __volatile__ ("lock; xaddl %0,%1"
-			: "=r" (result), "=m" (*mem) : "0" (val), "1" (*mem));
-  return result;
-}
-
-static inline void
-__attribute__ ((unused))
-atomic_add (volatile uint32_t *mem, int val)
-{
-  __asm__ __volatile__ ("lock; addl %1,%0"
-			: "=m" (*mem) : "ir" (val), "0" (*mem));
-}
-
-static inline char
-__attribute__ ((unused))
-compare_and_swap (volatile long int *p, long int oldval, long int newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
-                        : "=q" (ret), "=m" (*p), "=a" (readval)
-                        : "r" (newval), "1" (*p), "a" (oldval));
-  return ret;
-}
-
-#endif /* atomicity.h */
diff -Nur sysdeps/i386/i486/bits/atomic.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/bits/atomic.h
--- sysdeps/i386/i486/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/bits/atomic.h	2004-09-08 00:30:47.000000000 +0200
@@ -0,0 +1,366 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int16_t atomic16_t;
+typedef uint16_t uatomic16_t;
+typedef int_fast16_t atomic_fast16_t;
+typedef uint_fast16_t uatomic_fast16_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+
+#ifndef LOCK_PREFIX
+# ifdef UP
+#  define LOCK_PREFIX	/* nothing */
+# else
+#  define LOCK_PREFIX "lock;"
+# endif
+#endif
+
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret;						      \
+     __asm __volatile (LOCK_PREFIX "cmpxchgb %b2, %1"			      \
+		       : "=a" (ret), "=m" (*mem)			      \
+		       : "q" (newval), "m" (*mem), "0" (oldval));	      \
+     ret; })
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret;						      \
+     __asm __volatile (LOCK_PREFIX "cmpxchgw %w2, %1"			      \
+		       : "=a" (ret), "=m" (*mem)			      \
+		       : "r" (newval), "m" (*mem), "0" (oldval));	      \
+     ret; })
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret;						      \
+     __asm __volatile (LOCK_PREFIX "cmpxchgl %2, %1"			      \
+		       : "=a" (ret), "=m" (*mem)			      \
+		       : "r" (newval), "m" (*mem), "0" (oldval));	      \
+     ret; })
+
+/* XXX We do not really need 64-bit compare-and-exchange.  At least
+   not in the moment.  Using it would mean causing portability
+   problems since not many other 32-bit architectures have support for
+   such an operation.  So don't define any code for now.  If it is
+   really going to be used the code below can be used on Intel Pentium
+   and later, but NOT on i486.  */
+#if 1
+# define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret = *(mem); abort (); ret = (newval); ret = (oldval); })
+#else
+# ifdef __PIC__
+#  define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret;						      \
+     __asm __volatile ("xchgl %2, %%ebx\n\t"				      \
+		       LOCK_PREFIX "cmpxchg8b %1\n\t"			      \
+		       "xchgl %2, %%ebx"				      \
+		       : "=A" (ret), "=m" (*mem)			      \
+		       : "DS" (((unsigned long long int) (newval))	      \
+			       & 0xffffffff),				      \
+			 "c" (((unsigned long long int) (newval)) >> 32),     \
+			 "m" (*mem), "a" (((unsigned long long int) (oldval)) \
+					  & 0xffffffff),		      \
+			 "d" (((unsigned long long int) (oldval)) >> 32));    \
+     ret; })
+# else
+#  define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __typeof (*mem) ret;						      \
+     __asm __volatile (LOCK_PREFIX "cmpxchg8b %1"			      \
+		       : "=A" (ret), "=m" (*mem)			      \
+		       : "b" (((unsigned long long int) (newval))	      \
+			      & 0xffffffff),				      \
+			 "c" (((unsigned long long int) (newval)) >> 32),     \
+			 "m" (*mem), "a" (((unsigned long long int) (oldval)) \
+					  & 0xffffffff),		      \
+			 "d" (((unsigned long long int) (oldval)) >> 32));    \
+     ret; })
+# endif
+#endif
+
+
+/* Note that we need no lock prefix.  */
+#define atomic_exchange_acq(mem, newvalue) \
+  ({ __typeof (*mem) result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile ("xchgb %b0, %1"				      \
+			 : "=r" (result), "=m" (*mem)			      \
+			 : "0" (newvalue), "m" (*mem));			      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile ("xchgw %w0, %1"				      \
+			 : "=r" (result), "=m" (*mem)			      \
+			 : "0" (newvalue), "m" (*mem));			      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile ("xchgl %0, %1"					      \
+			 : "=r" (result), "=m" (*mem)			      \
+			 : "0" (newvalue), "m" (*mem));			      \
+     else								      \
+       {								      \
+	 result = 0;							      \
+	 abort ();							      \
+       }								      \
+     result; })
+
+
+#define atomic_exchange_and_add(mem, value) \
+  ({ __typeof (*mem) __result;						      \
+     __typeof (value) __addval = (value);				      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "xaddb %b0, %1"			      \
+			 : "=r" (__result), "=m" (*mem)			      \
+			 : "0" (__addval), "m" (*mem));			      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "xaddw %w0, %1"			      \
+			 : "=r" (__result), "=m" (*mem)			      \
+			 : "0" (__addval), "m" (*mem));			      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "xaddl %0, %1"			      \
+			 : "=r" (__result), "=m" (*mem)			      \
+			 : "0" (__addval), "m" (*mem));			      \
+     else								      \
+       {								      \
+	 __typeof (mem) __memp = (mem);					      \
+	 __typeof (*mem) __tmpval;					      \
+	 __result = *__memp;						      \
+	 do								      \
+	   __tmpval = __result;						      \
+	 while ((__result = __arch_compare_and_exchange_val_64_acq	      \
+		 (__memp, __result + __addval, __result)) == __tmpval);	      \
+       }								      \
+     __result; })
+
+
+#define atomic_add(mem, value) \
+  (void) ({ if (__builtin_constant_p (value) && (value) == 1)		      \
+	      atomic_increment (mem);					      \
+	    else if (__builtin_constant_p (value) && (value) == -1)	      \
+	      atomic_decrement (mem);					      \
+	    else if (sizeof (*mem) == 1)				      \
+	      __asm __volatile (LOCK_PREFIX "addb %b1, %0"		      \
+				: "=m" (*mem)				      \
+				: "ir" (value), "m" (*mem));		      \
+	    else if (sizeof (*mem) == 2)				      \
+	      __asm __volatile (LOCK_PREFIX "addw %w1, %0"		      \
+				: "=m" (*mem)				      \
+				: "ir" (value), "m" (*mem));		      \
+	    else if (sizeof (*mem) == 4)				      \
+	      __asm __volatile (LOCK_PREFIX "addl %1, %0"		      \
+				: "=m" (*mem)				      \
+				: "ir" (value), "m" (*mem));		      \
+	    else							      \
+	      {								      \
+		__typeof (value) __addval = (value);			      \
+		__typeof (mem) __memp = (mem);				      \
+		__typeof (*mem) __oldval = *__memp;			      \
+		__typeof (*mem) __tmpval;				      \
+		do							      \
+		  __tmpval = __oldval;					      \
+		while ((__oldval = __arch_compare_and_exchange_val_64_acq     \
+		       (__memp, __oldval + __addval, __oldval)) == __tmpval); \
+	      }								      \
+	    })
+
+
+#define atomic_add_negative(mem, value) \
+  ({ unsigned char __result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "addb %b2, %0; sets %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "iq" (value), "m" (*mem));			      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "addw %w2, %0; sets %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "ir" (value), "m" (*mem));			      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "addl %2, %0; sets %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "ir" (value), "m" (*mem));			      \
+     else								      \
+       abort ();							      \
+     __result; })
+
+
+#define atomic_add_zero(mem, value) \
+  ({ unsigned char __result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "addb %b2, %0; setz %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "ir" (value), "m" (*mem));			      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "addw %w2, %0; setz %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "ir" (value), "m" (*mem));			      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "addl %2, %0; setz %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "ir" (value), "m" (*mem));			      \
+     else								      \
+       abort ();							      \
+     __result; })
+
+
+#define atomic_increment(mem) \
+  (void) ({ if (sizeof (*mem) == 1)					      \
+	      __asm __volatile (LOCK_PREFIX "incb %b0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else if (sizeof (*mem) == 2)				      \
+	      __asm __volatile (LOCK_PREFIX "incw %w0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else if (sizeof (*mem) == 4)				      \
+	      __asm __volatile (LOCK_PREFIX "incl %0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else							      \
+	      {								      \
+		__typeof (mem) __memp = (mem);				      \
+		__typeof (*mem) __oldval = *__memp;			      \
+		__typeof (*mem) __tmpval;				      \
+		do							      \
+		  __tmpval = __oldval;					      \
+		while ((__oldval = __arch_compare_and_exchange_val_64_acq     \
+		       (__memp, __oldval + 1, __oldval)) == __tmpval);	      \
+	      }								      \
+	    })
+
+
+#define atomic_increment_and_test(mem) \
+  ({ unsigned char __result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "incb %0; sete %b1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "incw %0; sete %w1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "incl %0; sete %1"			      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else								      \
+       abort ();							      \
+     __result; })
+
+
+#define atomic_decrement(mem) \
+  (void) ({ if (sizeof (*mem) == 1)					      \
+	      __asm __volatile (LOCK_PREFIX "decb %b0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else if (sizeof (*mem) == 2)				      \
+	      __asm __volatile (LOCK_PREFIX "decw %w0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else if (sizeof (*mem) == 4)				      \
+	      __asm __volatile (LOCK_PREFIX "decl %0"			      \
+				: "=m" (*mem)				      \
+				: "m" (*mem));				      \
+	    else							      \
+	      {								      \
+		__typeof (mem) __memp = (mem);				      \
+		__typeof (*mem) __oldval = *__memp;			      \
+		__typeof (*mem) __tmpval;				      \
+		do							      \
+		  __tmpval = __oldval;					      \
+		while ((__oldval = __arch_compare_and_exchange_val_64_acq     \
+		       (__memp, __oldval - 1, __oldval)) == __tmpval); 	      \
+	      }								      \
+	    })
+
+
+#define atomic_decrement_and_test(mem) \
+  ({ unsigned char __result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "decb %b0; sete %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "decw %w0; sete %1"		      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "decl %0; sete %1"			      \
+			 : "=m" (*mem), "=qm" (__result)		      \
+			 : "m" (*mem));					      \
+     else								      \
+       abort ();							      \
+     __result; })
+
+
+#define atomic_bit_set(mem, bit) \
+  (void) ({ if (sizeof (*mem) == 1)					      \
+	      __asm __volatile (LOCK_PREFIX "orb %b2, %0"		      \
+				: "=m" (*mem)				      \
+				: "m" (*mem), "ir" (1 << (bit)));	      \
+	    else if (sizeof (*mem) == 2)				      \
+	      __asm __volatile (LOCK_PREFIX "orw %w2, %0"		      \
+				: "=m" (*mem)				      \
+				: "m" (*mem), "ir" (1 << (bit)));	      \
+	    else if (sizeof (*mem) == 4)				      \
+	      __asm __volatile (LOCK_PREFIX "orl %2, %0"		      \
+				: "=m" (*mem)				      \
+				: "m" (*mem), "ir" (1 << (bit)));	      \
+	    else							      \
+	      abort ();							      \
+	    })
+
+
+#define atomic_bit_test_set(mem, bit) \
+  ({ unsigned char __result;						      \
+     if (sizeof (*mem) == 1)						      \
+       __asm __volatile (LOCK_PREFIX "btsb %3, %1; setc %0"		      \
+			 : "=q" (__result), "=m" (*mem)			      \
+			 : "m" (*mem), "ir" (bit));			      \
+     else if (sizeof (*mem) == 2)					      \
+       __asm __volatile (LOCK_PREFIX "btsw %3, %1; setc %0"		      \
+			 : "=q" (__result), "=m" (*mem)			      \
+			 : "m" (*mem), "ir" (bit));			      \
+     else if (sizeof (*mem) == 4)					      \
+       __asm __volatile (LOCK_PREFIX "btsl %3, %1; setc %0"		      \
+			 : "=q" (__result), "=m" (*mem)			      \
+			 : "m" (*mem), "ir" (bit));			      \
+     else							      	      \
+       abort ();							      \
+     __result; })
+
+
+#define atomic_delay() asm ("rep; nop")
diff -Nur sysdeps/i386/i486/bits/string.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/bits/string.h
--- sysdeps/i386/i486/bits/string.h	2002-07-11 01:14:16.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/bits/string.h	2004-12-15 21:30:16.000000000 +0100
@@ -1,5 +1,6 @@
 /* Optimized, inlined string functions.  i486 version.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2004
+   	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -40,18 +41,21 @@
 
 /* The macros are used in some of the optimized implementations below.  */
 #define __STRING_SMALL_GET16(src, idx) \
-  (((src)[idx + 1] << 8) | (src)[idx])
+  ((((__const unsigned char *) (src))[idx + 1] << 8)			      \
+   | ((__const unsigned char *) (src))[idx])
 #define __STRING_SMALL_GET32(src, idx) \
-  ((((src)[idx + 3] << 8 | (src)[idx + 2]) << 8				      \
-    | (src)[idx + 1]) << 8 | (src)[idx])
+  (((((__const unsigned char *) (src))[idx + 3] << 8			      \
+     | ((__const unsigned char *) (src))[idx + 2]) << 8			      \
+    | ((__const unsigned char *) (src))[idx + 1]) << 8			      \
+   | ((__const unsigned char *) (src))[idx])
 
 
 /* Copy N bytes of SRC to DEST.  */
 #define _HAVE_STRING_ARCH_memcpy 1
 #define memcpy(dest, src, n) \
   (__extension__ (__builtin_constant_p (n)				      \
-		  ? __memcpy_c (dest, src, n)				      \
-		  : __memcpy_g (dest, src, n)))
+		  ? __memcpy_c ((dest), (src), (n))			      \
+		  : __memcpy_g ((dest), (src), (n))))
 #define __memcpy_c(dest, src, n) \
   ((n) == 0								      \
    ? (dest)								      \
@@ -202,15 +206,15 @@
 #define memset(s, c, n) \
   (__extension__ (__builtin_constant_p (n) && (n) <= 16			      \
 		  ? ((n) == 1						      \
-		     ? __memset_c1 (s, c)				      \
-		     : __memset_gc (s, c, n))				      \
+		     ? __memset_c1 ((s), (c))				      \
+		     : __memset_gc ((s), (c), (n)))			      \
 		  : (__builtin_constant_p (c)				      \
 		     ? (__builtin_constant_p (n)			      \
-			? __memset_ccn (s, c, n)			      \
-			: memset (s, c, n))				      \
+			? __memset_ccn ((s), (c), (n))			      \
+			: memset ((s), (c), (n)))			      \
 		     : (__builtin_constant_p (n)			      \
-			? __memset_gcn (s, c, n)			      \
-			: memset (s, c, n)))))
+			? __memset_gcn ((s), (c), (n))			      \
+			: memset ((s), (c), (n))))))
 
 #define __memset_c1(s, c) ({ void *__s = (s);				      \
 			     *((unsigned char *) __s) = (unsigned char) (c);  \
@@ -229,7 +233,7 @@
 	assignments using immediate operands.  But this uses to much	      \
 	memory (7, instead of 4 bytes).  So we force the value in a	      \
 	registers.  */							      \
-     if (n == 3 || n >= 5)						      \
+     if ((n) == 3 || (n) >= 5)						      \
        __asm__ __volatile__ ("" : "=r" (__c) : "0" (__c));		      \
 									      \
      /* This `switch' statement will be removed at compile-time.  */	      \
@@ -480,7 +484,8 @@
     ("std\n\t"
      "repne; scasb\n\t"
      "cmovne %2,%0\n\t"
-     "cld"
+     "cld\n\t"
+     "incl %0"
      : "=D" (__res), "=&c" (__d0), "=&r" (__d1)
      : "a" (__c), "0" (__s + __n - 1), "1" (__n), "2" (-1),
        "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
@@ -491,16 +496,17 @@
      "repne; scasb\n\t"
      "je 1f\n\t"
      "orl $-1,%0\n"
-     "1:\tcld"
+     "1:\tcld\n\t"
+     "incl %0"
      : "=D" (__res), "=&c" (__d0)
      : "a" (__c), "0" (__s + __n - 1), "1" (__n),
        "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
      : "cc");
 # endif
-  return __res + 1;
+  return __res;
 }
 # ifdef __USE_GNU
-#  define memrchr(s, c, n) __memrchr (s, c, n)
+#  define memrchr(s, c, n) __memrchr ((s), (c), (n))
 # endif
 #endif
 
@@ -565,11 +571,11 @@
 #define strcpy(dest, src) \
   (__extension__ (__builtin_constant_p (src)				      \
 		  ? (sizeof ((src)[0]) == 1 && strlen (src) + 1 <= 8	      \
-		     ? __strcpy_a_small (dest, src, strlen (src) + 1)	      \
-		     : (char *) memcpy ((char *) dest,			      \
-					(__const char *) src,		      \
+		     ? __strcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : (char *) memcpy ((char *) (dest),		      \
+					(__const char *) (src),		      \
 					strlen (src) + 1))		      \
-		  : __strcpy_g (dest, src)))
+		  : __strcpy_g ((dest), (src))))
 
 #define __strcpy_a_small(dest, src, srclen) \
   (__extension__ ({ char *__dest = (dest);				      \
@@ -636,9 +642,10 @@
      "leal	1(%1),%1\n\t"
      "testb	%b2,%b2\n\t"
      "jne	1b"
-     : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy)
+     : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
      : "0" (__src), "1" (__tmp),
-       "m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
      : "cc");
   return __dest;
 }
@@ -650,9 +657,9 @@
 # define __stpcpy(dest, src) \
   (__extension__ (__builtin_constant_p (src)				      \
 		  ? (strlen (src) + 1 <= 8				      \
-		     ? __stpcpy_a_small (dest, src, strlen (src) + 1)	      \
-		     : __stpcpy_c (dest, src, strlen (src) + 1))	      \
-		  : __stpcpy_g (dest, src)))
+		     ? __stpcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : __stpcpy_c ((dest), (src), strlen (src) + 1))	      \
+		  : __stpcpy_g ((dest), (src))))
 # define __stpcpy_c(dest, src, srclen) \
   ((srclen) % 4 == 0							      \
    ? __mempcpy_by4 (dest, src, srclen) - 1				      \
@@ -661,7 +668,7 @@
       : __mempcpy_byn (dest, src, srclen) - 1))
 
 /* In glibc itself we use this symbol for namespace reasons.  */
-# define stpcpy(dest, src) __stpcpy (dest, src)
+# define stpcpy(dest, src) __stpcpy ((dest), (src))
 
 # define __stpcpy_a_small(dest, src, srclen) \
   (__extension__ ({ union {						      \
@@ -824,10 +831,10 @@
 #define strncpy(dest, src, n) \
   (__extension__ (__builtin_constant_p (src)				      \
 		  ? ((strlen (src) + 1 >= ((size_t) (n))		      \
-		      ? (char *) memcpy ((char *) dest,			      \
-					 (__const char *) src, n)	      \
-		      : __strncpy_cg (dest, src, strlen (src) + 1, n)))	      \
-		  : __strncpy_gg (dest, src, n)))
+		      ? (char *) memcpy ((char *) (dest),		      \
+					 (__const char *) (src), n)	      \
+		      : __strncpy_cg ((dest), (src), strlen (src) + 1, n)))   \
+		  : __strncpy_gg ((dest), (src), n)))
 #define __strncpy_cg(dest, src, srclen, n) \
   (((srclen) % 4 == 0)							      \
    ? __strncpy_by4 (dest, src, srclen, n)				      \
@@ -955,8 +962,8 @@
 #define _HAVE_STRING_ARCH_strcat 1
 #define strcat(dest, src) \
   (__extension__ (__builtin_constant_p (src)				      \
-		  ? __strcat_c (dest, src, strlen (src) + 1)		      \
-		  : __strcat_g (dest, src)))
+		  ? __strcat_c ((dest), (src), strlen (src) + 1)	      \
+		  : __strcat_g ((dest), (src))))
 
 __STRING_INLINE char *__strcat_c (char *__dest, __const char __src[],
 				  size_t __srclen);
@@ -1026,11 +1033,11 @@
   (__extension__ ({ char *__dest = (dest);				      \
 		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
 		    ? (strlen (src) < ((size_t) (n))			      \
-		       ? strcat (__dest, src)				      \
-		       : (*((char *)__mempcpy (strchr (__dest, '\0'),	      \
-					       (__const char *) src, n)) = 0, \
-			   __dest))					      \
-		    : __strncat_g (__dest, src, n); }))
+		       ? strcat (__dest, (src))				      \
+		       : (*(char *)__mempcpy (strchr (__dest, '\0'),	      \
+					       (__const char *) (src),	      \
+					      (n)) = 0, __dest))	      \
+		    : __strncat_g (__dest, (src), (n)); }))
 
 __STRING_INLINE char *__strncat_g (char *__dest, __const char __src[],
 				   size_t __n);
@@ -1043,6 +1050,7 @@
 #ifdef __i686__
   __asm__ __volatile__
     ("repne; scasb\n"
+     "movl %4, %3\n\t"
      "decl %1\n\t"
      "1:\n\t"
      "decl	%3\n\t"
@@ -1055,7 +1063,7 @@
      "2:\n\t"
      "movb	$0,(%1)"
      : "=&a" (__dummy), "=&D" (__tmp), "=&S" (__src), "=&c" (__n)
-     : "0" (0), "1" (__tmp), "2" (__src), "3" (__n)
+     :  "g" (__n), "0" (0), "1" (__tmp), "2" (__src), "3" (0xffffffff)
      : "memory", "cc");
 #else
   --__tmp;
@@ -1090,7 +1098,7 @@
   (__extension__ (__builtin_constant_p (s1) && __builtin_constant_p (s2)      \
 		  && (sizeof ((s1)[0]) != 1 || strlen (s1) >= 4)	      \
 		  && (sizeof ((s2)[0]) != 1 || strlen (s2) >= 4)	      \
-		  ? memcmp ((__const char *) s1, (__const char *) s2,	      \
+		  ? memcmp ((__const char *) (s1), (__const char *) (s2),     \
 			    (strlen (s1) < strlen (s2)			      \
 			     ? strlen (s1) : strlen (s2)) + 1)		      \
 		  : (__builtin_constant_p (s1) && sizeof ((s1)[0]) == 1	      \
@@ -1111,7 +1119,7 @@
 			   : __strcmp_gc ((__const unsigned char *) (s1),     \
 					  (__const unsigned char *) (s2),     \
 					  strlen (s2)))			      \
-			: __strcmp_gg (s1, s2)))))
+			: __strcmp_gg ((s1), (s2))))))
 
 #define __strcmp_cc(s1, s2, l) \
   (__extension__ ({ register int __result = (s1)[0] - (s2)[0];		      \
@@ -1192,10 +1200,10 @@
 #define _HAVE_STRING_ARCH_strncmp 1
 #define strncmp(s1, s2, n) \
   (__extension__ (__builtin_constant_p (s1) && strlen (s1) < ((size_t) (n))   \
-		  ? strcmp (s1, s2)					      \
+		  ? strcmp ((s1), (s2))					      \
 		  : (__builtin_constant_p (s2) && strlen (s2) < ((size_t) (n))\
-		     ? strcmp (s1, s2)					      \
-		     : __strncmp_g (s1, s2, n))))
+		     ? strcmp ((s1), (s2))				      \
+		     : __strncmp_g ((s1), (s2), (n)))))
 
 __STRING_INLINE int __strncmp_g (__const char *__s1, __const char *__s2,
 				 size_t __n);
@@ -1238,9 +1246,9 @@
 #define strchr(s, c) \
   (__extension__ (__builtin_constant_p (c)				      \
 		  ? ((c) == '\0'					      \
-		     ? (char *) __rawmemchr (s, c)			      \
-		     : __strchr_c (s, ((c) & 0xff) << 8))		      \
-		  : __strchr_g (s, c)))
+		     ? (char *) __rawmemchr ((s), (c))			      \
+		     : __strchr_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchr_g ((s), (c))))
 
 __STRING_INLINE char *__strchr_c (__const char *__s, int __c);
 
@@ -1297,9 +1305,9 @@
 #define __strchrnul(s, c) \
   (__extension__ (__builtin_constant_p (c)				      \
 		  ? ((c) == '\0'					      \
-		     ? (char *) __rawmemchr (s, c)			      \
-		     : __strchrnul_c (s, ((c) & 0xff) << 8))		      \
-		  : __strchrnul_g (s, c)))
+		     ? (char *) __rawmemchr ((s), c)			      \
+		     : __strchrnul_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchrnul_g ((s), c)))
 
 __STRING_INLINE char *__strchrnul_c (__const char *__s, int __c);
 
@@ -1350,7 +1358,7 @@
   return __res;
 }
 #ifdef __USE_GNU
-# define strchrnul(s, c) __strchrnul (s, c)
+# define strchrnul(s, c) __strchrnul ((s), (c))
 #endif
 
 
@@ -1359,8 +1367,8 @@
 # define _HAVE_STRING_ARCH_index 1
 # define index(s, c) \
   (__extension__ (__builtin_constant_p (c)				      \
-		  ? __strchr_c (s, ((c) & 0xff) << 8)			      \
-		  : __strchr_g (s, c)))
+		  ? __strchr_c ((s), ((c) & 0xff) << 8)			      \
+		  : __strchr_g ((s), (c))))
 #endif
 
 
@@ -1368,8 +1376,8 @@
 #define _HAVE_STRING_ARCH_strrchr 1
 #define strrchr(s, c) \
   (__extension__ (__builtin_constant_p (c)				      \
-		  ? __strrchr_c (s, ((c) & 0xff) << 8)			      \
-		  : __strrchr_g (s, c)))
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
 
 #ifdef __i686__
 __STRING_INLINE char *__strrchr_c (__const char *__s, int __c);
@@ -1473,8 +1481,8 @@
 # define _HAVE_STRING_ARCH_rindex 1
 # define rindex(s, c) \
   (__extension__ (__builtin_constant_p (c)				      \
-		  ? __strrchr_c (s, ((c) & 0xff) << 8)			      \
-		  : __strrchr_g (s, c)))
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
 #endif
 
 
@@ -1486,9 +1494,9 @@
 		  ? ((reject)[0] == '\0'				      \
 		     ? strlen (s)					      \
 		     : ((reject)[1] == '\0'				      \
-			? __strcspn_c1 (s, (((reject)[0] << 8) & 0xff00))     \
-			: __strcspn_cg (s, reject, strlen (reject))))	      \
-		  : __strcspn_g (s, reject)))
+			? __strcspn_c1 ((s), (((reject)[0] << 8) & 0xff00))   \
+			: __strcspn_cg ((s), (reject), strlen (reject))))     \
+		  : __strcspn_g ((s), (reject))))
 
 __STRING_INLINE size_t __strcspn_c1 (__const char *__s, int __reject);
 
@@ -1607,9 +1615,9 @@
 		  ? ((accept)[0] == '\0'				      \
 		     ? ((void) (s), 0)					      \
 		     : ((accept)[1] == '\0'				      \
-			? __strspn_c1 (s, (((accept)[0] << 8 ) & 0xff00))     \
-			: __strspn_cg (s, accept, strlen (accept))))	      \
-		  : __strspn_g (s, accept)))
+			? __strspn_c1 ((s), (((accept)[0] << 8 ) & 0xff00))   \
+			: __strspn_cg ((s), (accept), strlen (accept))))      \
+		  : __strspn_g ((s), (accept))))
 
 #ifndef _FORCE_INLINES
 __STRING_INLINE size_t __strspn_c1 (__const char *__s, int __accept);
@@ -1648,14 +1656,15 @@
      "lodsb\n\t"
      "testb	%%al,%%al\n\t"
      "je	2f\n\t"
-     "movl	%1,%%edi\n\t"
+     "movl	%5,%%edi\n\t"
      "movl	%6,%%ecx\n\t"
      "repne; scasb\n\t"
      "je	1b\n"
      "2:"
-     : "=S" (__res), "=&d" (__d0), "=&c" (__d1), "=&D" (__d2)
-     : "0" (__s), "1" (__accept), "g" (__accept_len),
-       /* Since we do not know how large the memory we access it, use a really large amount.  */
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "g" (__accept), "g" (__accept_len),
+       /* Since we do not know how large the memory we access it, use a
+	  really large amount.  */
        "m" ( *(struct { char __x[0xfffffff]; } *)__s),
        "m" ( *(struct { __extension__ char __x[__accept_len]; } *)__accept)
      : "cc");
@@ -1724,11 +1733,11 @@
 #define strpbrk(s, accept) \
   (__extension__ (__builtin_constant_p (accept) && sizeof ((accept)[0]) == 1  \
 		  ? ((accept)[0] == '\0'				      \
-		     ? ((void) (s), NULL)				      \
+		     ? ((void) (s), (char *) 0)				      \
 		     : ((accept)[1] == '\0'				      \
-			? strchr (s, (accept)[0])			      \
-			: __strpbrk_cg (s, accept, strlen (accept))))	      \
-		  : __strpbrk_g (s, accept)))
+			? strchr ((s), (accept)[0])			      \
+			: __strpbrk_cg ((s), (accept), strlen (accept))))     \
+		  : __strpbrk_g ((s), (accept))))
 
 __STRING_INLINE char *__strpbrk_cg (__const char *__s, __const char __accept[],
 				    size_t __accept_len);
@@ -1831,11 +1840,12 @@
 #define strstr(haystack, needle) \
   (__extension__ (__builtin_constant_p (needle) && sizeof ((needle)[0]) == 1  \
 		  ? ((needle)[0] == '\0'				      \
-		     ? haystack						      \
+		     ? (haystack)					      \
 		     : ((needle)[1] == '\0'				      \
-			? strchr (haystack, (needle)[0])		      \
-			: __strstr_cg (haystack, needle, strlen (needle))))   \
-		  : __strstr_g (haystack, needle)))
+			? strchr ((haystack), (needle)[0])		      \
+			: __strstr_cg ((haystack), (needle),		      \
+				       strlen (needle))))		      \
+		  : __strstr_g ((haystack), (needle))))
 
 /* Please note that this function need not handle NEEDLEs with a
    length shorter than two.  */
diff -Nur sysdeps/i386/i486/strcat.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/strcat.S
--- sysdeps/i386/i486/strcat.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/strcat.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* strcat(dest, src) -- Append SRC on the end of DEST.
    For Intel 80x86, x>=4.
-   Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994,1995,1996,1997,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@ipd.info.uni-karlsruhe.de>.
    Optimised a little by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -267,3 +267,4 @@
 	LEAVE
 	RET_PTR
 END (BP_SYM (strcat))
+libc_hidden_builtin_def (strcat)
diff -Nur sysdeps/i386/i486/string-inlines.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/string-inlines.c
--- sysdeps/i386/i486/string-inlines.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/string-inlines.c	2003-04-30 00:49:22.000000000 +0200
@@ -0,0 +1,65 @@
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  <bits/string.h> and <bits/string2.h> declare some extern inline
+    functions.  These functions are declared additionally here if
+    inlining is not possible.  */
+
+#undef __USE_STRING_INLINES
+#define __USE_STRING_INLINES
+#define _FORCE_INLINES
+#define __STRING_INLINE /* empty */
+#define __NO_INLINE__
+
+/* This is to avoid PLT entries for the x86 version.  */
+#define __memcpy_g __memcpy_g_internal
+#define __strchr_g __strchr_g_internal
+
+#include <string.h>
+#undef index
+#undef rindex
+
+#undef __NO_INLINE__
+#include <bits/string.h>
+#include <bits/string2.h>
+
+void *
+(__memcpy_c) (void *d, const void *s, size_t n)
+{
+  return memcpy (d, s, n);
+}
+
+void *
+__memset_cc (void *s, unsigned long int pattern, size_t n)
+{
+  return memset (s, pattern & 0xff, n);
+}
+strong_alias (__memset_cc, __memset_cg)
+
+void *
+__memset_gg (void *s, char c, size_t n)
+{
+  return memset (s, c, n);
+}
+
+#ifdef __memcpy_c
+# undef __memcpy_g
+strong_alias (__memcpy_g_internal, __memcpy_g)
+# undef __strchr_g
+strong_alias (__strchr_g_internal, __strchr_g)
+#endif
diff -Nur sysdeps/i386/i486/strlen.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/strlen.S
--- sysdeps/i386/i486/strlen.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i486/strlen.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* strlen(str) -- determine the length of the string STR.
    Optimized for Intel 80x86, x>=4.
-   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1991-1997, 2000, 2003 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>.
    This file is part of the GNU C Library.
 
@@ -136,3 +136,4 @@
 	LEAVE
 	ret
 END (BP_SYM (strlen))
+libc_hidden_builtin_def (strlen)
diff -Nur sysdeps/i386/i586/memcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/memcpy.S
--- sysdeps/i386/i586/memcpy.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/memcpy.S	2004-05-28 08:38:44.000000000 +0200
@@ -1,5 +1,5 @@
 /* Highly optimized version for i586.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -116,3 +116,6 @@
 	LEAVE
 	RET_PTR
 END (BP_SYM (memcpy))
+#if !MEMPCPY_P
+libc_hidden_builtin_def (memcpy)
+#endif
diff -Nur sysdeps/i386/i586/mempcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/mempcpy.S
--- sysdeps/i386/i586/mempcpy.S	2002-08-02 23:46:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/mempcpy.S	2004-05-28 08:39:37.000000000 +0200
@@ -3,3 +3,4 @@
 
 libc_hidden_def (BP_SYM (__mempcpy))
 weak_alias (BP_SYM (__mempcpy), BP_SYM (mempcpy))
+libc_hidden_builtin_def (mempcpy)
diff -Nur sysdeps/i386/i586/memset.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/memset.S
--- sysdeps/i386/i586/memset.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/memset.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* memset/bzero -- set memory area to CH/0
    Highly optimized version for ix86, x>=5.
-   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund, <tege@matematik.su.se>
 
@@ -114,3 +114,4 @@
 	RET_PTR
 #endif
 END (BP_SYM (memset))
+libc_hidden_builtin_def (memset)
diff -Nur sysdeps/i386/i586/stpcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/stpcpy.S
--- sysdeps/i386/i586/stpcpy.S	2002-08-04 01:28:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/stpcpy.S	2004-05-28 08:39:37.000000000 +0200
@@ -5,3 +5,4 @@
 
 weak_alias (__stpcpy, stpcpy)
 libc_hidden_def (__stpcpy)
+libc_hidden_builtin_def (stpcpy)
diff -Nur sysdeps/i386/i586/strchr.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strchr.S
--- sysdeps/i386/i586/strchr.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strchr.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* Find character CH in a NUL terminated string.
    Highly optimized version for ix85, x>=5.
-   Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.ai.mit.edu>.
 
@@ -339,3 +339,4 @@
 
 #undef index
 weak_alias (BP_SYM (strchr), BP_SYM (index))
+libc_hidden_builtin_def (strchr)
diff -Nur sysdeps/i386/i586/strcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strcpy.S
--- sysdeps/i386/i586/strcpy.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strcpy.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,5 +1,5 @@
 /* strcpy/stpcpy implementation for i586.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -159,3 +159,6 @@
 	LEAVE
 	RET_PTR
 END (BP_SYM (STRCPY))
+#ifndef USE_AS_STPCPY
+libc_hidden_builtin_def (strcpy)
+#endif
diff -Nur sysdeps/i386/i586/strlen.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strlen.S
--- sysdeps/i386/i586/strlen.S	2002-03-12 02:28:49.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i586/strlen.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* strlen -- Compute length of NUL terminated string.
    Highly optimized version for ix86, x>=5.
-   Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995,1996,1997,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.ai.mit.edu>.
 
@@ -186,3 +186,4 @@
 	LEAVE
 	ret
 END (BP_SYM (strlen))
+libc_hidden_builtin_def (strlen)
diff -Nur sysdeps/i386/i686/dl-hash.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/dl-hash.h
--- sysdeps/i386/i686/dl-hash.h	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/dl-hash.h	2003-06-18 20:30:28.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute hash alue for given string according to ELF standard.
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -26,7 +26,7 @@
    optimized for the PII processors.  Though it will run on i586 it
    would be much slower than the generic C implementation.  So don't
    use it.  */
-static inline unsigned int
+static unsigned int
 _dl_elf_hash (const unsigned char *name)
 {
   unsigned int result;
@@ -71,10 +71,9 @@
      "jnz 2b\n"
      "1:\t"
      : "=&r" (result), "=r" (name), "=&c" (temp0), "=&r" (temp1)
-     : "0" (0), "1" (name));		
+     : "0" (0), "1" (name));
 
   return result;
 }
 
 #endif /* dl-hash.h */
-
diff -Nur sysdeps/i386/i686/ffs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/ffs.c
--- sysdeps/i386/i686/ffs.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/ffs.c	2004-07-05 19:36:12.000000000 +0200
@@ -1,7 +1,7 @@
 /* ffs -- find first set bit in a word, counted from least significant end.
    For Intel 80x86, x>=6.
    This file is part of the GNU C Library.
-   Copyright (C) 1991, 92, 93, 94, 97, 98 Free Software Foundation, Inc.
+   Copyright (C) 1991, 92, 93, 94, 97, 98, 2004 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@cygnus.com>.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -40,6 +40,7 @@
   return cnt + 1;
 }
 weak_alias (__ffs, ffs)
+libc_hidden_builtin_def (ffs)
 #undef ffsl
 weak_alias (__ffs, ffsl)
 
diff -Nur sysdeps/i386/i686/fpu/s_fdimf.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdimf.S
--- sysdeps/i386/i686/fpu/s_fdimf.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdimf.S	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -28,12 +28,14 @@
 	fucomi	%st(1), %st
 	jp	1f
 
-	fsubrp	%st, %st(1)
+	jc	3f
+	fstp	%st(1)
 	fldz
-	fcomi	%st(1), %st
-	fcmovb	%st(1), %st
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fucomi	%st(0), %st
 	fcmovnu	%st(1), %st
 2:	fstp	%st(1)
diff -Nur sysdeps/i386/i686/fpu/s_fdiml.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdiml.S
--- sysdeps/i386/i686/fpu/s_fdiml.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdiml.S	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -28,12 +28,14 @@
 	fucomi	%st(1), %st
 	jp	1f
 
-	fsubrp	%st, %st(1)
+	jc	3f
+	fstp	%st(1)
 	fldz
-	fcomi	%st(1), %st
-	fcmovb	%st(1), %st
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fucomi	%st(0), %st
 	fcmovnu	%st(1), %st
 2:	fstp	%st(1)
diff -Nur sysdeps/i386/i686/fpu/s_fdim.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdim.S
--- sysdeps/i386/i686/fpu/s_fdim.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/fpu/s_fdim.S	2004-09-26 12:10:30.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compute positive difference.
-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -28,12 +28,14 @@
 	fucomi	%st(1), %st
 	jp	1f
 
-	fsubrp	%st, %st(1)
+	jc	3f
+	fstp	%st(1)
 	fldz
-	fcomi	%st(1), %st
-	fcmovb	%st(1), %st
 	jmp	2f
 
+3:	fsubrp	%st, %st(1)
+	ret
+
 1:	fucomi	%st(0), %st
 	fcmovnu	%st(1), %st
 2:	fstp	%st(1)
diff -Nur sysdeps/i386/i686/hp-timing.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/hp-timing.h
--- sysdeps/i386/i686/hp-timing.h	2002-02-01 07:34:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/hp-timing.h	2004-03-07 09:38:43.000000000 +0100
@@ -1,5 +1,5 @@
 /* High precision, low overhead timing functions.  i686 version.
-   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -97,17 +97,17 @@
 /* Use two 'rdtsc' instructions in a row to find out how long it takes.  */
 #define HP_TIMING_DIFF_INIT() \
   do {									      \
-    if (GL(dl_hp_timing_overhead) == 0)					      \
+    if (GLRO(dl_hp_timing_overhead) == 0)				      \
       {									      \
 	int __cnt = 5;							      \
-	GL(dl_hp_timing_overhead) = ~0ull;				      \
+	GLRO(dl_hp_timing_overhead) = ~0ull;				      \
 	do								      \
 	  {								      \
 	    hp_timing_t __t1, __t2;					      \
 	    HP_TIMING_NOW (__t1);					      \
 	    HP_TIMING_NOW (__t2);					      \
-	    if (__t2 - __t1 < GL(dl_hp_timing_overhead))		      \
-	      GL(dl_hp_timing_overhead) = __t2 - __t1;			      \
+	    if (__t2 - __t1 < GLRO(dl_hp_timing_overhead))		      \
+	      GLRO(dl_hp_timing_overhead) = __t2 - __t1;		      \
 	  }								      \
 	while (--__cnt > 0);						      \
       }									      \
@@ -121,7 +121,7 @@
   do {									      \
     char __not_done;							      \
     hp_timing_t __oldval = (Sum);					      \
-    hp_timing_t __diff = (Diff) - GL(dl_hp_timing_overhead);		      \
+    hp_timing_t __diff = (Diff) - GLRO(dl_hp_timing_overhead);		      \
     do									      \
       {									      \
 	hp_timing_t __newval = __oldval + __diff;			      \
@@ -149,7 +149,7 @@
   do {									      \
     char __buf[20];							      \
     char *__cp = _itoa (Val, __buf + sizeof (__buf), 10, 0);		      \
-    int __len = (Len);							      \
+    size_t __len = (Len);						      \
     char *__dest = (Buf);						      \
     while (__len-- > 0 && __cp < __buf + sizeof (__buf))		      \
       *__dest++ = *__cp++;						      \
diff -Nur sysdeps/i386/i686/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/Implies
--- sysdeps/i386/i686/Implies	1999-07-14 05:43:52.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/Implies	2004-08-09 02:54:53.000000000 +0200
@@ -1,4 +1,4 @@
-# Due to the reordering and the oher nifty extensions in the i686 it is
+# Due to the reordering and the other nifty extensions in the i686 it is
 # not really good to use heavily i586 optimized code on a i686.  It's
 # better to use i486/i386 code.
 i386/i486
diff -Nur sysdeps/i386/i686/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/Makefile
--- sysdeps/i386/i686/Makefile	2002-02-01 07:38:19.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/Makefile	2004-08-16 08:46:13.000000000 +0200
@@ -1,4 +1,7 @@
 ifeq ($(subdir),csu)
 sysdep_routines += hp-timing
-static-only-routines += hp-timing
+elide-routines.os += hp-timing
 endif
+
+# So that we can test __m128's alignment
+stack-align-test-flags += -msse
diff -Nur sysdeps/i386/i686/memcmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcmp.S
--- sysdeps/i386/i686/memcmp.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcmp.S	2004-04-02 01:28:37.000000000 +0200
@@ -0,0 +1,394 @@
+/* Compare two memory blocks for differences in the first COUNT bytes.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+#include "bp-sym.h"
+#include "bp-asm.h"
+
+#define PARMS		LINKAGE+4	/* Preserve EBX.  */
+#define BLK1		PARMS
+#define BLK2		BLK1+PTR_SIZE
+#define LEN		BLK2+PTR_SIZE
+#define ENTRANCE	pushl %ebx; ENTER
+#define RETURN		popl %ebx; LEAVE; ret
+
+/* Load an entry in a jump table into EBX.  TABLE is a jump table
+   with relative offsets.  INDEX is a register contains the index
+   into the jump table.  */
+#define LOAD_JUMP_TABLE_ENTRY(TABLE, INDEX) \
+  /* We first load PC into EBX.  */					      \
+  call	__i686.get_pc_thunk.bx;						      \
+  /* Get the address of the jump table.  */				      \
+  addl	$(TABLE - .), %ebx;						      \
+  /* Get the entry and convert the relative offset to the		      \
+     absolute address.  */						      \
+  addl	(%ebx,INDEX,4), %ebx
+
+#ifdef HAVE_HIDDEN
+	.section	.gnu.linkonce.t.__i686.get_pc_thunk.bx,"ax",@progbits
+	.globl	__i686.get_pc_thunk.bx
+	.hidden	__i686.get_pc_thunk.bx
+#else
+        .text
+#endif
+	ALIGN (4)
+	.type	__i686.get_pc_thunk.bx,@function
+__i686.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+
+        .text
+	ALIGN (4)
+ENTRY (BP_SYM (memcmp))
+	ENTRANCE
+
+	movl	BLK1(%esp), %eax
+	movl	BLK2(%esp), %edx
+	movl	LEN(%esp), %ecx
+
+	cmpl 	$1, %ecx
+	jne	L(not_1)
+	movzbl	(%eax), %ecx		/* LEN == 1  */
+	cmpb	(%edx), %cl
+	jne	L(neq)
+L(bye):
+	xorl	%eax, %eax
+	RETURN
+
+L(neq):
+	sbbl	%eax, %eax
+	sbbl	$-1, %eax
+	RETURN
+
+L(not_1):
+	jl	L(bye)			/* LEN == 0  */
+
+	pushl	%esi
+	movl	%eax, %esi
+	cmpl	$32, %ecx;
+	jge	L(32bytesormore)	/* LEN => 32  */
+
+	LOAD_JUMP_TABLE_ENTRY (L(table_32bytes), %ecx)
+	addl	%ecx, %edx
+	addl	%ecx, %esi
+	jmp	*%ebx
+
+	ALIGN (4)
+L(28bytes):
+	movl	-28(%esi), %eax
+	movl	-28(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(24bytes):
+	movl	-24(%esi), %eax
+	movl	-24(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(20bytes):
+	movl	-20(%esi), %eax
+	movl	-20(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(16bytes):
+	movl	-16(%esi), %eax
+	movl	-16(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(12bytes):
+	movl	-12(%esi), %eax
+	movl	-12(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(8bytes):
+	movl	-8(%esi), %eax
+	movl	-8(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(4bytes):
+	movl	-4(%esi), %eax
+	movl	-4(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(0bytes):
+	popl	%esi
+	xorl	%eax, %eax
+	RETURN
+
+L(29bytes):
+	movl	-29(%esi), %eax
+	movl	-29(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(25bytes):
+	movl	-25(%esi), %eax
+	movl	-25(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(21bytes):
+	movl	-21(%esi), %eax
+	movl	-21(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(17bytes):
+	movl	-17(%esi), %eax
+	movl	-17(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(13bytes):
+	movl	-13(%esi), %eax
+	movl	-13(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(9bytes):
+	movl	-9(%esi), %eax
+	movl	-9(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(5bytes):
+	movl	-5(%esi), %eax
+	movl	-5(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(1bytes):
+	movzbl	-1(%esi), %eax
+	cmpb	-1(%edx), %al
+	jne	L(set)
+	popl	%esi
+	xorl	%eax, %eax
+	RETURN
+
+L(30bytes):
+	movl	-30(%esi), %eax
+	movl	-30(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(26bytes):
+	movl	-26(%esi), %eax
+	movl	-26(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(22bytes):
+	movl	-22(%esi), %eax
+	movl	-22(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(18bytes):
+	movl	-18(%esi), %eax
+	movl	-18(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(14bytes):
+	movl	-14(%esi), %eax
+	movl	-14(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(10bytes):
+	movl	-10(%esi), %eax
+	movl	-10(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(6bytes):
+	movl	-6(%esi), %eax
+	movl	-6(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(2bytes):
+	movzwl	-2(%esi), %eax
+	movzwl	-2(%edx), %ecx
+	cmpb	%cl, %al
+	jne	L(set)
+	cmpl	%ecx, %eax
+	jne	L(set)
+	popl	%esi
+	xorl	%eax, %eax
+	RETURN
+
+L(31bytes):
+	movl	-31(%esi), %eax
+	movl	-31(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(27bytes):
+	movl	-27(%esi), %eax
+	movl	-27(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(23bytes):
+	movl	-23(%esi), %eax
+	movl	-23(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(19bytes):
+	movl	-19(%esi), %eax
+	movl	-19(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(15bytes):
+	movl	-15(%esi), %eax
+	movl	-15(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(11bytes):
+	movl	-11(%esi), %eax
+	movl	-11(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(7bytes):
+	movl	-7(%esi), %eax
+	movl	-7(%edx), %ecx
+	cmpl	%ecx, %eax
+	jne	L(find_diff)
+L(3bytes):
+	movzwl	-3(%esi), %eax
+	movzwl	-3(%edx), %ecx
+	cmpb	%cl, %al
+	jne	L(set)
+	cmpl	%ecx, %eax
+	jne	L(set)
+	movzbl	-1(%esi), %eax
+	cmpb	-1(%edx), %al
+	jne	L(set)
+	popl	%esi
+	xorl	%eax, %eax
+	RETURN
+
+	ALIGN (4)
+/* ECX >= 32.  */
+L(32bytesormore):
+	subl	$32, %ecx
+
+	movl	(%esi), %eax
+	cmpl	(%edx), %eax
+	jne	L(load_ecx)
+
+	movl	4(%esi), %eax
+	cmpl	4(%edx), %eax
+	jne	L(load_ecx_4)
+
+	movl	8(%esi), %eax
+	cmpl	8(%edx), %eax
+	jne	L(load_ecx_8)
+
+	movl	12(%esi), %eax
+	cmpl	12(%edx), %eax
+	jne	L(load_ecx_12)
+
+	movl	16(%esi), %eax
+	cmpl	16(%edx), %eax
+	jne	L(load_ecx_16)
+
+	movl	20(%esi), %eax
+	cmpl	20(%edx), %eax
+	jne	L(load_ecx_20)
+
+	movl	24(%esi), %eax
+	cmpl	24(%edx), %eax
+	jne	L(load_ecx_24)
+
+	movl	28(%esi), %eax
+	cmpl	28(%edx), %eax
+	jne	L(load_ecx_28)
+
+	addl	$32, %esi
+	addl	$32, %edx
+	cmpl	$32, %ecx
+	jge	L(32bytesormore)
+
+	LOAD_JUMP_TABLE_ENTRY (L(table_32bytes), %ecx)
+	addl	%ecx, %edx
+	addl	%ecx, %esi
+	jmp	*%ebx
+
+L(load_ecx_28):
+	addl	$0x4, %edx
+L(load_ecx_24):
+	addl	$0x4, %edx
+L(load_ecx_20):
+	addl	$0x4, %edx
+L(load_ecx_16):
+	addl	$0x4, %edx
+L(load_ecx_12):
+	addl	$0x4, %edx
+L(load_ecx_8):
+	addl	$0x4, %edx
+L(load_ecx_4):
+	addl	$0x4, %edx
+L(load_ecx):
+	movl	(%edx), %ecx
+
+L(find_diff):
+	cmpb	%cl, %al
+	jne	L(set)
+	cmpb	%ch, %ah
+	jne	L(set)
+	shrl	$16,%eax
+	shrl	$16,%ecx
+	cmpb	%cl, %al
+	jne	L(set)
+	/* We get there only if we already know there is a
+	   difference.  */
+	cmpl	%ecx, %eax
+L(set):
+	sbbl	%eax, %eax
+	sbbl	$-1, %eax
+	popl	%esi
+	RETURN
+
+	.section	.rodata
+	ALIGN (2)
+L(table_32bytes) :
+	.long	L(0bytes) - . + 0x0
+	.long	L(1bytes) - . + 0x4
+	.long	L(2bytes) - . + 0x8
+	.long	L(3bytes) - . + 0xc
+	.long	L(4bytes) - . + 0x10
+	.long	L(5bytes) - . + 0x14
+	.long	L(6bytes) - . + 0x18
+	.long	L(7bytes) - . + 0x1c
+	.long	L(8bytes) - . + 0x20
+	.long	L(9bytes) - . + 0x24
+	.long	L(10bytes) - . + 0x28
+	.long	L(11bytes) - . + 0x2c
+	.long	L(12bytes) - . + 0x30
+	.long	L(13bytes) - . + 0x34
+	.long	L(14bytes) - . + 0x38
+	.long	L(15bytes) - . + 0x3c
+	.long	L(16bytes) - . + 0x40
+	.long	L(17bytes) - . + 0x44
+	.long	L(18bytes) - . + 0x48
+	.long	L(19bytes) - . + 0x4c
+	.long	L(20bytes) - . + 0x50
+	.long	L(21bytes) - . + 0x54
+	.long	L(22bytes) - . + 0x58
+	.long	L(23bytes) - . + 0x5c
+	.long	L(24bytes) - . + 0x60
+	.long	L(25bytes) - . + 0x64
+	.long	L(26bytes) - . + 0x68
+	.long	L(27bytes) - . + 0x6c
+	.long	L(28bytes) - . + 0x70
+	.long	L(29bytes) - . + 0x74
+	.long	L(30bytes) - . + 0x78
+	.long	L(31bytes) - . + 0x7c
+
+END (BP_SYM (memcmp))
+
+#undef bcmp
+weak_alias (BP_SYM (memcmp), BP_SYM (bcmp))
+libc_hidden_builtin_def (BP_SYM (memcmp))
diff -Nur sysdeps/i386/i686/memcpy_chk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcpy_chk.S
--- sysdeps/i386/i686/memcpy_chk.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcpy_chk.S	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,35 @@
+/* Checking memcpy for x86-64.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+
+#ifndef PIC
+	/* For libc.so this is defined in memcpy.S.
+	   For libc.a, this is a separate source to avoid
+	   memcpy bringing in __chk_fail and all routines
+	   it calls.  */
+        .text
+ENTRY (__memcpy_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	__chk_fail
+	jmp	memcpy
+END (__memcpy_chk)
+#endif
diff -Nur sysdeps/i386/i686/memcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcpy.S
--- sysdeps/i386/i686/memcpy.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memcpy.S	2004-10-18 06:17:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* Copy memory block and return pointer to beginning of destination block
    For Intel 80x86, x>=6.
    This file is part of the GNU C Library.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,6 +31,13 @@
 #define LEN	SRC+PTR_SIZE
 
 	.text
+#if defined PIC && !defined NOT_IN_libc
+ENTRY (__memcpy_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	HIDDEN_JUMPTARGET (__chk_fail)
+END (__memcpy_chk)
+#endif
 ENTRY (BP_SYM (memcpy))
 	ENTER
 
@@ -59,3 +66,4 @@
 	LEAVE
 	RET_PTR
 END (BP_SYM (memcpy))
+libc_hidden_builtin_def (memcpy)
diff -Nur sysdeps/i386/i686/memmove_chk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memmove_chk.S
--- sysdeps/i386/i686/memmove_chk.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memmove_chk.S	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,35 @@
+/* Checking memmove for x86-64.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+
+#ifndef PIC
+	/* For libc.so this is defined in memmove.S.
+	   For libc.a, this is a separate source to avoid
+	   memmove bringing in __chk_fail and all routines
+	   it calls.  */
+        .text
+ENTRY (__memmove_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	__chk_fail
+	jmp	memmove
+END (__memmove_chk)
+#endif
diff -Nur sysdeps/i386/i686/memmove.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memmove.S
--- sysdeps/i386/i686/memmove.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memmove.S	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,102 @@
+/* Copy memory block and return pointer to beginning of destination block
+   For Intel 80x86, x>=6.
+   This file is part of the GNU C Library.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+#include "bp-sym.h"
+#include "bp-asm.h"
+
+#define PARMS	LINKAGE+4	/* one spilled register */
+#define RTN	PARMS
+#define DEST	RTN+RTN_SIZE
+#define SRC	DEST+PTR_SIZE
+#define LEN	SRC+PTR_SIZE
+
+	.text
+#if defined PIC && !defined NOT_IN_libc
+ENTRY (__memmove_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	HIDDEN_JUMPTARGET (__chk_fail)
+END (__memmove_chk)
+#endif
+ENTRY (BP_SYM (memmove))
+	ENTER
+
+	pushl	%edi
+
+	movl	LEN(%esp), %ecx
+	movl	DEST(%esp), %edi
+	movl	%esi, %edx
+	movl	SRC(%esp), %esi
+	CHECK_BOUNDS_BOTH_WIDE (%edi, DEST(%esp), %ecx)
+	CHECK_BOUNDS_BOTH_WIDE (%esi, SRC(%esp), %ecx)
+
+	movl	%edi, %eax
+	subl	%esi, %eax
+	cmpl	%eax, %edi
+	jae	3f
+
+	cld
+	shrl	$1, %ecx
+	jnc	1f
+	movsb
+1:	shrl	$1, %ecx
+	jnc	2f
+	movsw
+2:	rep
+	movsl
+	movl	%edx, %esi
+	movl	DEST(%esp), %eax
+	RETURN_BOUNDED_POINTER (DEST(%esp))
+
+	popl	%edi
+
+	LEAVE
+	RET_PTR
+
+	/* Backward copying.  */
+3:	std
+	leal	-1(%edi, %ecx), %edi
+	leal	-1(%esi, %ecx), %esi
+	shrl	$1, %ecx
+	jnc	1f
+	movsb
+1:	subl	$1, %edi
+	subl	$1, %esi
+	shrl	$1, %ecx
+	jnc	2f
+	movsw
+2:	subl	$2, %edi
+	subl	$2, %esi
+	rep
+	movsl
+	movl	%edx, %esi
+	movl	DEST(%esp), %eax
+	RETURN_BOUNDED_POINTER (DEST(%esp))
+
+	cld
+	popl	%edi
+
+	LEAVE
+	RET_PTR
+END (BP_SYM (memmove))
+libc_hidden_builtin_def (memmove)
diff -Nur sysdeps/i386/i686/mempcpy_chk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/mempcpy_chk.S
--- sysdeps/i386/i686/mempcpy_chk.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/mempcpy_chk.S	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,35 @@
+/* Checking mempcpy for x86-64.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+
+#ifndef PIC
+	/* For libc.so this is defined in mempcpy.S.
+	   For libc.a, this is a separate source to avoid
+	   mempcpy bringing in __chk_fail and all routines
+	   it calls.  */
+        .text
+ENTRY (__mempcpy_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	__chk_fail
+	jmp	mempcpy
+END (__mempcpy_chk)
+#endif
diff -Nur sysdeps/i386/i686/mempcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/mempcpy.S
--- sysdeps/i386/i686/mempcpy.S	2002-08-02 23:46:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/mempcpy.S	2004-10-18 06:17:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* Copy memory block and return pointer to following byte.
    For Intel 80x86, x>=6.
    This file is part of the GNU C Library.
-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,6 +31,13 @@
 #define LEN	SRC+PTR_SIZE
 
 	.text
+#if defined PIC && !defined NOT_IN_libc
+ENTRY (__mempcpy_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	HIDDEN_JUMPTARGET (__chk_fail)
+END (__mempcpy_chk)
+#endif
 ENTRY (BP_SYM (__mempcpy))
 	ENTER
 
@@ -59,3 +66,4 @@
 END (BP_SYM (__mempcpy))
 libc_hidden_def (BP_SYM (__mempcpy))
 weak_alias (BP_SYM (__mempcpy), BP_SYM (mempcpy))
+libc_hidden_builtin_def (mempcpy)
diff -Nur sysdeps/i386/i686/memset_chk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memset_chk.S
--- sysdeps/i386/i686/memset_chk.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memset_chk.S	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,35 @@
+/* Checking memset for x86-64.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "asm-syntax.h"
+
+#ifndef PIC
+	/* For libc.so this is defined in memset.S.
+	   For libc.a, this is a separate source to avoid
+	   memset bringing in __chk_fail and all routines
+	   it calls.  */
+        .text
+ENTRY (__memset_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	__chk_fail
+	jmp	memset
+END (__memset_chk)
+#endif
diff -Nur sysdeps/i386/i686/memset.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memset.S
--- sysdeps/i386/i686/memset.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/memset.S	2004-10-18 06:17:11.000000000 +0200
@@ -1,6 +1,6 @@
 /* memset/bzero -- set memory area to CH/0
    Highly optimized version for ix86, x>=6.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
 
@@ -39,6 +39,13 @@
 #endif
 
         .text
+#if defined PIC && !defined NOT_IN_libc && !BZERO_P
+ENTRY (__memset_chk)
+	movl	12(%esp), %eax
+	cmpl	%eax, 16(%esp)
+	jb	HIDDEN_JUMPTARGET (__chk_fail)
+END (__memset_chk)
+#endif
 ENTRY (BP_SYM (memset))
 	ENTER
 
@@ -93,3 +100,4 @@
 	RET_PTR
 #endif
 END (BP_SYM (memset))
+libc_hidden_builtin_def (memset)
diff -Nur sysdeps/i386/i686/strcmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/strcmp.S
--- sysdeps/i386/i686/strcmp.S	2002-03-12 02:28:14.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/strcmp.S	2003-04-30 00:47:19.000000000 +0200
@@ -1,5 +1,5 @@
 /* Highly optimized version for ix86, x>=6.
-   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
 
@@ -69,3 +69,4 @@
 	LEAVE
 	ret
 END (BP_SYM (strcmp))
+libc_hidden_builtin_def (strcmp)
diff -Nur sysdeps/i386/i686/strtok_r.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/strtok_r.S
--- sysdeps/i386/i686/strtok_r.S	2000-06-27 06:02:55.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/strtok_r.S	2004-07-10 21:58:12.000000000 +0200
@@ -2,3 +2,4 @@
 #define USE_AS_STRTOK_R	1
 #include <sysdeps/i386/i686/strtok.S>
 weak_alias (BP_SYM (__strtok_r), BP_SYM (strtok_r))
+strong_alias (BP_SYM (__strtok_r), BP_SYM (__GI___strtok_r))
diff -Nur sysdeps/i386/i686/tst-stack-align.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/tst-stack-align.h
--- sysdeps/i386/i686/tst-stack-align.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/i686/tst-stack-align.h	2003-09-17 10:37:57.000000000 +0200
@@ -0,0 +1,45 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdint.h>
+#ifndef __SSE__
+#include_next <tst-stack-align.h>
+#else
+#include <xmmintrin.h>
+
+#define TEST_STACK_ALIGN() \
+  ({									     \
+    __m128 _m;								     \
+    double _d = 12.0;							     \
+    long double _ld = 15.0;						     \
+    int _ret = 0;							     \
+    printf ("__m128:  %p %zu\n", &_m, __alignof (__m128));		     \
+    if ((((uintptr_t) &_m) & (__alignof (__m128) - 1)) != 0)		     \
+      _ret = 1;								     \
+									     \
+    printf ("double:  %g %p %zu\n", _d, &_d, __alignof (double));	     \
+    if ((((uintptr_t) &_d) & (__alignof (double) - 1)) != 0)		     \
+      _ret = 1;								     \
+									     \
+    printf ("ldouble: %Lg %p %zu\n", _ld, &_ld, __alignof (long double));    \
+    if ((((uintptr_t) &_ld) & (__alignof (long double) - 1)) != 0)	     \
+      _ret = 1;								     \
+    _ret;								     \
+    })
+#endif
diff -Nur sysdeps/i386/__longjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/__longjmp.S
--- sysdeps/i386/__longjmp.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/__longjmp.S	2002-12-31 21:37:23.000000000 +0100
@@ -1,5 +1,5 @@
 /* longjmp for i386.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995,1996,1997,1998,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
diff -Nur sysdeps/i386/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/Makefile
--- sysdeps/i386/Makefile	2002-09-19 08:42:09.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/Makefile	2005-02-16 12:07:19.000000000 +0100
@@ -20,3 +20,48 @@
 CFLAGS-dl-load.c += -Wno-unused
 CFLAGS-dl-reloc.c += -Wno-unused
 endif
+
+ifeq ($(subdir),debug)
+CFLAGS-backtrace.c += -fexceptions
+endif
+
+# Most of the glibc routines don't ever call user defined callbacks
+# nor use any FPU or SSE* and as such don't need bigger %esp alignment
+# than 4 bytes.
+# Lots of routines in math will use FPU, so make math subdir an exception
+# here.
+ifeq ($(subdir),math)
+sysdep-CFLAGS += -mpreferred-stack-boundary=4
+else
+ifeq ($(subdir),csu)
+sysdep-CFLAGS += -mpreferred-stack-boundary=4
+else
+sysdep-CFLAGS += -mpreferred-stack-boundary=2
+# Likewise, any function which calls user callbacks
+uses-callbacks += -mpreferred-stack-boundary=4
+# Likewise, any stack alignment tests
+stack-align-test-flags += -malign-double -mpreferred-stack-boundary=4
+endif
+endif
+
+# And a couple of other routines
+ifeq ($(subdir),stdlib)
+CFLAGS-exit.c += -mpreferred-stack-boundary=4
+endif
+ifeq ($(subdir),elf)
+CFLAGS-dl-init.c += -mpreferred-stack-boundary=4
+CFLAGS-dl-fini.c += -mpreferred-stack-boundary=4
+CFLAGS-dl-open.c += -mpreferred-stack-boundary=4
+CFLAGS-dl-close.c += -mpreferred-stack-boundary=4
+CFLAGS-dl-error.c += -mpreferred-stack-boundary=4
+endif
+ifeq ($(subdir),dlfcn)
+CFLAGS-dlopen.c += -mpreferred-stack-boundary=4
+CFLAGS-dlopenold.c += -mpreferred-stack-boundary=4
+CFLAGS-dlclose.c += -mpreferred-stack-boundary=4
+CFLAGS-dlerror.c += -mpreferred-stack-boundary=4
+endif
+
+ifneq (,$(filter -mno-tls-direct-seg-refs,$(CFLAGS)))
+defines += -DNO_TLS_DIRECT_SEG_REFS
+endif
diff -Nur sysdeps/i386/memchr.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memchr.S
--- sysdeps/i386/memchr.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memchr.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,7 +1,7 @@
 /* memchr (str, chr, len) -- Return pointer to first occurrence of CHR in STR less
    than LEN.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994-1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Optimised a little by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -330,3 +330,4 @@
 #if !__BOUNDED_POINTERS__
 weak_alias (__memchr, __ubp_memchr)
 #endif
+libc_hidden_builtin_def (memchr)
diff -Nur sysdeps/i386/memcmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memcmp.S
--- sysdeps/i386/memcmp.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memcmp.S	2004-04-02 01:28:16.000000000 +0200
@@ -1,5 +1,5 @@
 /* Compare two memory blocks for differences in the first COUNT bytes.
-   Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -73,3 +73,4 @@
 
 #undef bcmp
 weak_alias (BP_SYM (memcmp), BP_SYM (bcmp))
+libc_hidden_builtin_def (BP_SYM (memcmp))
diff -Nur sysdeps/i386/memset.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memset.c
--- sysdeps/i386/memset.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/memset.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* Set a block of memory to some byte value.
    For Intel 80x86, x>=3.
-   Copyright (C) 1991, 1992, 1993, 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1991,1992,1993,1997,1998,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -79,6 +79,7 @@
 
   return dstpp;
 }
+libc_hidden_builtin_def (memset)
 
 #else
 #include <sysdeps/generic/memset.c>
diff -Nur sysdeps/i386/setfpucw.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/setfpucw.c
--- sysdeps/i386/setfpucw.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/setfpucw.c	2004-03-05 11:14:49.000000000 +0100
@@ -0,0 +1,55 @@
+/* Set the FPU control word for x86.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <math.h>
+#include <fpu_control.h>
+#include <fenv.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-procinfo.h>
+
+void
+__setfpucw (fpu_control_t set)
+{
+  fpu_control_t cw;
+
+  /* Fetch the current control word.  */
+  __asm__ ("fnstcw %0" : "=m" (*&cw));
+
+  /* Preserve the reserved bits, and set the rest as the user
+     specified (or the default, if the user gave zero).  */
+  cw &= _FPU_RESERVED;
+  cw |= set & ~_FPU_RESERVED;
+
+  __asm__ ("fldcw %0" : : "m" (*&cw));
+
+  /* If the CPU supports SSE, we set the MXCSR as well.  */
+  if ((GLRO(dl_hwcap) & HWCAP_I386_XMM) != 0)
+    {
+      unsigned int xnew_exc;
+
+      /* Get the current MXCSR.  */
+      __asm__ ("stmxcsr %0" : "=m" (*&xnew_exc));
+
+      xnew_exc &= ~((0xc00 << 3) | (FE_ALL_EXCEPT << 7));
+      xnew_exc |= ((set & 0xc00) << 3) | ((set & FE_ALL_EXCEPT) << 7);
+
+      __asm__ ("ldmxcsr %0" : : "m" (*&xnew_exc));
+    }
+}
diff -Nur sysdeps/i386/soft-fp/sfp-machine.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/soft-fp/sfp-machine.h
--- sysdeps/i386/soft-fp/sfp-machine.h	2000-09-05 10:39:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/soft-fp/sfp-machine.h	2002-11-01 22:49:28.000000000 +0100
@@ -50,8 +50,10 @@
 
 #define _FP_NANFRAC_S		_FP_QNANBIT_S
 #define _FP_NANFRAC_D		_FP_QNANBIT_D, 0
+#define _FP_NANFRAC_Q		_FP_QNANBIT_Q, 0, 0, 0
 #define _FP_NANSIGN_S		1
 #define _FP_NANSIGN_D		1
+#define _FP_NANSIGN_Q		1
 
 #define _FP_KEEPNANFRACP 1
 /* Here is something Intel misdesigned: the specs don't define
diff -Nur sysdeps/i386/stpcpy.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/stpcpy.S
--- sysdeps/i386/stpcpy.S	2002-08-04 01:28:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/stpcpy.S	2004-05-28 08:39:37.000000000 +0200
@@ -1,6 +1,7 @@
 /* Copy SRC to DEST returning the address of the terminating '\0' in DEST.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994,1995,1996,1997,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper (drepper@gnu.ai.mit.edu).
 
@@ -94,3 +95,4 @@
 
 weak_alias (BP_SYM (__stpcpy), BP_SYM (stpcpy))
 libc_hidden_def (__stpcpy)
+libc_hidden_builtin_def (stpcpy)
diff -Nur sysdeps/i386/strchr.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strchr.S
--- sysdeps/i386/strchr.S	2002-08-12 02:17:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strchr.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* strchr (str, ch) -- Return pointer to first occurrence of CH in STR.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1994-1997,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Some optimisations by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -289,3 +289,4 @@
 END (BP_SYM (strchr))
 
 weak_alias (BP_SYM (strchr), BP_SYM (index))
+libc_hidden_builtin_def (strchr)
diff -Nur sysdeps/i386/strcspn.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strcspn.S
--- sysdeps/i386/strcspn.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strcspn.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,7 +1,7 @@
 /* strcspn (str, ss) -- Return the length of the initial segment of STR
 			which contains no characters from SS.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994,1995,1996,1997,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Bug fixes by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -179,3 +179,4 @@
 	LEAVE
 	ret
 END (BP_SYM (strcspn))
+libc_hidden_builtin_def (strcspn)
diff -Nur sysdeps/i386/string-inlines.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/string-inlines.c
--- sysdeps/i386/string-inlines.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/string-inlines.c	2003-04-30 00:49:14.000000000 +0200
@@ -0,0 +1,189 @@
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  <bits/string.h> and <bits/string2.h> declare some extern inline
+    functions.  These functions are declared additionally here if
+    inlining is not possible.  */
+
+#undef __USE_STRING_INLINES
+#define __USE_STRING_INLINES
+#define _FORCE_INLINES
+#define __STRING_INLINE /* empty */
+#define __NO_INLINE__
+
+#include <string.h>
+#undef index
+#undef rindex
+
+#undef __NO_INLINE__
+#include <bits/string.h>
+#include <bits/string2.h>
+
+/* Functions which are inlines in i486 but not i386.  */
+void *
+__memcpy_by2 (void *dest, const void *src, size_t n)
+{
+  return memcpy (dest, src, n);
+}
+strong_alias (__memcpy_by2, __memcpy_by4)
+strong_alias (__memcpy_by2, __memcpy_g)
+strong_alias (__memcpy_by2, __memcpy_g_internal)
+
+void *
+__memset_ccn_by2 (void *s, unsigned int c, size_t n)
+{
+  return memset (s, c & 0xff, n);
+}
+strong_alias (__memset_ccn_by2, __memset_ccn_by4)
+
+void *
+__memset_gcn_by2 (void *s, int c, size_t n)
+{
+  return memset (s, c, n);
+}
+strong_alias (__memset_gcn_by2, __memset_gcn_by4)
+
+size_t
+__strlen_g (const char *s)
+{
+  return strlen (s);
+}
+
+char *
+__strcpy_g (char *d, const char *s)
+{
+  return strcpy (d, s);
+}
+
+char *
+__mempcpy_by2 (char *d, const char *s, size_t n)
+{
+  return mempcpy (d, s, n);
+}
+strong_alias (__mempcpy_by2, __mempcpy_by4)
+strong_alias (__mempcpy_by2, __mempcpy_byn)
+
+char *
+__stpcpy_g (char *d, const char *s)
+{
+  return stpcpy (d, s);
+}
+
+char *
+__strncpy_by2 (char *d, const char s[], size_t srclen, size_t n)
+{
+  return strncpy (d, s, n);
+}
+strong_alias (__strncpy_by2, __strncpy_by4)
+strong_alias (__strncpy_by2, __strncpy_byn)
+
+char *
+__strncpy_gg (char *d, const char *s, size_t n)
+{
+  return strncpy (d, s, n);
+}
+
+char *
+__strcat_c (char *d, const char s[], size_t srclen)
+{
+  return strcat (d, s);
+}
+
+char *
+__strcat_g (char *d, const char *s)
+{
+  return strcat (d, s);
+}
+
+char *
+__strncat_g (char *d, const char s[], size_t n)
+{
+  return strncat (d, s, n);
+}
+
+int
+__strcmp_gg (const char *s1, const char *s2)
+{
+  return strcmp (s1, s2);
+}
+
+int
+__strncmp_g (const char *s1, const char *s2, size_t n)
+{
+  return strncmp (s1, s2, n);
+}
+
+char *
+__strrchr_c (const char *s, int c)
+{
+  return strrchr (s, c >> 8);
+}
+
+char *
+__strrchr_g (const char *s, int c)
+{
+  return strrchr (s, c);
+}
+
+size_t
+__strcspn_cg (const char *s, const char reject[], size_t reject_len)
+{
+  return strcspn (s, reject);
+}
+
+size_t
+__strcspn_g (const char *s, const char *reject)
+{
+  return strcspn (s, reject);
+}
+
+size_t
+__strspn_cg (const char *s, const char accept[], size_t accept_len)
+{
+  return strspn (s, accept);
+}
+
+size_t
+__strspn_g (const char *s, const char *accept)
+{
+  return strspn (s, accept);
+}
+
+char *
+__strpbrk_cg (const char *s, const char accept[], size_t accept_len)
+{
+  return strpbrk (s, accept);
+}
+
+char *
+__strpbrk_g (const char *s, const char *accept)
+{
+  return strpbrk (s, accept);
+}
+
+char *
+__strstr_cg (const char *haystack, const char needle[], size_t needle_len)
+{
+  return strstr (haystack, needle);
+}
+
+char *
+__strstr_g (const char *haystack, const char needle[])
+{
+  return strstr (haystack, needle);
+}
diff -Nur sysdeps/i386/strlen.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strlen.c
--- sysdeps/i386/strlen.c	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strlen.c	2003-04-30 00:47:20.000000000 +0200
@@ -1,5 +1,5 @@
 /* Determine the length of a string.  For Intel 80x86, x>=3.
-   Copyright (C) 1991, 1992, 1993, 1996, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991,1992,1993,1996,1997,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Torbjorn Granlund (tege@sics.se).
 
@@ -33,3 +33,4 @@
 
   return -2 - cnt;
 }
+libc_hidden_builtin_def (strlen)
diff -Nur sysdeps/i386/strpbrk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strpbrk.S
--- sysdeps/i386/strpbrk.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strpbrk.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,7 +1,7 @@
 /* strcspn (str, ss) -- Return the length of the initial segement of STR
 			which contains no characters from SS.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994-1997, 2000, 2003 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Bug fixes by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
    This file is part of the GNU C Library.
@@ -188,3 +188,4 @@
 	LEAVE
 	RET_PTR
 END (BP_SYM (strpbrk))
+libc_hidden_builtin_def (strpbrk)
diff -Nur sysdeps/i386/strrchr.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strrchr.S
--- sysdeps/i386/strrchr.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strrchr.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,6 +1,6 @@
 /* strrchr (str, ch) -- Return pointer to last occurrence of CH in STR.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994-1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Some optimisations by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -331,3 +331,4 @@
 END (BP_SYM (strrchr))
 
 weak_alias (BP_SYM (strrchr), BP_SYM (rindex))
+libc_hidden_builtin_def (strrchr)
diff -Nur sysdeps/i386/strspn.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strspn.S
--- sysdeps/i386/strspn.S	2001-07-07 21:21:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strspn.S	2003-04-30 00:47:20.000000000 +0200
@@ -1,7 +1,7 @@
 /* strcspn (str, ss) -- Return the length of the initial segment of STR
 			which contains only characters from SS.
    For Intel 80x86, x>=3.
-   Copyright (C) 1994, 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1994-1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>
    Bug fixes by Alan Modra <Alan@SPRI.Levels.UniSA.Edu.Au>
@@ -179,3 +179,4 @@
 	LEAVE
 	ret
 END (BP_SYM (strspn))
+libc_hidden_builtin_def (strspn)
diff -Nur sysdeps/i386/strtok_r.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strtok_r.S
--- sysdeps/i386/strtok_r.S	2000-06-27 06:02:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/strtok_r.S	2004-07-10 21:58:12.000000000 +0200
@@ -2,3 +2,4 @@
 #define USE_AS_STRTOK_R	1
 #include <sysdeps/i386/strtok.S>
 weak_alias (BP_SYM (__strtok_r), BP_SYM (strtok_r))
+strong_alias (BP_SYM (__strtok_r), BP_SYM (__GI___strtok_r))
diff -Nur sysdeps/i386/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/sysdep.h
--- sysdeps/i386/sysdep.h	2002-08-26 23:16:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/sysdep.h	2003-03-10 10:10:46.000000000 +0100
@@ -1,5 +1,5 @@
 /* Assembler macros for i386.
-   Copyright (C) 1991,92,93,95,96,98,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,93,95,96,98,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -64,6 +64,14 @@
   ASM_SIZE_DIRECTIVE(name)						      \
   STABS_FUN_END(name)
 
+#ifdef HAVE_CPP_ASM_DEBUGINFO
+/* Disable that goop, because we just pass -g through to the assembler
+   and it generates proper line number information directly.  */
+# define STABS_CURRENT_FILE1(name)
+# define STABS_CURRENT_FILE(name)
+# define STABS_FUN(name)
+# define STABS_FUN_END(name)
+#else
 /* Remove the following two lines once the gdb bug is fixed.  */
 #define STABS_CURRENT_FILE(name)					      \
   STABS_CURRENT_FILE1 (#name)
@@ -77,6 +85,7 @@
   .stabs #namestr,36,0,0,name;
 #define STABS_FUN_END(name)						      \
   1: .stabs "",36,0,0,1b-name;
+#endif
 
 /* If compiled for profiling, call `mcount' at the start of each function.  */
 #ifdef	PROF
@@ -108,6 +117,7 @@
 #define	PSEUDO_END(name)						      \
   END (name)
 
+#undef JUMPTARGET
 #ifdef PIC
 #define JUMPTARGET(name)	name##@PLT
 #define SYSCALL_PIC_SETUP \
diff -Nur sysdeps/i386/tst-stack-align.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/tst-stack-align.h
--- sysdeps/i386/tst-stack-align.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/tst-stack-align.h	2005-02-16 09:45:34.000000000 +0100
@@ -0,0 +1,42 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdint.h>
+
+typedef struct { int i[4]; } int_al16 __attribute__((aligned (16)));
+
+#define TEST_STACK_ALIGN() \
+  ({									     \
+    int_al16 _m;							     \
+    double _d = 12.0;							     \
+    long double _ld = 15.0;						     \
+    int _ret = 0;							     \
+    printf ("int_al16:  %p %zu\n", &_m, __alignof (int_al16));		     \
+    if ((((uintptr_t) &_m) & (__alignof (int_al16) - 1)) != 0)		     \
+      _ret = 1;								     \
+									     \
+    printf ("double:  %g %p %zu\n", _d, &_d, __alignof (double));	     \
+    if ((((uintptr_t) &_d) & (__alignof (double) - 1)) != 0)		     \
+      _ret = 1;								     \
+									     \
+    printf ("ldouble: %Lg %p %zu\n", _ld, &_ld, __alignof (long double));    \
+    if ((((uintptr_t) &_ld) & (__alignof (long double) - 1)) != 0)	     \
+      _ret = 1;								     \
+    _ret;								     \
+    })
diff -Nur sysdeps/i386/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/Versions
--- sysdeps/i386/Versions	2000-06-15 08:53:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/i386/Versions	2003-04-30 00:47:20.000000000 +0200
@@ -9,7 +9,14 @@
   }
   GLIBC_2.1.1 {
     # extern inline functions used by <bits/string.h>
-    __memcpy_c; __memset_cc; __memset_cg; __memset_gg; __strchr_c; __strchr_g;
-    __strchrnul_c; __strchrnul_g;
+    __memcpy_c; __memset_cc; __memset_cg; __memset_gg;
+    __memcpy_by2; __memcpy_by4; __memcpy_g; __mempcpy_by2; __mempcpy_by4;
+    __mempcpy_byn; __memset_ccn_by2; __memset_ccn_by4; __memset_gcn_by2;
+    __memset_gcn_by4; __stpcpy_g; __strcat_c; __strcat_g; __strchr_c;
+    __strchr_g; __strchrnul_c; __strchrnul_g; __strcmp_gg; __strcpy_g;
+    __strcspn_c1; __strcspn_cg; __strcspn_g; __strlen_g; __strncat_g;
+    __strncmp_g; __strncpy_by2; __strncpy_by4; __strncpy_byn; __strncpy_gg;
+    __strpbrk_cg; __strpbrk_g; __strrchr_c; __strrchr_g; __strspn_c1;
+    __strspn_cg; __strspn_g; __strstr_cg; __strstr_g;
   }
 }
diff -Nur sysdeps/ieee754/bits/huge_valf.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/huge_valf.h
--- sysdeps/ieee754/bits/huge_valf.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/huge_valf.h	2004-03-15 22:44:10.000000000 +0100
@@ -0,0 +1,53 @@
+/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_valf.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALF	(__builtin_huge_valf())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VALF	(__extension__ 0x1.0p255f)
+#elif defined __GNUC__
+
+#   define HUGE_VALF \
+  (__extension__							      \
+   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })    \
+    { __l: 0x7f800000UL }).__d)
+
+#else /* not GCC */
+
+typedef union { unsigned char __c[4]; float __f; } __huge_valf_t;
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __HUGE_VALF_bytes	{ 0x7f, 0x80, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __HUGE_VALF_bytes	{ 0, 0, 0x80, 0x7f }
+# endif
+
+static __huge_valf_t __huge_valf = { __HUGE_VALF_bytes };
+# define HUGE_VALF	(__huge_valf.__f)
+
+#endif	/* GCC.  */
diff -Nur sysdeps/ieee754/bits/huge_val.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/huge_val.h
--- sysdeps/ieee754/bits/huge_val.h	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/huge_val.h	2004-03-15 22:44:10.000000000 +0100
@@ -1,6 +1,7 @@
-/* `HUGE_VAL' constants for IEEE 754 machines (where it is infinity).
+/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
    Used by <stdlib.h> and <math.h> functions for overflow.
-   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,25 +23,19 @@
 # error "Never use <bits/huge_val.h> directly; include <math.h> instead."
 #endif
 
-#include <features.h>
-
 /* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
 
-#ifdef	__GNUC__
-
-# if __GNUC_PREREQ(2,96)
-
-#  define HUGE_VAL (__extension__ 0x1.0p2047)
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VAL	(__builtin_huge_val())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VAL	(__extension__ 0x1.0p2047)
+#elif defined __GNUC__
 
-# else
-
-#  define HUGE_VAL \
+# define HUGE_VAL \
   (__extension__							      \
    ((union { unsigned __l __attribute__((__mode__(__DI__))); double __d; })   \
     { __l: 0x7ff0000000000000ULL }).__d)
 
-# endif
-
 #else /* not GCC */
 
 # include <endian.h>
@@ -58,46 +53,3 @@
 # define HUGE_VAL	(__huge_val.__d)
 
 #endif	/* GCC.  */
-
-
-/* ISO C99 extensions: (float) HUGE_VALF and (long double) HUGE_VALL.  */
-
-#ifdef __USE_ISOC99
-
-# ifdef __GNUC__
-
-#  if __GNUC_PREREQ(2,96)
-
-#   define HUGE_VALF (__extension__ 0x1.0p255f)
-
-#  else
-
-#   define HUGE_VALF \
-  (__extension__							      \
-   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })    \
-    { __l: 0x7f800000UL }).__d)
-
-#  endif
-
-# else /* not GCC */
-
-typedef union { unsigned char __c[4]; float __f; } __huge_valf_t;
-
-#  if __BYTE_ORDER == __BIG_ENDIAN
-#   define __HUGE_VALF_bytes	{ 0x7f, 0x80, 0, 0 }
-#  endif
-#  if __BYTE_ORDER == __LITTLE_ENDIAN
-#   define __HUGE_VALF_bytes	{ 0, 0, 0x80, 0x7f }
-#  endif
-
-static __huge_valf_t __huge_valf = { __HUGE_VALF_bytes };
-#  define HUGE_VALF	(__huge_valf.__f)
-
-# endif	/* GCC.  */
-
-
-/* Generally there is no separate `long double' format and it is the
-   same as `double'.  */
-# define HUGE_VALL HUGE_VAL
-
-#endif /* __USE_ISOC99.  */
diff -Nur sysdeps/ieee754/bits/inf.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/inf.h
--- sysdeps/ieee754/bits/inf.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/inf.h	2004-03-15 22:44:10.000000000 +0100
@@ -0,0 +1,30 @@
+/* `INFINITY' constant for IEEE 754 machines.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/inf.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity.  */
+
+#if __GNUC_PREREQ(3,3)
+# define INFINITY	(__builtin_inff())
+#else
+# define INFINITY	HUGE_VALF
+#endif
diff -Nur sysdeps/ieee754/bits/nan.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/nan.h
--- sysdeps/ieee754/bits/nan.h	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/bits/nan.h	2004-04-17 00:03:35.000000000 +0200
@@ -1,5 +1,5 @@
 /* `NAN' constant for IEEE 754 machines.
-   Copyright (C) 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1992, 1996, 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,7 +24,11 @@
 
 /* IEEE Not A Number.  */
 
-#ifdef	__GNUC__
+#if __GNUC_PREREQ(3,3)
+
+# define NAN	(__builtin_nanf(""))
+
+#elif defined__GNUC__
 
 # define NAN \
   (__extension__                                                            \
@@ -42,7 +46,8 @@
 #  define __nan_bytes		{ 0, 0, 0xc0, 0x7f }
 # endif
 
-static union { unsigned char __c[4]; float __d; } __nan_union = { __nan_bytes };
+static union { unsigned char __c[4]; float __d; } __nan_union
+    __attribute_used__ = { __nan_bytes };
 # define NAN	(__nan_union.__d)
 
 #endif	/* GCC.  */
diff -Nur sysdeps/ieee754/dbl-64/dbl2mpn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/dbl2mpn.c
--- sysdeps/ieee754/dbl-64/dbl2mpn.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/dbl2mpn.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1993,1994,1995,1996,1997,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,7 +45,7 @@
 #elif BITS_PER_MP_LIMB == 64
   /* Hopefully the compiler will combine the two bitfield extracts
      and this composition into just the original quadword extract.  */
-  res_ptr[0] = ((unsigned long int) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
+  res_ptr[0] = ((mp_limb_t) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
   #define N 1
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
@@ -101,7 +101,8 @@
     }
   else
     /* Add the implicit leading one bit for a normalized number.  */
-    res_ptr[N - 1] |= 1L << (DBL_MANT_DIG - 1 - ((N - 1) * BITS_PER_MP_LIMB));
+    res_ptr[N - 1] |= (mp_limb_t) 1 << (DBL_MANT_DIG - 1
+					- ((N - 1) * BITS_PER_MP_LIMB));
 
   return N;
 }
diff -Nur sysdeps/ieee754/dbl-64/e_exp.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_exp.c
--- sysdeps/ieee754/dbl-64/e_exp.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_exp.c	2003-12-28 19:57:35.000000000 +0100
@@ -92,10 +92,10 @@
   if (n <= smallint) return 1.0;
 
   if (n >= badint) {
-    if (n > infint) return(zero/zero);               /* x is NaN,  return invalid */
+    if (n > infint) return(x+x);               /* x is NaN */
     if (n < infint) return ( (x>0) ? (hhuge*hhuge) : (tiny*tiny) );
     /* x is finite,  cause either overflow or underflow  */
-    if (junk1.i[LOW_HALF] != 0)  return (zero/zero);                /*  x is NaN  */
+    if (junk1.i[LOW_HALF] != 0)  return (x+x);                /*  x is NaN  */
     return ((x>0)?inf.x:zero );             /* |x| = inf;  return either inf or 0 */
   }
 
diff -Nur sysdeps/ieee754/dbl-64/e_gamma_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_gamma_r.c
--- sysdeps/ieee754/dbl-64/e_gamma_r.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_gamma_r.c	2004-11-21 20:57:13.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of gamma function according to ISO C.
-   Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -35,9 +35,9 @@
 
   if (((hx & 0x7fffffff) | lx) == 0)
     {
-      /* Return value for x == 0 is NaN with invalid exception.  */
+      /* Return value for x == 0 is Inf with divide by zero exception.  */
       *signgamp = 0;
-      return x / x;
+      return 1.0 / x;
     }
   if (hx < 0 && (u_int32_t) hx < 0xfff00000 && __rint (x) == x)
     {
diff -Nur sysdeps/ieee754/dbl-64/e_j0.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_j0.c
--- sysdeps/ieee754/dbl-64/e_j0.c	2001-02-13 02:17:09.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_j0.c	2003-12-28 21:50:19.000000000 +0100
@@ -185,10 +185,10 @@
 
 	EXTRACT_WORDS(hx,lx,x);
         ix = 0x7fffffff&hx;
-    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
+    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0, y0(0) is -inf.  */
 	if(ix>=0x7ff00000) return  one/(x+x*x);
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+        if((ix|lx)==0) return -HUGE_VAL+x; /* -inf and overflow exception.  */
+        if(hx<0) return zero/(zero*x);
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
diff -Nur sysdeps/ieee754/dbl-64/e_j1.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_j1.c
--- sysdeps/ieee754/dbl-64/e_j1.c	2001-02-13 02:16:42.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_j1.c	2003-12-28 21:50:19.000000000 +0100
@@ -190,8 +190,8 @@
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
 	if(ix>=0x7ff00000) return  one/(x+x*x);
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+        if((ix|lx)==0) return -HUGE_VAL+x; /* -inf and overflow exception.  */;
+        if(hx<0) return zero/(zero*x);
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
 		__sincos (x, &s, &c);
                 ss = -s-c;
diff -Nur sysdeps/ieee754/dbl-64/e_jn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_jn.c
--- sysdeps/ieee754/dbl-64/e_jn.c	2001-02-13 02:20:14.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_jn.c	2003-12-28 21:50:19.000000000 +0100
@@ -20,7 +20,7 @@
  * of order n
  *
  * Special cases:
- *	y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
+ *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
  *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
  * Note 2. About jn(n,x), yn(n,x)
  *	For n=0, j0(x) is called,
@@ -236,8 +236,8 @@
 	ix = 0x7fffffff&hx;
     /* if Y(n,NaN) is NaN */
 	if((ix|((u_int32_t)(lx|-lx))>>31)>0x7ff00000) return x+x;
-	if((ix|lx)==0) return -one/zero;
-	if(hx<0) return zero/zero;
+	if((ix|lx)==0) return -HUGE_VAL+x; /* -inf and overflow exception.  */;
+	if(hx<0) return zero/(zero*x);
 	sign = 1;
 	if(n<0){
 		n = -n;
diff -Nur sysdeps/ieee754/dbl-64/e_pow.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_pow.c
--- sysdeps/ieee754/dbl-64/e_pow.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_pow.c	2004-01-23 14:16:24.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * IBM Accurate Mathematical Library
  * written by International Business Machines Corp.
- * Copyright (C) 2001, 2002 Free Software Foundation
+ * Copyright (C) 2001, 2002, 2004 Free Software Foundation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
@@ -22,7 +22,7 @@
 /*                                                                         */
 /*  FUNCTIONS: upow                                                        */
 /*             power1                                                      */
-/*             log2                                                        */
+/*             my_log2                                                        */
 /*             log1                                                        */
 /*             checkint                                                    */
 /* FILES NEEDED: dla.h endian.h mpa.h mydefs.h                             */
@@ -46,7 +46,7 @@
 
 double __exp1(double x, double xx, double error);
 static double log1(double x, double *delta, double *error);
-static double log2(double x, double *delta, double *error);
+static double my_log2(double x, double *delta, double *error);
 double __slowpow(double x, double y,double z);
 static double power1(double x, double y);
 static int checkint(double x);
@@ -159,7 +159,7 @@
 /**************************************************************************/
 static double power1(double x, double y) {
   double z,a,aa,error, t,a1,a2,y1,y2;
-  z = log2(x,&aa,&error);
+  z = my_log2(x,&aa,&error);
   t = y*134217729.0;
   y1 = t - (t-y);
   y2 = y - y1;
@@ -272,7 +272,7 @@
 /* Computing log(x)(x is left argument).The result is return double + delta.*/
 /* The result is bounded by error (right argument)                           */
 /****************************************************************************/
-static double log2(double x, double *delta, double *error) {
+static double my_log2(double x, double *delta, double *error) {
   int i,j,m;
 #if 0
   int n;
diff -Nur sysdeps/ieee754/dbl-64/e_sqrt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_sqrt.c
--- sysdeps/ieee754/dbl-64/e_sqrt.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/e_sqrt.c	2004-06-18 01:48:39.000000000 +0200
@@ -41,7 +41,7 @@
 #include "math_private.h"
 
 /*********************************************************************/
-/* An ultimate aqrt routine. Given an IEEE double machine number x   */
+/* An ultimate sqrt routine. Given an IEEE double machine number x   */
 /* it computes the correctly rounded (to nearest) value of square    */
 /* root of x.                                                        */
 /*********************************************************************/
@@ -52,7 +52,7 @@
     rt1 = 4.99999999495955425917856814202739E-01,
     rt2 = 3.75017500867345182581453026130850E-01,
     rt3 = 3.12523626554518656309172508769531E-01;
-  static const double big =  134217728.0, big1 =  134217729.0;
+  static const double big =  134217728.0;
   double y,t,del,res,res1,hy,z,zz,p,hx,tx,ty,s;
   mynumber a,c={{0,0}};
   int4 k;
@@ -79,13 +79,10 @@
     }
   }
   else {
-    if (k>0x7ff00000)            /* x -> infinity */
-       return (big1-big1)/(big-big);
-      if (k<0x00100000) {        /* x -> -infinity */
-      if (x==0) return x;
-      if (k<0) return (big1-big1)/(big-big);
-      else return tm256.x*__ieee754_sqrt(x*t512.x);
-    }
-    else return (a.i[LOW_HALF]==0)?x:(big1-big1)/(big-big);
+    if ((k & 0x7ff00000) == 0x7ff00000)
+      return x*x+x;	/* sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN */
+    if (x==0) return x;	/* sqrt(+0)=+0, sqrt(-0)=-0 */
+    if (k<0) return (x-x)/(x-x); /* sqrt(-ve)=sNaN */
+    return tm256.x*__ieee754_sqrt(x*t512.x);
   }
 }
diff -Nur sysdeps/ieee754/dbl-64/mpa.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpa.c
--- sysdeps/ieee754/dbl-64/mpa.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpa.c	2004-08-11 20:54:42.000000000 +0200
@@ -47,6 +47,7 @@
 #include "endian.h"
 #include "mpa.h"
 #include "mpa2.h"
+#include <sys/param.h>	/* For MIN() */
 /* mcr() compares the sizes of the mantissas of two multiple precision  */
 /* numbers. Mantissas are compared regardless of the signs of the       */
 /* numbers, even if x->d[0] or y->d[0] are zero. Exponents are also     */
diff -Nur sysdeps/ieee754/dbl-64/mpa.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpa.h
--- sysdeps/ieee754/dbl-64/mpa.h	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpa.h	2004-08-11 20:54:42.000000000 +0200
@@ -63,8 +63,6 @@
 #define  EY  y->e
 #define  EZ  z->e
 
-#define MAX(x,y) ((x) < (y) ?  (y) : (x))
-#define MIN(x,y) ((x) < (y) ?  (x) : (y))
 #define ABS(x)   ((x) <  0  ? -(x) : (x))
 
 int __acr(const mp_no *, const mp_no *, int);
diff -Nur sysdeps/ieee754/dbl-64/mpn2dbl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpn2dbl.c
--- sysdeps/ieee754/dbl-64/mpn2dbl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpn2dbl.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,10 +34,12 @@
   u.ieee.exponent = expt + IEEE754_DOUBLE_BIAS;
 #if BITS_PER_MP_LIMB == 32
   u.ieee.mantissa1 = frac_ptr[0];
-  u.ieee.mantissa0 = frac_ptr[1] & ((1 << (DBL_MANT_DIG - 32)) - 1);
+  u.ieee.mantissa0 = frac_ptr[1] & (((mp_limb_t) 1
+				     << (DBL_MANT_DIG - 32)) - 1);
 #elif BITS_PER_MP_LIMB == 64
-  u.ieee.mantissa1 = frac_ptr[0] & ((1L << 32) - 1);
-  u.ieee.mantissa0 = (frac_ptr[0] >> 32) & ((1 << (DBL_MANT_DIG - 32)) - 1);
+  u.ieee.mantissa1 = frac_ptr[0] & (((mp_limb_t) 1 << 32) - 1);
+  u.ieee.mantissa0 = (frac_ptr[0] >> 32) & (((mp_limb_t) 1
+					     << (DBL_MANT_DIG - 32)) - 1);
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
 #endif
diff -Nur sysdeps/ieee754/dbl-64/mpsqrt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpsqrt.c
--- sysdeps/ieee754/dbl-64/mpsqrt.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/mpsqrt.c	2003-11-29 07:09:24.000000000 +0100
@@ -83,9 +83,9 @@
 /* with the relative error bounded by 2**-51.              */
 /***********************************************************/
 double fastiroot(double x) {
-  union {long i[2]; double d;} p,q;
+  union {int i[2]; double d;} p,q;
   double y,z, t;
-  long n;
+  int n;
   static const double c0 = 0.99674, c1 = -0.53380, c2 = 0.45472, c3 = -0.21553;
 
   p.d = x;
diff -Nur sysdeps/ieee754/dbl-64/sincos32.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/sincos32.c
--- sysdeps/ieee754/dbl-64/sincos32.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/sincos32.c	2003-01-20 06:25:30.000000000 +0100
@@ -214,7 +214,7 @@
   __add(&a,&b,&c,p);
   if (x>0.8)
   { __sub(&hp,&c,&b,p);
-    __c32(&b,&a,&c,p);
+    __c32(&b,&c,&a,p);
   }
   else __c32(&c,&a,&b,p);     /* a = cos(x+dx)     */
   __mp_dbl(&a,&y,p);
diff -Nur sysdeps/ieee754/dbl-64/s_llrint.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_llrint.c
--- sysdeps/ieee754/dbl-64/s_llrint.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_llrint.c	2004-02-01 20:20:22.000000000 +0100
@@ -1,6 +1,6 @@
 /* Round argument to nearest integral value according to current rounding
    direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -75,7 +75,10 @@
 	  i0 &= 0xfffff;
 	  i0 |= 0x100000;
 
-	  result = ((long long int) i0 << (j0 - 20)) | (i1 >> (52 - j0));
+	  if (j0 == 20)
+	    result = (long long int) i0;
+	  else
+	    result = ((long long int) i0 << (j0 - 20)) | (i1 >> (52 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/dbl-64/s_lrint.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_lrint.c
--- sysdeps/ieee754/dbl-64/s_lrint.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_lrint.c	2004-02-01 20:01:03.000000000 +0100
@@ -1,6 +1,6 @@
 /* Round argument to nearest integral value according to current rounding
    direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -75,7 +75,10 @@
 	  i0 &= 0xfffff;
 	  i0 |= 0x100000;
 
-	  result = ((long int) i0 << (j0 - 20)) | (i1 >> (52 - j0));
+	  if (j0 == 20)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 20)) | (i1 >> (52 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/dbl-64/s_lround.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_lround.c
--- sysdeps/ieee754/dbl-64/s_lround.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/dbl-64/s_lround.c	2004-02-01 19:53:58.000000000 +0100
@@ -1,5 +1,5 @@
 /* Round double value to long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -58,7 +58,10 @@
 	  if (j < i1)
 	    ++i0;
 
-	  result = ((long int) i0 << (j0 - 20)) | (j >> (52 - j0));
+	  if (j0 == 20)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 20)) | (j >> (52 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/flt-32/e_gammaf_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_gammaf_r.c
--- sysdeps/ieee754/flt-32/e_gammaf_r.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_gammaf_r.c	2004-11-21 20:57:13.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of gamma function according to ISO C.
-   Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -34,9 +34,9 @@
 
   if ((hx & 0x7fffffff) == 0)
     {
-      /* Return value for x == 0 is NaN with invalid exception.  */
+      /* Return value for x == 0 is Inf with divide by zero exception.  */
       *signgamp = 0;
-      return x / x;
+      return 1.0 / x;
     }
   if (hx < 0 && (u_int32_t) hx < 0xff800000 && __rintf (x) == x)
     {
diff -Nur sysdeps/ieee754/flt-32/e_j0f.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_j0f.c
--- sysdeps/ieee754/flt-32/e_j0f.c	2001-02-13 02:20:43.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_j0f.c	2003-12-28 21:50:20.000000000 +0100
@@ -131,10 +131,10 @@
 
 	GET_FLOAT_WORD(hx,x);
         ix = 0x7fffffff&hx;
-    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
+    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0, y0(0) is -inf.  */
 	if(ix>=0x7f800000) return  one/(x+x*x);
-        if(ix==0) return -one/zero;
-        if(hx<0) return zero/zero;
+        if(ix==0) return -HUGE_VALF+x;  /* -inf and overflow exception.  */
+        if(hx<0) return zero/(zero*x);
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
diff -Nur sysdeps/ieee754/flt-32/e_j1f.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_j1f.c
--- sysdeps/ieee754/flt-32/e_j1f.c	2001-02-13 02:21:30.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_j1f.c	2003-12-28 21:50:20.000000000 +0100
@@ -134,8 +134,8 @@
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
 	if(ix>=0x7f800000) return  one/(x+x*x);
-        if(ix==0) return -one/zero;
-        if(hx<0) return zero/zero;
+        if(ix==0) return -HUGE_VALF+x;  /* -inf and overflow exception.  */
+        if(hx<0) return zero/(zero*x);
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
 		__sincosf (x, &s, &c);
                 ss = -s-c;
diff -Nur sysdeps/ieee754/flt-32/e_jnf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_jnf.c
--- sysdeps/ieee754/flt-32/e_jnf.c	2002-08-23 21:46:47.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/e_jnf.c	2003-12-28 21:50:20.000000000 +0100
@@ -187,8 +187,8 @@
 	ix = 0x7fffffff&hx;
     /* if Y(n,NaN) is NaN */
 	if(ix>0x7f800000) return x+x;
-	if(ix==0) return -one/zero;
-	if(hx<0) return zero/zero;
+	if(ix==0) return -HUGE_VALF+x;  /* -inf and overflow exception.  */
+	if(hx<0) return zero/(zero*x);
 	sign = 1;
 	if(n<0){
 		n = -n;
diff -Nur sysdeps/ieee754/flt-32/mpn2flt.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/mpn2flt.c
--- sysdeps/ieee754/flt-32/mpn2flt.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/mpn2flt.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1997,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,7 +33,7 @@
   u.ieee.negative = sign;
   u.ieee.exponent = expt + IEEE754_FLOAT_BIAS;
 #if BITS_PER_MP_LIMB > FLT_MANT_DIG
-  u.ieee.mantissa = frac_ptr[0] & ((1 << FLT_MANT_DIG) - 1);
+  u.ieee.mantissa = frac_ptr[0] & (((mp_limb_t) 1 << FLT_MANT_DIG) - 1);
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
 #endif
diff -Nur sysdeps/ieee754/flt-32/s_nextafterf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/s_nextafterf.c
--- sysdeps/ieee754/flt-32/s_nextafterf.c	1999-07-14 05:43:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/s_nextafterf.c	2003-12-07 21:53:59.000000000 +0100
@@ -19,6 +19,7 @@
 
 #include "math.h"
 #include "math_private.h"
+#include <float.h>
 
 #ifdef __STDC__
 	float __nextafterf(float x, float y)
@@ -57,7 +58,12 @@
 	    }
 	}
 	hy = hx&0x7f800000;
-	if(hy>=0x7f800000) return x+x;	/* overflow  */
+	if(hy>=0x7f800000) {
+	  x = x+x;	/* overflow  */
+	  if (FLT_EVAL_METHOD != 0)
+	    asm ("" : "=m"(x) : "m"(x));
+	  return x;	/* overflow  */
+	}
 	if(hy<0x00800000) {		/* underflow */
 	    y = x*x;
 	    if(y!=x) {		/* raise underflow flag */
diff -Nur sysdeps/ieee754/flt-32/s_scalbnf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/s_scalbnf.c
--- sysdeps/ieee754/flt-32/s_scalbnf.c	1999-07-14 05:43:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/flt-32/s_scalbnf.c	2003-08-28 02:11:19.000000000 +0200
@@ -49,13 +49,13 @@
         if (k==0xff) return x+x;		/* NaN or Inf */
         k = k+n;
         if (n> 50000 || k >  0xfe)
-	  return huge*copysignf(huge,x); /* overflow  */
+	  return huge*__copysignf(huge,x); /* overflow  */
 	if (n< -50000)
-	  return tiny*copysignf(tiny,x);	/*underflow*/
+	  return tiny*__copysignf(tiny,x);	/*underflow*/
         if (k > 0) 				/* normal result */
 	    {SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23)); return x;}
         if (k <= -25)
-	    return tiny*copysignf(tiny,x);	/*underflow*/
+	    return tiny*__copysignf(tiny,x);	/*underflow*/
         k += 25;				/* subnormal result */
 	SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23));
         return x*twom25;
diff -Nur sysdeps/ieee754/k_standard.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/k_standard.c
--- sysdeps/ieee754/k_standard.c	2001-06-09 22:29:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/k_standard.c	2004-11-21 20:58:02.000000000 +0100
@@ -90,6 +90,7 @@
  *	47-- exp10 underflow
  *	48-- log2(0)
  *	49-- log2(x<0)
+ *	50-- tgamma(+-0)
  */
 
 
@@ -832,7 +833,7 @@
 	    case 40:
 	    case 140:
 	    case 240:
-		/* gamma(finite) overflow */
+		/* tgamma(finite) overflow */
 		exc.type = OVERFLOW;
 		exc.name = type < 100 ? "tgamma" : (type < 200
 						   ? "tgammaf" : "tgammal");
@@ -846,7 +847,7 @@
 	    case 41:
 	    case 141:
 	    case 241:
-		/* gamma(-integer) or gamma(0) */
+		/* tgamma(-integer) */
 		exc.type = SING;
 		exc.name = type < 100 ? "tgamma" : (type < 200
 						   ? "tgammaf" : "tgammal");
@@ -973,8 +974,24 @@
 		  __set_errno (EDOM);
 		}
 		break;
+	    case 50:
+	    case 150:
+	    case 250:
+		/* tgamma(+-0) */
+		exc.type = SING;
+		exc.name = type < 100 ? "tgamma" : (type < 200
+						    ? "tgammaf" : "tgammal");
+		exc.retval = __copysign (HUGE_VAL, x);
+		if (_LIB_VERSION == _POSIX_)
+		  __set_errno (ERANGE);
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_)
+		    (void) WRITE2("tgamma: SING error\n", 18);
+		  __set_errno (ERANGE);
+		}
+		break;
 		
-		/* #### Last used is 49/149/249 ### */
+		/* #### Last used is 50/150/250 ### */
 	}
 	return exc.retval;
 }
diff -Nur sysdeps/ieee754/ldbl-128/bits/huge_vall.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/bits/huge_vall.h
--- sysdeps/ieee754/ldbl-128/bits/huge_vall.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/bits/huge_vall.h	2004-04-21 20:58:01.000000000 +0200
@@ -0,0 +1,51 @@
+/* `HUGE_VALL' constant for IEEE 754 machines (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALL	(__builtin_huge_vall())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VALL	(__extension__ 0x1.0p32767L)
+#else
+# include <endian.h>
+
+typedef union { unsigned char __c[16]; long double __ld; } __huge_vall_t;
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __HUGE_VALL_bytes	{ 0x7f, 0xff, 0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __HUGE_VALL_bytes	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0xff, 0x7f }
+# endif
+
+# ifdef __GNUC__
+#  define HUGE_VALL	(__extension__ \
+			 ((__huge_vall_t) { __c : __HUGE_VALL_bytes }).__ld)
+# else
+static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
+#  define HUGE_VALL	(__huge_vall.__ld)
+# endif
+#endif 
diff -Nur sysdeps/ieee754/ldbl-128/e_expl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_expl.c
--- sysdeps/ieee754/ldbl-128/e_expl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_expl.c	2004-12-16 17:48:54.000000000 +0100
@@ -66,6 +66,7 @@
 #include <fenv.h>
 #include <inttypes.h>
 #include <math_private.h>
+#include <stdlib.h>
 #include "t_expl.h"
 
 static const long double C[] = {
diff -Nur sysdeps/ieee754/ldbl-128/e_gammal_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_gammal_r.c
--- sysdeps/ieee754/ldbl-128/e_gammal_r.c	2002-07-11 05:09:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_gammal_r.c	2004-11-21 20:57:14.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of gamma function according to ISO C.
-   Copyright (C) 1997, 1999, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
    		  Jakub Jelinek <jj@ultra.linux.cz, 1999.
@@ -36,9 +36,9 @@
 
   if (((hx & 0x7fffffffffffffffLL) | lx) == 0)
     {
-      /* Return value for x == 0 is NaN with invalid exception.  */
+      /* Return value for x == 0 is Inf with divide by zero exception.  */
       *signgamp = 0;
-      return x / x;
+      return 1.0 / x;
     }
   if (hx < 0 && (u_int64_t) hx < 0xffff000000000000ULL && __rintl (x) == x)
     {
diff -Nur sysdeps/ieee754/ldbl-128/e_j0l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_j0l.c
--- sysdeps/ieee754/ldbl-128/e_j0l.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_j0l.c	2003-12-28 21:50:20.000000000 +0100
@@ -827,8 +827,8 @@
   if (x <= 0.0L)
     {
       if (x < 0.0L)
-	return (zero / zero);
-      return 1.0L / zero;
+	return (zero / (zero * x));
+      return -HUGE_VALL + x;
     }
   xx = fabsl (x);
   if (xx <= 2.0L)
diff -Nur sysdeps/ieee754/ldbl-128/e_j1l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_j1l.c
--- sysdeps/ieee754/ldbl-128/e_j1l.c	2002-08-27 06:52:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_j1l.c	2003-12-28 21:50:20.000000000 +0100
@@ -834,8 +834,8 @@
   if (x <= 0.0L)
     {
       if (x < 0.0L)
-	return (zero / zero);
-      return -1.0L / zero;
+	return (zero / (zero * x));
+      return -HUGE_VALL + x;
     }
   xx = fabsl (x);
   if (xx <= 2.0L)
diff -Nur sysdeps/ieee754/ldbl-128/e_jnl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_jnl.c
--- sysdeps/ieee754/ldbl-128/e_jnl.c	2002-08-28 07:52:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/e_jnl.c	2003-12-28 21:50:20.000000000 +0100
@@ -323,9 +323,9 @@
   if (x <= 0.0L)
     {
       if (x == 0.0L)
-	return -one / zero;
+	return -HUGE_VALL + x;
       if (se & 0x80000000)
-	return zero / zero;
+	return zero / (zero * x);
     }
   sign = 1;
   if (n < 0)
diff -Nur sysdeps/ieee754/ldbl-128/ldbl2mpn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/ldbl2mpn.c
--- sysdeps/ieee754/ldbl-128/ldbl2mpn.c	2002-07-11 05:09:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/ldbl2mpn.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,1999,2002,2003
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -49,8 +50,8 @@
 #elif BITS_PER_MP_LIMB == 64
   /* Hopefully the compiler will combine the two bitfield extracts
      and this composition into just the original quadword extract.  */
-  res_ptr[0] = ((unsigned long int) u.ieee.mantissa2 << 32) | u.ieee.mantissa3;
-  res_ptr[1] = ((unsigned long int) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
+  res_ptr[0] = ((mp_limb_t) u.ieee.mantissa2 << 32) | u.ieee.mantissa3;
+  res_ptr[1] = ((mp_limb_t) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
   #define N 2
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
@@ -133,7 +134,8 @@
     }
   else
     /* Add the implicit leading one bit for a normalized number.  */
-    res_ptr[N - 1] |= 1L << (LDBL_MANT_DIG - 1 - ((N - 1) * BITS_PER_MP_LIMB));
+    res_ptr[N - 1] |= (mp_limb_t) 1 << (LDBL_MANT_DIG - 1
+					- ((N - 1) * BITS_PER_MP_LIMB));
 
   return N;
 }
diff -Nur sysdeps/ieee754/ldbl-128/mpn2ldbl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/mpn2ldbl.c
--- sysdeps/ieee754/ldbl-128/mpn2ldbl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/mpn2ldbl.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,1999,2002,2003
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,12 +38,14 @@
   u.ieee.mantissa3 = frac_ptr[0];
   u.ieee.mantissa2 = frac_ptr[1];
   u.ieee.mantissa1 = frac_ptr[2];
-  u.ieee.mantissa0 = frac_ptr[3] & ((1 << (LDBL_MANT_DIG - 96)) - 1);
+  u.ieee.mantissa0 = frac_ptr[3] & (((mp_limb_t) 1
+				     << (LDBL_MANT_DIG - 96)) - 1);
 #elif BITS_PER_MP_LIMB == 64
-  u.ieee.mantissa3 = frac_ptr[0] & ((1L << 32) - 1);
+  u.ieee.mantissa3 = frac_ptr[0] & (((mp_limb_t) 1 << 32) - 1);
   u.ieee.mantissa2 = frac_ptr[0] >> 32;
-  u.ieee.mantissa1 = frac_ptr[1] & ((1L << 32) - 1);
-  u.ieee.mantissa0 = (frac_ptr[1] >> 32) & ((1 << (LDBL_MANT_DIG - 96)) - 1);
+  u.ieee.mantissa1 = frac_ptr[1] & (((mp_limb_t) 1 << 32) - 1);
+  u.ieee.mantissa0 = (frac_ptr[1] >> 32) & (((mp_limb_t) 1
+					     << (LDBL_MANT_DIG - 96)) - 1);
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
 #endif
diff -Nur sysdeps/ieee754/ldbl-128/s_llroundl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_llroundl.c
--- sysdeps/ieee754/ldbl-128/s_llroundl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_llroundl.c	2004-02-12 21:57:40.000000000 +0100
@@ -1,5 +1,5 @@
 /* Round long double value to long long int.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
    		  Jakub Jelinek <jj@ultra.linux.cz>, 1999.
@@ -58,7 +58,10 @@
 	  if (j < i1)
 	    ++i0;
 
-	  result = ((long long int) i0 << (j0 - 48)) | (j >> (112 - j0));
+	  if (j0 == 48)
+	    result = (long long int) i0;
+	  else
+	    result = ((long long int) i0 << (j0 - 48)) | (j >> (112 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/ldbl-128/s_lrintl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_lrintl.c
--- sysdeps/ieee754/ldbl-128/s_lrintl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_lrintl.c	2004-02-12 21:57:40.000000000 +0100
@@ -1,6 +1,6 @@
 /* Round argument to nearest integral value according to current rounding
    direction.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
    		  Jakub Jelinek <jj@ultra.linux.cz>, 1999.
@@ -75,7 +75,10 @@
 	  i0 &= 0x0000ffffffffffffLL;
 	  i0 |= 0x0001000000000000LL;
 
-	  result = ((long int) i0 << (j0 - 48)) | (i1 >> (112 - j0));
+	  if (j0 == 48)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 48)) | (i1 >> (112 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/ldbl-128/s_lroundl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_lroundl.c
--- sysdeps/ieee754/ldbl-128/s_lroundl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_lroundl.c	2004-02-12 21:57:40.000000000 +0100
@@ -1,5 +1,5 @@
 /* Round long double value to long int.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
    		  Jakub Jelinek <jj@ultra.linux.cz>, 1999.
@@ -58,7 +58,10 @@
 	  if (j < i1)
 	    ++i0;
 
-	  result = ((long int) i0 << (j0 - 48)) | (j >> (112 - j0));
+	  if (j0 == 48)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 48)) | (j >> (112 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/ldbl-128/s_nexttoward.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_nexttoward.c
--- sysdeps/ieee754/ldbl-128/s_nexttoward.c	2000-10-09 16:48:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/s_nexttoward.c	2003-12-07 22:21:29.000000000 +0100
@@ -27,6 +27,7 @@
 
 #include "math.h"
 #include "math_private.h"
+#include <float.h>
 
 #ifdef __STDC__
 	double __nexttoward(double x, long double y)
@@ -83,7 +84,13 @@
 	    }
 	}
 	hy = hx&0x7ff00000;
-	if(hy>=0x7ff00000) return x+x;	/* overflow  */
+	if(hy>=0x7ff00000) {
+	  x = x+x;	/* overflow  */
+	  if (FLT_EVAL_METHOD != 0 && FLT_EVAL_METHOD != 1)
+	    /* Force conversion to float.  */
+	    asm ("" : "=m"(x) : "m"(x));
+	  return x;
+	}
 	if(hy<0x00100000) {		/* underflow */
 	    double x2 = x*x;
 	    if(x2!=x) {		/* raise underflow flag */
diff -Nur sysdeps/ieee754/ldbl-128/strtold.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/strtold.c
--- sysdeps/ieee754/ldbl-128/strtold.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/strtold.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* The actual implementation for all floating point sizes is in strtod.c.
-   These macros tell it to produce the `long double' version, `strtold'.  */
-
-# define FLOAT		long double
-# define FLT		LDBL
-# ifdef USE_IN_EXTENDED_LOCALE_MODEL
-#  define STRTOF	__strtold_l
-# else
-#  define STRTOF	strtold
-# endif
-# define MPN2FLOAT	__mpn_construct_long_double
-# define FLOAT_HUGE_VAL	HUGE_VALL
-# define SET_MANTISSA(flt, mant) \
-  do { union ieee854_long_double u;					      \
-       u.d = (flt);							      \
-       u.ieee.mantissa0 = 0x8000;					      \
-       u.ieee.mantissa1 = 0;						      \
-       u.ieee.mantissa2 = ((mant) >> 32);	      			      \
-       u.ieee.mantissa3 = (mant) & 0xffffffff;				      \
-       (flt) = u.d;							      \
-  } while (0)
-
-# include "strtod.c"
diff -Nur sysdeps/ieee754/ldbl-128/strtold_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/strtold_l.c
--- sysdeps/ieee754/ldbl-128/strtold_l.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-128/strtold_l.c	2004-03-14 22:00:47.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (C) 1999, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <math.h>
+
+/* The actual implementation for all floating point sizes is in strtod.c.
+   These macros tell it to produce the `long double' version, `strtold'.  */
+
+#define FLOAT		long double
+#define FLT		LDBL
+#ifdef USE_WIDE_CHAR
+# define STRTOF		wcstold_l
+# define __STRTOF	__wcstold_l
+#else
+# define STRTOF		strtold_l
+# define __STRTOF	__strtold_l
+#endif
+#define MPN2FLOAT	__mpn_construct_long_double
+#define FLOAT_HUGE_VAL	HUGE_VALL
+#define SET_MANTISSA(flt, mant) \
+  do { union ieee854_long_double u;					      \
+       u.d = (flt);							      \
+       u.ieee.mantissa0 = 0x8000;					      \
+       u.ieee.mantissa1 = 0;						      \
+       u.ieee.mantissa2 = ((mant) >> 32);	      			      \
+       u.ieee.mantissa3 = (mant) & 0xffffffff;				      \
+       (flt) = u.d;							      \
+  } while (0)
+
+#include <strtod_l.c>
diff -Nur sysdeps/ieee754/ldbl-96/e_gammal_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_gammal_r.c
--- sysdeps/ieee754/ldbl-96/e_gammal_r.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_gammal_r.c	2004-11-21 20:57:14.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of gamma function according to ISO C.
-   Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2001, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -34,9 +34,9 @@
 
   if (((es & 0x7fff) | hx | lx) == 0)
     {
-      /* Return value for x == 0 is NaN with invalid exception.  */
+      /* Return value for x == 0 is Inf with divide by zero exception.  */
       *signgamp = 0;
-      return x / x;
+      return 1.0 / x;
     }
   if (es == 0xffffffff && ((hx & 0x7fffffff) | lx) == 0)
     {
@@ -45,8 +45,11 @@
       return x - x;
     }
   if ((es & 0x7fff) == 0x7fff && ((hx & 0x7fffffff) | lx) != 0)
-    /* NaN, return it.  */
-    return x;
+    {
+      /* NaN, return it.  */
+      *signgamp = 0;
+      return x;
+    }
   if ((es & 0x8000) != 0 && x < 0xffffffff && __rintl (x) == x)
     {
       /* Return value for integer x < 0 is NaN with invalid exception.  */
diff -Nur sysdeps/ieee754/ldbl-96/e_j0l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_j0l.c
--- sysdeps/ieee754/ldbl-96/e_j0l.c	2002-08-28 07:52:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_j0l.c	2003-12-28 21:50:20.000000000 +0100
@@ -232,11 +232,11 @@
   ix = se & 0x7fff;
   /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
   if (se & 0x8000)
-    return zero / zero;
+    return zero / (zero * x);
   if (ix >= 0x7fff)
     return one / (x + x * x);
   if ((i0 | i1) == 0)
-    return -one / zero;
+    return -HUGE_VALL + x;  /* -inf and overflow exception.  */
   if (ix >= 0x4000)
     {				/* |x| >= 2.0 */
 
diff -Nur sysdeps/ieee754/ldbl-96/e_j1l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_j1l.c
--- sysdeps/ieee754/ldbl-96/e_j1l.c	2002-08-28 07:52:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_j1l.c	2003-12-28 21:50:20.000000000 +0100
@@ -224,11 +224,11 @@
   ix = se & 0x7fff;
   /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
   if (se & 0x8000)
-    return zero / zero;
+    return zero / (zero * x);
   if (ix >= 0x7fff)
     return one / (x + x * x);
   if ((i0 | i1) == 0)
-    return -one / zero;
+    return -HUGE_VALL + x;  /* -inf and overflow exception.  */
   if (ix >= 0x4000)
     {				/* |x| >= 2.0 */
       __sincosl (x, &s, &c);
diff -Nur sysdeps/ieee754/ldbl-96/e_jnl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_jnl.c
--- sysdeps/ieee754/ldbl-96/e_jnl.c	2002-08-28 07:52:04.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/e_jnl.c	2003-12-28 21:50:20.000000000 +0100
@@ -36,7 +36,7 @@
  * of order n
  *
  * Special cases:
- *	y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
+ *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
  *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
  * Note 2. About jn(n,x), yn(n,x)
  *	For n=0, j0(x) is called,
@@ -312,9 +312,9 @@
   if ((ix == 0x7fff) && ((i0 & 0x7fffffff) != 0))
     return x + x;
   if ((ix | i0 | i1) == 0)
-    return -one / zero;
+    return -HUGE_VALL + x;  /* -inf and overflow exception.  */
   if (se & 0x8000)
-    return zero / zero;
+    return zero / (zero * x);
   sign = 1;
   if (n < 0)
     {
diff -Nur sysdeps/ieee754/ldbl-96/ldbl2mpn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/ldbl2mpn.c
--- sysdeps/ieee754/ldbl-96/ldbl2mpn.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/ldbl2mpn.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,7 +47,7 @@
 #elif BITS_PER_MP_LIMB == 64
   /* Hopefully the compiler will combine the two bitfield extracts
      and this composition into just the original quadword extract.  */
-  res_ptr[0] = ((unsigned long int) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
+  res_ptr[0] = ((mp_limb_t) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
   #define N 1
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
diff -Nur sysdeps/ieee754/ldbl-96/mpn2ldbl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/mpn2ldbl.c
--- sysdeps/ieee754/ldbl-96/mpn2ldbl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/mpn2ldbl.c	2003-03-14 04:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,7 +37,7 @@
   u.ieee.mantissa1 = frac_ptr[0];
   u.ieee.mantissa0 = frac_ptr[1];
 #elif BITS_PER_MP_LIMB == 64
-  u.ieee.mantissa1 = frac_ptr[0] & ((1L << 32) - 1);
+  u.ieee.mantissa1 = frac_ptr[0] & (((mp_limb_t) 1 << 32) - 1);
   u.ieee.mantissa0 = frac_ptr[0] >> 32;
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
diff -Nur sysdeps/ieee754/ldbl-96/s_llrintl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_llrintl.c
--- sysdeps/ieee754/ldbl-96/s_llrintl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_llrintl.c	2004-02-12 21:57:52.000000000 +0100
@@ -1,6 +1,6 @@
 /* Round argument to nearest integral value according to current rounding
    direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -58,7 +58,7 @@
 	  GET_LDOUBLE_WORDS (se, i0, i1, t);
 	  j0 = (se & 0x7fff) - 0x3fff;
 
-	  if (j0 < 31)
+	  if (j0 <= 31)
 	    result = i0 >> (31 - j0);
 	  else
 	    result = ((long long int) i0 << (j0 - 31)) | (i1 >> (63 - j0));
diff -Nur sysdeps/ieee754/ldbl-96/s_lrintl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_lrintl.c
--- sysdeps/ieee754/ldbl-96/s_lrintl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_lrintl.c	2004-02-01 20:11:52.000000000 +0100
@@ -1,6 +1,6 @@
 /* Round argument to nearest integral value according to current rounding
    direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -70,7 +70,10 @@
 	  GET_LDOUBLE_WORDS (se, i0, i1, t);
 	  j0 = (se & 0x7fff) - 0x3fff;
 
-	  result = ((long int) i0 << (j0 - 31)) | (i1 >> (63 - j0));
+	  if (j0 == 31)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 31)) | (i1 >> (63 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/ldbl-96/s_lroundl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_lroundl.c
--- sysdeps/ieee754/ldbl-96/s_lroundl.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_lroundl.c	2004-02-01 20:06:30.000000000 +0100
@@ -1,5 +1,5 @@
 /* Round long double value to long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -62,7 +62,10 @@
 	  if (j < i1)
 	    ++i0;
 
-	  result = ((long int) i0 << (j0 - 31)) | (j >> (63 - j0));
+	  if (j0 == 31)
+	    result = (long int) i0;
+	  else
+	    result = ((long int) i0 << (j0 - 31)) | (j >> (63 - j0));
 	}
     }
   else
diff -Nur sysdeps/ieee754/ldbl-96/s_nexttoward.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_nexttoward.c
--- sysdeps/ieee754/ldbl-96/s_nexttoward.c	2001-06-16 05:30:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/s_nexttoward.c	2003-12-07 22:21:10.000000000 +0100
@@ -27,6 +27,7 @@
 
 #include "math.h"
 #include "math_private.h"
+#include <float.h>
 
 #ifdef __STDC__
 	double __nexttoward(double x, long double y)
@@ -80,7 +81,13 @@
 	    }
 	}
 	hy = hx&0x7ff00000;
-	if(hy>=0x7ff00000) return x+x;	/* overflow  */
+	if(hy>=0x7ff00000) {
+	  x = x+x;	/* overflow  */
+	  if (FLT_EVAL_METHOD != 0 && FLT_EVAL_METHOD != 1)
+	    /* Force conversion to float.  */
+	    asm ("" : "=m"(x) : "m"(x));
+	  return x;
+	}
 	if(hy<0x00100000) {		/* underflow */
 	    double x2 = x*x;
 	    if(x2!=x) {		/* raise underflow flag */
diff -Nur sysdeps/ieee754/ldbl-96/strtold.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/strtold.c
--- sysdeps/ieee754/ldbl-96/strtold.c	2001-07-07 21:21:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/strtold.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* The actual implementation for all floating point sizes is in strtod.c.
-   These macros tell it to produce the `long double' version, `strtold'.  */
-
-# define FLOAT		long double
-# define FLT		LDBL
-# ifdef USE_IN_EXTENDED_LOCALE_MODEL
-#  define STRTOF	__strtold_l
-# else
-#  define STRTOF	strtold
-# endif
-# define MPN2FLOAT	__mpn_construct_long_double
-# define FLOAT_HUGE_VAL	HUGE_VALL
-# define SET_MANTISSA(flt, mant) \
-  do { union ieee854_long_double u;					      \
-       u.d = (flt);							      \
-       if ((mant & 0x7fffffffffffffffULL) == 0)				      \
-	 mant = 0x4000000000000000ULL;					      \
-       u.ieee.mantissa0 = (((mant) >> 32) & 0x7fffffff) | 0x80000000;	      \
-       u.ieee.mantissa1 = (mant) & 0xffffffff;				      \
-       (flt) = u.d;							      \
-  } while (0)
-
-# include "strtod.c"
diff -Nur sysdeps/ieee754/ldbl-96/strtold_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/strtold_l.c
--- sysdeps/ieee754/ldbl-96/strtold_l.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/ieee754/ldbl-96/strtold_l.c	2004-03-14 22:00:57.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (C) 1999, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <math.h>
+
+/* The actual implementation for all floating point sizes is in strtod.c.
+   These macros tell it to produce the `long double' version, `strtold'.  */
+
+#define FLOAT		long double
+#define FLT		LDBL
+#ifdef USE_WIDE_CHAR
+# define STRTOF		wcstold_l
+# define __STRTOF	__wcstold_l
+#else
+# define STRTOF		strtold_l
+# define __STRTOF	__strtold_l
+#endif
+#define MPN2FLOAT	__mpn_construct_long_double
+#define FLOAT_HUGE_VAL	HUGE_VALL
+#define SET_MANTISSA(flt, mant) \
+  do { union ieee854_long_double u;					      \
+       u.d = (flt);							      \
+       if ((mant & 0x7fffffffffffffffULL) == 0)				      \
+	 mant = 0x4000000000000000ULL;					      \
+       u.ieee.mantissa0 = (((mant) >> 32) & 0x7fffffff) | 0x80000000;	      \
+       u.ieee.mantissa1 = (mant) & 0xffffffff;				      \
+       (flt) = u.d;							      \
+  } while (0)
+
+#include <strtod_l.c>
diff -Nur sysdeps/posix/clock_getres.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/clock_getres.c
--- sysdeps/posix/clock_getres.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/clock_getres.c	2003-06-25 01:58:29.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,7 +24,7 @@
 #include <libc-internal.h>
 
 
-#if HP_TIMING_AVAIL
+#if HP_TIMING_AVAIL && !defined HANDLED_CPUTIME
 /* Clock frequency of the processor.  */
 static long int nsec;
 #endif
@@ -38,26 +38,45 @@
 
   switch (clock_id)
     {
-    case CLOCK_REALTIME:
-      {
-	long int clk_tck = sysconf (_SC_CLK_TCK);
+#define HANDLE_REALTIME \
+      do {								      \
+	long int clk_tck = sysconf (_SC_CLK_TCK);			      \
+									      \
+	if (__builtin_expect (clk_tck != -1, 1))			      \
+	  {								      \
+	    /* This implementation assumes that the realtime clock has a      \
+	       resolution higher than 1 second.  This is the case for any     \
+	       reasonable implementation.  */				      \
+	    res->tv_sec = 0;						      \
+	    res->tv_nsec = 1000000000 / clk_tck;			      \
+									      \
+	    retval = 0;							      \
+	  }								      \
+      } while (0)
 
-	if (__builtin_expect (clk_tck != -1, 1))
-	  {
-	    /* This implementation assumes that the realtime clock has a
-	       resolution higher than 1 second.  This is the case for any
-	       reasonable implementation.  */
-	    res->tv_sec = 0;
-	    res->tv_nsec = 1000000000 / clk_tck;
+#ifdef SYSDEP_GETRES
+      SYSDEP_GETRES;
+#endif
 
-	    retval = 0;
-	  }
-      }
+#ifndef HANDLED_REALTIME
+    case CLOCK_REALTIME:
+      HANDLE_REALTIME;
       break;
+#endif	/* handled REALTIME */
 
+    default:
 #if HP_TIMING_AVAIL
+      if ((clock_id & ((1 << CLOCK_IDFIELD_SIZE) - 1))
+	  != CLOCK_THREAD_CPUTIME_ID)
+#endif
+	{
+	  __set_errno (EINVAL);
+	  break;
+	}
+
+#if HP_TIMING_AVAIL && !defined HANDLED_CPUTIME
+      /* FALLTHROUGH.  */
     case CLOCK_PROCESS_CPUTIME_ID:
-    case CLOCK_THREAD_CPUTIME_ID:
       {
 	if (__builtin_expect (nsec == 0, 0))
 	  {
@@ -84,10 +103,6 @@
       }
       break;
 #endif
-
-    default:
-      __set_errno (EINVAL);
-      break;
     }
 
   return retval;
diff -Nur sysdeps/posix/fpathconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/fpathconf.c
--- sysdeps/posix/fpathconf.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/fpathconf.c	2003-03-14 07:22:16.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,1995,1996,1998,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1998,2000,2001,2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -229,6 +230,10 @@
       /* In general there are no limits.  If a system has one it should
 	 overwrite this case.  */
       return -1;
+
+    case _PC_2_SYMLINKS:
+      /* Unix systems generally have symlinks.  */
+      return 1;
     }
 }
 
diff -Nur sysdeps/posix/gai_strerror.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/gai_strerror.c
--- sysdeps/posix/gai_strerror.c	2002-08-12 10:54:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/gai_strerror.c	2004-03-08 23:21:13.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997,2001,02 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Philip Blundell <pjb27@cam.ac.uk>, 1997.
 
@@ -43,7 +43,8 @@
     { EAI_CANCELED, N_("Request canceled") },
     { EAI_NOTCANCELED, N_("Request not canceled") },
     { EAI_ALLDONE, N_("All requests done") },
-    { EAI_INTR, N_("Interrupted by a signal") }
+    { EAI_INTR, N_("Interrupted by a signal") },
+    { EAI_IDN_ENCODE, N_("Parameter string not correctly encoded") }
   };
 
 const char *
diff -Nur sysdeps/posix/getaddrinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/getaddrinfo.c
--- sysdeps/posix/getaddrinfo.c	2002-08-29 10:49:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/getaddrinfo.c	2004-11-22 19:41:37.000000000 +0100
@@ -37,8 +37,10 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <ifaddrs.h>
 #include <netdb.h>
 #include <resolv.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -50,6 +52,17 @@
 #include <sys/un.h>
 #include <sys/utsname.h>
 #include <net/if.h>
+#include <nsswitch.h>
+#include <not-cancel.h>
+#include <nscd/nscd-client.h>
+#include <nscd/nscd_proto.h>
+
+#ifdef HAVE_LIBIDN
+extern int __idna_to_ascii_lz (const char *input, char **output, int flags);
+extern int __idna_to_unicode_lzlz (const char *input, char **output,
+				   int flags);
+# include <libidn/idna.h>
+#endif
 
 #define GAIH_OKIFUNSPEC 0x0100
 #define GAIH_EAI        ~(GAIH_OKIFUNSPEC)
@@ -77,8 +90,9 @@
 struct gaih_addrtuple
   {
     struct gaih_addrtuple *next;
+    char *name;
     int family;
-    char addr[16];
+    uint32_t addr[4];
     uint32_t scopeid;
   };
 
@@ -110,12 +124,17 @@
 		const struct addrinfo *req, struct addrinfo **pai);
   };
 
-#if PF_UNSPEC == 0
-static const struct addrinfo default_hints;
-#else
 static const struct addrinfo default_hints =
-	{ 0, PF_UNSPEC, 0, 0, 0, NULL, NULL, NULL };
-#endif
+  {
+    .ai_flags = AI_DEFAULT,
+    .ai_family = PF_UNSPEC,
+    .ai_socktype = 0,
+    .ai_protocol = 0,
+    .ai_addrlen = 0,
+    .ai_addr = NULL,
+    .ai_canonname = NULL,
+    .ai_next = NULL
+  };
 
 
 #if 0
@@ -264,49 +283,84 @@
   return 0;
 }
 
-#define gethosts(_family, _type)				\
- {								\
-  int i, herrno;						\
-  size_t tmpbuflen;						\
-  struct hostent th;						\
-  char *tmpbuf;							\
-  tmpbuflen = 512;						\
-  no_data = 0;							\
-  do {								\
-    tmpbuflen *= 2;						\
-    tmpbuf = __alloca (tmpbuflen);				\
-    rc = __gethostbyname2_r (name, _family, &th, tmpbuf,	\
-         tmpbuflen, &h, &herrno);				\
-  } while (rc == ERANGE && herrno == NETDB_INTERNAL);		\
-  if (rc != 0)							\
-    {								\
-      if (herrno == NETDB_INTERNAL)				\
-	{							\
-	  __set_h_errno (herrno);				\
-	  return -EAI_SYSTEM;					\
-	}							\
-      if (herrno == TRY_AGAIN)					\
-	no_data = EAI_AGAIN;					\
-      else							\
-	no_data = herrno == NO_DATA;				\
-    }								\
-  else if (h != NULL)						\
-    {								\
-      for (i = 0; h->h_addr_list[i]; i++)			\
-	{							\
-	  if (*pat == NULL) {					\
-	    *pat = __alloca (sizeof(struct gaih_addrtuple));	\
-	    (*pat)->scopeid = 0;				\
-	  }							\
-	  (*pat)->next = NULL;					\
-	  (*pat)->family = _family;				\
-	  memcpy ((*pat)->addr, h->h_addr_list[i],		\
-		 sizeof(_type));				\
-	  pat = &((*pat)->next);				\
-	}							\
-    }								\
+#define gethosts(_family, _type) \
+ {									      \
+  int i;								      \
+  int herrno;								      \
+  struct hostent th;							      \
+  struct hostent *h;							      \
+  char *localcanon = NULL;						      \
+  no_data = 0;								      \
+  while (1) {								      \
+    rc = 0;								      \
+    status = DL_CALL_FCT (fct, (name, _family, &th, tmpbuf, tmpbuflen,	      \
+				&rc, &herrno, NULL, &localcanon));	      \
+    if (rc != ERANGE || herrno != NETDB_INTERNAL)			      \
+      break;								      \
+    tmpbuf = extend_alloca (tmpbuf, tmpbuflen, 2 * tmpbuflen);		      \
+  }									      \
+  if (status == NSS_STATUS_SUCCESS && rc == 0)				      \
+    h = &th;								      \
+  else									      \
+    h = NULL;								      \
+  if (rc != 0)								      \
+    {									      \
+      if (herrno == NETDB_INTERNAL)					      \
+	{								      \
+	  __set_h_errno (herrno);					      \
+	  return -EAI_SYSTEM;						      \
+	}								      \
+      if (herrno == TRY_AGAIN)						      \
+	no_data = EAI_AGAIN;						      \
+      else								      \
+	no_data = herrno == NO_DATA;					      \
+    }									      \
+  else if (h != NULL)							      \
+    {									      \
+      for (i = 0; h->h_addr_list[i]; i++)				      \
+	{								      \
+	  if (*pat == NULL)						      \
+	    {								      \
+	      *pat = __alloca (sizeof (struct gaih_addrtuple));		      \
+	      (*pat)->scopeid = 0;					      \
+	    }								      \
+	  uint32_t *addr = (*pat)->addr;				      \
+	  (*pat)->next = NULL;						      \
+	  (*pat)->name = i == 0 ? strdupa (h->h_name) : NULL;		      \
+	  if (_family == AF_INET && req->ai_family == AF_INET6)		      \
+	    {								      \
+	      (*pat)->family = AF_INET6;				      \
+	      addr[3] = *(uint32_t *) h->h_addr_list[i];		      \
+	      addr[2] = htonl (0xffff);					      \
+	      addr[1] = 0;						      \
+	      addr[0] = 0;						      \
+	    }								      \
+	  else								      \
+	    {								      \
+	      (*pat)->family = _family;					      \
+	      memcpy (addr, h->h_addr_list[i], sizeof(_type));		      \
+	    }								      \
+	  pat = &((*pat)->next);					      \
+	}								      \
+									      \
+      if (localcanon !=	NULL && canon == NULL)				      \
+	canon = strdupa (localcanon);					      \
+									      \
+      if (_family == AF_INET6 && i > 0)					      \
+	got_ipv6 = true;						      \
+    }									      \
  }
 
+
+typedef enum nss_status (*nss_gethostbyname3_r)
+  (const char *name, int af, struct hostent *host,
+   char *buffer, size_t buflen, int *errnop,
+   int *h_errnop, int32_t *ttlp, char **canonp);
+typedef enum nss_status (*nss_getcanonname_r)
+  (const char *name, char *buffer, size_t buflen, char **result,
+   int *errnop, int *h_errnop);
+extern service_user *__nss_hosts_database attribute_hidden;
+
 static int
 gaih_inet (const char *name, const struct gaih_service *service,
 	   const struct addrinfo *req, struct addrinfo **pai)
@@ -315,6 +369,9 @@
   struct gaih_servtuple *st = (struct gaih_servtuple *) &nullserv;
   struct gaih_addrtuple *at = NULL;
   int rc;
+  bool got_ipv6 = false;
+  const char *canon = NULL;
+  const char *orig_name = name;
 
   if (req->ai_protocol || req->ai_socktype)
     {
@@ -388,12 +445,35 @@
 	}
       else
 	{
-	  st = __alloca (sizeof (struct gaih_servtuple));
-	  st->next = NULL;
-	  st->socktype = tp->socktype;
-	  st->protocol = ((tp->protoflag & GAI_PROTO_PROTOANY)
-			  ? req->ai_protocol : tp->protocol);
-	  st->port = htons (service->num);
+	  if (req->ai_socktype || req->ai_protocol)
+	    {
+	      st = __alloca (sizeof (struct gaih_servtuple));
+	      st->next = NULL;
+	      st->socktype = tp->socktype;
+	      st->protocol = ((tp->protoflag & GAI_PROTO_PROTOANY)
+			      ? req->ai_protocol : tp->protocol);
+	      st->port = htons (service->num);
+	    }
+	  else
+	    {
+	      /* Neither socket type nor protocol is set.  Return all
+		 socket types we know about.  */
+	      struct gaih_servtuple **lastp = &st;
+	      for (tp = gaih_inet_typeproto + 1; tp->name[0]; ++tp)
+		if ((tp->protoflag & GAI_PROTO_NOSERVICE) == 0)
+		  {
+		    struct gaih_servtuple *newp;
+
+		    newp = __alloca (sizeof (struct gaih_servtuple));
+		    newp->next = NULL;
+		    newp->socktype = tp->socktype;
+		    newp->protocol = tp->protocol;
+		    newp->port = htons (service->num);
+
+		    *lastp = newp;
+		    lastp = &newp->next;
+		  }
+	    }
 	}
     }
   else if (req->ai_socktype || req->ai_protocol)
@@ -433,12 +513,57 @@
       at->scopeid = 0;
       at->next = NULL;
 
-      if (inet_pton (AF_INET, name, at->addr) > 0)
+#ifdef HAVE_LIBIDN
+      if (req->ai_flags & AI_IDN)
+	{
+	  int idn_flags = 0;
+	  if (req->ai_flags & AI_IDN_ALLOW_UNASSIGNED)
+	    idn_flags |= IDNA_ALLOW_UNASSIGNED;
+	  if (req->ai_flags & AI_IDN_USE_STD3_ASCII_RULES)
+	    idn_flags |= IDNA_USE_STD3_ASCII_RULES;
+
+	  char *p = NULL;
+	  rc = __idna_to_ascii_lz (name, &p, idn_flags);
+	  if (rc != IDNA_SUCCESS)
+	    {
+	      if (rc == IDNA_MALLOC_ERROR)
+		return -EAI_MEMORY;
+	      if (rc == IDNA_DLOPEN_ERROR)
+		return -EAI_SYSTEM;
+	      return -EAI_IDN_ENCODE;
+	    }
+	  /* In case the output string is the same as the input string
+	     no new string has been allocated.  */
+	  if (p != name)
+	    {
+	      name = strdupa (p);
+	      free (p);
+	    }
+	}
+#endif
+
+      if (__inet_aton (name, (struct in_addr *) at->addr) != 0)
 	{
 	  if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET)
 	    at->family = AF_INET;
+	  else if (req->ai_family == AF_INET6 && req->ai_flags & AI_V4MAPPED)
+	    {
+	      at->addr[3] = at->addr[0];
+	      at->addr[2] = htonl (0xffff);
+	      at->addr[1] = 0;
+	      at->addr[0] = 0;
+	      at->family = AF_INET6;
+	    }
 	  else
 	    return -EAI_ADDRFAMILY;
+
+	dupname:
+	  if (req->ai_flags & AI_CANONNAME)
+	    {
+	      canon = strdup (name);
+	      if (canon == NULL)
+		return -EAI_MEMORY;
+	    }
 	}
 
       if (at->family == AF_UNSPEC)
@@ -454,6 +579,12 @@
 	    {
 	      if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET6)
 		at->family = AF_INET6;
+	      else if (req->ai_family == AF_INET
+		       && IN6_IS_ADDR_V4MAPPED (at->addr))
+		{
+		  at->addr[0] = at->addr[3];
+		  at->family = AF_INET;
+		}
 	      else
 		return -EAI_ADDRFAMILY;
 
@@ -480,33 +611,298 @@
 			return GAIH_OKIFUNSPEC | -EAI_NONAME;
 		    }
 		}
+
+	      goto dupname;
 	    }
 	}
 
       if (at->family == AF_UNSPEC && (req->ai_flags & AI_NUMERICHOST) == 0)
 	{
-	  struct hostent *h;
 	  struct gaih_addrtuple **pat = &at;
 	  int no_data = 0;
-	  int no_inet6_data;
-	  int old_res_options = _res.options;
+	  int no_inet6_data = 0;
+	  service_user *nip = NULL;
+	  enum nss_status inet6_status = NSS_STATUS_UNAVAIL;
+	  enum nss_status status = NSS_STATUS_UNAVAIL;
+	  int no_more;
+	  int old_res_options;
+
+	  /* If we do not have to look for IPv4 and IPv6 together, use
+	     the simple, old functions.  */
+	  if (req->ai_family == AF_INET || req->ai_family == AF_INET6)
+	    {
+	      int family = req->ai_family;
+	      size_t tmpbuflen = 512;
+	      char *tmpbuf = alloca (tmpbuflen);
+	      int rc;
+	      struct hostent th;
+	      struct hostent *h;
+	      int herrno;
+
+	    simple_again:
+	      while (1)
+		{
+		  rc = __gethostbyname2_r (name, family, &th, tmpbuf,
+					   tmpbuflen, &h, &herrno);
+		  if (rc != ERANGE || herrno != NETDB_INTERNAL)
+		    break;
+		  tmpbuf = extend_alloca (tmpbuf, tmpbuflen, 2 * tmpbuflen);
+		}
+
+	      if (rc == 0)
+		{
+		  if (h == NULL)
+		    {
+		      if (req->ai_family == AF_INET6
+			  && (req->ai_flags & AI_V4MAPPED)
+			  && family == AF_INET6)
+			{
+			  /* Try again, this time looking for IPv4
+			     addresses.  */
+			  family = AF_INET;
+			  goto simple_again;
+			}
+		    }
+		  else
+		    {
+		      /* We found data, now convert it into the list.  */
+		      for (int i = 0; h->h_addr_list[i]; ++i)
+			{
+			  if (*pat == NULL)
+			    {
+			      *pat = __alloca (sizeof (struct gaih_addrtuple));
+			      (*pat)->scopeid = 0;
+			    }
+			  (*pat)->next = NULL;
+			  (*pat)->family = req->ai_family;
+			  if (family == req->ai_family)
+			    memcpy ((*pat)->addr, h->h_addr_list[i],
+				    h->h_length);
+			  else
+			    {
+			      int32_t *addr = (uint32_t *) (*pat)->addr;
+			      addr[3] = *(uint32_t *) h->h_addr_list[i];
+			      addr[2] = htonl (0xffff);
+			      addr[1] = 0;
+			      addr[0] = 0;
+			    }
+			  pat = &((*pat)->next);
+			}
+		    }
+		}
+	      else
+		{
+		  if (herrno == NETDB_INTERNAL)
+		    {
+		      __set_h_errno (herrno);
+		      return -EAI_SYSTEM;
+		    }
+		  if (herrno == TRY_AGAIN)
+		    {
+		      return -EAI_AGAIN;
+		    }
+		  /* We made requests but they turned out no data.
+		     The name is known, though.  */
+		  return (GAIH_OKIFUNSPEC | -EAI_NODATA);
+		}
+
+	      goto process_list;
+	    }
+
+#ifdef USE_NSCD
+	  if (__nss_not_use_nscd_hosts > 0
+	      && ++__nss_not_use_nscd_hosts > NSS_NSCD_RETRY)
+	    __nss_not_use_nscd_hosts = 0;
+
+	  if (!__nss_not_use_nscd_hosts)
+	    {
+	      /* Try to use nscd.  */
+	      struct nscd_ai_result *air = NULL;
+	      int herrno;
+	      int err = __nscd_getai (name, &air, &herrno);
+	      if (air != NULL)
+		{
+		  /* Transform into gaih_addrtuple list.  */
+		  bool added_canon = (req->ai_flags & AI_CANONNAME) == 0;
+		  char *addrs = air->addrs;
+
+		  for (int i = 0; i < air->naddrs; ++i)
+		    {
+		      socklen_t size = (air->family[i] == AF_INET
+					? INADDRSZ : IN6ADDRSZ);
+		      if (*pat == NULL)
+			{
+			  *pat = __alloca (sizeof (struct gaih_addrtuple));
+			  (*pat)->scopeid = 0;
+			}
+		      uint32_t *pataddr = (*pat)->addr;
+		      (*pat)->next = NULL;
+		      if (added_canon || air->canon == NULL)
+			(*pat)->name = NULL;
+		      else
+			canon = (*pat)->name = strdupa (air->canon);
+
+		      if (air->family[i] == AF_INET
+			  && req->ai_family == AF_INET6
+			  && (req->ai_flags & AI_V4MAPPED))
+			{
+			  (*pat)->family = AF_INET6;
+			  pataddr[3] = *(uint32_t *) addrs;
+			  pataddr[2] = htonl (0xffff);
+			  pataddr[1] = 0;
+			  pataddr[0] = 0;
+			  pat = &((*pat)->next);
+			  added_canon = true;
+			}
+		      else if (req->ai_family == AF_UNSPEC
+			       || air->family[i] == req->ai_family)
+			{
+			  (*pat)->family = air->family[i];
+			  memcpy (pataddr, addrs, size);
+			  pat = &((*pat)->next);
+			  added_canon = true;
+			  if (air->family[i] == AF_INET6)
+			    got_ipv6 = true;
+			}
+		      addrs += size;
+		    }
+
+		  free (air);
+
+		  if (at->family == AF_UNSPEC)
+		    return (GAIH_OKIFUNSPEC | -EAI_NONAME);
+
+		  goto process_list;
+		}
+	      else if (err != 0 && __nss_not_use_nscd_hosts == 0)
+		{
+		  if (herrno == NETDB_INTERNAL && errno == ENOMEM)
+		    return -EAI_MEMORY;
+		  if (herrno == TRY_AGAIN)
+		    return -EAI_AGAIN;
+		  return -EAI_SYSTEM;
+		}
+	    }
+#endif
+
+	  if (__nss_hosts_database != NULL)
+	    {
+	      no_more = 0;
+	      nip = __nss_hosts_database;
+	    }
+	  else
+	    no_more = __nss_database_lookup ("hosts", NULL,
+					     "dns [!UNAVAIL=return] files",
+					     &nip);
+
+	  if (__res_maybe_init (&_res, 0) == -1)
+	    no_more = 1;
 
 	  /* If we are looking for both IPv4 and IPv6 address we don't
 	     want the lookup functions to automatically promote IPv4
 	     addresses to IPv6 addresses.  Currently this is decided
 	     by setting the RES_USE_INET6 bit in _res.options.  */
-	  if (req->ai_family == AF_UNSPEC)
-	    _res.options &= ~RES_USE_INET6;
+	  old_res_options = _res.options;
+	  _res.options &= ~RES_USE_INET6;
 
-	  if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET6)
-	    gethosts (AF_INET6, struct in6_addr);
-	  no_inet6_data = no_data;
+	  size_t tmpbuflen = 512;
+	  char *tmpbuf = alloca (tmpbuflen);
 
-	  if (req->ai_family == AF_UNSPEC)
-	    _res.options = old_res_options;
+	  while (!no_more)
+	    {
+	      nss_gethostbyname3_r fct = NULL;
+	      if (req->ai_flags & AI_CANONNAME)
+		/* No need to use this function if we do not look for
+		   the canonical name.  The function does not exist in
+		   all NSS modules and therefore the lookup would
+		   often fail.  */
+		fct = __nss_lookup_function (nip, "gethostbyname3_r");
+	      if (fct == NULL)
+		/* We are cheating here.  The gethostbyname2_r function does
+		   not have the same interface as gethostbyname3_r but the
+		   extra arguments the latter takes are added at the end.
+		   So the gethostbyname2_r code will just ignore them.  */
+		fct = __nss_lookup_function (nip, "gethostbyname2_r");
 
-	  if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET)
-	    gethosts (AF_INET, struct in_addr);
+	      if (fct != NULL)
+		{
+		  if (req->ai_family == AF_INET6
+		      || req->ai_family == AF_UNSPEC)
+		    {
+		      gethosts (AF_INET6, struct in6_addr);
+		      no_inet6_data = no_data;
+		      inet6_status = status;
+		    }
+		  if (req->ai_family == AF_INET
+		      || req->ai_family == AF_UNSPEC
+		      || (req->ai_family == AF_INET6
+			  && (req->ai_flags & AI_V4MAPPED)
+			  /* Avoid generating the mapped addresses if we
+			     know we are not going to need them.  */
+			  && ((req->ai_flags & AI_ALL) || !got_ipv6)))
+		    {
+		      gethosts (AF_INET, struct in_addr);
+
+		      if (req->ai_family == AF_INET)
+			{
+			  no_inet6_data = no_data;
+			  inet6_status = status;
+			}
+		    }
+
+		  /* If we found one address for AF_INET or AF_INET6,
+		     don't continue the search.  */
+		  if (inet6_status == NSS_STATUS_SUCCESS
+		      || status == NSS_STATUS_SUCCESS)
+		    {
+		      if ((req->ai_flags & AI_CANONNAME) != 0 && canon == NULL)
+			{
+			  /* If we need the canonical name, get it
+			     from the same service as the result.  */
+			  nss_getcanonname_r cfct;
+			  int herrno;
+
+			  cfct = __nss_lookup_function (nip, "getcanonname_r");
+			  if (cfct != NULL)
+			    {
+			      const size_t max_fqdn_len = 256;
+			      char *buf = alloca (max_fqdn_len);
+			      char *s;
+
+			      if (DL_CALL_FCT (cfct, (at->name ?: name, buf,
+						      max_fqdn_len, &s, &rc,
+						      &herrno))
+				  == NSS_STATUS_SUCCESS)
+				canon = s;
+			      else
+				/* Set to name now to avoid using
+				   gethostbyaddr.  */
+				canon = name;
+			    }
+			}
+
+		      break;
+		    }
+
+		  /* We can have different states for AF_INET and
+		     AF_INET6.  Try to find a useful one for both.  */
+		  if (inet6_status == NSS_STATUS_TRYAGAIN)
+		    status = NSS_STATUS_TRYAGAIN;
+		  else if (status == NSS_STATUS_UNAVAIL &&
+			   inet6_status != NSS_STATUS_UNAVAIL)
+		    status = inet6_status;
+		}
+
+	      if (nss_next_action (nip, status) == NSS_ACTION_RETURN)
+		break;
+
+	      if (nip->next == NULL)
+		no_more = -1;
+	      else
+		nip = nip->next;
+	    }
+
+	  _res.options = old_res_options;
 
 	  if (no_data != 0 && no_inet6_data != 0)
 	    {
@@ -520,6 +916,7 @@
 	    }
 	}
 
+    process_list:
       if (at->family == AF_UNSPEC)
 	return (GAIH_OKIFUNSPEC | -EAI_NONAME);
     }
@@ -529,13 +926,13 @@
       atr = at = __alloca (sizeof (struct gaih_addrtuple));
       memset (at, '\0', sizeof (struct gaih_addrtuple));
 
-      if (req->ai_family == 0)
+      if (req->ai_family == AF_UNSPEC)
 	{
 	  at->next = __alloca (sizeof (struct gaih_addrtuple));
 	  memset (at->next, '\0', sizeof (struct gaih_addrtuple));
 	}
 
-      if (req->ai_family == 0 || req->ai_family == AF_INET6)
+      if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET6)
 	{
 	  at->family = AF_INET6;
 	  if ((req->ai_flags & AI_PASSIVE) == 0)
@@ -543,11 +940,11 @@
 	  atr = at->next;
 	}
 
-      if (req->ai_family == 0 || req->ai_family == AF_INET)
+      if (req->ai_family == AF_UNSPEC || req->ai_family == AF_INET)
 	{
 	  atr->family = AF_INET;
 	  if ((req->ai_flags & AI_PASSIVE) == 0)
-	    *(uint32_t *) atr->addr = htonl (INADDR_LOOPBACK);
+	    atr->addr[0] = htonl (INADDR_LOOPBACK);
 	}
     }
 
@@ -555,10 +952,9 @@
     return 0;
 
   {
-    const char *c = NULL;
     struct gaih_servtuple *st2;
     struct gaih_addrtuple *at2 = at;
-    size_t socklen, namelen;
+    size_t socklen;
     sa_family_t family;
 
     /*
@@ -566,85 +962,95 @@
      */
     while (at2 != NULL)
       {
-	if (req->ai_flags & AI_CANONNAME)
+	/* Only the first entry gets the canonical name.  */
+	if (at2 == at && (req->ai_flags & AI_CANONNAME) != 0)
 	  {
-	    struct hostent *h = NULL;
-
-	    int herrno;
-	    struct hostent th;
-	    size_t tmpbuflen = 512;
-	    char *tmpbuf;
-
-	    do
+	    if (canon == NULL)
 	      {
-		tmpbuflen *= 2;
-		tmpbuf = __alloca (tmpbuflen);
+		struct hostent *h = NULL;
+		int herrno;
+		struct hostent th;
+		size_t tmpbuflen = 512;
+		char *tmpbuf = NULL;
 
-		rc = __gethostbyaddr_r (at2->addr,
-					((at2->family == AF_INET6)
-					 ? sizeof(struct in6_addr)
-					 : sizeof(struct in_addr)),
-					at2->family, &th, tmpbuf, tmpbuflen,
-					&h, &herrno);
+		do
+		  {
+		    tmpbuf = extend_alloca (tmpbuf, tmpbuflen, tmpbuflen * 2);
+		    rc = __gethostbyaddr_r (at2->addr,
+					    ((at2->family == AF_INET6)
+					     ? sizeof (struct in6_addr)
+					     : sizeof (struct in_addr)),
+					    at2->family, &th, tmpbuf,
+					    tmpbuflen, &h, &herrno);
+		  }
+		while (rc == ERANGE && herrno == NETDB_INTERNAL);
 
-	      }
-	    while (rc == errno && herrno == NETDB_INTERNAL);
+		if (rc != 0 && herrno == NETDB_INTERNAL)
+		  {
+		    __set_h_errno (herrno);
+		    return -EAI_SYSTEM;
+		  }
 
-	    if (rc != 0 && herrno == NETDB_INTERNAL)
-	      {
-		__set_h_errno (herrno);
-		return -EAI_SYSTEM;
+		if (h != NULL)
+		  canon = h->h_name;
+		else
+		  {
+		    assert (orig_name != NULL);
+		    /* If the canonical name cannot be determined, use
+		       the passed in string.  */
+		    canon = orig_name;
+		  }
 	      }
 
-	    if (h != NULL)
-	      c = h->h_name;
-	    else
+#ifdef HAVE_LIBIDN
+	    if (req->ai_flags & AI_CANONIDN)
 	      {
-		/* We have to try to get the canonical in some other
-		   way.  If we are looking for either AF_INET or
-		   AF_INET6 try the other line.  */
-		if (req->ai_family == AF_UNSPEC)
+		int idn_flags = 0;
+		if (req->ai_flags & AI_IDN_ALLOW_UNASSIGNED)
+		  idn_flags |= IDNA_ALLOW_UNASSIGNED;
+		if (req->ai_flags & AI_IDN_USE_STD3_ASCII_RULES)
+		  idn_flags |= IDNA_USE_STD3_ASCII_RULES;
+
+		char *out;
+		int rc = __idna_to_unicode_lzlz (canon, &out, idn_flags);
+		if (rc != IDNA_SUCCESS)
 		  {
-		    struct addrinfo *p = NULL;
-		    struct addrinfo **end = &p;
-		    struct addrinfo localreq = *req;
-		    struct addrinfo *runp;
-
-		    localreq.ai_family = AF_INET + AF_INET6 - at2->family;
-		    (void) gaih_inet (name, service, &localreq, end);
-
-		    runp = p;
-		    while (runp != NULL)
-		      {
-			if (p->ai_canonname != name)
-			  {
-			    c = strdupa (p->ai_canonname);
-			    break;
-			  }
-			runp = runp->ai_next;
-		      }
-
-		    freeaddrinfo (p);
+		    if (rc == IDNA_MALLOC_ERROR)
+		      return -EAI_MEMORY;
+		    if (rc == IDNA_DLOPEN_ERROR)
+		      return -EAI_SYSTEM;
+		    return -EAI_IDN_ENCODE;
 		  }
-
-		/* If this code is used the missing canonical name is
-		   substituted with the name passed in by the user.  */
-		if (c == NULL)
-		  c = name;
+		/* In case the output string is the same as the input
+		   string no new string has been allocated.  Otherwise
+		   make a copy.  */
+		if (out == canon)
+		  goto make_copy;
+	      }
+	    else
+#endif
+	      {
+#ifdef HAVE_LIBIDN
+	      make_copy:
+#endif
+		canon = strdup (canon);
+		if (canon == NULL)
+		  return -EAI_MEMORY;
 	      }
-
-	    if (c == NULL)
-	      return GAIH_OKIFUNSPEC | -EAI_NONAME;
-
-	    namelen = strlen (c) + 1;
 	  }
-	else
-	  namelen = 0;
 
 	if (at2->family == AF_INET6)
 	  {
 	    family = AF_INET6;
 	    socklen = sizeof (struct sockaddr_in6);
+
+	    /* If we looked up IPv4 mapped address discard them here if
+	       the caller isn't interested in all address and we have
+	       found at least one IPv6 address.  */
+	    if (got_ipv6
+		&& (req->ai_flags & (AI_V4MAPPED|AI_ALL)) == AI_V4MAPPED
+		&& IN6_IS_ADDR_V4MAPPED (at2->addr))
+	      goto ignore;
 	  }
 	else
 	  {
@@ -654,55 +1060,53 @@
 
 	for (st2 = st; st2 != NULL; st2 = st2->next)
 	  {
-	    *pai = malloc (sizeof (struct addrinfo) + socklen + namelen);
-	    if (*pai == NULL)
+	    struct addrinfo *ai;
+	    ai = *pai = malloc (sizeof (struct addrinfo) + socklen);
+	    if (ai == NULL)
 	      return -EAI_MEMORY;
 
-	    (*pai)->ai_flags = req->ai_flags;
-	    (*pai)->ai_family = family;
-	    (*pai)->ai_socktype = st2->socktype;
-	    (*pai)->ai_protocol = st2->protocol;
-	    (*pai)->ai_addrlen = socklen;
-	    (*pai)->ai_addr = (void *) (*pai) + sizeof(struct addrinfo);
+	    ai->ai_flags = req->ai_flags;
+	    ai->ai_family = family;
+	    ai->ai_socktype = st2->socktype;
+	    ai->ai_protocol = st2->protocol;
+	    ai->ai_addrlen = socklen;
+	    ai->ai_addr = (void *) (ai + 1);
+
+	    /* We only add the canonical name once.  */
+	    ai->ai_canonname = (char *) canon;
+	    canon = NULL;
+
 #if SALEN
-	    (*pai)->ai_addr->sa_len = socklen;
+	    ai->ai_addr->sa_len = socklen;
 #endif /* SALEN */
-	    (*pai)->ai_addr->sa_family = family;
+	    ai->ai_addr->sa_family = family;
 
 	    if (family == AF_INET6)
 	      {
 		struct sockaddr_in6 *sin6p =
-		  (struct sockaddr_in6 *) (*pai)->ai_addr;
+		  (struct sockaddr_in6 *) ai->ai_addr;
 
+		sin6p->sin6_port = st2->port;
 		sin6p->sin6_flowinfo = 0;
 		memcpy (&sin6p->sin6_addr,
 			at2->addr, sizeof (struct in6_addr));
-		sin6p->sin6_port = st2->port;
 		sin6p->sin6_scope_id = at2->scopeid;
 	      }
 	    else
 	      {
 		struct sockaddr_in *sinp =
-		  (struct sockaddr_in *) (*pai)->ai_addr;
+		  (struct sockaddr_in *) ai->ai_addr;
+		sinp->sin_port = st2->port;
 		memcpy (&sinp->sin_addr,
 			at2->addr, sizeof (struct in_addr));
-		sinp->sin_port = st2->port;
 		memset (sinp->sin_zero, '\0', sizeof (sinp->sin_zero));
 	      }
 
-	    if (c)
-	      {
-		(*pai)->ai_canonname = ((void *) (*pai) +
-					sizeof (struct addrinfo) + socklen);
-		strcpy ((*pai)->ai_canonname, c);
-	      }
-	    else
-	      (*pai)->ai_canonname = NULL;
-
-	    (*pai)->ai_next = NULL;
-	    pai = &((*pai)->ai_next);
+	    pai = &(ai->ai_next);
 	  }
+	*pai = NULL;
 
+      ignore:
 	at2 = at2->next;
       }
   }
@@ -719,14 +1123,347 @@
     { PF_UNSPEC, NULL }
   };
 
+struct sort_result
+{
+  struct addrinfo *dest_addr;
+  struct sockaddr_storage source_addr;
+  uint8_t source_addr_len;
+  bool got_source_addr;
+};
+
+
+static int
+get_scope (const struct sockaddr_storage *ss)
+{
+  int scope;
+  if (ss->ss_family == PF_INET6)
+    {
+      const struct sockaddr_in6 *in6 = (const struct sockaddr_in6 *) ss;
+
+      if (! IN6_IS_ADDR_MULTICAST (&in6->sin6_addr))
+	{
+	  if (IN6_IS_ADDR_LINKLOCAL (&in6->sin6_addr))
+	    scope = 2;
+	  else if (IN6_IS_ADDR_SITELOCAL (&in6->sin6_addr))
+	    scope = 5;
+	  else
+	    /* XXX Is this the correct default behavior?  */
+	    scope = 14;
+	}
+      else
+	scope = in6->sin6_addr.s6_addr[1] & 0xf;
+    }
+  else if (ss->ss_family == PF_INET)
+    {
+      const struct sockaddr_in *in = (const struct sockaddr_in *) ss;
+      const uint8_t *addr = (const uint8_t *) &in->sin_addr;
+
+      /* RFC 3484 specifies how to map IPv6 addresses to scopes.
+	 169.254/16 and 127/8 are link-local.  */
+      if ((addr[0] == 169 && addr[1] == 254) || addr[0] == 127)
+	scope = 2;
+      else if (addr[0] == 10 || (addr[0] == 172 && addr[1] == 16)
+	       || (addr[0] == 192 && addr[1] == 168))
+	scope = 5;
+      else
+	scope = 14;
+    }
+  else
+    /* XXX What is a good default?  */
+    scope = 15;
+
+  return scope;
+}
+
+
+/* XXX The system administrator should be able to install other
+   tables.  We need to make this configurable.  The problem is that
+   the kernel is also involved since it needs the same table.  */
+static const struct prefixlist
+{
+  struct in6_addr prefix;
+  unsigned int bits;
+  int val;
+} default_labels[] =
+  {
+    /* See RFC 3484 for the details.  */
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0001 } } },
+      128, 0 },
+    { { .in6_u = { .u6_addr16 = { 0x2002, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      16, 2 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      96, 3 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0xffff, 0x0000, 0x0000 } } },
+      96, 4 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      0, 1 }
+  };
+
+
+static const struct prefixlist default_precedence[] =
+  {
+    /* See RFC 3484 for the details.  */
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0001 } } },
+      128, 50 },
+    { { .in6_u = { .u6_addr16 = { 0x2002, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      16, 30 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      96, 20 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0xffff, 0x0000, 0x0000 } } },
+      96, 10 },
+    { { .in6_u = { .u6_addr16 = { 0x0000, 0x0000, 0x0000, 0x0000,
+				  0x0000, 0x0000, 0x0000, 0x0000 } } },
+      0, 40 }
+  };
+
+
+static int
+match_prefix (const struct sockaddr_storage *ss, const struct prefixlist *list,
+	      int default_val)
+{
+  int idx;
+  struct sockaddr_in6 in6_mem;
+  const struct sockaddr_in6 *in6;
+
+  if (ss->ss_family == PF_INET6)
+    in6 = (const struct sockaddr_in6 *) ss;
+  else if (ss->ss_family == PF_INET)
+    {
+      const struct sockaddr_in *in = (const struct sockaddr_in *) ss;
+
+      /* Convert to IPv6 address.  */
+      in6_mem.sin6_family = PF_INET6;
+      in6_mem.sin6_port = in->sin_port;
+      in6_mem.sin6_flowinfo = 0;
+      if (in->sin_addr.s_addr == htonl (0x7f000001))
+	in6_mem.sin6_addr = (struct in6_addr) IN6ADDR_LOOPBACK_INIT;
+      else
+	{
+	  /* Construct a V4-to-6 mapped address.  */
+	  memset (&in6_mem.sin6_addr, '\0', sizeof (in6_mem.sin6_addr));
+	  in6_mem.sin6_addr.s6_addr16[5] = 0xffff;
+	  in6_mem.sin6_addr.s6_addr32[3] = in->sin_addr.s_addr;
+	  in6_mem.sin6_scope_id = 0;
+	}
+
+      in6 = &in6_mem;
+    }
+  else
+    return default_val;
+
+  for (idx = 0; ; ++idx)
+    {
+      unsigned int bits = list[idx].bits;
+      uint8_t *mask = list[idx].prefix.s6_addr;
+      uint8_t *val = in6->sin6_addr.s6_addr;
+
+      while (bits > 8)
+	{
+	  if (*mask != *val)
+	    break;
+
+	  ++mask;
+	  ++val;
+	  bits -= 8;
+	}
+
+      if (bits < 8)
+	{
+	  if ((*mask & (0xff00 >> bits)) == (*val & (0xff00 >> bits)))
+	    /* Match!  */
+	    break;
+	}
+    }
+
+  return list[idx].val;
+}
+
+
+static int
+get_label (const struct sockaddr_storage *ss)
+{
+  /* XXX What is a good default value?  */
+  return match_prefix (ss, default_labels, INT_MAX);
+}
+
+
+static int
+get_precedence (const struct sockaddr_storage *ss)
+{
+  /* XXX What is a good default value?  */
+  return match_prefix (ss, default_precedence, 0);
+}
+
+
+static int
+rfc3484_sort (const void *p1, const void *p2)
+{
+  const struct sort_result *a1 = (const struct sort_result *) p1;
+  const struct sort_result *a2 = (const struct sort_result *) p2;
+
+  /* Rule 1: Avoid unusable destinations.
+     We have the got_source_addr flag set if the destination is reachable.  */
+  if (a1->got_source_addr && ! a2->got_source_addr)
+    return -1;
+  if (! a1->got_source_addr && a2->got_source_addr)
+    return 1;
+
+
+  /* Rule 2: Prefer matching scope.  Only interesting if both
+     destination addresses are IPv6.  */
+  int a1_dst_scope
+    = get_scope ((struct sockaddr_storage *) a1->dest_addr->ai_addr);
+
+  int a2_dst_scope
+    = get_scope ((struct sockaddr_storage *) a2->dest_addr->ai_addr);
+
+  if (a1->got_source_addr)
+    {
+      int a1_src_scope = get_scope (&a1->source_addr);
+      int a2_src_scope = get_scope (&a2->source_addr);
+
+      if (a1_dst_scope == a1_src_scope && a2_dst_scope != a2_src_scope)
+	return -1;
+      if (a1_dst_scope != a1_src_scope && a2_dst_scope == a2_src_scope)
+	return 1;
+    }
+
+
+  /* Rule 3: Avoid deprecated addresses.
+     That's something only the kernel could decide.  */
+
+  /* Rule 4: Prefer home addresses.
+     Another thing only the kernel can decide.  */
+
+  /* Rule 5: Prefer matching label.  */
+  if (a1->got_source_addr)
+    {
+      int a1_dst_label
+	= get_label ((struct sockaddr_storage *) a1->dest_addr->ai_addr);
+      int a1_src_label = get_label (&a1->source_addr);
+
+      int a2_dst_label
+	= get_label ((struct sockaddr_storage *) a2->dest_addr->ai_addr);
+      int a2_src_label = get_label (&a2->source_addr);
+
+      if (a1_dst_label == a1_src_label && a2_dst_label != a2_src_label)
+	return -1;
+      if (a1_dst_label != a1_src_label && a2_dst_label == a2_src_label)
+	return 1;
+    }
+
+
+  /* Rule 6: Prefer higher precedence.  */
+  int a1_prec
+    = get_precedence ((struct sockaddr_storage *) a1->dest_addr->ai_addr);
+  int a2_prec
+    = get_precedence ((struct sockaddr_storage *) a2->dest_addr->ai_addr);
+
+  if (a1_prec > a2_prec)
+    return -1;
+  if (a1_prec < a2_prec)
+    return 1;
+
+
+  /* Rule 7: Prefer native transport.
+     XXX How to recognize tunnels?  */
+
+
+  /* Rule 8: Prefer smaller scope.  */
+  if (a1_dst_scope < a2_dst_scope)
+    return -1;
+  if (a1_dst_scope > a2_dst_scope)
+    return 1;
+
+
+  /* Rule 9: Use longest matching prefix.  */
+  if (a1->got_source_addr
+      && a1->dest_addr->ai_family == a2->dest_addr->ai_family)
+    {
+      int bit1 = 0;
+      int bit2 = 0;
+
+      if (a1->dest_addr->ai_family == PF_INET)
+	{
+	  assert (a1->source_addr.ss_family == PF_INET);
+	  assert (a2->source_addr.ss_family == PF_INET);
+
+	  struct sockaddr_in *in1_dst;
+	  struct sockaddr_in *in1_src;
+	  struct sockaddr_in *in2_dst;
+	  struct sockaddr_in *in2_src;
+
+	  in1_dst = (struct sockaddr_in *) a1->dest_addr->ai_addr;
+	  in1_src = (struct sockaddr_in *) &a1->source_addr;
+	  in2_dst = (struct sockaddr_in *) a2->dest_addr->ai_addr;
+	  in2_src = (struct sockaddr_in *) &a2->source_addr;
+
+	  bit1 = ffs (in1_dst->sin_addr.s_addr ^ in1_src->sin_addr.s_addr);
+	  bit2 = ffs (in2_dst->sin_addr.s_addr ^ in2_src->sin_addr.s_addr);
+	}
+      else if (a1->dest_addr->ai_family == PF_INET6)
+	{
+	  assert (a1->source_addr.ss_family == PF_INET6);
+	  assert (a2->source_addr.ss_family == PF_INET6);
+
+	  struct sockaddr_in6 *in1_dst;
+	  struct sockaddr_in6 *in1_src;
+	  struct sockaddr_in6 *in2_dst;
+	  struct sockaddr_in6 *in2_src;
+
+	  in1_dst = (struct sockaddr_in6 *) a1->dest_addr->ai_addr;
+	  in1_src = (struct sockaddr_in6 *) &a1->source_addr;
+	  in2_dst = (struct sockaddr_in6 *) a2->dest_addr->ai_addr;
+	  in2_src = (struct sockaddr_in6 *) &a2->source_addr;
+
+	  int i;
+	  for (i = 0; i < 4; ++i)
+	    if (in1_dst->sin6_addr.s6_addr32[i]
+		!= in1_src->sin6_addr.s6_addr32[i]
+		|| (in2_dst->sin6_addr.s6_addr32[i]
+		    != in2_src->sin6_addr.s6_addr32[i]))
+	      break;
+
+	  if (i < 4)
+	    {
+	      bit1 = ffs (in1_dst->sin6_addr.s6_addr32[i]
+			  ^ in1_src->sin6_addr.s6_addr32[i]);
+	      bit2 = ffs (in2_dst->sin6_addr.s6_addr32[i]
+			  ^ in2_src->sin6_addr.s6_addr32[i]);
+	    }
+	}
+
+      if (bit1 > bit2)
+	return -1;
+      if (bit1 < bit2)
+	return 1;
+    }
+
+
+  /* Rule 10: Otherwise, leave the order unchanged.  */
+  return 0;
+}
+
+
 int
 getaddrinfo (const char *name, const char *service,
 	     const struct addrinfo *hints, struct addrinfo **pai)
 {
   int i = 0, j = 0, last_i = 0;
+  int nresults = 0;
   struct addrinfo *p = NULL, **end;
   struct gaih *g = gaih, *pg = NULL;
   struct gaih_service gaih_service, *pservice;
+  struct addrinfo local_hints;
 
   if (name != NULL && name[0] == '*' && name[1] == 0)
     name = NULL;
@@ -740,24 +1477,58 @@
   if (hints == NULL)
     hints = &default_hints;
 
-  if (hints->ai_flags & ~(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST))
+  if (hints->ai_flags
+      & ~(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST|AI_ADDRCONFIG|AI_V4MAPPED
+#ifdef HAVE_LIBIDN
+	  |AI_IDN|AI_CANONIDN|AI_IDN_ALLOW_UNASSIGNED
+	  |AI_IDN_USE_STD3_ASCII_RULES
+#endif
+	  |AI_NUMERICSERV|AI_ALL))
     return EAI_BADFLAGS;
 
   if ((hints->ai_flags & AI_CANONNAME) && name == NULL)
     return EAI_BADFLAGS;
 
+  if (hints->ai_flags & AI_ADDRCONFIG)
+    {
+      /* Determine whether we have IPv4 or IPv6 interfaces or both.
+	 We cannot cache the results since new interfaces could be
+	 added at any time.  */
+      bool seen_ipv4;
+      bool seen_ipv6;
+      __check_pf (&seen_ipv4, &seen_ipv6);
+
+      /* Now make a decision on what we return, if anything.  */
+      if (hints->ai_family == PF_UNSPEC && (seen_ipv4 || seen_ipv6))
+	{
+	  /* If we haven't seen both IPv4 and IPv6 interfaces we can
+	     narrow down the search.  */
+	  if (! seen_ipv4 || ! seen_ipv6)
+	    {
+	      local_hints = *hints;
+	      local_hints.ai_family = seen_ipv4 ? PF_INET : PF_INET6;
+	      hints = &local_hints;
+	    }
+	}
+      else if ((hints->ai_family == PF_INET && ! seen_ipv4)
+	       || (hints->ai_family == PF_INET6 && ! seen_ipv6))
+	/* We cannot possibly return a valid answer.  */
+	return EAI_NONAME;
+    }
+
   if (service && service[0])
     {
       char *c;
       gaih_service.name = service;
       gaih_service.num = strtoul (gaih_service.name, &c, 10);
-      if (*c)
-	gaih_service.num = -1;
-      else
-	/* Can't specify a numerical socket unless a protocol family was
-	   given. */
-        if (hints->ai_socktype == 0 && hints->ai_protocol == 0)
-          return EAI_SERVICE;
+      if (*c != '\0')
+	{
+	  if (hints->ai_flags & AI_NUMERICSERV)
+	    return EAI_NONAME;
+
+	  gaih_service.num = -1;
+	}
+
       pservice = &gaih_service;
     }
   else
@@ -795,7 +1566,11 @@
 		  return -(i & GAIH_EAI);
 		}
 	      if (end)
-		while(*end) end = &((*end)->ai_next);
+		while (*end)
+		  {
+		    end = &((*end)->ai_next);
+		    ++nresults;
+		  }
 	    }
 	}
       ++g;
@@ -804,6 +1579,78 @@
   if (j == 0)
     return EAI_FAMILY;
 
+  if (nresults > 1)
+    {
+      /* Sort results according to RFC 3484.  */
+      struct sort_result results[nresults];
+      struct addrinfo *q;
+      struct addrinfo *last = NULL;
+      char *canonname = NULL;
+
+      for (i = 0, q = p; q != NULL; ++i, last = q, q = q->ai_next)
+	{
+	  results[i].dest_addr = q;
+	  results[i].got_source_addr = false;
+
+	  /* If we just looked up the address for a different
+	     protocol, reuse the result.  */
+	  if (last != NULL && last->ai_addrlen == q->ai_addrlen
+	      && memcmp (last->ai_addr, q->ai_addr, q->ai_addrlen) == 0)
+	    {
+	      memcpy (&results[i].source_addr, &results[i - 1].source_addr,
+		      results[i - 1].source_addr_len);
+	      results[i].source_addr_len = results[i - 1].source_addr_len;
+	      results[i].got_source_addr = results[i - 1].got_source_addr;
+	    }
+	  else
+	    {
+	      /* We overwrite the type with SOCK_DGRAM since we do not
+		 want connect() to connect to the other side.  If we
+		 cannot determine the source address remember this
+		 fact.  */
+	      int fd = __socket (q->ai_family, SOCK_DGRAM, IPPROTO_IP);
+	      socklen_t sl = sizeof (results[i].source_addr);
+	      if (fd != -1
+		  && __connect (fd, q->ai_addr, q->ai_addrlen) == 0
+		  && __getsockname (fd,
+				    (struct sockaddr *) &results[i].source_addr,
+				    &sl) == 0)
+		{
+		  results[i].source_addr_len = sl;
+		  results[i].got_source_addr = true;
+		}
+	      else
+		/* Just make sure that if we have to process the same
+		   address again we do not copy any memory.  */
+		results[i].source_addr_len = 0;
+
+	      if (fd != -1)
+		close_not_cancel_no_status (fd);
+	    }
+
+	  /* Remember the canonical name.  */
+	  if (q->ai_canonname != NULL)
+	    {
+	      assert (canonname == NULL);
+	      canonname = q->ai_canonname;
+	      q->ai_canonname = NULL;
+	    }
+	}
+
+      /* We got all the source addresses we can get, now sort using
+	 the information.  */
+      qsort (results, nresults, sizeof (results[0]), rfc3484_sort);
+
+      /* Queue the results up as they come out of sorting.  */
+      q = p = results[0].dest_addr;
+      for (i = 1; i < nresults; ++i)
+	q = q->ai_next = results[i].dest_addr;
+      q->ai_next = NULL;
+
+      /* Fill in the canonical name into the new first entry.  */
+      p->ai_canonname = canonname;
+    }
+
   if (p)
     {
       *pai = p;
@@ -813,12 +1660,12 @@
   if (pai == NULL && last_i == 0)
     return 0;
 
-  freeaddrinfo (p);
-
   return last_i ? -(last_i & GAIH_EAI) : EAI_NONAME;
 }
 libc_hidden_def (getaddrinfo)
 
+static_link_warning (getaddrinfo)
+
 void
 freeaddrinfo (struct addrinfo *ai)
 {
@@ -828,6 +1675,7 @@
     {
       p = ai;
       ai = ai->ai_next;
+      free (p->ai_canonname);
       free (p);
     }
 }
diff -Nur sysdeps/posix/libc_fatal.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/libc_fatal.c
--- sysdeps/posix/libc_fatal.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/libc_fatal.c	2004-11-17 10:09:28.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1994, 1995, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1993,1994,1995,1997,2000,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,43 +16,134 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <stdarg.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sysdep.h>
 #include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/syslog.h>
+#include <sys/uio.h>
+#include <not-cancel.h>
 
 #ifdef FATAL_PREPARE_INCLUDE
 #include FATAL_PREPARE_INCLUDE
 #endif
 
+struct str_list
+{
+  const char *str;
+  size_t len;
+  struct str_list *next;
+};
+
+
 /* Abort with an error message.  */
 void
-__libc_fatal (message)
-     const char *message;
+__libc_message (int do_abort, const char *fmt, ...)
 {
-  size_t len = strlen (message);
+  va_list ap;
+  va_list ap_copy;
+  int fd = -1;
+
+  va_start (ap, fmt);
+  va_copy (ap_copy, ap);
 
 #ifdef FATAL_PREPARE
   FATAL_PREPARE;
 #endif
 
-  while (len > 0)
+  /* Open a descriptor for /dev/tty unless the user explicitly
+     requests errors on standard error.  */
+  const char *on_2 = __secure_getenv ("LIBC_FATAL_STDERR_");
+  if (on_2 == NULL || *on_2 == '\0')
+    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);
+
+  if (fd == -1)
+    fd = STDERR_FILENO;
+
+  struct str_list *list = NULL;
+  int nlist = 0;
+
+  const char *cp = fmt;
+  while (*cp != '\0')
     {
-      register int count = __write (STDERR_FILENO, message, len);
-      if (count > 0)
+      /* Find the next "%s" or the end of the string.  */
+      char *next = cp;
+      while (next[0] != '%' || next[1] != 's')
 	{
-	  message += count;
-	  len -= count;
+	  next = __strchrnul (next + 1, '%');
+
+	  if (next[0] == '\0')
+	    break;
 	}
-      else if (count < 0
-#ifdef EINTR
-	       && errno != EINTR
-#endif
-	       )
-	break;
+
+      /* Determine what to print.  */
+      const char *str;
+      size_t len;
+      if (cp[0] == '%' && cp[1] == 's')
+	{
+	  str = va_arg (ap, const char *);
+	  len = strlen (str);
+	  cp += 2;
+	}
+      else
+	{
+	  str = cp;
+	  len = next - cp;
+	  cp = next;
+	}
+
+      struct str_list *newp = alloca (sizeof (struct str_list));
+      newp->str = str;
+      newp->len = len;
+      newp->next = list;
+      list = newp;
+      ++nlist;
+    }
+
+  bool written = false;
+  if (nlist > 0)
+    {
+      struct iovec *iov = alloca (nlist * sizeof (struct iovec));
+      ssize_t total = 0;
+
+      for (int cnt = nlist - 1; cnt >= 0; --cnt)
+	{
+	  iov[cnt].iov_base = list->str;
+	  iov[cnt].iov_len = list->len;
+	  total += list->len;
+	  list = list->next;
+	}
+
+      if (TEMP_FAILURE_RETRY (__writev (fd, iov, nlist)) == total)
+	written = true;
     }
 
-  abort ();
+  va_end (ap);
+
+  /* If we  had no success writing the message, use syslog.  */
+  if (! written)
+    vsyslog (LOG_ERR, fmt, ap_copy);
+
+  va_end (ap_copy);
+
+  if (do_abort)
+    /* Kill the application.  */
+    abort ();
+}
+
+
+void
+__libc_fatal (message)
+     const char *message;
+{
+  /* The loop is added only to keep gcc happy.  */
+  while (1)
+    __libc_message (1, "%s", message);
 }
+libc_hidden_def (__libc_fatal)
diff -Nur sysdeps/posix/open64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/open64.c
--- sysdeps/posix/open64.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/open64.c	2002-12-15 11:25:22.000000000 +0100
@@ -19,6 +19,7 @@
 #include <fcntl.h>
 #include <stdarg.h>
 #include <bp-sym.h>
+#include <sysdep-cancel.h>
 
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
@@ -35,7 +36,16 @@
       va_end (arg);
     }
 
-  return __libc_open (file, oflag | O_LARGEFILE, mode);
+  if (SINGLE_THREAD_P)
+    return __libc_open (file, oflag | O_LARGEFILE, mode);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __libc_open (file, oflag | O_LARGEFILE, mode);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 weak_alias (__libc_open64, BP_SYM (__open64))
 libc_hidden_weak (BP_SYM (__open64))
diff -Nur sysdeps/posix/pathconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/pathconf.c
--- sysdeps/posix/pathconf.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/pathconf.c	2003-03-14 07:22:16.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,1995,1996,1998,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1998,2000,2001,2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -225,6 +226,10 @@
       /* In general there are no limits.  If a system has one it should
 	 overwrite this case.  */
       return -1;
+
+    case _PC_2_SYMLINKS:
+      /* Unix systems generally have symlinks.  */
+      return 1;
     }
 }
 
diff -Nur sysdeps/posix/pause.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/pause.c
--- sysdeps/posix/pause.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/pause.c	2003-02-24 23:35:53.000000000 +0100
@@ -0,0 +1,41 @@
+/* pause -- suspend the process until a signal arrives.  POSIX.1 version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <signal.h>
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+/* Suspend the process until a signal arrives.
+   This always returns -1 and sets errno to EINTR.  */
+int
+__libc_pause (void)
+{
+  sigset_t set;
+
+  __sigemptyset (&set);
+  __sigprocmask (SIG_BLOCK, NULL, &set);
+
+  /* pause is a cancellation point, but so is sigsuspend.
+     So no need for anything special here.  */
+
+  return __sigsuspend (&set);
+}
+weak_alias (__libc_pause, pause)
+
+LIBC_CANCEL_HANDLED ();		/* sigsuspend handles our cancellation.  */
diff -Nur sysdeps/posix/posix_fallocate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/posix_fallocate64.c
--- sysdeps/posix/posix_fallocate64.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/posix_fallocate64.c	2004-03-10 10:28:25.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,7 +25,7 @@
 /* Reserve storage for the data of the file associated with FD.  */
 
 int
-posix_fallocate64 (int fd, __off64_t offset, size_t len)
+__posix_fallocate64_l64 (int fd, __off64_t offset, __off64_t len)
 {
   struct stat64 st;
   struct statfs64 f;
@@ -33,7 +33,7 @@
 
   /* `off64_t is a signed type.  Therefore we can determine whether
      OFFSET + LEN is too large if it is a negative value.  */
-  if (offset < 0 || len == 0)
+  if (offset < 0 || len < 0)
     return EINVAL;
   if (offset + len < 0)
     return EFBIG;
@@ -69,3 +69,22 @@
 
   return 0;
 }
+
+#include <shlib-compat.h>
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 32 && SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fallocate64_l32 (int fd, off64_t offset, size_t len)
+{
+  return __posix_fallocate64_l64 (fd, offset, len);
+}
+
+versioned_symbol (libc, __posix_fallocate64_l64, posix_fallocate64,
+		  GLIBC_2_3_3);
+compat_symbol (libc, __posix_fallocate64_l32, posix_fallocate64, GLIBC_2_2);
+#else
+strong_alias (__posix_fallocate64_l64, posix_fallocate64);
+#endif
diff -Nur sysdeps/posix/posix_fallocate.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/posix_fallocate.c
--- sysdeps/posix/posix_fallocate.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/posix_fallocate.c	2003-08-22 20:08:29.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,7 +25,7 @@
 /* Reserve storage for the data of the file associated with FD.  */
 
 int
-posix_fallocate (int fd, __off_t offset, size_t len)
+posix_fallocate (int fd, __off_t offset, __off_t len)
 {
   struct stat64 st;
   struct statfs f;
@@ -33,7 +33,7 @@
 
   /* `off_t is a signed type.  Therefore we can determine whether
      OFFSET + LEN is too large if it is a negative value.  */
-  if (offset < 0 || len == 0)
+  if (offset < 0 || len < 0)
     return EINVAL;
   if (offset + len < 0)
     return EFBIG;
diff -Nur sysdeps/posix/profil.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/profil.c
--- sysdeps/posix/profil.c	2002-08-04 04:20:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/profil.c	2004-07-06 06:17:14.000000000 +0200
@@ -1,5 +1,5 @@
 /* Low-level statistical profiling support function.  Mostly POSIX.1 version.
-   Copyright (C) 1996,97,98,2002 Free Software Foundation, Inc.
+   Copyright (C) 1996,97,98,2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -62,10 +62,13 @@
 int
 __profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
 {
-  static struct sigaction oact;
-  static struct itimerval otimer;
   struct sigaction act;
   struct itimerval timer;
+#ifndef IS_IN_rtld
+  static struct sigaction oact;
+  static struct itimerval otimer;
+# define oact_ptr &oact
+# define otimer_ptr &otimer
 
   if (sample_buffer == NULL)
     {
@@ -88,6 +91,12 @@
 	  || __sigaction (SIGPROF, &oact, NULL) < 0)
 	return -1;
     }
+#else
+ /* In ld.so profiling should never be disabled once it runs.  */
+ //assert (sample_buffer != NULL);
+# define oact_ptr NULL
+# define otimer_ptr NULL
+#endif
 
   samples = sample_buffer;
   nsamples = size / sizeof *samples;
@@ -97,13 +106,13 @@
   act.sa_handler = (sighandler_t) &profil_counter;
   act.sa_flags = SA_RESTART;
   __sigfillset (&act.sa_mask);
-  if (__sigaction (SIGPROF, &act, &oact) < 0)
+  if (__sigaction (SIGPROF, &act, oact_ptr) < 0)
     return -1;
 
   timer.it_value.tv_sec = 0;
   timer.it_value.tv_usec = 1;
   timer.it_interval = timer.it_value;
-  return __setitimer (ITIMER_PROF, &timer, &otimer);
+  return __setitimer (ITIMER_PROF, &timer, otimer_ptr);
 }
 weak_alias (__profil, profil)
 
diff -Nur sysdeps/posix/raise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/raise.c
--- sysdeps/posix/raise.c	2002-08-12 02:17:47.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/raise.c	2002-12-07 04:45:55.000000000 +0100
@@ -26,4 +26,5 @@
 {
   return __kill (__getpid (), sig);
 }
+libc_hidden_def (raise)
 weak_alias (raise, gsignal)
diff -Nur sysdeps/posix/readv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/readv.c
--- sysdeps/posix/readv.c	2002-08-26 23:16:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/readv.c	2002-11-25 00:56:43.000000000 +0100
@@ -23,6 +23,7 @@
 #include <stdbool.h>
 #include <sys/param.h>
 #include <sys/uio.h>
+#include <errno.h>
 
 /* Read data from file descriptor FD, and put the result in the
    buffers described by VECTOR, which is a vector of COUNT `struct iovec's.
@@ -30,7 +31,7 @@
    Operates just like `read' (see <unistd.h>) except that data are
    put in VECTOR instead of a contiguous buffer.  */
 ssize_t
-__readv (int fd, const struct iovec *vector, int count)
+__libc_readv (int fd, const struct iovec *vector, int count)
 {
   char *buffer;
   char *buffer_start;
@@ -46,7 +47,7 @@
       /* Check for ssize_t overflow.  */
       if (SSIZE_MAX - bytes < vector[i].iov_len)
 	{
-	  errno = EINVAL;
+	  __set_errno (EINVAL);
 	  return -1;
 	}
       bytes += vector[i].iov_len;
@@ -55,8 +56,8 @@
   /* Allocate a temporary buffer to hold the data.  We should normally
      use alloca since it's faster and does not require synchronization
      with other threads.  But we cannot if the amount of memory
-     required is too large.  Use 512k as the limit.  */
-  if (bytes < 512 * 1024)
+     required is too large.  */
+  if (__libc_use_alloca (bytes))
     buffer = (char *) __alloca (bytes);
   else
     {
@@ -94,6 +95,7 @@
 
   return bytes_read;
 }
-#ifndef __readv
-weak_alias (__readv, readv)
+#ifndef __libc_readv
+strong_alias (__libc_readv, __readv)
+weak_alias (__libc_readv, readv)
 #endif
diff -Nur sysdeps/posix/remove.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/remove.c
--- sysdeps/posix/remove.c	2002-08-10 20:09:09.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/remove.c	2003-04-19 09:52:13.000000000 +0200
@@ -1,5 +1,5 @@
 /* ANSI C `remove' function to delete a file or directory.  POSIX.1 version.
-   Copyright (C) 1995,96,97,2002 Free Software Foundation, Inc.
+   Copyright (C) 1995,96,97,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,17 +25,15 @@
 remove (file)
      const char *file;
 {
-  int save;
+  /* First try to unlink since this is more frequently the necessary action. */
+  if (__unlink (file) != 0
+      /* If it is indeed a directory...  */
+      && (errno != EISDIR
+	  /* ...try to remove it.  */
+	  || __rmdir (file) != 0))
+    /* Cannot remove the object for whatever reason.  */
+    return -1;
 
-  save = errno;
-  if (__rmdir (file) == 0)
-    return 0;
-  else if (errno == ENOTDIR && __unlink (file) == 0)
-    {
-      __set_errno (save);
-      return 0;
-    }
-
-  return -1;
+  return 0;
 }
 libc_hidden_def (remove)
diff -Nur sysdeps/posix/sigpause.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigpause.c
--- sysdeps/posix/sigpause.c	2002-08-27 06:52:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigpause.c	2004-05-10 06:48:48.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,92,94-98,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,94-98,2000,2002,2003,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,16 +17,19 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#define sigpause __rename_sigpause
 #include <errno.h>
 #include <signal.h>
 #include <stddef.h>		/* For NULL.  */
+#include <sysdep-cancel.h>
+#undef sigpause
 
 #include <sigset-cvt-mask.h>
 
 /* Set the mask of blocked signals to MASK,
    wait for a signal to arrive, and then restore the mask.  */
-int
-__sigpause (int sig_or_mask, int is_sig)
+static int
+do_sigpause (int sig_or_mask, int is_sig)
 {
   sigset_t set;
 
@@ -33,34 +37,55 @@
     {
       /* The modern X/Open implementation is requested.  */
       if (__sigprocmask (0, NULL, &set) < 0
-	  /* Yes, we call `sigdelset' and not `__sigdelset'.  */
-	  || __sigdelset (&set, sig_or_mask) < 0)
+	  || sigdelset (&set, sig_or_mask) < 0)
 	return -1;
     }
   else if (sigset_set_old_mask (&set, sig_or_mask) < 0)
     return -1;
 
+  /* Note the sigpause() is a cancellation point.  But since we call
+     sigsuspend() which itself is a cancellation point we do not have
+     to do anything here.  */
   return __sigsuspend (&set);
 }
+
+int
+__sigpause (int sig_or_mask, int is_sig)
+{
+  if (SINGLE_THREAD_P)
+    return do_sigpause (sig_or_mask, is_sig);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigpause (sig_or_mask, is_sig);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
 libc_hidden_def (__sigpause)
 
 /* We have to provide a default version of this function since the
    standards demand it.  The version which is a bit more reasonable is
    the BSD version.  So make this the default.  */
 int
+__attribute__ ((weak))
 __default_sigpause (int mask)
 {
   return __sigpause (mask, 0);
 }
 #undef sigpause
 weak_alias (__default_sigpause, sigpause)
+strong_alias (__default_sigpause, __libc_sigpause)
 
 
 /* We have to provide a default version of this function since the
    standards demand it.  The version which is a bit more reasonable is
    the BSD version.  So make this the default.  */
 int
+__attribute__ ((weak))
 __xpg_sigpause (int sig)
 {
   return __sigpause (sig, 1);
 }
+strong_alias (__xpg_sigpause, __libc___xpg_sigpause)
diff -Nur sysdeps/posix/sigvec.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigvec.c
--- sysdeps/posix/sigvec.c	2002-08-27 06:52:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigvec.c	2004-09-14 06:24:48.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,92,94,95,96,97,98,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,1994-98,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,16 +23,19 @@
 /* Include macros to convert between `sigset_t' and old-style mask. */
 #include <sigset-cvt-mask.h>
 
-/* We use a wrapper handler to support SV_RESETHAND.  */
+#ifndef SA_RESETHAND
+/* When sigaction lacks the extension bit for it,
+   we use a wrapper handler to support SV_RESETHAND.  */
 struct sigvec_wrapper_data
 {
   __sighandler_t sw_handler;
   unsigned int sw_mask;
 };
 
-static void sigvec_wrapper_handler __P ((int sig));
+static void sigvec_wrapper_handler (int sig) __THROW;
 
 static struct sigvec_wrapper_data sigvec_wrapper_data[NSIG];
+#endif
 
 
 /* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
@@ -48,7 +51,9 @@
 {
   struct sigaction old;
 
+#ifndef SA_RESETHAND
   if (vec == NULL || !(vec->sv_flags & SV_RESETHAND))
+#endif
     {
       struct sigaction new, *n;
 
@@ -78,6 +83,10 @@
 	  if (!(sv_flags & SV_INTERRUPT))
 	    sa_flags |= SA_RESTART;
 #endif
+#ifdef SA_RESETHAND
+	  if (sv_flags & SV_RESETHAND)
+	    sa_flags |= SA_RESETHAND;
+#endif
 	  n = &new;
 	  new.sa_handler = handler;
 	  if (sigset_set_old_mask (&new.sa_mask, mask) < 0)
@@ -88,6 +97,7 @@
       if (__sigaction (sig, n, &old) < 0)
 	return -1;
     }
+#ifndef SA_RESETHAND
   else
     {
       __sighandler_t handler;
@@ -106,6 +116,7 @@
       if (__sigaction (sig, &wrapper, &old) < 0)
 	return -1;
     }
+#endif
 
   if (ovec != NULL)
     {
@@ -117,12 +128,17 @@
       handler = old.sa_handler;
       sv_flags = 0;
       sa_flags = old.sa_flags;
+#ifndef SA_RESETHAND
       if (handler == sigvec_wrapper_handler)
 	{
 	  handler = sigvec_wrapper_data[sig].sw_handler;
 	  /* should we use data->sw_mask?? */
 	  sv_flags |= SV_RESETHAND;
 	}
+#else
+     if (sa_flags & SA_RESETHAND)
+	sv_flags |= SV_RESETHAND;
+#endif
       mask = sigset_get_old_mask (&old.sa_mask);
 #ifdef SA_ONSTACK
      if (sa_flags & SA_ONSTACK)
@@ -142,7 +158,7 @@
 
 weak_alias (__sigvec, sigvec)
 
-
+#ifndef SA_RESETHAND
 static void
 sigvec_wrapper_handler (sig)
      int sig;
@@ -163,3 +179,4 @@
 
   (*handler) (sig);
 }
+#endif
diff -Nur sysdeps/posix/sigwait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigwait.c
--- sysdeps/posix/sigwait.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sigwait.c	2002-12-15 11:25:22.000000000 +0100
@@ -1,5 +1,5 @@
 /* Implementation of sigwait function from POSIX.1c.
-   Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <signal.h>
 #include <stddef.h>		/* For NULL.  */
+#include <sysdep-cancel.h>
 
 /* This is our dummy signal handler we use here.  */
 static void ignore_signal (int sig);
@@ -31,8 +32,8 @@
 static int was_sig;
 
 
-int
-__sigwait (const sigset_t *set, int *sig)
+static int
+do_sigwait (const sigset_t *set, int *sig)
 {
   sigset_t tmp_mask;
   struct sigaction saved[NSIG];
@@ -80,6 +81,23 @@
   *sig = was_sig;
   return was_sig == -1 ? -1 : 0;
 }
+
+
+int
+__sigwait (const sigset_t *set, int *sig)
+{
+  if (SINGLE_THREAD_P)
+    return do_sigwait (set, sig);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigwait (set, sig);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__sigwait)
 weak_alias (__sigwait, sigwait)
 
 
diff -Nur sysdeps/posix/spawni.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/spawni.c
--- sysdeps/posix/spawni.c	2002-08-04 04:20:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/spawni.c	2004-09-12 20:05:00.000000000 +0200
@@ -1,5 +1,5 @@
 /* Guts of POSIX spawn interface.  Generic POSIX.1 version.
-   Copyright (C) 2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <unistd.h>
 #include "spawn_int.h"
+#include <not-cancel.h>
 
 
 /* The Unix standard contains a long explanation of the way to signal
@@ -75,10 +76,16 @@
   char *path, *p, *name;
   size_t len;
   size_t pathlen;
-  short int flags;
+
+  /* Do this once.  */
+  short int flags = attrp == NULL ? 0 : attrp->__flags;
 
   /* Generate the new process.  */
-  new_pid = __fork ();
+  if (flags & POSIX_SPAWN_USEVFORK)
+    new_pid = __vfork ();
+  else
+    new_pid = __fork ();
+
   if (new_pid != 0)
     {
       if (new_pid < 0)
@@ -91,9 +98,6 @@
       return 0;
     }
 
-  /* Do this once.  */
-  flags = attrp == NULL ? 0 : attrp->__flags;
-
   /* Set signal mask.  */
   if ((flags & POSIX_SPAWN_SETSIGMASK) != 0
       && __sigprocmask (SIG_SETMASK, &attrp->__ss, NULL) != 0)
@@ -158,7 +162,7 @@
 	  switch (action->tag)
 	    {
 	    case spawn_do_close:
-	      if (__close (action->action.close_action.fd) != 0)
+	      if (close_not_cancel (action->action.close_action.fd) != 0)
 		/* Signal the error.  */
 		_exit (SPAWN_ERROR);
 	      break;
diff -Nur sysdeps/posix/sprofil.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sprofil.c
--- sysdeps/posix/sprofil.c	2002-09-24 07:12:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sprofil.c	2003-09-23 09:23:31.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001,02 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    Contributed by David Mosberger-Tang <davidm@hpl.hp.com>.
    This file is part of the GNU C Library.
 
@@ -61,17 +61,17 @@
 
 static struct region default_overflow_region =
   {
-    offset:	0,
-    nsamples:	1,
-    scale:	2,
-    sample:	{ &overflow_counter },
-    start:	0,
-    end:	~(size_t) 0
+    .offset	= 0,
+    .nsamples	= 1,
+    .scale	= 2,
+    .sample	= { &overflow_counter },
+    .start	= 0,
+    .end	= ~(size_t) 0
   };
 
 static struct prof_info prof_info;
 
-static inline unsigned long int
+static unsigned long int
 pc_to_index (size_t pc, size_t offset, unsigned int scale, int prof_uint)
 {
   size_t i = (pc - offset) / (prof_uint ? sizeof (int) : sizeof (short));
@@ -104,7 +104,7 @@
   return pc;
 }
 
-static inline void
+static void
 profil_count (void *pcp, int prof_uint)
 {
   struct region *region, *r = prof_info.last;
diff -Nur sysdeps/posix/sysconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sysconf.c
--- sysdeps/posix/sysconf.c	2002-08-04 09:29:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/sysconf.c	2004-12-14 16:39:14.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,93,1995-1997,1999-2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1993,1995-1997,1999-2003,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,14 +23,27 @@
 #include <pwd.h>
 #include <stddef.h>
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <time.h>
 #include <unistd.h>
 #include <sys/param.h>
+#include <sys/stat.h>
 #include <sys/sysinfo.h>
 #include <sys/types.h>
 #include <regex.h>
 
 
+#define NEED_CHECK_SPEC \
+  (!defined _XBS5_ILP32_OFF32 || !defined _XBS5_ILP32_OFFBIG \
+   || !defined _XBS5_LP64_OFF64 || !defined _XBS5_LPBIG_OFFBIG \
+   || !defined _POSIX_V6_ILP32_OFF32 || !defined _POSIX_V6_ILP32_OFFBIG \
+   || !defined _POSIX_V6_LP64_OFF64 || !defined _POSIX_V6_LPBIG_OFFBIG)
+#if NEED_CHECK_SPEC
+static long int __sysconf_check_spec (const char *spec);
+#endif
+
+
 /* Get the value of the system variable NAME.  */
 long int
 __sysconf (name)
@@ -37,6 +51,8 @@
 {
   switch (name)
     {
+      /* Also add obsolete or unnecessarily added constants here.  */
+    case _SC_EQUIV_CLASS_MAX:
     default:
       __set_errno (EINVAL);
       return -1;
@@ -94,98 +110,98 @@
 
     case _SC_REALTIME_SIGNALS:
 #ifdef	_POSIX_REALTIME_SIGNALS
-      return 1;
+      return _POSIX_REALTIME_SIGNALS;
 #else
       return -1;
 #endif
 
     case _SC_PRIORITY_SCHEDULING:
 #ifdef	_POSIX_PRIORITY_SCHEDULING
-      return 1;
+      return _POSIX_PRIORITY_SCHEDULING;
 #else
       return -1;
 #endif
 
     case _SC_TIMERS:
 #ifdef	_POSIX_TIMERS
-      return 1;
+      return _POSIX_TIMERS;
 #else
       return -1;
 #endif
 
     case _SC_ASYNCHRONOUS_IO:
 #ifdef	_POSIX_ASYNCHRONOUS_IO
-      return 1;
+      return _POSIX_ASYNCHRONOUS_IO;
 #else
       return -1;
 #endif
 
     case _SC_PRIORITIZED_IO:
 #ifdef	_POSIX_PRIORITIZED_IO
-      return 1;
+      return _POSIX_PRIORITIZED_IO;
 #else
       return -1;
 #endif
 
     case _SC_SYNCHRONIZED_IO:
 #ifdef	_POSIX_SYNCHRONIZED_IO
-      return 1;
+      return _POSIX_SYNCHRONIZED_IO;
 #else
       return -1;
 #endif
 
     case _SC_FSYNC:
 #ifdef	_POSIX_FSYNC
-      return 1;
+      return _POSIX_FSYNC;
 #else
       return -1;
 #endif
 
     case _SC_MAPPED_FILES:
 #ifdef	_POSIX_MAPPED_FILES
-      return 1;
+      return _POSIX_MAPPED_FILES;
 #else
       return -1;
 #endif
 
     case _SC_MEMLOCK:
 #ifdef	_POSIX_MEMLOCK
-      return 1;
+      return _POSIX_MEMLOCK;
 #else
       return -1;
 #endif
 
     case _SC_MEMLOCK_RANGE:
 #ifdef	_POSIX_MEMLOCK_RANGE
-      return 1;
+      return _POSIX_MEMLOCK_RANGE;
 #else
       return -1;
 #endif
 
     case _SC_MEMORY_PROTECTION:
 #ifdef	_POSIX_MEMORY_PROTECTION
-      return 1;
+      return _POSIX_MEMORY_PROTECTION;
 #else
       return -1;
 #endif
 
     case _SC_MESSAGE_PASSING:
 #ifdef	_POSIX_MESSAGE_PASSING
-      return 1;
+      return _POSIX_MESSAGE_PASSING;
 #else
       return -1;
 #endif
 
     case _SC_SEMAPHORES:
 #ifdef	_POSIX_SEMAPHORES
-      return 1;
+      return _POSIX_SEMAPHORES;
 #else
       return -1;
 #endif
 
     case _SC_SHARED_MEMORY_OBJECTS:
 #ifdef	_POSIX_SHARED_MEMORY_OBJECTS
-      return 1;
+      return _POSIX_SHARED_MEMORY_OBJECTS;
 #else
       return -1;
 #endif
@@ -385,6 +401,7 @@
       return -1;
 #endif
 
+      /* The same as _SC_IOV_MAX.  */
     case _SC_UIO_MAXIOV:
 #ifdef	UIO_MAXIOV
       return UIO_MAXIOV;
@@ -465,6 +482,13 @@
       return -1;
 #endif
 
+    case _SC_2_FORT_RUN:
+#ifdef	_POSIX2_FORT_RUN
+      return _POSIX2_FORT_RUN;
+#else
+      return -1;
+#endif
+
     case _SC_2_LOCALEDEF:
 #ifdef	_POSIX2_LOCALEDEF
       return _POSIX2_LOCALEDEF;
@@ -496,42 +520,34 @@
       /* POSIX 1003.1c (POSIX Threads).  */
     case _SC_THREADS:
 #ifdef	_POSIX_THREADS
-      return 1;
+      return _POSIX_THREADS;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_SAFE_FUNCTIONS:
 #ifdef	_POSIX_THREAD_SAFE_FUNCTIONS
-      return 1;
+      return _POSIX_THREAD_SAFE_FUNCTIONS;
 #else
       return -1;
 #endif
 
     case _SC_GETGR_R_SIZE_MAX:
-#ifdef	NSS_BUFLEN_GROUP
       return NSS_BUFLEN_GROUP;
-#else
-      return -1;
-#endif
 
     case _SC_GETPW_R_SIZE_MAX:
-#ifdef	NSS_BUFLEN_PASSWD
       return NSS_BUFLEN_PASSWD;
-#else
-      return -1;
-#endif
 
     case _SC_LOGIN_NAME_MAX:
-#ifdef	_POSIX_LOGIN_NAME_MAX
-      return _POSIX_LOGIN_NAME_MAX;
+#ifdef	LOGIN_NAME_MAX
+      return LOGIN_NAME_MAX;
 #else
       return -1;
 #endif
 
     case _SC_TTY_NAME_MAX:
-#ifdef	_POSIX_TTY_NAME_MAX
-      return _POSIX_TTY_NAME_MAX;
+#ifdef	TTY_NAME_MAX
+      return TTY_NAME_MAX;
 #else
       return -1;
 #endif
@@ -566,42 +582,42 @@
 
     case _SC_THREAD_ATTR_STACKADDR:
 #ifdef	_POSIX_THREAD_ATTR_STACKADDR
-      return 1;
+      return _POSIX_THREAD_ATTR_STACKADDR;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_ATTR_STACKSIZE:
 #ifdef	_POSIX_THREAD_ATTR_STACKSIZE
-      return 1;
+      return _POSIX_THREAD_ATTR_STACKSIZE;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_PRIORITY_SCHEDULING:
 #ifdef	_POSIX_THREAD_PRIORITY_SCHEDULING
-      return 1;
+      return _POSIX_THREAD_PRIORITY_SCHEDULING;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_PRIO_INHERIT:
 #ifdef	_POSIX_THREAD_PRIO_INHERIT
-      return 1;
+      return _POSIX_THREAD_PRIO_INHERIT;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_PRIO_PROTECT:
 #ifdef	_POSIX_THREAD_PRIO_PROTECT
-      return 1;
+      return _POSIX_THREAD_PRIO_PROTECT;
 #else
       return -1;
 #endif
 
     case _SC_THREAD_PROCESS_SHARED:
 #ifdef	_POSIX_THREAD_PROCESS_SHARED
-      return 1;
+      return _POSIX_THREAD_PROCESS_SHARED;
 #else
       return -1;
 #endif
@@ -778,50 +794,50 @@
 #ifdef _XBS5_ILP32_OFF32
       return _XBS5_ILP32_OFF32;
 #else
-      return -1;
+      return __sysconf_check_spec ("ILP32_OFF32");
 #endif
     case _SC_XBS5_ILP32_OFFBIG:
 #ifdef _XBS5_ILP32_OFFBIG
       return _XBS5_ILP32_OFFBIG;
 #else
-      return -1;
+      return __sysconf_check_spec ("ILP32_OFFBIG");
 #endif
     case _SC_XBS5_LP64_OFF64:
 #ifdef _XBS5_LP64_OFF64
       return _XBS5_LP64_OFF64;
 #else
-      return -1;
+      return __sysconf_check_spec ("LP64_OFF64");
 #endif
     case _SC_XBS5_LPBIG_OFFBIG:
 #ifdef _XBS5_LPBIG_OFFBIG
       return _XBS5_LPBIG_OFFBIG;
 #else
-      return -1;
+      return __sysconf_check_spec ("LPBIG_OFFBIG");
 #endif
 
     case _SC_V6_ILP32_OFF32:
 #ifdef _POSIX_V6_ILP32_OFF32
       return _POSIX_V6_ILP32_OFF32;
 #else
-      return -1;
+      return __sysconf_check_spec ("ILP32_OFF32");
 #endif
     case _SC_V6_ILP32_OFFBIG:
 #ifdef _POSIX_V6_ILP32_OFFBIG
       return _POSIX_V6_ILP32_OFFBIG;
 #else
-      return -1;
+      return __sysconf_check_spec ("ILP32_OFFBIG");
 #endif
     case _SC_V6_LP64_OFF64:
 #ifdef _POSIX_V6_LP64_OFF64
       return _POSIX_V6_LP64_OFF64;
 #else
-      return -1;
+      return __sysconf_check_spec ("LP64_OFF64");
 #endif
     case _SC_V6_LPBIG_OFFBIG:
 #ifdef _POSIX_V6_LPBIG_OFFBIG
       return _POSIX_V6_LPBIG_OFFBIG;
 #else
-      return -1;
+      return __sysconf_check_spec ("LPBIG_OFFBIG");
 #endif
 
     case _SC_XOPEN_LEGACY:
@@ -881,7 +897,7 @@
 #endif
 
     case _SC_CPUTIME:
-#ifdef _POSIX_CPUTIME
+#if _POSIX_CPUTIME > 0
       return _POSIX_CPUTIME;
 #else
       return -1;
@@ -946,7 +962,7 @@
 #endif
 
     case _SC_MONOTONIC_CLOCK:
-#ifdef _POSIX_MONOTONIC_CLOCK
+#if _POSIX_MONOTONIC_CLOCK
       return _POSIX_MONOTONIC_CLOCK;
 #else
       return -1;
@@ -1046,7 +1062,7 @@
 #endif
 
     case _SC_THREAD_CPUTIME:
-#ifdef _POSIX_THREAD_CPUTIME
+#if _POSIX_THREAD_CPUTIME > 0
       return _POSIX_THREAD_CPUTIME;
 #else
       return -1;
@@ -1103,6 +1119,12 @@
 #else
       return -1;
 #endif
+    case _SC_2_PBS_MESSAGE:
+#ifdef _POSIX2_PBS_MESSAGE
+      return _POSIX2_PBS_MESSAGE;
+#else
+      return -1;
+#endif
     case _SC_2_PBS_TRACK:
 #ifdef _POSIX2_PBS_TRACK
       return _POSIX2_PBS_TRACK;
@@ -1123,9 +1145,97 @@
 #else
       return -1;
 #endif
+
+    case _SC_HOST_NAME_MAX:
+#ifdef HOST_NAME_MAX
+      return HOST_NAME_MAX;
+#else
+      return -1;
+#endif
+
+    case _SC_TRACE:
+#ifdef _POSIX_TRACE
+      return _POSIX_TRACE;
+#else
+      return -1;
+#endif
+    case _SC_TRACE_EVENT_FILTER:
+#ifdef _POSIX_TRACE_EVENT_FILTER
+      return _POSIX_TRACE_EVENT_FILTER;
+#else
+      return -1;
+#endif
+    case _SC_TRACE_INHERIT:
+#ifdef _POSIX_TRACE_INHERIT
+      return _POSIX_TRACE_INHERIT;
+#else
+      return -1;
+#endif
+    case _SC_TRACE_LOG:
+#ifdef _POSIX_TRACE_LOG
+      return _POSIX_TRACE_LOG;
+#else
+      return -1;
+#endif
+
+    case _SC_LEVEL1_ICACHE_SIZE:
+    case _SC_LEVEL1_ICACHE_ASSOC:
+    case _SC_LEVEL1_ICACHE_LINESIZE:
+    case _SC_LEVEL1_DCACHE_SIZE:
+    case _SC_LEVEL1_DCACHE_ASSOC:
+    case _SC_LEVEL1_DCACHE_LINESIZE:
+    case _SC_LEVEL2_CACHE_SIZE:
+    case _SC_LEVEL2_CACHE_ASSOC:
+    case _SC_LEVEL2_CACHE_LINESIZE:
+    case _SC_LEVEL3_CACHE_SIZE:
+    case _SC_LEVEL3_CACHE_ASSOC:
+    case _SC_LEVEL3_CACHE_LINESIZE:
+    case _SC_LEVEL4_CACHE_SIZE:
+    case _SC_LEVEL4_CACHE_ASSOC:
+      /* In general we cannot determine these values.  Therefore we
+	 return zero which indicates that no information is
+	 available.  */
+      return 0;
+
+    case _SC_IPV6:
+#ifdef _POSIX_IPV6
+      return _POSIX_IPV6;
+#else
+      return -1;
+#endif
+
+    case _SC_RAW_SOCKETS:
+#ifdef _POSIX_RAW_SOCKETS
+      return _POSIX_RAW_SOCKETS;
+#else
+      return -1;
+#endif
     }
 }
 
 #undef __sysconf
 weak_alias (__sysconf, sysconf)
 libc_hidden_def (__sysconf)
+
+#if NEED_CHECK_SPEC
+static long int
+__sysconf_check_spec (const char *spec)
+{
+  int save_errno = errno;
+
+  const char *getconf_dir = __secure_getenv ("GETCONF_DIR") ?: GETCONF_DIR;
+  size_t getconf_dirlen = strlen (getconf_dir);
+  size_t speclen = strlen (spec);
+
+  char name[getconf_dirlen + sizeof ("/POSIX_V6_") + speclen];
+  memcpy (mempcpy (mempcpy (name, getconf_dir, getconf_dirlen),
+		   "/POSIX_V6_", sizeof ("/POSIX_V6_") - 1),
+	  spec, speclen + 1);
+
+  struct stat64 st;
+  long int ret = __xstat64 (_STAT_VER, name, &st) >= 0 ? 1 : -1;
+
+  __set_errno (save_errno);
+  return ret;
+}
+#endif
diff -Nur sysdeps/posix/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/system.c
--- sysdeps/posix/system.c	2002-08-08 04:08:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/system.c	2003-06-15 23:12:34.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991-99,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1991-2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,13 +16,15 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
+#include <signal.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <sys/wait.h>
-#include <signal.h>
 #include <sys/types.h>
-#include <errno.h>
+#include <sys/wait.h>
+#include <bits/libc-lock.h>
+#include <sysdep-cancel.h>
 
 
 #ifndef	HAVE_GNU_LD
@@ -32,60 +34,94 @@
 #define	SHELL_PATH	"/bin/sh"	/* Path of the shell.  */
 #define	SHELL_NAME	"sh"		/* Name to give it.  */
 
+
+#ifdef _LIBC_REENTRANT
+static struct sigaction intr, quit;
+static int sa_refcntr;
+__libc_lock_define_initialized (static, lock);
+
+# define DO_LOCK() __libc_lock_lock (lock)
+# define DO_UNLOCK() __libc_lock_unlock (lock)
+# define INIT_LOCK() ({ __libc_lock_init (lock); sa_refcntr = 0; })
+# define ADD_REF() sa_refcntr++
+# define SUB_REF() --sa_refcntr
+#else
+# define DO_LOCK()
+# define DO_UNLOCK()
+# define INIT_LOCK()
+# define ADD_REF() 0
+# define SUB_REF() 0
+#endif
+
+
 /* Execute LINE as a shell command, returning its status.  */
 static int
 do_system (const char *line)
 {
   int status, save;
   pid_t pid;
-  struct sigaction sa, intr, quit;
-#ifndef WAITPID_CANNOT_BLOCK_SIGCHLD
-  sigset_t block, omask;
+  struct sigaction sa;
+#ifndef _LIBC_REENTRANT
+  struct sigaction intr, quit;
 #endif
+  sigset_t omask;
 
   sa.sa_handler = SIG_IGN;
   sa.sa_flags = 0;
   __sigemptyset (&sa.sa_mask);
 
-  if (__sigaction (SIGINT, &sa, &intr) < 0)
-    return -1;
-  if (__sigaction (SIGQUIT, &sa, &quit) < 0)
+  DO_LOCK ();
+  if (ADD_REF () == 0)
     {
-      save = errno;
-      (void) __sigaction (SIGINT, &intr, (struct sigaction *) NULL);
-      __set_errno (save);
-      return -1;
+      if (__sigaction (SIGINT, &sa, &intr) < 0)
+	{
+	  SUB_REF ();
+	  goto out;
+	}
+      if (__sigaction (SIGQUIT, &sa, &quit) < 0)
+	{
+	  save = errno;
+	  SUB_REF ();
+	  goto out_restore_sigint;
+	}
     }
+  DO_UNLOCK ();
 
-#ifndef WAITPID_CANNOT_BLOCK_SIGCHLD
-
-/* SCO 3.2v4 has a bug where `waitpid' will never return if SIGCHLD is
-   blocked.  This makes it impossible for `system' to be implemented in
-   compliance with POSIX.2-1992.  They have acknowledged that this is a bug
-   but I have not seen nor heard of any forthcoming fix.  */
-
-  __sigemptyset (&block);
-  __sigaddset (&block, SIGCHLD);
+  /* We reuse the bitmap in the 'sa' structure.  */
+  __sigaddset (&sa.sa_mask, SIGCHLD);
   save = errno;
-  if (__sigprocmask (SIG_BLOCK, &block, &omask) < 0)
+  if (__sigprocmask (SIG_BLOCK, &sa.sa_mask, &omask) < 0)
     {
+#ifndef _LIBC
       if (errno == ENOSYS)
 	__set_errno (save);
       else
+#endif
 	{
-	  save = errno;
-	  (void) __sigaction (SIGINT, &intr, (struct sigaction *) NULL);
-	  (void) __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
-	  __set_errno (save);
+	  DO_LOCK ();
+	  if (SUB_REF () == 0)
+	    {
+	      save = errno;
+	      (void) __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
+	    out_restore_sigint:
+	      (void) __sigaction (SIGINT, &intr, (struct sigaction *) NULL);
+	      __set_errno (save);
+	    }
+	out:
+	  DO_UNLOCK ();
 	  return -1;
 	}
     }
-# define UNBLOCK __sigprocmask (SIG_SETMASK, &omask, (sigset_t *) NULL)
-#else
-# define UNBLOCK 0
+
+#ifdef CLEANUP_HANDLER
+  CLEANUP_HANDLER;
 #endif
 
+#ifdef FORK
+  pid = FORK ();
+#else
   pid = __fork ();
+#endif
   if (pid == (pid_t) 0)
     {
       /* Child side.  */
@@ -98,7 +134,8 @@
       /* Restore the signals.  */
       (void) __sigaction (SIGINT, &intr, (struct sigaction *) NULL);
       (void) __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
-      (void) UNBLOCK;
+      (void) __sigprocmask (SIG_SETMASK, &omask, (sigset_t *) NULL);
+      INIT_LOCK ();
 
       /* Exec the shell.  */
       (void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);
@@ -125,27 +162,34 @@
 	}
       while (child != pid);
 #else
-      int n;
-
-      do
-	n = __waitpid (pid, &status, 0);
-      while (n == -1 && errno == EINTR);
-
-      if (n != pid)
+      /* Note the system() is a cancellation point.  But since we call
+	 waitpid() which itself is a cancellation point we do not
+	 have to do anything here.  */
+      if (TEMP_FAILURE_RETRY (__waitpid (pid, &status, 0)) != pid)
 	status = -1;
 #endif
     }
 
+#ifdef CLEANUP_HANDLER
+  CLEANUP_RESET;
+#endif
+
   save = errno;
-  if ((__sigaction (SIGINT, &intr, (struct sigaction *) NULL) |
-       __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL) |
-       UNBLOCK) != 0)
+  DO_LOCK ();
+  if ((SUB_REF () == 0
+       && (__sigaction (SIGINT, &intr, (struct sigaction *) NULL)
+	   | __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL)) != 0)
+      || __sigprocmask (SIG_SETMASK, &omask, (sigset_t *) NULL) != 0)
     {
+#ifndef _LIBC
+      /* glibc cannot be used on systems without waitpid.  */
       if (errno == ENOSYS)
 	__set_errno (save);
       else
-	return -1;
+#endif
+	status = -1;
     }
+  DO_UNLOCK ();
 
   return status;
 }
@@ -158,6 +202,15 @@
        not be available after a chroot(), for example.  */
     return do_system ("exit 0") == 0;
 
-  return do_system (line);
+  if (SINGLE_THREAD_P)
+    return do_system (line);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_system (line);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 weak_alias (__libc_system, system)
diff -Nur sysdeps/posix/ttyname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/ttyname.c
--- sysdeps/posix/ttyname.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/ttyname.c	2002-11-01 21:43:39.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 96, 97, 98, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,96,97,98,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,7 +32,7 @@
 			 int save, int *dostat) internal_function;
 
 
-static char *getttyname_name;
+libc_freeres_ptr (static char *getttyname_name);
 
 static char *
 internal_function
@@ -134,11 +134,3 @@
 
   return name;
 }
-
-
-static void
-free_mem (void)
-{
-  free (getttyname_name);
-}
-text_set_element (__libc_subfreeres, free_mem);
diff -Nur sysdeps/posix/ttyname_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/ttyname_r.c
--- sysdeps/posix/ttyname_r.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/ttyname_r.c	2004-09-14 06:24:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 95, 96, 97, 98 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,95,96,97,98,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,9 +32,9 @@
 
 static const char dev[] = "/dev";
 
-static int getttyname_r __P ((int fd, char *buf, size_t buflen,
-			      dev_t mydev, ino_t myino, int save,
-			      int *dostat)) internal_function;
+static int getttyname_r (int fd, char *buf, size_t buflen,
+			 dev_t mydev, ino_t myino, int save,
+			 int *dostat) __THROW internal_function;
 
 static int
 internal_function
diff -Nur sysdeps/posix/utimes.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/utimes.c
--- sysdeps/posix/utimes.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/utimes.c	2003-09-17 11:17:33.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,8 +31,8 @@
   if (tvp)
     {
       times = &buf;
-      times->actime = tvp[0].tv_sec + tvp[0].tv_usec / 1000000;
-      times->modtime = tvp[1].tv_sec + tvp[1].tv_usec / 1000000;
+      buf.actime = tvp[0].tv_sec + tvp[0].tv_usec / 1000000;
+      buf.modtime = tvp[1].tv_sec + tvp[1].tv_usec / 1000000;
     }
   else
     times = NULL;
diff -Nur sysdeps/posix/waitid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/waitid.c
--- sysdeps/posix/waitid.c	2001-07-07 21:21:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/waitid.c	2004-07-27 03:20:15.000000000 +0200
@@ -1,5 +1,5 @@
 /* Pseudo implementation of waitid.
-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Zack Weinberg <zack@rabi.phys.columbia.edu>, 1997.
 
@@ -18,21 +18,25 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <assert.h>
 #include <errno.h>
 #include <signal.h>
 #define __need_NULL
 #include <stddef.h>
 #include <sys/wait.h>
 #include <sys/types.h>
+#include <sysdep-cancel.h>
 
-#include <assert.h>
 
-int
-waitid (idtype, id, infop, options)
-     idtype_t idtype;
-     id_t id;
-     siginfo_t *infop;
-     int options;
+#ifdef DO_WAITID
+# define OUR_WAITID DO_WAITID
+#elif !defined NO_DO_WAITID
+# define OUR_WAITID do_waitid
+#endif
+
+#ifdef OUR_WAITID
+static int
+OUR_WAITID (idtype_t idtype, id_t id, siginfo_t *infop, int options)
 {
   pid_t pid, child;
   int status;
@@ -69,7 +73,31 @@
       return -1;
     }
 
-  child = __waitpid (pid, &status, options);
+  /* This emulation using waitpid cannot support the waitid modes in which
+     we do not reap the child, or match only stopped and not dead children.  */
+  if (0
+#ifdef WNOWAIT
+      || (options & WNOWAIT)
+#endif
+#ifdef WEXITED
+      || ((options & (WEXITED|WSTOPPED|WCONTINUED))
+	  != (WEXITED | (options & WUNTRACED)))
+#endif
+      )
+    {
+      __set_errno (ENOTSUP);
+      return -1;
+    }
+
+  /* Note the waitid() is a cancellation point.  But since we call
+     waitpid() which itself is a cancellation point we do not have
+     to do anything here.  */
+  child = __waitpid (pid, &status,
+		     options
+#ifdef WEXITED
+		     &~ WEXITED
+#endif
+		     );
 
   if (child == -1)
     /* `waitpid' set `errno' for us.  */
@@ -118,3 +146,26 @@
 
   return 0;
 }
+#endif
+
+
+int
+__waitid (idtype, id, infop, options)
+     idtype_t idtype;
+     id_t id;
+     siginfo_t *infop;
+     int options;
+{
+  if (SINGLE_THREAD_P)
+    return do_waitid (idtype, id, infop, options);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_waitid (idtype, id, infop, options);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__waitid, waitid)
+strong_alias (__waitid, __libc_waitid)
diff -Nur sysdeps/posix/writev.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/writev.c
--- sysdeps/posix/writev.c	2002-08-26 23:16:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/posix/writev.c	2002-11-25 00:56:43.000000000 +0100
@@ -23,6 +23,7 @@
 #include <stdbool.h>
 #include <sys/param.h>
 #include <sys/uio.h>
+#include <errno.h>
 
 /* Write data pointed by the buffers described by VECTOR, which
    is a vector of COUNT `struct iovec's, to file descriptor FD.
@@ -30,7 +31,7 @@
    Operates just like `write' (see <unistd.h>) except that the data
    are taken from VECTOR instead of a contiguous buffer.  */
 ssize_t
-__writev (int fd, const struct iovec *vector, int count)
+__libc_writev (int fd, const struct iovec *vector, int count)
 {
   char *buffer;
   register char *bp;
@@ -46,7 +47,7 @@
       /* Check for ssize_t overflow.  */
       if (SSIZE_MAX - bytes < vector[i].iov_len)
 	{
-	  errno = EINVAL;
+	  __set_errno (EINVAL);
 	  return -1;
 	}
       bytes += vector[i].iov_len;
@@ -55,8 +56,8 @@
   /* Allocate a temporary buffer to hold the data.  We should normally
      use alloca since it's faster and does not require synchronization
      with other threads.  But we cannot if the amount of memory
-     required is too large.  Use 512k as the limit.  */
-  if (bytes < 512 * 1024)
+     required is too large.  */
+  if (__libc_use_alloca (bytes))
     buffer = (char *) __alloca (bytes);
   else
     {
@@ -90,6 +91,7 @@
 
   return bytes_written;
 }
-#ifndef __writev
-weak_alias (__writev, writev)
+#ifndef __libc_writev
+strong_alias (__libc_writev, __writev)
+weak_alias (__libc_writev, writev)
 #endif
diff -Nur sysdeps/pthread/aio_cancel.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_cancel.c
--- sysdeps/pthread/aio_cancel.c	2002-08-29 01:39:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_cancel.c	2003-07-25 09:55:53.000000000 +0200
@@ -60,7 +60,13 @@
     {
       /* If the AIO request is not for this descriptor it has no value
 	 to look for the request block.  */
-      if (aiocbp->aio_fildes == fildes)
+      if (aiocbp->aio_fildes != fildes)
+	{
+	  pthread_mutex_unlock (&__aio_requests_mutex);
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      else if (aiocbp->__error_code == EINPROGRESS)
 	{
 	  struct requestlist *last = NULL;
 
diff -Nur sysdeps/pthread/aio_misc.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_misc.c
--- sysdeps/pthread/aio_misc.c	2002-03-11 09:32:01.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_misc.c	2004-08-11 20:51:09.000000000 +0200
@@ -1,5 +1,6 @@
 /* Handle general operations.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -27,8 +28,27 @@
 #include <unistd.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <aio_misc.h>
 
-#include "aio_misc.h"
+#ifndef aio_create_helper_thread
+# define aio_create_helper_thread __aio_create_helper_thread
+
+extern inline int
+__aio_create_helper_thread (pthread_t *threadp, void *(*tf) (void *), void *arg)
+{
+  pthread_attr_t attr;
+
+  /* Make sure the thread is created detached.  */
+  pthread_attr_init (&attr);
+  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
+
+  int ret = pthread_create (threadp, &attr, tf, arg);
+
+  (void) pthread_attr_destroy (&attr);
+  return ret;
+}                                                                                 
+
+#endif
 
 static void add_request_to_runlist (struct requestlist *newrequest);
 
@@ -328,8 +348,10 @@
       return NULL;
     }
   newp->aiocbp = aiocbp;
+#ifdef BROKEN_THREAD_SIGNALS
   newp->caller_pid = (aiocbp->aiocb.aio_sigevent.sigev_notify == SIGEV_SIGNAL
 		      ? getpid () : 0);
+#endif
   newp->waiting = NULL;
 
   aiocbp->aiocb.__abs_prio = prio;
@@ -398,16 +420,11 @@
       if (nthreads < optim.aio_threads && idle_thread_count == 0)
 	{
 	  pthread_t thid;
-	  pthread_attr_t attr;
-
-	  /* Make sure the thread is created detached.  */
-	  pthread_attr_init (&attr);
-	  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
 
 	  running = newp->running = allocated;
 
 	  /* Now try to start a thread.  */
-	  if (pthread_create (&thid, &attr, handle_fildes_io, newp) == 0)
+	  if (aio_create_helper_thread (&thid, handle_fildes_io, newp) == 0)
 	    /* We managed to enqueue the request.  All errors which can
 	       happen now can be recognized by calls to `aio_return' and
 	       `aio_error'.  */
@@ -454,7 +471,6 @@
 
 
 static void *
-__attribute__ ((noreturn))
 handle_fildes_io (void *arg)
 {
   pthread_t self = pthread_self ();
@@ -530,7 +546,7 @@
 						  aiocbp->aiocb64.aio_offset));
 	      else
 		aiocbp->aiocb.__return_value =
-		  TEMP_FAILURE_RETRY (pwrite (fildes, (const void *)
+		  TEMP_FAILURE_RETRY (__libc_pwrite (fildes, (const void *)
 					      aiocbp->aiocb.aio_buf,
 					      aiocbp->aiocb.aio_nbytes,
 					      aiocbp->aiocb.aio_offset));
@@ -660,14 +676,12 @@
     }
   while (runp != NULL);
 
-  pthread_exit (NULL);
+  return NULL;
 }
 
 
 /* Free allocated resources.  */
-static void
-__attribute__ ((unused))
-free_res (void)
+libc_freeres_fn (free_res)
 {
   size_t row;
 
@@ -676,7 +690,6 @@
 
   free (pool);
 }
-text_set_element (__libc_subfreeres, free_res);
 
 
 /* Add newrequest to the runlist. The __abs_prio flag of newrequest must
diff -Nur sysdeps/pthread/aio_misc.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_misc.h
--- sysdeps/pthread/aio_misc.h	2002-03-11 09:32:01.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_misc.h	2003-08-14 02:01:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -50,9 +50,11 @@
     volatile int *counterp;
     /* The next field is used in asynchronous `lio_listio' operations.  */
     struct sigevent *sigevp;
+#ifdef BROKEN_THREAD_SIGNALS
     /* XXX See requestlist, it's used to work around the broken signal
        handling in Linux.  */
     pid_t caller_pid;
+#endif
   };
 
 
@@ -80,9 +82,11 @@
     /* Pointer to the actual data.  */
     aiocb_union *aiocbp;
 
+#ifdef BROKEN_THREAD_SIGNALS
     /* PID of the initiator thread.
        XXX This is only necessary for the broken signal handling on Linux.  */
     pid_t caller_pid;
+#endif
 
     /* List of waiting processes.  */
     struct waitlist *waiting;
@@ -90,38 +94,46 @@
 
 
 /* Lock for global I/O list of requests.  */
-extern pthread_mutex_t __aio_requests_mutex;
+extern pthread_mutex_t __aio_requests_mutex attribute_hidden;
 
 
 /* Enqueue request.  */
 extern struct requestlist *__aio_enqueue_request (aiocb_union *aiocbp,
 						  int operation)
-     internal_function;
+     attribute_hidden internal_function;
 
 /* Find request entry for given AIO control block.  */
 extern struct requestlist *__aio_find_req (aiocb_union *elem)
-     internal_function;
+     attribute_hidden internal_function;
 
 /* Find request entry for given file descriptor.  */
-extern struct requestlist *__aio_find_req_fd (int fildes) internal_function;
+extern struct requestlist *__aio_find_req_fd (int fildes)
+     attribute_hidden internal_function;
 
 /* Remove request from the list.  */
 extern void __aio_remove_request (struct requestlist *last,
 				  struct requestlist *req, int all)
-     internal_function;
+     attribute_hidden internal_function;
 
 /* Release the entry for the request.  */
-extern void __aio_free_request (struct requestlist *req) internal_function;
+extern void __aio_free_request (struct requestlist *req)
+     attribute_hidden internal_function;
 
 /* Notify initiator of request and tell this everybody listening.  */
-extern void __aio_notify (struct requestlist *req) internal_function;
+extern void __aio_notify (struct requestlist *req)
+     attribute_hidden internal_function;
 
 /* Notify initiator of request.  */
+#ifdef BROKEN_THREAD_SIGNALS
 extern int __aio_notify_only (struct sigevent *sigev, pid_t caller_pid)
-     internal_function;
+     attribute_hidden internal_function;
+#else
+extern int __aio_notify_only (struct sigevent *sigev)
+     attribute_hidden internal_function;
+#endif
 
 /* Send the signal.  */
 extern int __aio_sigqueue (int sig, const union sigval val, pid_t caller_pid)
-     internal_function;
+     attribute_hidden internal_function;
 
 #endif /* aio_misc.h */
diff -Nur sysdeps/pthread/aio_notify.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_notify.c
--- sysdeps/pthread/aio_notify.c	2001-07-07 21:21:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_notify.c	2004-05-26 06:23:43.000000000 +0200
@@ -1,5 +1,6 @@
 /* Notify initiator of AIO request.
-   Copyright (C) 1997,98,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,26 +23,43 @@
 #include <pthread.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include "aio_misc.h"
+#include <aio_misc.h>
 
+#ifndef aio_start_notify_thread
+# define aio_start_notify_thread() do { } while (0)
+#endif
+
+struct notify_func
+  {
+    void (*func) (sigval_t);
+    sigval_t value;
+  };
 
 static void *
 notify_func_wrapper (void *arg)
 {
-  struct sigevent *sigev = arg;
-  sigev->sigev_notify_function (sigev->sigev_value);
+  aio_start_notify_thread ();
+  struct notify_func *const n = arg;
+  void (*func) (sigval_t) = n->func;
+  sigval_t value = n->value;
+  free (n);
+  (*func) (value);
   return NULL;
 }
 
 
 int
 internal_function
+#ifdef BROKEN_THREAD_SIGNALS
 __aio_notify_only (struct sigevent *sigev, pid_t caller_pid)
+#else
+__aio_notify_only (struct sigevent *sigev)
+#endif
 {
   int result = 0;
 
   /* Send the signal to notify about finished processing of the request.  */
-  if (sigev->sigev_notify == SIGEV_THREAD)
+  if (__builtin_expect (sigev->sigev_notify == SIGEV_THREAD, 0))
     {
       /* We have to start a thread.  */
       pthread_t tid;
@@ -55,8 +73,26 @@
 	  pattr = &attr;
 	}
 
-      if (pthread_create (&tid, pattr, notify_func_wrapper, sigev) < 0)
+      /* SIGEV may be freed as soon as we return, so we cannot let the
+	 notification thread use that pointer.  Even though a sigval_t is
+	 only one word and the same size as a void *, we cannot just pass
+	 the value through pthread_create as the argument and have the new
+	 thread run the user's function directly, because on some machines
+	 the calling convention for a union like sigval_t is different from
+	 that for a pointer type like void *.  */
+      struct notify_func *nf = malloc (sizeof *nf);
+      if (nf == NULL)
 	result = -1;
+      else
+	{
+	  nf->func = sigev->sigev_notify_function;
+	  nf->value = sigev->sigev_value;
+	  if (pthread_create (&tid, pattr, notify_func_wrapper, nf) < 0)
+	    {
+	      free (nf);
+	      result = -1;
+	    }
+	}
     }
   else if (sigev->sigev_notify == SIGEV_SIGNAL)
     {
@@ -64,9 +100,15 @@
 #if _POSIX_REALTIME_SIGNALS
       /* Note that the standard gives us the option of using a plain
 	 non-queuing signal here when SA_SIGINFO is not set for the signal.  */
+# ifdef BROKEN_THREAD_SIGNALS
       if (__aio_sigqueue (sigev->sigev_signo, sigev->sigev_value, caller_pid)
 	  < 0)
 	result = -1;
+# else
+      if (__aio_sigqueue (sigev->sigev_signo, sigev->sigev_value, getpid ())
+	  < 0)
+	result = -1;
+# endif
 #else
       /* There are no queued signals on this system at all.  */
       result = raise (sigev->sigev_signo);
@@ -84,7 +126,11 @@
   struct waitlist *waitlist;
   struct aiocb *aiocbp = &req->aiocbp->aiocb;
 
+#ifdef BROKEN_THREAD_SIGNALS
   if (__aio_notify_only (&aiocbp->aio_sigevent, req->caller_pid) != 0)
+#else
+  if (__aio_notify_only (&aiocbp->aio_sigevent) != 0)
+#endif
     {
       /* XXX What shall we do if already an error is set by
 	 read/write/fsync?  */
@@ -108,7 +154,11 @@
 	   this request is the last one, send the signal.  */
 	if (*waitlist->counterp == 0)
 	  {
+#ifdef BROKEN_THREAD_SIGNALS
 	    __aio_notify_only (waitlist->sigevp, waitlist->caller_pid);
+#else
+	    __aio_notify_only (waitlist->sigevp);
+#endif
 	    /* This is tricky.  See lio_listio.c for the reason why
 	       this works.  */
 	    free ((void *) waitlist->counterp);
diff -Nur sysdeps/pthread/aio_suspend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_suspend.c
--- sysdeps/pthread/aio_suspend.c	2002-06-30 01:23:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/aio_suspend.c	2003-08-14 02:04:38.000000000 +0200
@@ -1,5 +1,5 @@
 /* Suspend until termination of a requests.
-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -35,9 +35,54 @@
 #include <stdlib.h>
 #include <sys/time.h>
 
+#include <bits/libc-lock.h>
 #include "aio_misc.h"
 
 
+struct clparam
+{
+  const struct aiocb *const *list;
+  struct waitlist *waitlist;
+  struct requestlist **requestlist;
+  pthread_cond_t *cond;
+  int nent;
+};
+
+
+static void
+cleanup (void *arg)
+{
+  const struct clparam *param = (const struct clparam *) arg;
+
+  /* Now remove the entry in the waiting list for all requests
+     which didn't terminate.  */
+  int cnt = param->nent;
+  while (cnt-- > 0)
+    if (param->list[cnt] != NULL
+	&& param->list[cnt]->__error_code == EINPROGRESS)
+      {
+	struct waitlist **listp;
+
+	assert (param->requestlist[cnt] != NULL);
+
+	/* There is the chance that we cannot find our entry anymore. This
+	   could happen if the request terminated and restarted again.  */
+	listp = &param->requestlist[cnt]->waiting;
+	while (*listp != NULL && *listp != &param->waitlist[cnt])
+	  listp = &(*listp)->next;
+
+	if (*listp != NULL)
+	  *listp = (*listp)->next;
+      }
+
+  /* Release the conditional variable.  */
+  (void) pthread_cond_destroy (param->cond);
+
+  /* Release the mutex.  */
+  pthread_mutex_unlock (&__aio_requests_mutex);
+}
+
+
 int
 aio_suspend (list, nent, timeout)
      const struct aiocb *const list[];
@@ -48,9 +93,9 @@
   struct requestlist *requestlist[nent];
   pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
   int cnt;
+  bool any = false;
   int result = 0;
   int dummy;
-  bool any = false;
 
   /* Request the mutex.  */
   pthread_mutex_lock (&__aio_requests_mutex);
@@ -70,7 +115,9 @@
 		waitlist[cnt].next = requestlist[cnt]->waiting;
 		waitlist[cnt].counterp = &dummy;
 		waitlist[cnt].sigevp = NULL;
+#ifdef BROKEN_THREAD_SIGNALS
 		waitlist[cnt].caller_pid = 0;	/* Not needed.  */
+#endif
 		requestlist[cnt]->waiting = &waitlist[cnt];
 		any = true;
 	      }
@@ -83,81 +130,81 @@
 	  break;
       }
 
-  /* If there is no finished request wait for it.  In any case we have
-     to dequeue the requests if we enqueued them.  */
-  if (any)
-    {
-      int oldstate;
-
-      /* Since `pthread_cond_wait'/`pthread_cond_timedwait' are cancelation
-	 points we must be careful.  We added entries to the waiting lists
-	 which we must remove.  So defer cancelation for now.  */
-      pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &oldstate);
 
-      /* Only if none of the entries is NULL or finished to be wait.  */
-      if (cnt == nent)
+  /* Only if none of the entries is NULL or finished to be wait.  */
+  if (cnt == nent && any)
+    {
+      struct clparam clparam =
+	{
+	  .list = list,
+	  .waitlist = waitlist,
+	  .requestlist = requestlist,
+	  .cond = &cond,
+	  .nent = nent
+	};
+
+      pthread_cleanup_push (cleanup, &clparam);
+
+      if (timeout == NULL)
+	result = pthread_cond_wait (&cond, &__aio_requests_mutex);
+      else
 	{
-	  if (timeout == NULL)
-	    result = pthread_cond_wait (&cond, &__aio_requests_mutex);
-	  else
+	  /* We have to convert the relative timeout value into an
+	     absolute time value with pthread_cond_timedwait expects.  */
+	  struct timeval now;
+	  struct timespec abstime;
+
+	  __gettimeofday (&now, NULL);
+	  abstime.tv_nsec = timeout->tv_nsec + now.tv_usec * 1000;
+	  abstime.tv_sec = timeout->tv_sec + now.tv_sec;
+	  if (abstime.tv_nsec >= 1000000000)
 	    {
-	      /* We have to convert the relative timeout value into an
-		 absolute time value with pthread_cond_timedwait expects.  */
-	      struct timeval now;
-	      struct timespec abstime;
-
-	      __gettimeofday (&now, NULL);
-	      abstime.tv_nsec = timeout->tv_nsec + now.tv_usec * 1000;
-	      abstime.tv_sec = timeout->tv_sec + now.tv_sec;
-	      if (abstime.tv_nsec >= 1000000000)
-		{
-		  abstime.tv_nsec -= 1000000000;
-		  abstime.tv_sec += 1;
-		}
-
-	      result = pthread_cond_timedwait (&cond, &__aio_requests_mutex,
-					       &abstime);
+	      abstime.tv_nsec -= 1000000000;
+	      abstime.tv_sec += 1;
 	    }
+
+	  result = pthread_cond_timedwait (&cond, &__aio_requests_mutex,
+					   &abstime);
 	}
 
-      /* Now remove the entry in the waiting list for all requests
-	 which didn't terminate.  */
-      while (cnt-- > 0)
-	if (list[cnt] != NULL && list[cnt]->__error_code == EINPROGRESS)
-	  {
-	    struct waitlist **listp;
+      pthread_cleanup_pop (0);
+    }
 
-	    assert (requestlist[cnt] != NULL);
+  /* Now remove the entry in the waiting list for all requests
+     which didn't terminate.  */
+  while (cnt-- > 0)
+    if (list[cnt] != NULL && list[cnt]->__error_code == EINPROGRESS)
+      {
+	struct waitlist **listp;
 
-	    /* There is the chance that we cannot find our entry anymore.
-	       This could happen if the request terminated and restarted
-	       again.  */
-	    listp = &requestlist[cnt]->waiting;
-	    while (*listp != NULL && *listp != &waitlist[cnt])
-	      listp = &(*listp)->next;
+	assert (requestlist[cnt] != NULL);
 
-	    if (*listp != NULL)
-	      *listp = (*listp)->next;
-	  }
+	/* There is the chance that we cannot find our entry anymore. This
+	   could happen if the request terminated and restarted again.  */
+	listp = &requestlist[cnt]->waiting;
+	while (*listp != NULL && *listp != &waitlist[cnt])
+	  listp = &(*listp)->next;
 
-      /* Now it's time to restore the cancelation state.  */
-      pthread_setcancelstate (oldstate, NULL);
+	if (*listp != NULL)
+	  *listp = (*listp)->next;
+      }
 
-      /* Release the conditional variable.  */
-      if (__builtin_expect (pthread_cond_destroy (&cond) != 0, 0))
-	/* This must never happen.  */
-	abort ();
+  /* Release the conditional variable.  */
+  if (__builtin_expect (pthread_cond_destroy (&cond) != 0, 0))
+    /* This must never happen.  */
+    abort ();
 
-      if (result != 0)
-	{
-	  /* An error occurred.  Possibly it's EINTR.  We have to translate
-	     the timeout error report of `pthread_cond_timedwait' to the
-	     form expected from `aio_suspend'.  */
-	  if (result == ETIMEDOUT)
-	    __set_errno (EAGAIN);
+  if (result != 0)
+    {
+      /* An error occurred.  Possibly it's EINTR.  We have to translate
+	 the timeout error report of `pthread_cond_timedwait' to the
+	 form expected from `aio_suspend'.  */
+      if (result == ETIMEDOUT)
+	__set_errno (EAGAIN);
+      else
+	__set_errno (result);
 
-	  result = -1;
-	}
+      result = -1;
     }
 
   /* Release the mutex.  */
diff -Nur sysdeps/pthread/lio_listio64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/lio_listio64.c
--- sysdeps/pthread/lio_listio64.c	2001-07-07 21:21:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/lio_listio64.c	2003-07-23 20:49:28.000000000 +0200
@@ -1,5 +1,5 @@
 /* Enqueue and list of read or write requests, 64bit offset version.
-   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,151 +19,14 @@
    02111-1307 USA.  */
 
 #include <aio.h>
+#include <assert.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <unistd.h>
 
 #include "aio_misc.h"
 
-
-/* We need this special structure to handle asynchronous I/O.  */
-struct async_waitlist
-  {
-    int counter;
-    struct sigevent sigev;
-    struct waitlist list[0];
-  };
-
-
-int
-lio_listio64 (mode, list, nent, sig)
-     int mode;
-     struct aiocb64 *const list[];
-     int nent;
-     struct sigevent *sig;
-{
-  struct requestlist *requests[nent];
-  int cnt;
-  volatile int total = 0;
-  int result = 0;
-
-  /* Check arguments.  */
-  if (mode != LIO_WAIT && mode != LIO_NOWAIT)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  /* Request the mutex.  */
-  pthread_mutex_lock (&__aio_requests_mutex);
-
-  /* Now we can enqueue all requests.  Since we already acquired the
-     mutex the enqueue function need not do this.  */
-  for (cnt = 0; cnt < nent; ++cnt)
-    if (list[cnt] != NULL && list[cnt]->aio_lio_opcode != LIO_NOP)
-      {
-	requests[cnt] = __aio_enqueue_request ((aiocb_union *) list[cnt],
-					       (list[cnt]->aio_lio_opcode
-						| 128));
-	if (requests[cnt] != NULL)
-	  /* Successfully enqueued.  */
-	  ++total;
-	else
-	  /* Signal that we've seen an error.  `errno' and the error code
-	     of the aiocb will tell more.  */
-	  result = -1;
-      }
-
-  if (total == 0)
-    {
-      /* We don't have anything to do except signalling if we work
-	 asynchronously.  */
-
-      /* Release the mutex.  We do this before raising a signal since the
-	 signal handler might do a `siglongjmp' and then the mutex is
-	 locked forever.  */
-      pthread_mutex_unlock (&__aio_requests_mutex);
-
-      if (mode == LIO_NOWAIT)
-	__aio_notify_only (sig,
-			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
-
-      return result;
-    }
-  else if (mode == LIO_WAIT)
-    {
-      pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
-      struct waitlist waitlist[nent];
-      int oldstate;
-
-      total = 0;
-      for (cnt = 0; cnt < nent; ++cnt)
-	if (list[cnt] != NULL && list[cnt]->aio_lio_opcode != LIO_NOP
-	    && requests[cnt] != NULL)
-	  {
-	    waitlist[cnt].cond = &cond;
-	    waitlist[cnt].next = requests[cnt]->waiting;
-	    waitlist[cnt].counterp = &total;
-	    waitlist[cnt].sigevp = NULL;
-	    waitlist[cnt].caller_pid = 0;	/* Not needed.  */
-	    requests[cnt]->waiting = &waitlist[cnt];
-	    ++total;
-	  }
-
-      /* Since `pthread_cond_wait'/`pthread_cond_timedwait' are cancelation
-	 points we must be careful.  We added entries to the waiting lists
-	 which we must remove.  So defer cancelation for now.  */
-      pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &oldstate);
-
-      while (total > 0)
-	pthread_cond_wait (&cond, &__aio_requests_mutex);
-
-      /* Now it's time to restore the cancelation state.  */
-      pthread_setcancelstate (oldstate, NULL);
-
-      /* Release the conditional variable.  */
-      if (pthread_cond_destroy (&cond) != 0)
-	/* This must never happen.  */
-	abort ();
-    }
-  else
-    {
-      struct async_waitlist *waitlist;
-
-      waitlist = (struct async_waitlist *)
-	malloc (sizeof (struct async_waitlist)
-		+ (nent * sizeof (struct waitlist)));
-
-      if (waitlist == NULL)
-	{
-	  __set_errno (EAGAIN);
-	  result = -1;
-	}
-      else
-	{
-	  pid_t caller_pid = sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0;
-	  total = 0;
-
-	  for (cnt = 0; cnt < nent; ++cnt)
-	    if (list[cnt] != NULL && list[cnt]->aio_lio_opcode != LIO_NOP
-		&& requests[cnt] != NULL)
-	      {
-		waitlist->list[cnt].cond = NULL;
-		waitlist->list[cnt].next = requests[cnt]->waiting;
-		waitlist->list[cnt].counterp = &waitlist->counter;
-		waitlist->list[cnt].sigevp = &waitlist->sigev;
-		waitlist->list[cnt].caller_pid = caller_pid;
-		requests[cnt]->waiting = &waitlist->list[cnt];
-		++total;
-	      }
-
-	  waitlist->counter = total;
-	  waitlist->sigev = *sig;
-	}
-    }
-
-  /* Release the mutex.  */
-  pthread_mutex_unlock (&__aio_requests_mutex);
-
-  return result;
-}
+#define lio_listio lio_listio64
+#define aiocb aiocb64
+#define LIO_OPCODE_BASE 128
+#include <lio_listio.c>
diff -Nur sysdeps/pthread/lio_listio.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/lio_listio.c
--- sysdeps/pthread/lio_listio.c	2001-07-07 21:21:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/pthread/lio_listio.c	2003-08-14 02:06:07.000000000 +0200
@@ -1,5 +1,5 @@
 /* Enqueue and list of read or write requests.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,6 +18,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#ifndef lio_listio
 #include <aio.h>
 #include <assert.h>
 #include <errno.h>
@@ -26,6 +27,8 @@
 
 #include "aio_misc.h"
 
+#define LIO_OPCODE_BASE 0
+#endif
 
 /* We need this special structure to handle asynchronous I/O.  */
 struct async_waitlist
@@ -72,7 +75,8 @@
       {
 	list[cnt]->aio_sigevent.sigev_notify = SIGEV_NONE;
 	requests[cnt] = __aio_enqueue_request ((aiocb_union *) list[cnt],
-					       list[cnt]->aio_lio_opcode);
+					       (list[cnt]->aio_lio_opcode
+					        | LIO_OPCODE_BASE));
 
 	if (requests[cnt] != NULL)
 	  /* Successfully enqueued.  */
@@ -96,8 +100,14 @@
       pthread_mutex_unlock (&__aio_requests_mutex);
 
       if (mode == LIO_NOWAIT)
+	{
+#ifdef BROKEN_THREAD_SIGNALS
 	__aio_notify_only (sig,
 			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
+#else
+	__aio_notify_only (sig);
+#endif
+	}
 
       return result;
     }
@@ -118,7 +128,9 @@
 	      waitlist[cnt].next = requests[cnt]->waiting;
 	      waitlist[cnt].counterp = &total;
 	      waitlist[cnt].sigevp = NULL;
+#ifdef BROKEN_THREAD_SIGNALS
 	      waitlist[cnt].caller_pid = 0;	/* Not needed.  */
+#endif
 	      requests[cnt]->waiting = &waitlist[cnt];
 	      ++total;
 	    }
@@ -155,7 +167,9 @@
 	}
       else
 	{
+#ifdef BROKEN_THREAD_SIGNALS
 	  pid_t caller_pid = sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0;
+#endif
 	  total = 0;
 
 	  for (cnt = 0; cnt < nent; ++cnt)
@@ -169,7 +183,9 @@
 		  waitlist->list[cnt].next = requests[cnt]->waiting;
 		  waitlist->list[cnt].counterp = &waitlist->counter;
 		  waitlist->list[cnt].sigevp = &waitlist->sigev;
+#ifdef BROKEN_THREAD_SIGNALS
 		  waitlist->list[cnt].caller_pid = caller_pid;
+#endif
 		  requests[cnt]->waiting = &waitlist->list[cnt];
 		  ++total;
 		}
diff -Nur sysdeps/standalone/arm/sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/arm/sysdep.c
--- sysdeps/standalone/arm/sysdep.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/arm/sysdep.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-/* errno has to be defined somewhere, and it might as well be here.  */
-int errno = 0;
-
-/* The same goes for these magic signal functions.  This is a standalone
-   environment so we do nothing.  */
-void _sig_dfl(int sig)
-{
-}
-
-void _sig_ign(int sig)
-{
-}
diff -Nur sysdeps/standalone/bits/errno.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/bits/errno.h
--- sysdeps/standalone/bits/errno.h	2002-07-18 02:17:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/bits/errno.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Copyright (C) 1991, 1994, 1996, 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This file defines the `errno' constants.  */
-
-#if !defined __Emath_defined && (defined _ERRNO_H || defined __need_Emath)
-#undef	__need_Emath
-#define	__Emath_defined	1
-
-# define EDOM	1
-# define EILSEQ 17
-# define ERANGE	2
-#endif
-
-#ifdef	_ERRNO_H
-# define ENOSYS	3
-# define EINVAL	4
-# define ESPIPE	5
-# define EBADF	6
-# define ENOMEM	7
-# define EACCES	8
-# define ENFILE  9
-# define EMFILE  10
-# define ENOMSG  11
-# define ENAMETOOLONG 12
-# define ELOOP 13
-# define E2BIG 15
-# define EINTR 16
-# define ENOEXEC 18
-# define ENOENT 19
-# define EPROTOTYPE 20
-# define ESRCH 21
-# define EPERM 22
-# define EEXIST 23
-# define ENOTDIR 24
-# define ESTALE 25
-# define ENOTTY 26
-# define EISDIR 27
-# define EOPNOTSUPP 28
-# define EAGAIN 29
-# define EIO 30
-# define ENOSPC 31
-# define EBUSY 32
-#endif
diff -Nur sysdeps/standalone/brk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/brk.c
--- sysdeps/standalone/brk.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/brk.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/* Copyright (C) 1991, 1994, 1995, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <stdlib.h>
-
-void *__curbrk;
-void *__rorig;
-void *__rlimit;
-
-int
-__brk (inaddr)
-     void *inaddr;
-{
-
-  if ( ( (void *)inaddr > (void *)__rlimit ) ||
-                        ( (void *)inaddr < (void *)__rorig ) )
-    return -1;
-
-  __curbrk = inaddr;
-  return 0;
-}
-
-/* Initialization Code for Memory Allocation */
-
-void *__C_heap_start;
-int __C_heap_size;
-
-#ifdef HAVE_GNU_LD
-static
-#endif
-void
-__NONE_set_memvals (argc, argv, envp)
-     int argc;
-     char **argv;
-     char **envp;
-{
-
-  __rorig  =
-  __curbrk = __C_heap_start;
-  __rlimit = __curbrk + __C_heap_size;
-
-  (void) &__NONE_set_memvals;    /* Avoid "defined but not used" warning.  */
-}
-
-#ifdef  HAVE_GNU_LD
-text_set_element (__libc_subinit, __NONE_set_memvals);
-#endif
-
-weak_alias (__brk, brk)
diff -Nur sysdeps/standalone/close.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/close.c
--- sysdeps/standalone/close.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/close.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Copyright (C) 1994, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#define _STDIO_H
-#include <bits/stdio_lim.h>
-#include "filedesc.h"
-
-/* Close the file descriptor FD.  */
-int
-__close (fd)
-     int fd;
-{
-  if ( !__FD_Is_valid( fd ) || !__FD_Table[ fd ].in_use )
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-
-  __FD_Table[ fd ].in_use = 0;
-  return 0;
-}
-libc_hidden_def (__close)
-weak_alias (__close, close)
diff -Nur sysdeps/standalone/dirstream.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/dirstream.h
--- sysdeps/standalone/dirstream.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/dirstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef	_DIRSTREAM_H
-
-#define	_DIRSTREAM_H	1
-
-#define __need_size_t
-#include <stddef.h>
-
-/* Directory stream type.
-
-   The miscellaneous Unix `readdir' implementations read directory data
-   into a buffer and fill in a `struct dirent' copy in the `DIR' object. */
-
-struct __dirstream
-  {
-    int __fd;			/* File descriptor.  */
-
-    char *__data;		/* Directory block.  */
-    size_t __allocation;	/* Space allocated for the block.  */
-    size_t __offset;		/* Current offset into the block.  */
-    size_t __size;		/* Total valid data in the block.  */
-
-    struct dirent __entry;	/* Returned by `readdir'.  */
-  };
-
-#endif	/* dirstream.h */
diff -Nur sysdeps/standalone/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/Dist
--- sysdeps/standalone/Dist	1994-08-26 08:15:51.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-filedesc.h
-standalone.h
diff -Nur sysdeps/standalone/filedesc.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/filedesc.h
--- sysdeps/standalone/filedesc.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/filedesc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-/* Copyright (C) 1994, 1997, 1998 Free Software Foundation, Inc.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- *  This is the file descriptor used by the no OS implementation
- *  of __open, __read, __write, and __close.
- */
-
-#ifndef __FILEDESC_h
-#define __FILEDESC_h
-
-#define __need_FOPEN_MAX
-#include <bits/stdio_lim.h>
-
-#ifndef __DECLARE_FILE_DESCRIPTORS__
-#define FILEDESC_EXTERN extern
-#else
-#define FILEDESC_EXTERN
-#endif
-
-typedef struct {
-  int  in_use;         /* 1 if in use, 0 otherwise */
-  int  flags;          /* Flags from open */
-}   __no_os_file_descriptor;
-
-#define __FD_Is_valid( _fd ) \
-  ( (_fd) >= 0 && (_fd) < FOPEN_MAX )
-
-FILEDESC_EXTERN __no_os_file_descriptor __FD_Table[ FOPEN_MAX ];
-
-#endif
diff -Nur sysdeps/standalone/i386/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/Dist
--- sysdeps/standalone/i386/Dist	1994-11-15 07:34:25.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-i386.h
diff -Nur sysdeps/standalone/i386/force_cpu386/brdinit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/brdinit.c
--- sysdeps/standalone/i386/force_cpu386/brdinit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/brdinit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "i386.h"
-
-/*  _Board_Initialize()
-
-This routine initializes the FORCE CPU386 board.  */
-
-void _Console_Initialize __P ((void));
-
-void
-_Board_Initialize ()
-{
-  /*
-   *  FORCE documentation incorrectly states that the bus request
-   *  level is initialized to 3.  It is actually initialized by
-   *  FORCEbug to 0.
-   */
-
-  outport_byte (0x00, 0x3f);      /* resets VMEbus request level */
-
-  _Console_Initialize ();
-}
diff -Nur sysdeps/standalone/i386/force_cpu386/console.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/console.c
--- sysdeps/standalone/i386/force_cpu386/console.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/console.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "i386.h"
-
-/* Console IO routines for a FORCE CPU386 board. */
-
-/* Force CPU/386 specific IO addressing
- *
- * The following determines whether Port B or the Console should
- * be used for console I/O.  Setting ONE (and only ONE) of these to 1
- * enables I/O on that port.
- *
- *     PORT A - DUSCC MC68562 Channel A  (*** not supported here ***)
- *     PORT B - DUSCC MC68562 Channel B
- *     PORT C - MFP MC68901 Channel      (*** FORCEbug console ***)
- */
-
-#define PORTB         1               /* use port b as console */
-#define PORTC         0               /* use console port as console */
-
-#if ( PORTB == 1 )
-#define TX_STATUS     0x1b6           /* DUSCC General Status Register */
-#define RX_STATUS     0x1b6           /* DUSCC General Status Register */
-#define TX_BUFFER     0x1e0           /* DUSCC Transmitter Channel B */
-#define RX_BUFFER     0x1e8           /* DUSCC Receiver Channel B */
-#define Is_tx_ready( _status ) ( (_status) & 0x20 )
-#define Is_rx_ready( _status ) ( (_status) & 0x10 )
-#endif
-
-#if ( PORTC == 1 )
-#define TX_STATUS     0x12c           /* MFP Transmit Status Register */
-#define RX_STATUS     0x12a           /* MFP Receive Status Register */
-#define TX_BUFFER     0x12e           /* MFP Transmitter Channel  */
-#define RX_BUFFER     0x12e           /* MFP Receiver Channel  */
-#define Is_tx_ready( _status ) ( (_status) & 0x80 )
-#define Is_rx_ready( _status ) ( (_status) & 0x80 )
-#endif
-
-/* _Console_Initialize
-
-On the Force board the console require some initialization. */
-
-void
-_Console_Initialize ()
-{
-  register unsigned8 ignored;
-
-  /* FORCE technical support mentioned that it may be necessary to
-     read the DUSCC RX_BUFFER port four times to remove all junk.
-     This code is a little more paranoid.  */
-
-  inport_byte( RX_BUFFER, ignored );
-  inport_byte( RX_BUFFER, ignored );
-  inport_byte( RX_BUFFER, ignored );
-  inport_byte( RX_BUFFER, ignored );
-  inport_byte( RX_BUFFER, ignored );
-}
-
-/* Miscellaneous support for console IO */
-
-static inline int _Force386_is_rx_ready ()
-{
-  register unsigned8 status;
-
-  inport_byte( RX_STATUS, status );
-
-  if ( Is_rx_ready( status ) ) return 1;
-  else                         return 0;
-}
-
-static inline int _Force386_is_tx_ready ()
-{
-  register unsigned8 status;
-
-  inport_byte( TX_STATUS, status );
-
-  if ( Is_tx_ready( status ) ) return 1;
-  else                         return 0;
-}
-
-
-static inline int _Force386_read_data ()
-{
-  register unsigned8 ch;
-
-#if ( PORTB == 1 )
-    /* Force example code resets the Channel B Receiver here.
-     * It appears to cause XON's to be lost.
-     */
-
-     /* outport_byte( RX_STATUS, 0x10 );  */
-#endif
-
-  inport_byte( RX_BUFFER, ch );
-
-  return ch;
-}
-
-/* _Console_Putc
-
-This routine transmits a character.  It supports XON/XOFF flow control.  */
-
-#define XON             0x11            /* control-Q */
-#define XOFF            0x13            /* control-S */
-
-int
-_Console_Putc (ch)
-     char ch;
-{
-  register unsigned8 inch;
-
-  while ( !_Force386_is_tx_ready() );
-
-  while ( _Force386_is_rx_ready() == 1 ) {      /* must be an XOFF */
-    inch = _Force386_read_data();
-    if ( inch == XOFF )
-      do {
-        while ( _Force386_is_rx_ready() == 0 );
-        inch = _Force386_read_data();
-      } while ( inch != XON );
-  }
-
-  outport_byte( TX_BUFFER, ch );
-  return( 0 );
-}
-
-/* _Console_Getc
-
-This routine reads a character from the UART and returns it. */
-
-int
-_Console_Getc (poll)
-     int poll;
-{
-  if ( poll ) {
-    if ( !_Force386_is_rx_ready() )
-      return -1;
-    else
-      return _Force386_read_data();
-  } else {
-    while ( !_Force386_is_rx_ready() );
-    return _Force386_read_data();
-  }
-}
diff -Nur sysdeps/standalone/i386/force_cpu386/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/Dist
--- sysdeps/standalone/i386/force_cpu386/Dist	1994-11-01 09:32:25.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-target.ld
diff -Nur sysdeps/standalone/i386/force_cpu386/_exit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/_exit.c
--- sysdeps/standalone/i386/force_cpu386/_exit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/_exit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/* Copyright (C) 1991, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <unistd.h>
-#include <stdlib.h>
-
-/* This returns control to FORCEbug. */
-
-void Bsp_cleanup __P ((void));
-
-/* The function `_exit' should take a status argument and simply
-   terminate program execution, using the low-order 8 bits of the
-   given integer as status.  */
-
-__NORETURN void
-_exit (status)
-     int status;
-{
-  /* status is ignored */
-  Bsp_cleanup();
-}
-weak_alias (_exit, _Exit)
-
-#ifdef	 HAVE_GNU_LD
-
-#include <gnu-stabs.h>
-
-stub_warning(_exit);
-
-#endif	/* GNU stabs.  */
diff -Nur sysdeps/standalone/i386/force_cpu386/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/Makefile
--- sysdeps/standalone/i386/force_cpu386/Makefile	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-# Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-# Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-#   On-Line Applications Research Corporation.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; if not, write to the Free
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-# 02111-1307 USA.
-
-ifeq (bare,$(subdir))
-install-others += $(inst_libdir)/force_cpu386.ld
-$(inst_libdir)/force_cpu386.ld: $(sysdep_dir)/standalone/i386/target.ld \
-				$(+force)
-	$(do-install)
-endif
diff -Nur sysdeps/standalone/i386/force_cpu386/strtsupp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/strtsupp.S
--- sysdeps/standalone/i386/force_cpu386/strtsupp.S	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/strtsupp.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  This file assists the board independent startup code by
- *  loading the proper segment register values.  The values
- *  loaded are dependent on the FORCEBUG.
- *
- *  NOTE:  No stack has been established when this routine
- *         is invoked.  It returns by jumping back to the start code.
- *
- */
-
-/*
- *  FORCEBUG loads us into a virtual address space which
- *  really starts at PHYSICAL_ADDRESS_BASE.
- *
- */
-
-.set PHYSICAL_ADDRESS_BASE,    0x00002000
-
-/*
- *  At reset time, FORCEBUG normally has the segment selectors preloaded.
- *  If a human resets the instruction pointer, this will not have occurred.
- *  However, no guarantee can be made of the other registers if cs:ip was
- *  modified to restart the program.  Because of this, the BSP reloads all
- *  segment registers (except cs) with the values they have following
- *  a reset.
- */
-
-
-.set RESET_SS, 0x40        # initial value of stack segment register
-.set RESET_DS, 0x40        # initial value of data segment register
-.set RESET_ES, 0x40        # initial value of extra segment register
-.set RESET_FS, 0x40        # initial value of "f" segment register
-.set RESET_GS, 0x30        # initial value of "g" segment register
-
-
-#define LOAD_SEGMENTS(_value,_segreg) \
-	movw      $_value##,%ax ;  \
-	movw      %ax,##_segreg
-
-
-	.global  _load_segments
-
-	.global   _establish_stack
-
-_load_segments:
-
-	LOAD_SEGMENTS( RESET_SS, %ss )
-	LOAD_SEGMENTS( RESET_DS, %ds )
-	LOAD_SEGMENTS( RESET_ES, %es )
-	LOAD_SEGMENTS( RESET_FS, %fs )
-	LOAD_SEGMENTS( RESET_GS, %gs )
-
-	jmp     _establish_stack        # return to the bsp entry code
-
-	.global  _return_to_monitor
-_return_to_monitor:
-
-	movb    $0,%al
-	int     $0x20                   # restart FORCEbug
-	jmp     start                   # FORCEbug does not reset PC
-
-	.data
-
-	.global _Do_Load_IDT
-_Do_Load_IDT:   .byte 1
-
-	.global _Do_Load_GDT
-_Do_Load_GDT:   .byte 0
diff -Nur sysdeps/standalone/i386/force_cpu386/target.ld /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/target.ld
--- sysdeps/standalone/i386/force_cpu386/target.ld	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/force_cpu386/target.ld	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This file contains directives for the GNU linker which are specific
-to the FORCE CPU386 board.  */
-
-MEMORY
-        {
-        ram : org = 0x0, l = 1M
-        }
-
-/* This value is also when the space is allocated.  If you change
-this one, change the other one!!! */
-
-heap_size = 0x20000;
-
-SECTIONS
-{
-        .text 0x0 :
-        {
-            _text_start = ABSOLUTE(.) ;
-            *(.text)
-            _etext = ALIGN( 0x10 ) ;
-        }
-        .data ADDR( .text ) + SIZEOF( .text ):
-        {
-            _data_start = . ;
-            *(.data)
-            _edata = ALIGN( 0x10 ) ;
-        }
-        .bss ADDR( .data ) + SIZEOF( .data ):
-        {
-            _bss_start = . ;
-            *(.bss)
-            *(COMMON)
-            heap_memory = .;
-            . += 0x20000;
-            _end = . ;
-            __end = . ;
-        }
-}
diff -Nur sysdeps/standalone/i386/i386.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/i386.h
--- sysdeps/standalone/i386/i386.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/i386.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,326 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  i386.h
- *
- *  This file contains macros which are used to access i80386
- *  registers which are not addressable by C.  This file contains
- *  functions which are useful to those developing target
- *  specific support routines.
- */
-
-#ifndef i386_h__
-#define i386_h__
-
-typedef unsigned char   unsigned8;
-typedef unsigned short  unsigned16;
-typedef unsigned int    unsigned32;
-
-#define disable_intr( isrlevel ) \
-  { (isrlevel) = 0; \
-    asm volatile ( "pushf ; \
-		    pop  %0 ; \
-		    cli   " \
-		    : "=r" ((isrlevel)) : "0" ((isrlevel)) ); \
-  }
-
-
-#define enable_intr( isrlevel ) \
-  { asm volatile ( "push %0 ; \
-		    popf " \
-		    : "=r" ((isrlevel)) : "0" ((isrlevel)) ); \
-  }
-
-#define delay( _microseconds ) \
-  { \
-    unsigned32 _counter; \
-    \
-    _counter = (_microseconds); \
-    \
-    asm volatile ( "0: nop;" \
-		   " mov %0,%0 ;" \
-		   " loop 0" : "=c" (_counter) \
-				      : "0"  (_counter) \
-		 ); \
-    \
-  }
-
-/* segment access functions */
-
-static inline unsigned16 get_cs()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%cs,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-static inline unsigned16 get_ds()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%ds,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-static inline unsigned16 get_es()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%es,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-static inline unsigned16 get_ss()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%ss,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-static inline unsigned16 get_fs()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%fs,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-static inline unsigned16 get_gs()
-{
-  register unsigned16 segment = 0;
-
-  asm volatile ( "movw %%gs,%0" : "=r" (segment) : "0" (segment) );
-
-  return segment;
-}
-
-/* i80x86 I/O instructions */
-
-#define outport_byte( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned8  __value = _value; \
-     \
-     asm volatile ( "outb %0,%1" : "=a" (__value), "=d" (__port) \
-				 : "0"   (__value), "1"  (__port) \
-		  ); \
-   }
-
-#define outport_word( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned16 __value = _value; \
-     \
-     asm volatile ( "outw %0,%1" : "=a" (__value), "=d" (__port) \
-				 : "0"   (__value), "1"  (__port) \
-		  ); \
-   }
-
-#define outport_long( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned32 __value = _value; \
-     \
-     asm volatile ( "outl %0,%1" : "=a" (__value), "=d" (__port) \
-				 : "0"   (__value), "1"  (__port) \
-		  ); \
-   }
-
-#define inport_byte( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned8  __value = 0; \
-     \
-     asm volatile ( "inb %1,%0" : "=a" (__value), "=d" (__port) \
-				: "0"   (__value), "1"  (__port) \
-		  ); \
-     _value = __value; \
-   }
-
-#define inport_word( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned16 __value = 0; \
-     \
-     asm volatile ( "inw %1,%0" : "=a" (__value), "=d" (__port) \
-				: "0"   (__value), "1"  (__port) \
-		  ); \
-     _value = __value; \
-   }
-
-#define inport_long( _port, _value ) \
-   { register unsigned16 __port  = _port; \
-     register unsigned32 __value = 0; \
-     \
-     asm volatile ( "inl %1,%0" : "=a" (__value), "=d" (__port) \
-				: "0"   (__value), "1"  (__port) \
-		  ); \
-     _value = __value; \
-   }
-
-/* structures */
-
-/* See Chapter 5 - Memory Management in i386 manual */
-
-struct GDT_slot {
-  unsigned16 limit_0_15;
-  unsigned16 base_0_15;
-  unsigned8  base_16_23;
-  unsigned8  type_dt_dpl_p;
-  unsigned8  limit_16_19_granularity;
-  unsigned8  base_24_31;
-};
-
-/* See Chapter 9 - Exceptions and Interrupts in i386 manual
- *
- *  NOTE: This is the IDT entry for interrupt gates ONLY.
- */
-
-struct IDT_slot {
-  unsigned16 offset_0_15;
-  unsigned16 segment_selector;
-  unsigned8  reserved;
-  unsigned8  p_dpl;
-  unsigned16 offset_16_31;
-};
-
-struct DTR_load_save_format {
-  unsigned16 limit;
-  unsigned32 physical_address;
-};
-
-/* variables */
-
-extern struct IDT_slot Interrupt_descriptor_table[ 256 ];
-extern struct GDT_slot Global_descriptor_table[ 8192 ];
-
-/* functions */
-
-#ifdef CPU_INITIALIZE
-#define EXTERN
-#else
-#undef EXTERN
-#define EXTERN extern
-#endif
-
-void *Logical_to_physical(
-  unsigned16  segment,
-  void             *address
-);
-
-void *Physical_to_logical(
-  unsigned16  segment,
-  void             *address
-);
-
-/* complicated static inline functions */
-
-#define get_GDTR( _gdtr_address ) \
-  { \
-    void                        *_gdtr = (_gdtr_address); \
-    \
-    asm volatile( "sgdt   (%0)" : "=r" (_gdtr) : "0" (_gdtr) ); \
-  }
-
-#define get_GDT_slot( _gdtr_base, _segment, _slot_address ) \
-  { \
-    register unsigned32  _gdt_slot  = (_gdtr_base) + (_segment); \
-    register volatile void    *_slot      = (_slot_address); \
-    register unsigned32  _temporary = 0; \
-    \
-    asm volatile( "movl %%gs:(%0),%1 ; \
-		   movl %1,(%2) ; \
-		   movl %%gs:4(%0),%1 ; \
-		   movl %1,4(%2)"  \
-		     : "=r" (_gdt_slot), "=r" (_temporary), "=r" (_slot) \
-		     : "0"  (_gdt_slot), "1"  (_temporary), "2"  (_slot) \
-		);  \
-  }
-
-#define set_GDT_slot( _gdtr_base, _segment, _slot_address ) \
-  { \
-    register unsigned32  _gdt_slot  = (_gdtr_base) + (_segment); \
-    register volatile void    *_slot      = (_slot_address); \
-    register unsigned32  _temporary = 0; \
-    \
-    asm volatile( "movl (%2),%1 ; \
-		   movl %1,%%gs:(%0) ; \
-		   movl 4(%2),%1 ; \
-		   movl %1,%%gs:4(%0) \
-		  " \
-		     : "=r" (_gdt_slot), "=r" (_temporary), "=r" (_slot) \
-		     : "0"  (_gdt_slot), "1"  (_temporary), "2"  (_slot) \
-		);  \
-  }
-
-static inline void set_segment(
-  unsigned16 segment,
-  unsigned32 base,
-  unsigned32 limit
-)
-{
-  struct DTR_load_save_format  gdtr;
-  volatile struct GDT_slot     Gdt_slot;
-  volatile struct GDT_slot    *gdt_slot = &Gdt_slot;
-  unsigned16             tmp_segment = 0;
-  unsigned32             limit_adjusted;
-
-
-  /* load physical address of the GDT */
-
-  get_GDTR( &gdtr );
-
-  gdt_slot->type_dt_dpl_p  = 0x92;             /* present, dpl=0,      */
-					       /* application=1,       */
-					       /* type=data read/write */
-  gdt_slot->limit_16_19_granularity = 0x40;    /* 32 bit segment       */
-
-  limit_adjusted = limit;
-  if ( limit > 4095 ) {
-    gdt_slot->limit_16_19_granularity |= 0x80; /* set granularity bit */
-    limit_adjusted /= 4096;
-  }
-
-  gdt_slot->limit_16_19_granularity |= (limit_adjusted >> 16) & 0xff;
-  gdt_slot->limit_0_15               = limit_adjusted & 0xffff;
-
-  gdt_slot->base_0_15  = base & 0xffff;
-  gdt_slot->base_16_23 = (base >> 16) & 0xff;
-  gdt_slot->base_24_31 = (base >> 24);
-
-  set_GDT_slot( gdtr.physical_address, segment, gdt_slot );
-
-  /* Now, reload all segment registers so the limit takes effect. */
-
-  asm volatile( "movw %%ds,%0 ; movw %0,%%ds\n"
-		"movw %%es,%0 ; movw %0,%%es\n"
-		"movw %%fs,%0 ; movw %0,%%fs\n"
-		"movw %%gs,%0 ; movw %0,%%gs\n"
-		"movw %%ss,%0 ; movw %0,%%ss"
-		   : "=r" (tmp_segment)
-		   : "0"  (tmp_segment)
-	      );
-
-}
-
-#endif
-/* end of include file */
diff -Nur sysdeps/standalone/i386/start.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/start.S
--- sysdeps/standalone/i386/start.S	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i386/start.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,321 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  entry.s
- *
- *  This file contains the entry point for the application.
- *  The name of this entry point is compiler dependent.
- *  It jumps to the BSP which is responsible for performing
- *  all initialization.
- *
- */
-
-	.data
-	.global  _Do_Load_IDT
-	.global  _Do_Load_GDT
-
-	.text
-	      .global  start                  # GNU default entry point
-	.global  _establish_stack
-
-	.global   _bsp_start
-	.global   _load_segments
-	.global   __exit
-
-start:
-	nop
-	cli                             # DISABLE INTERRUPTS!!!
-#
-#  Load the segment registers
-#
-#  NOTE: Upon return, gs will contain the segment descriptor for
-#        a segment which maps directly to all of physical memory.
-#
-	jmp     _load_segments          # load board dependent segments
-
-#
-#  Set up the stack
-#
-
-_establish_stack:
-
-	movl    $stack_end,%esp         # set stack pointer
-	movl    $stack_end,%ebp         # set base pointer
-
-#
-#  Zero out the BSS segment
-#
-zero_bss:
-	cld                             # make direction flag count up
-	movl    $_end,%ecx              # find end of .bss
-	movl    $_bss_start,%edi        # edi = beginning of .bss
-	subl    %edi,%ecx               # ecx = size of .bss in bytes
-	shrl    $2,%ecx                 # size of .bss in longs
-	xorl    %eax,%eax               # value to clear out memory
-	repne                           # while ecx != 0
-	stosl                           #   clear a long in the bss
-
-#
-#  Set the C heap information for malloc
-#
-	movl    $heap_size,___C_heap_size    # set ___C_heap_size
-	movl    $heap_memory,___C_heap_start # set ___C_heap_start
-
-#
-#  Copy the Global Descriptor Table to our space
-#
-
-	sgdt    _Original_GDTR          # save original GDT
-	movzwl  _Original_GDTR_limit,%ecx # size of GDT in bytes; limit
-					  #   is 8192 entries * 8 bytes per
-
-	# make ds:esi point to the original GDT
-
-	movl    _Original_GDTR_base,%esi
-	push    %ds                     # save ds
-	movw    %gs,%ax
-	movw    %ax,%ds
-
-	# make es:edi point to the new (our copy) GDT
-	movl    $_Global_descriptor_table,%edi
-
-	rep
-	movsb                            # copy the GDT (ds:esi -> es:edi)
-
-	pop     %ds                      # restore ds
-
-	# Build and load new contents of GDTR
-	movw    _Original_GDTR_limit,%ecx # set new limit
-	movw    %cx,_New_GDTR_limit
-
-	push    $_Global_descriptor_table
-	push    %es
-	call    _Logical_to_physical
-	addl    $6,%esp
-	movl    %eax,_New_GDTR_base      # set new base
-
-	cmpb    $0,_Do_Load_GDT          # Should the new GDT be loaded?
-	je      no_gdt_load              # NO, then branch
-	lgdt    _New_GDTR                # load the new GDT
-no_gdt_load:
-
-#
-#  Copy the Interrupt Descriptor Table to our space
-#
-
-	sidt    _Original_IDTR          # save original IDT
-	movzwl  _Original_IDTR_limit,%ecx # size of IDT in bytes; limit
-					  #   is 256 entries * 8 bytes per
-
-
-	# make ds:esi point to the original IDT
-	movl    _Original_IDTR_base,%esi
-
-	push    %ds                     # save ds
-	movw    %gs,%ax
-	movw    %ax,%ds
-
-	# make es:edi point to the new (our copy) IDT
-	movl    $_Interrupt_descriptor_table,%edi
-
-	rep
-	movsb                            # copy the IDT (ds:esi -> es:edi)
-	pop     %ds                      # restore ds
-
-	# Build and load new contents of IDTR
-	movw    _Original_IDTR_limit,%ecx # set new limit
-	movw    %cx,_New_IDTR_limit
-
-	push    $_Interrupt_descriptor_table
-	push    %es
-	call    _Logical_to_physical
-	addl    $6,%esp
-	movl    %eax,_New_IDTR_base      # set new base
-
-	cmpb    $0,_Do_Load_IDT          # Should the new IDT be loaded?
-	je      no_idt_load              # NO, then branch
-	lidt    _New_IDTR                # load the new IDT
-no_idt_load:
-
-#
-#  Initialize the i387.
-#
-#  Using the NO WAIT form of the instruction insures that if
-#  it is not present the board will not lock up or get an
-#  exception.
-#
-
-	fninit                           # MUST USE NO-WAIT FORM
-
-	call    __Board_Initialize       # initialize the board
-
-	pushl   $0                       # envp = NULL
-	pushl   $0                       # argv = NULL
-	pushl   $0                       # argc = NULL
-	call    ___libc_init             # initialize the library and
-					 #   call main
-	addl    $12,%esp
-
-	pushl   $0                       # argc = NULL
-	call    __exit                   # call the Board specific exit
-	addl     $4,%esp
-
-#
-#  Clean up
-#
-
-
-	.global  _Bsp_cleanup
-
-	.global   _return_to_monitor
-
-_Bsp_cleanup:
-	cmpb    $0,_Do_Load_IDT          # Was the new IDT loaded?
-	je      no_idt_restore           # NO, then branch
-	lidt    _Original_IDTR           # restore the new IDT
-no_idt_restore:
-
-	cmpb    $0,_Do_Load_GDT          # Was the new GDT loaded?
-	je      no_gdt_restore           # NO, then branch
-	lgdt    _Original_GDTR           # restore the new GDT
-no_gdt_restore:
-	jmp     _return_to_monitor
-
-#
-#  void *Logical_to_physical(
-#     rtems_unsigned16  segment,
-#     void             *address
-#  );
-#
-#  Returns thirty-two bit physical address for segment:address.
-#
-
-	.global  _Logical_to_physical
-
-.set SEGMENT_ARG, 4
-.set ADDRESS_ARG, 8
-
-_Logical_to_physical:
-
-	xorl    %eax,%eax                # clear eax
-	movzwl  SEGMENT_ARG(%esp),%ecx   # ecx = segment value
-	movl    $_Global_descriptor_table,%edx # edx = address of our GDT
-	addl    %ecx,%edx                # edx = address of desired entry
-	movb    7(%edx),%ah              # ah = base 31:24
-	movb    4(%edx),%al              # al = base 23:16
-	shll    $16,%eax                 # move ax into correct bits
-	movw    2(%edx),%ax              # ax = base 0:15
-	movl    ADDRESS_ARG(%esp),%ecx   # ecx = address to convert
-	addl    %eax,%ecx                # ecx = physical address equivalent
-	movl    %ecx,%eax                # eax = ecx
-	ret
-
-#
-#  void *Physical_to_logical(
-#     rtems_unsigned16  segment,
-#     void             *address
-#  );
-#
-#  Returns thirty-two bit physical address for segment:address.
-#
-
-	.global  _Physical_to_logical
-
-#.set SEGMENT_ARG, 4
-#.set ADDRESS_ARG, 8   -- use sets from above
-
-_Physical_to_logical:
-
-	xorl    %eax,%eax                # clear eax
-	movzwl  SEGMENT_ARG(%esp),%ecx   # ecx = segment value
-	movl    $_Global_descriptor_table,%edx # edx = address of our GDT
-	addl    %ecx,%edx                # edx = address of desired entry
-	movb    7(%edx),%ah              # ah = base 31:24
-	movb    4(%edx),%al              # al = base 23:16
-	shll    $16,%eax                 # move ax into correct bits
-	movw    2(%edx),%ax              # ax = base 0:15
-	movl    ADDRESS_ARG(%esp),%ecx   # ecx = address to convert
-	subl    %eax,%ecx                # ecx = logical address equivalent
-	movl    %ecx,%eax                # eax = ecx
-	ret
-
-
-/*
- *  Data Declarations.  Start with a macro which helps declare space.
- */
-
-	.bss
-
-#define DECLARE_SPACE(_name,_space,_align) \
-	  .globl   _name ; \
-	  .align   _align ; \
-_name##:  .space _space
-
-#define DECLARE_LABEL(_name) \
-	  .globl   _name ; \
-_name##:
-
-#define DECLARE_PTR(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U32(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U16(_name) DECLARE_SPACE(_name,2,1)
-
-/*
- *  Require environment stuff
- */
-
-DECLARE_LABEL(_environ)
-DECLARE_PTR(environ)
-
-DECLARE_LABEL(_errno)
-DECLARE_U32(errno)
-
-/*
- *  Miscellaneous Variables used to restore the CPU state.
- *
- *  Start with a macro to declare the space for the contents of
- *  a Descriptor Table register.
- */
-
-#define DECLARE_DTR_SPACE(_name) \
-	  .global   _name ; \
-	  .align    4 ; \
-_name##:  ; \
-_name##_limit:  .space 2  ; \
-_name##_base:   .space 4
-
-DECLARE_SPACE(_Interrupt_descriptor_table,256*8,4)
-DECLARE_SPACE(_Global_descriptor_table,8192*8,4)
-
-DECLARE_DTR_SPACE(_Original_IDTR)
-DECLARE_DTR_SPACE(_New_IDTR)
-DECLARE_DTR_SPACE(_Original_GDTR)
-DECLARE_DTR_SPACE(_New_GDTR)
-
-DECLARE_SPACE(_Physical_base_of_ds,4,4)
-DECLARE_SPACE(_Physical_base_of_cs,4,4)
-
-/*
- *  Stack Size and Space
- */
-
-	.set stack_size, 0x20000
-
-DECLARE_SPACE(stack_memory,stack_size,4)
-DECLARE_LABEL(stack_end)
diff -Nur sysdeps/standalone/i960/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/Dist
--- sysdeps/standalone/i960/Dist	1994-09-16 04:14:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-i960ca.h
diff -Nur sysdeps/standalone/i960/i960ca.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/i960ca.h
--- sysdeps/standalone/i960/i960ca.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/i960ca.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,206 +0,0 @@
-/* Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-   On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* i960ca.h
- *
- *  This file contains macros which are used to access i80960CA
- *  registers which are not addressable by C.  The functions
- *  in this file should be useful to the developer of target
- *  specific code.
- */
-
-#ifndef i960ca_h__
-#define i960ca_h__
-
-typedef unsigned char   unsigned8;
-typedef unsigned short  unsigned16;
-typedef unsigned int    unsigned32;
-
-/*
- *  Intel i80960CA Processor Control Block
- */
-
-struct i80960ca_prcb {
-  unsigned32          *fault_tbl;     /* fault table base address     */
-  struct i80960ca_ctltbl
-                      *control_tbl;   /* control table base address   */
-  unsigned32           initial_ac;    /* AC register initial value    */
-  unsigned32           fault_config;  /* fault configuration word     */
-  void                *intr_tbl;      /* interrupt table base address */
-  void                *sys_proc_tbl;  /* system procedure table       */
-                                      /*   base address               */
-  unsigned32           reserved;      /* reserved                     */
-  unsigned32          *intr_stack;    /* interrupt stack pointer      */
-  unsigned32           ins_cache_cfg; /* instruction cache            */
-                                      /*   configuration word         */
-  unsigned32           reg_cache_cfg; /* register cache               */
-                                      /*   configuration word         */
-};
-
-/*
- *  Intel i80960CA Control Table
- */
-
-struct i80960ca_ctltbl {
-                            /* Control Group 0 */
-  unsigned32       ipb0;              /* IP breakpoint 0 */
-  unsigned32       ipb1;              /* IP breakpoint 1 */
-  unsigned32       dab0;              /* data address breakpoint 0 */
-  unsigned32       dab1;              /* data address breakpoint 1 */
-                            /* Control Group 1 */
-  unsigned32       imap0;             /* interrupt map 0 */
-  unsigned32       imap1;             /* interrupt map 1 */
-  unsigned32       imap2;             /* interrupt map 2 */
-  unsigned32       icon;              /* interrupt control */
-                            /* Control Group 2 */
-  unsigned32       mcon0;             /* memory region 0 configuration */
-  unsigned32       mcon1;             /* memory region 1 configuration */
-  unsigned32       mcon2;             /* memory region 2 configuration */
-  unsigned32       mcon3;             /* memory region 3 configuration */
-                            /* Control Group 3 */
-  unsigned32       mcon4;             /* memory region 4 configuration */
-  unsigned32       mcon5;             /* memory region 5 configuration */
-  unsigned32       mcon6;             /* memory region 6 configuration */
-  unsigned32       mcon7;             /* memory region 7 configuration */
-                            /* Control Group 4 */
-  unsigned32       mcon8;             /* memory region 8 configuration */
-  unsigned32       mcon9;             /* memory region 9 configuration */
-  unsigned32       mcon10;            /* memory region 10 configuration */
-  unsigned32       mcon11;            /* memory region 11 configuration */
-                            /* Control Group 5 */
-  unsigned32       mcon12;            /* memory region 12 configuration */
-  unsigned32       mcon13;            /* memory region 13 configuration */
-  unsigned32       mcon14;            /* memory region 14 configuration */
-  unsigned32       mcon15;            /* memory region 15 configuration */
-                            /* Control Group 6 */
-  unsigned32       bpcon;             /* breakpoint control */
-  unsigned32       tc;                /* trace control */
-  unsigned32       bcon;              /* bus configuration control */
-  unsigned32       reserved;          /* reserved */
-};
-
-#define disable_intr( oldlevel ) \
-  { (oldlevel) = 0x1f0000; \
-    asm volatile ( "modpc   0,%1,%1" \
-                       : "=d" ((oldlevel)) \
-                       : "0"  ((oldlevel)) ); \
-  }
-
-#define enable_intr( oldlevel ) \
-  { unsigned32 _mask = 0x1f0000; \
-    asm volatile ( "modpc   0,%0,%1" \
-                       : "=d" (_mask), "=d" ((oldlevel)) \
-                       : "0"  (_mask), "1"  ((oldlevel)) ); \
-  }
-
-#define flash_intr( oldlevel ) \
-  { unsigned32 _mask = 0x1f0000; \
-    asm volatile ( "modpc   0,%0,%1 ; \
-                    mov     %0,%1 ; \
-                    modpc   0,%0,%1"  \
-                       : "=d" (_mask), "=d" ((oldlevel)) \
-                       : "0"  (_mask), "1"  ((oldlevel)) ); \
-  }
-
-#define atomic_modify( mask, addr, prev ) \
- { register unsigned32  _mask = (mask); \
-   register unsigned32 *_addr = (unsigned32 *)(addr); \
-   asm volatile( "atmod  %0,%1,%1" \
-                  : "=d" (_addr), "=d" (_mask) \
-                  : "0"  (_addr), "1"  (_mask) ); \
-   (prev) = _mask; \
- }
-
-#define delay( microseconds ) \
-  { register unsigned32 _delay=(microseconds); \
-    register unsigned32 _tmp; \
-    asm volatile( "delay0: \
-                     remo      3,31,%0 ; \
-                     cmpo      0,%0 ; \
-                     subo      1,%1,%1 ; \
-                     cmpobne.t 0,%1,delay0 " \
-                  : "=d" (_tmp), "=d" (_delay) \
-                  : "0"  (_tmp), "1"  (_delay) ); \
-  }
-
-#define enable_tracing() \
- { register unsigned32 _pc = 0x1; \
-   asm volatile( "modpc 0,%0,%0" : "=d" (_pc) : "0" (_pc) ); \
- }
-
-#define unmask_intr( xint ) \
- { register unsigned32 _mask= (1<<(xint)); \
-   asm volatile( "or sf1,%0,sf1" : "=d" (_mask) : "0" (_mask) ); \
- }
-
-#define mask_intr( xint ) \
- { register unsigned32 _mask= (1<<(xint)); \
-   asm volatile( "andnot %0,sf1,sf1" : "=d" (_mask) : "0" (_mask) ); \
- }
-
-#define clear_intr( xint ) \
- { register unsigned32 _xint=(xint); \
-   asm volatile( "loop_til_cleared:" \
-                 "  clrbit %0,sf0,sf0 ;" \
-                 "  bbs    %0,sf0,loop_til_cleared" \
-                 : "=d" (_xint) : "0" (_xint) ); \
- }
-
-#define reload_ctl_group( group ) \
- { register int _cmd = ((group)|0x400) ; \
-   asm volatile( "sysctl %0,%0,%0" : "=d" (_cmd) : "0" (_cmd) ); \
- }
-
-#define cause_intr( intr ) \
- { register int _intr = (intr); \
-   asm volatile( "sysctl %0,%0,%0" : "=d" (_intr) : "0" (_intr) ); \
- }
-
-#define soft_reset( prcb ) \
- { register struct i80960ca_prcb *_prcb = (prcb); \
-   register unsigned32         *_next=0; \
-   register unsigned32          _cmd  = 0x30000; \
-   asm volatile( "lda    next,%1; \
-                  sysctl %0,%1,%2; \
-            next: mov    g0,g0" \
-                  : "=d" (_cmd), "=d" (_next), "=d" (_prcb) \
-                  : "0"  (_cmd), "1"  (_next), "2"  (_prcb) ); \
- }
-
-static inline unsigned32 pend_intrs()
-{ register unsigned32 _intr=0;
-  asm volatile( "mov sf0,%0" : "=d" (_intr) : "0" (_intr) );
-  return ( _intr );
-}
-
-static inline unsigned32 mask_intrs()
-{ register unsigned32 _intr=0;
-  asm volatile( "mov sf1,%0" : "=d" (_intr) : "0" (_intr) );
-  return( _intr );
-}
-
-static inline unsigned32 get_fp()
-{ register unsigned32 _fp=0;
-  asm volatile( "mov fp,%0" : "=d" (_fp) : "0" (_fp) );
-  return ( _fp );
-}
-
-#endif
-/* end of include file */
diff -Nur sysdeps/standalone/i960/nindy960/brdinit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/brdinit.c
--- sysdeps/standalone/i960/nindy960/brdinit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/brdinit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "i960ca.h"
-
-/*  _Board_Initialize()
-
-This routine initializes the board.
-
-NOTE: Only tested on a Cyclone CVME961 but should be OK on any i960ca board. */
-
-void
-_Board_Initialize ()
-{
-  struct i80960ca_prcb   *prcb;     /* ptr to processor control block */
-  struct i80960ca_ctltbl *ctl_tbl;  /* ptr to control table */
-
-  static inline struct i80960ca_prcb *get_prcb()
-  { register struct i80960ca_prcb *_prcb = 0;
-    asm volatile( "calls 5; \
-                   mov   g0,%0" \
-                   : "=d" (_prcb) \
-                   : "0" (_prcb) );
-    return ( _prcb );
-  }
-
-  prcb    = get_prcb ();
-  ctl_tbl = prcb->control_tbl;
-
-  /*   The following configures the data breakpoint (which must be set
-   *   before this is executed) to break on writes only.
-   */
-
-  ctl_tbl->bpcon &= ~0x00cc0000;
-  reload_ctl_group (6);
-
-   /*  bit 31 of the Register Cache Control can be set to
-    *  enable an alternative caching algorithm.  It does
-    *  not appear to help our applications.
-    */
-
-   /* Configure Number of Register Caches */
-
-  prcb->reg_cache_cfg = 8;
-  soft_reset (prcb);
-}
diff -Nur sysdeps/standalone/i960/nindy960/console.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/console.c
--- sysdeps/standalone/i960/nindy960/console.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/console.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "i960ca.h"
-
-/* Console IO routines for a NINDY960 board. */
-
-/*
- *  NINDY_IO( ... )
- *
- *  Interface to NINDY.
- */
-
-#define NINDY_INPUT   0
-#define NINDY_OUTPUT  1
-
-void ___NINDY_IO_WRAPPER( void )  /* never called */
-{
-   asm volatile ( "       .text" );
-   asm volatile ( "       .align 4" );
-   asm volatile ( "       .globl _NINDY_IO" );
-   asm volatile ( "_NINDY_IO:" );
-   asm volatile ( "        calls   0       /* call console routines */" );
-   asm volatile ( "        ret" );
-}
-
-/***** !!!! HOW DO I EXFUN NINDY_IO? !!!! *****/
-
-/* _Console_Putc
-
-This routine transmits a character using NINDY.  */
-
-int
-_Console_Putc (ch)
-     char ch;
-{
-  NINDY_IO( NINDY_OUTPUT, ch );
-  return( 0 );
-}
-
-/* _Console_Getc
-
-This routine reads a character from NINDY and returns it. */
-
-int
-_Console_Getc (poll)
-     int poll;
-{
-  char ch;
-
-  if ( poll ) {
-    /* I don't know how to poll with NINDY */
-    return -1;
-  } else {
-    NINDY_IO( NINDY_INPUT, &ch );
-    return ch;
-  }
-}
diff -Nur sysdeps/standalone/i960/nindy960/_exit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/_exit.c
--- sysdeps/standalone/i960/nindy960/_exit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/_exit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/* Copyright (C) 1991, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <unistd.h>
-#include <stdlib.h>
-
-/* The function `_exit' should take a status argument and simply
-   terminate program execution, using the low-order 8 bits of the
-   given integer as status.  */
-
-/* This returns control to Nindy.  */
-/* XXX where is __NORETURN ? */
-__NORETURN void
-_exit (status)
-     int status;
-{
-  /* status is ignored */
-
-  asm volatile( "mov   0,g0; \
-                 fmark ; \
-           syncf ; \
-           .word    0xfeedface ; \
-                 bx       start" : : );
- /*  The constant 0xfeedface is a magic word for break which
-  *  is defined by NINDY.  The branch extended restarts the
-  *  application if the user types "go".
-  */
-}
-weak_alias (_exit, _Exit)
-
-
-#ifdef	 HAVE_GNU_LD
-
-#include <gnu-stabs.h>
-
-stub_warning(_exit);
-
-#endif	/* GNU stabs.  */
diff -Nur sysdeps/standalone/i960/nindy960/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/Makefile
--- sysdeps/standalone/i960/nindy960/Makefile	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/nindy960/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-# Copyright (C) 1993, 1997 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-# Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-#   On-Line Applications Research Corporation.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; if not, write to the Free
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-# 02111-1307 USA.
-
-
-# The nindy960 support has only been tested on the following boards:
-#
-#   + Cyclone CVME961 VMEbus single board computer.
diff -Nur sysdeps/standalone/i960/start.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/start.S
--- sysdeps/standalone/i960/start.S	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/i960/start.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  entry.s
- *
- *  This file contains the entry point for the application.
- *  The name of this entry point is compiler dependent.
- *  It jumps to the BSP which is responsible for performing
- *  all initialization.
- *
- */
-
-	 .text
-	 .globl  start                  # GNU960 default entry point
-
-start:
-	mov     3, r12
-	modpc   r12, r12, r12         # enable tracing/trace faults
-	mov     g5, g5                # NOP
-	mov     0, g14                # initialize constant for C
-
-	/*
-	 * zero out uninitialized data area
-	 */
-zerobss:
-	lda     _end, r4        /* find end of .bss */
-	lda     _bss_start, r5  /* find beginning of .bss */
-	ldconst 0, r6
-
-loop:   st      r6, (r5)        /* to zero out uninitialized */
-	addo    4, r5, r5       /* data area                 */
-	cmpobl  r5, r4, loop    /* loop until _end reached   */
-
-
-	lda     heap_memory, r12      /* tell C lib where heap is */
-	st      r12,___C_heap_start
-	lda     heap_size, r12        /* tell C lib how big heap is */
-	st      r12,___C_heap_size
-	lda     stack_memory,r12      /* set up stack pointer: */
-	mov     r12, sp
-	mov     0, g14           /* initialize constant for C */
-
-	call    init_frames
-	ret                      /* return to monitor */
-
-init_frames:
-	ldconst 0x3b001000, g0
-	ldconst 0x00009107, g1
-	modac   g1, g0, g0       /* set AC controls */
-
-	/*
-	 * Call application mainline.
-	 *      Someday, real values of argc and argv will be set up.
-	 *      For now, they are set to 0.
-	 */
-
-	callx   __Board_Initialize    /* Initialize the board */
-
-	ldconst 0,g0
-	ldconst 0,g1
-	ldconst 0,g2
-	callx   ___libc_init          /* initialize the library and */
-				      /*   call main */
-	/*
-	 * if we return from main, we have "fallen" off the end
-	 * of the program, therefore status is 0
-	 * so move 0 to g0 (exit parameter)
-	 */
-
-	mov     0, g0
-	callx   __exit
-	ret
-
-
-/*
- *  Data Declarations.  Start with a macro which helps declare space.
- */
-
-#define DECLARE_SPACE(_name,_space,_align) \
-	  .globl   _name ; \
-	  .align   _align ; \
-.comm     _name##,_space
-
-#define DECLARE_LABEL(_name) \
-	  .globl   _name ; \
-_name##:
-
-#define DECLARE_PTR(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U32(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U16(_name) DECLARE_SPACE(_name,2,1)
-
-/*
- *  Require environment stuff
- */
-
-DECLARE_LABEL(_environ)
-DECLARE_PTR(environ)
-
-DECLARE_LABEL(_errno)
-DECLARE_U32(errno)
-
-/*
- *  Stack Size and Space
- */
-
-	.set stack_size, 0x20000
-
-DECLARE_SPACE(stack_memory,stack_size,4)
-DECLARE_LABEL(stack_end)
-
-/*
- *  Heap Size and Space
- */
-
-	.set heap_size, 0x20000
-
-DECLARE_SPACE(heap_memory,heap_size,4)
-DECLARE_LABEL(heap_end)
diff -Nur sysdeps/standalone/m68k/m68020/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/Dist
--- sysdeps/standalone/m68k/m68020/Dist	1994-09-16 04:14:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-m68020.h
diff -Nur sysdeps/standalone/m68k/m68020/m68020.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/m68020.h
--- sysdeps/standalone/m68k/m68020/m68020.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/m68020.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  m68020.h
- *
- *  This file contains macros which are used to access MC68020
- *  registers which are not addressable by C.  These are
- *  useful when developing the board specific support.
- */
-
-#ifndef m68020_h__
-#define m68020_h__
-
-typedef void ( *mc68020_isr )( void );
-
-#define disable_intr( level ) \
-  { (level) = 0; \
-    asm volatile ( "movew   %%sr,%0 ; \
-		    orw     #0x0700,%%sr" \
-		    : "=d" ((level)) : "0" ((level)) ); \
-  }
-
-#define enable_intr( level ) \
-  { asm volatile ( "movew   %0,%%sr " \
-		       : "=d" ((level)) : "0" ((level)) ); \
-  }
-
-#define flash_intr( level ) \
-  { asm volatile ( "movew   %0,%%sr ; \
-		    orw     #0x0700,%%sr" \
-		       : "=d" ((level)) : "0" ((level)) ); \
-  }
-
-#define get_vbr( vbr ) \
-  { (vbr) = 0; \
-    asm volatile ( "movec   %%vbr,%0 " \
-		       : "=a" (vbr) : "0" (vbr) ); \
-  }
-
-#define set_vbr( vbr ) \
-  { register mc68020_isr *_vbr= (mc68020_isr *)(vbr); \
-    asm volatile ( "movec   %0,%%vbr " \
-		       : "=a" (_vbr) : "0" (_vbr) ); \
-  }
-
-#define enable_caching() \
-  { register unsigned int _ctl=0x01; \
-    asm volatile ( "movec   %0,%%cacr" \
-		       : "=d" (_ctl) : "0" (_ctl) ); \
-  }
-
-#define delay( microseconds ) \
-  { register unsigned int _delay=(microseconds); \
-    register unsigned int _tmp=123; \
-    asm volatile( "0: \
-		     nbcd      %0 ; \
-		     nbcd      %0 ; \
-		     dbf       %1,0 " \
-		  : "=d" (_tmp), "=d" (_delay) \
-		  : "0"  (_tmp), "1"  (_delay) ); \
-  }
-
-#define enable_tracing()
-#define cause_intr( X )
-#define clear_intr( X )
-
-extern mc68020_isr     M68Kvec[];   /* vector table address */
-
-#endif
-/* end of include file */
diff -Nur sysdeps/standalone/m68k/m68020/mvme135/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme135/Implies
--- sysdeps/standalone/m68k/m68020/mvme135/Implies	1994-08-24 15:54:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme135/Implies	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-# Motorola MVME135 and MVME136 are compatible.
-standalone/m68k/m68020/mvme136
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/brdinit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/brdinit.c
--- sysdeps/standalone/m68k/m68020/mvme136/brdinit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/brdinit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "m68020.h"
-
-/*  _Board_Initialize()
-
-This routine initializes the Motorola MVME135/MVME136.  */
-
-void
-_Board_Initialize ()
-{
-  mc68020_isr *monitors_vector_table;
-  int          index;
-
-  monitors_vector_table = (mc68020_isr *)0;   /* 135Bug Vectors are at 0 */
-  set_vbr( monitors_vector_table );
-
-  for ( index=2 ; index<=255 ; index++ )
-    M68Kvec[ index ] = monitors_vector_table[ 32 ];
-
-  M68Kvec[  2 ] = monitors_vector_table[  2 ];   /* bus error vector */
-  M68Kvec[  4 ] = monitors_vector_table[  4 ];   /* breakpoints vector */
-  M68Kvec[  9 ] = monitors_vector_table[  9 ];   /* trace vector */
-  M68Kvec[ 47 ] = monitors_vector_table[ 47 ];   /* system call vector */
-
-  set_vbr( &M68Kvec );
-
-  (*(unsigned char *)0xfffb0067) = 0x7f; /* make VME access round-robin */
-
-  enable_caching ();
-
-}
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/console.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/console.c
--- sysdeps/standalone/m68k/m68020/mvme136/console.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/console.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-/* Copyright (C) 1994, 1996 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-   On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <standalone.h>
-#include "m68020.h"
-
-/* Console IO routines for a Motorola MVME135/MVME136 board.
-
-They currently use the B port.  It should be possible to
-use the A port by filling in the reset of the chip structure,
-adding an ifdef for PORTA/PORTB, and switching the addresses,
-and maybe the macros based on the macro. */
-
-/* M68681 DUART chip register structures and constants */
-
-typedef struct {
-  volatile unsigned char fill1[ 5 ];     /* channel A regs ( not used ) */
-  volatile unsigned char isr;            /* interrupt status reg */
-  volatile unsigned char fill2[ 2 ];     /* counter regs (not used) */
-  volatile unsigned char mr1mr2b;        /* MR1B and MR2B regs */
-  volatile unsigned char srb;            /* status reg channel B */
-  volatile unsigned char fill3;          /* do not access */
-  volatile unsigned char rbb;            /* receive buffer channel B */
-  volatile unsigned char ivr;            /* interrupt vector register */
-} r_m681_info;
-
-typedef struct {
-  volatile unsigned char fill1[ 4 ];     /* channel A regs (not used) */
-  volatile unsigned char acr;            /* auxillary control reg */
-  volatile unsigned char imr;            /* interrupt mask reg */
-  volatile unsigned char fill2[ 2 ];     /* counter regs (not used) */
-  volatile unsigned char mr1mr2b;        /* MR1B and MR2B regs */
-  volatile unsigned char csrb;           /* clock select reg */
-  volatile unsigned char crb;            /* command reg */
-  volatile unsigned char tbb;            /* transmit buffer channel B */
-  volatile unsigned char ivr;            /* interrupt vector register */
-} w_m681_info;
-
-#define RD_M68681     ((r_m681_info *)0xfffb0040)   /* ptr to the M68681 */
-#define WR_M68681     ((w_m681_info *)0xfffb0040)   /* ptr to the M68681 */
-#define RXRDYB        0x01               /* status reg recv ready mask */
-#define TXRDYB        0x04               /* status reg trans ready mask */
-
-/* _Console_Putc
-
-This routine transmits a character out the M68681.  It supports
-XON/XOFF flow control.  */
-
-#define XON             0x11            /* control-Q */
-#define XOFF            0x13            /* control-S */
-
-int
-_Console_Putc (ch)
-     char ch;
-{
-  while ( ! (RD_M68681->srb & TXRDYB) ) ;
-  while ( RD_M68681->srb & RXRDYB )        /* must be an XOFF */
-    if ( RD_M68681->rbb == XOFF )
-      do {
-        while ( ! (RD_M68681->srb & RXRDYB) ) ;
-      } while ( RD_M68681->rbb != XON );
-
-  WR_M68681->tbb = ch;
-  return( 0 );
-}
-
-/* _Console_Getc
-
-This routine reads a character from the UART and returns it. */
-
-int
-_Console_Getc (poll)
-     int poll;
-{
-  if ( poll ) {
-    if ( !(RD_M68681->srb & RXRDYB) )
-      return -1;
-    else
-      return RD_M68681->rbb;
-  } else {
-    while ( !(RD_M68681->srb & RXRDYB) );
-    return RD_M68681->rbb;
-  }
-}
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/Dist
--- sysdeps/standalone/m68k/m68020/mvme136/Dist	1994-09-16 04:14:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-mvme136.ld
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/_exit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/_exit.c
--- sysdeps/standalone/m68k/m68020/mvme136/_exit.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/_exit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Copyright (C) 1994, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <unistd.h>
-#include <stdlib.h>
-#include "m68020.h"
-
-/* Return control to 135Bug */
-
-void
-__exit_trap ()
-{
-  set_vbr( 0 );                     /* restore 135Bug vectors */
-  asm volatile( "trap   #15"  );    /* trap to 135Bug */
-  asm volatile( ".short 0x63" );    /* return to 135Bug (.RETURN) */
-  asm volatile( "jmp    main" );    /* restart program */
-}
-
-/* The function `_exit' should take a status argument and simply
-   terminate program execution, using the low-order 8 bits of the
-   given integer as status.  */
-
-void
-__attribute__ ((noreturn))
-_exit (status)
-     int status;
-{
-  /* status is ignored */
-
-  M68Kvec[ 45 ] = __exit_trap;   /* install exit_trap handler */
-  asm volatile( "trap #13" );  /* insures SUPV mode */
-}
-weak_alias (_exit, _Exit)
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/Makefile
--- sysdeps/standalone/m68k/m68020/mvme136/Makefile	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-# Copyright (C) 1993, 1997 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-# Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-#   On-Line Applications Research Corporation.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; if not, write to the Free
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-# 02111-1307 USA.
-
-ifeq (bare,$(subdir))
-install-lib += mvme136.ld
-endif
diff -Nur sysdeps/standalone/m68k/m68020/mvme136/mvme136.ld /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/mvme136.ld
--- sysdeps/standalone/m68k/m68020/mvme136/mvme136.ld	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/mvme136/mvme136.ld	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This file contains directives for the GNU linker which are specific
-to the Motorola MVME136/MVME135 boards.  */
-
-MEMORY
-        {
-        ram : org = 0x3000, l = 1M
-        }
-
-/* This value is also when the space is allocated.  If you change
-this one, change the other one!!! */
-
-heap_size = 0x20000;
-
-SECTIONS
-{
-        .text 0x3000 :
-        {
-          text_start = ABSOLUTE(.) ;
-          *(.text)
-          etext = ALIGN( 0x10 ) ;
-        }
-
-        .data ADDR( .text ) + SIZEOF( .text ):
-        {
-          data_start = . ;
-          *(.data)
-          edata = ALIGN( 0x10 ) ;
-        }
-
-        .bss ADDR( .data ) + SIZEOF( .data ):
-        {
-          bss_start = . ;
-          _bss_start = . ;
-          *(.bss)
-          *(COMMON)
-          heap_memory = .;
-          . += 0x20000;
-          end = . ;
-          _end = . ;
-        }
-}
diff -Nur sysdeps/standalone/m68k/m68020/start.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/start.S
--- sysdeps/standalone/m68k/m68020/start.S	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/m68k/m68020/start.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-/* Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*  entry.s
- *
- *  This file contains the entry point for the application.
- *  The name of this entry point is compiler dependent.
- *  It jumps to the BSP which is responsible for performing
- *  all initialization.
- */
-
-	.text
-	      .globl   start                        | Default entry point
-	      .globl   _start                       | Default entry point
-	      .globl   M68Kvec                      | Vector Table
-	      .globl   _M68Kvec                     | Vector Table
-
-start:
-_start:
-M68Kvec:                               | standard location for vectors
-_M68Kvec:                               | standard location for vectors
-	nop                             | for linkers with problem
-					|   using location zero as entry
-	jmp      around
-	.space   4088                   | to avoid initial intr stack
-					|   from 135BUG on MVME13? as entry
-					|   and start code at 0x4000
-around:
-	move.w  %sr,initial_sr          | save initial values
-	movec   %isp,%a0
-	movel   %a0,initial_isp
-	movec   %usp,%a0
-	movel   %a0,initial_usp
-	movec   %msp,%a0
-	movel   %a0,initial_msp
-	oriw    #0x0700,%sr             | INTERRUPTS OFF!!!
-
-
-
-	|
-	| zero out uninitialized data area
-	|
-zerobss:
-	moveal  #end,%a0                | find end of .bss
-	moveal  #_bss_start,%a1         | find beginning of .bss
-	movel   #0,%d0
-
-loop:   movel   #0,%a1@+                | to zero out uninitialized
-	cmpal   %a0,%a1
-	jlt     loop                    | loop until _end reached
-
-	movel   #heap_size,__C_heap_size | set ___C_heap_size
-	movel   #heap_memory,__C_heap_start | set ___C_heap_start
-	moveal  #interrupt_stack_end,%a0 | set interrupt stack pointer
-	movec   %a0,%isp
-	moveal  #stack_end,%a0          | set master stack pointer
-	movec   %a0,%msp
-	moveal  #stack_end,%a6          | set base pointer
-	movw    #0x3000,%sr             | SUPV MODE,INTERRUPTS ON!!!
-
-#ifdef NEED_UNDERSCORES
-	jsr     __Board_Initialize      | initialize the board
-#else
-	jsr     _Board_Initialize       | initialize the board
-#endif
-
-	move.l  #0,%sp@-                | envp = NULL
-	move.l  #0,%sp@-                | argv = NULL
-	move.l  #0,%sp@-                | argc = NULL
-#ifdef NEED_UNDERSCORES
-	jsr     ___libc_init            | initialize the library and
-					|   call main
-#else
-	jsr     __libc_init             | initialize the library and
-					|   call main
-#endif
-	add.l   #12,%sp
-
-	move.l  #0,%sp@-                | argc = NULL
-	jsr     __exit                  | call the Board specific exit
-	addq.l  #4,%sp
-
-	move.l  initial_isp,%a0         | if __exit returns then we can
-	movec   %a0,%isp                |   restore the initial values
-	move.l  initial_usp,%a0
-	movec   %a0,%usp
-	move.l  initial_msp,%a0
-	movec   %a0,%msp
-	move.w  initial_sr,%sr
-	rts
-
-
-	.bss
-
-/*
- *  So initial stack registers and status register can be saved.
- */
-
-#define DECLARE_SPACE(_name,_space,_align) \
-	  .globl   _name ; \
-	  .align   _align ; \
-_name##:  .space _space
-
-#define DECLARE_LABEL(_name) \
-	  .globl   _name ; \
-_name##:
-
-#define DECLARE_PTR(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U32(_name) DECLARE_SPACE(_name,4,2)
-#define DECLARE_U16(_name) DECLARE_SPACE(_name,2,1)
-
-DECLARE_U32(initial_isp)
-DECLARE_U32(initial_msp)
-DECLARE_U32(initial_usp)
-DECLARE_U16(initial_sr)
-
-/*
- *  Require environment stuff
- */
-
-DECLARE_LABEL(_environ)
-DECLARE_PTR(environ)
-
-DECLARE_LABEL(__errno)
-DECLARE_LABEL(_errno)
-DECLARE_U32(errno)
-
-/*
- *  Stack Size and Space
- */
-
-	.set stack_size, 0x20000
-
-DECLARE_SPACE(stack_memory,stack_size,4)
-DECLARE_LABEL(stack_end)
-
-DECLARE_SPACE(interrupt_stack_memory,0x1000,4)
-DECLARE_LABEL(interrupt_stack_end)
diff -Nur sysdeps/standalone/open.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/open.c
--- sysdeps/standalone/open.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/open.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/* Copyright (C) 1994, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <stddef.h>
-
-#include <stdio.h>
-#include <bits/stdio_lim.h>
-#include <unistd.h>
-
-#define __DECLARE_FILE_DESCRIPTORS__
-
-#include "filedesc.h"
-
-/* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
-   a third argument is the file protection.  */
-int
-__open (file, oflag)
-     const char *file;
-     int oflag;
-{
-  int mode;
-  int newfd;
-  int index;
-
-  if (file == NULL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  if (oflag & O_CREAT)
-    {
-      va_list arg;
-      va_start(arg, oflag);
-      mode = va_arg(arg, int);
-      va_end(arg);
-    }
-
-  /*
-   *  Find an open slot.
-   */
-
-  newfd = -1;
-
-  for ( index=0 ; index< FOPEN_MAX ; index++ )
-    if ( !__FD_Table[ index ].in_use ) {
-      newfd = index;
-      break;
-    }
-
-  if ( newfd == -1 ) {
-    __set_errno (ENFILE);
-    return -1;
-  }
-
-  /*
-   *  Initialize the open slot
-   */
-
-  __FD_Table[ newfd ].in_use = 1;
-  __FD_Table[ newfd ].flags = oflag;
-
-  return newfd;
-}
-libc_hidden_def (__open)
-
-/* Initialization Code for Console I/O */
-
-#ifdef HAVE_GNU_LD
-static
-#endif
-void
-__NONE_init_console_io (argc, argv, envp)
-     int argc;
-     char **argv;
-     char **envp;
-{
-  int index;
-
-  for ( index=0 ; index< FOPEN_MAX ; index++ )
-    __FD_Table[ index ].in_use = 0;
-
-  stdin = fopen( "", "r" );
-
-  stdout = fopen( "", "w" );
-
-  stderr = fopen( "", "w" );
-
-  /*
-   *  Line buffer the standard input and output and use no buffering for
-   *  standard error.
-   */
-
-  setvbuf( stdin,  NULL, _IOLBF, BUFSIZ );
-  setvbuf( stdout, NULL, _IOLBF, BUFSIZ );
-  setvbuf( stderr, NULL, _IONBF, BUFSIZ );
-
-  (void) &__NONE_init_console_io;  /* Avoid "defined but not used" warning. */
-}
-
-#ifdef  HAVE_GNU_LD
-text_set_element (__libc_subinit, __NONE_init_console_io);
-#endif
-
-weak_alias (__open, open)
diff -Nur sysdeps/standalone/read.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/read.c
--- sysdeps/standalone/read.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/read.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-/* Copyright (C) 1994, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <stddef.h>
-
-#include "filedesc.h"
-#include <fcntl.h>
-#include <standalone.h>
-
-/* Read NBYTES into BUF from FD.  Return the number read or -1.  */
-ssize_t
-__libc_read (int fd, void *buf, size_t nbytes)
-{
-  char *buffer = (char *) buf;
-  int data;
-  int poll;
-
-  __set_errno (0);
-
-  if (nbytes == 0)
-    return 0;
-
-  if ( !__FD_Is_valid( fd ) || !__FD_Table[ fd ].in_use )
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-  if (buf == NULL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  if ( __FD_Table[ fd ].flags & O_WRONLY )  /* is it write only? */
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-
-  /* If this is a non-blocking fd, then we want to poll the console.  */
-
-  poll = ( __FD_Table[ fd ].flags & O_NONBLOCK ) ? 1 : 0;
-
-  /* Read a single character.  This is a cheap way to insure that the
-     upper layers get every character because _Console_Getc can't timeout
-     or otherwise know when to stop.  */
-
-
-  data = _Console_Getc(poll);
-
-  if ( data == -1 )                 /* if no data return */
-    return -1;
-
-  (void) _Console_Putc(data);       /* echo the character */
-
-  if ( data == '\r' ) {		/* translate CR -> CR/LF */
-    (void) _Console_Putc('\n');
-    data = '\n';
-  }
-
-  *buffer = data;
-  return 1;
-}
-libc_hidden_def (__libc_read)
-weak_alias (__libc_read, __read)
-libc_hidden_weak (__read)
-weak_alias (__libc_read, read)
diff -Nur sysdeps/standalone/standalone.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/standalone.h
--- sysdeps/standalone/standalone.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/standalone.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Joel Sherrill (jsherril@redstone-emh2.army.mil),
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _STANDALONE_H
-#define _STANDALONE_H
-
-#include <sys/cdefs.h>
-
-extern void _Board_Initialize __P ((void));
-
-extern int _Console_Putc __P ((char c));
-extern int _Console_Getc __P ((int poll));
-
-#endif
diff -Nur sysdeps/standalone/Subdirs /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/Subdirs
--- sysdeps/standalone/Subdirs	1994-08-26 07:45:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/Subdirs	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-# The `bare' subdirectory defines some structure for a target-specific
-# library of functions which are actually implemented in
-# sysdeps/standalone/CPU/TARGET.
-bare
diff -Nur sysdeps/standalone/write.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/write.c
--- sysdeps/standalone/write.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/standalone/write.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* Copyright (C) 1994, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
-   Ported to standalone by Joel Sherrill jsherril@redstone-emh2.army.mil,
-     On-Line Applications Research Corporation.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stddef.h>
-
-#include "filedesc.h"
-#include <fcntl.h>
-#include <standalone.h>
-
-/* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
-ssize_t
-__libc_write (int fd, const void *buf, size_t nbytes)
-{
-  int count;
-  const char *data = buf;
-
-  if (nbytes == 0)
-    return 0;
-  if ( !__FD_Is_valid( fd ) || !__FD_Table[ fd ].in_use )
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-  if (buf == NULL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  if ( !(__FD_Table[ fd ].flags & (O_WRONLY|O_RDWR)) )  /* is it writeable? */
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-
-  /*
-   *  All open file descriptors are mapped to the console.
-   */
-
-  for ( count=0 ; count != nbytes ; count++ ) {
-    if ( _Console_Putc(data[ count ]) == -1 )
-      return -1;
-    if ( data[count] == '\n' && _Console_Putc('\r') == -1 )
-      return -1;
-  }
-
-  return count;
-}
-
-libc_hidden_def (__libc_write)
-weak_alias (__libc_write, __write)
-libc_hidden_weak (__write)
-weak_alias (__libc_write, write)
diff -Nur sysdeps/tahoe/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/tahoe/Implies
--- sysdeps/tahoe/Implies	1993-05-06 02:31:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/tahoe/Implies	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-# A Tahoe is mostly just like a Vax.
-vax
diff -Nur sysdeps/unix/alarm.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/alarm.c
--- sysdeps/unix/alarm.c	2002-08-04 06:32:50.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/alarm.c	2005-02-16 10:26:38.000000000 +0100
@@ -41,7 +41,10 @@
     return 0;
 
   retval = old.it_value.tv_sec;
-  if (old.it_value.tv_usec)
+  /* Round to the nearest second, but never report zero seconds when
+     the alarm is still set.  */
+  if (old.it_value.tv_usec >= 500000
+      || (retval == 0 && old.it_value.tv_usec > 0))
     ++retval;
   return retval;
 }
diff -Nur sysdeps/unix/bsd/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bits/fcntl.h
--- sysdeps/unix/bsd/bits/fcntl.h	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bits/fcntl.h	2004-05-03 23:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for 4.3 BSD.
-   Copyright (C) 1991, 1992, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -85,7 +85,7 @@
 #define	F_SETFD		2	/* Set file descriptor flags.  */
 #define	F_GETFL		3	/* Get file status flags.  */
 #define	F_SETFL		4	/* Set file status flags.  */
-#ifdef __USE_BSD
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
 # define F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
 #endif
diff -Nur sysdeps/unix/bsd/bsd4.4/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/bits/fcntl.h
--- sysdeps/unix/bsd/bsd4.4/bits/fcntl.h	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/bits/fcntl.h	2004-05-03 23:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for 4.4 BSD.
-   Copyright (C) 1991, 1992, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1997, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -82,7 +82,7 @@
 #define	F_SETFD		2	/* Set file descriptor flags.  */
 #define	F_GETFL		3	/* Get file status flags.  */
 #define	F_SETFL		4	/* Set file status flags.  */
-#ifdef __USE_BSD
+#if defined __USE_BSD || defined __USE_UNIX98
 #define	F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
 #define	F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
 #endif
diff -Nur sysdeps/unix/bsd/bsd4.4/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/bits/socket.h
--- sysdeps/unix/bsd/bsd4.4/bits/socket.h	2002-08-27 06:52:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/bits/socket.h	2004-09-11 18:28:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* System-specific socket constants and types.  4.4 BSD version.
-   Copyright (C) 1991,92,1994-1999,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,1994-2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -230,7 +230,7 @@
 #  define _EXTERN_INLINE extern __inline
 # endif
 _EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
     /* The kernel header does this so there may be a reason.  */
diff -Nur sysdeps/unix/bsd/bsd4.4/freebsd/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/bits/environments.h
--- sysdeps/unix/bsd/bsd4.4/freebsd/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/bits/environments.h	2004-11-26 09:11:03.000000000 +0100
@@ -0,0 +1,72 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* We can never provide environments with 32-bit wide pointers.  */
+# define _POSIX_V6_ILP32_OFF32	-1
+# define _POSIX_V6_ILP32_OFFBIG	-1
+# define _XBS5_ILP32_OFF32	-1
+# define _XBS5_ILP32_OFFBIG	-1
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers
+   and 64-bit `off_t'.  */
+# define _POSIX_V6_ILP32_OFF32	-1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	-1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We can never provide environments with 64-bit wide pointers.  */
+# define _POSIX_V6_LP64_OFF64	-1
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LP64_OFF64	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+#endif /* __WORDSIZE == 32 */
diff -Nur sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
--- sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h	2003-07-31 21:34:16.000000000 +0200
@@ -0,0 +1,66 @@
+/* bits/typesizes.h -- underlying types for *_t.  FreeBSD version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff -Nur sysdeps/unix/bsd/bsd4.4/freebsd/sys/sysmacros.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/sys/sysmacros.h
--- sysdeps/unix/bsd/bsd4.4/freebsd/sys/sysmacros.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/bsd4.4/freebsd/sys/sysmacros.h	2002-10-19 22:03:41.000000000 +0200
@@ -0,0 +1,28 @@
+/* Definitions of macros to access `dev_t' values.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+/* For compatibility we provide alternative names.  */
+#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
+#define minor(dev) ((int)((dev) & 0xffff00ff))
+#define makedev(major, minor) (((major) << 8) | (minor))
+
+#endif /* sys/sysmacros.h */
diff -Nur sysdeps/unix/bsd/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/sigaction.c
--- sysdeps/unix/bsd/sigaction.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/bsd/sigaction.c	2004-09-14 06:24:50.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1995,1996,1997,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -51,7 +51,7 @@
 
   if (oact != NULL)
     {
-      oact->sa_handler = (void (*) __P ((int))) ovec.sv_handler;
+      oact->sa_handler = (void (*) (int)) ovec.sv_handler;
       oact->sa_mask = ovec.sv_mask;
       oact->sa_flags = (((ovec.sv_flags & SV_ONSTACK) ? SA_ONSTACK : 0) |
 			(!(ovec.sv_flags & SV_INTERRUPT) ? SA_RESTART : 0));
diff -Nur sysdeps/unix/clock_gettime.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_gettime.c
--- sysdeps/unix/clock_gettime.c	2002-02-01 00:39:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_gettime.c	2003-06-25 01:58:29.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,7 +32,8 @@
 
 
 /* This function is defined in the thread library.  */
-extern int __pthread_clock_gettime (hp_timing_t freq, struct timespec *tp)
+extern int __pthread_clock_gettime (clockid_t clock_id, hp_timing_t freq,
+				    struct timespec *tp)
      __attribute__ ((__weak__));
 #endif
 
@@ -41,21 +42,42 @@
 int
 clock_gettime (clockid_t clock_id, struct timespec *tp)
 {
-  struct timeval tv;
   int retval = -1;
 
   switch (clock_id)
     {
+#define HANDLE_REALTIME \
+      do {								      \
+        struct timeval tv;						      \
+	retval = gettimeofday (&tv, NULL);				      \
+	if (retval == 0)						      \
+	  /* Convert into `timespec'.  */				      \
+	  TIMEVAL_TO_TIMESPEC (&tv, tp);				      \
+      } while (0)
+
+#ifdef SYSDEP_GETTIME
+      SYSDEP_GETTIME;
+#endif
+
+#ifndef HANDLED_REALTIME
     case CLOCK_REALTIME:
-      retval = gettimeofday (&tv, NULL);
-      if (retval == 0)
-	/* Convert into `timespec'.  */
-	TIMEVAL_TO_TIMESPEC (&tv, tp);
+      HANDLE_REALTIME;
       break;
+#endif
 
+    default:
 #if HP_TIMING_AVAIL
+      if ((clock_id & ((1 << CLOCK_IDFIELD_SIZE) - 1))
+	  != CLOCK_THREAD_CPUTIME_ID)
+#endif
+	{
+	  __set_errno (EINVAL);
+	  break;
+	}
+
+#if HP_TIMING_AVAIL
+      /* FALLTHROUGH.  */
     case CLOCK_PROCESS_CPUTIME_ID:
-    case CLOCK_THREAD_CPUTIME_ID:
       {
 	hp_timing_t tsc;
 
@@ -71,10 +93,10 @@
 	      break;
 	  }
 
-	if (clock_id == CLOCK_THREAD_CPUTIME_ID
+	if (clock_id != CLOCK_PROCESS_CPUTIME_ID
 	    && __pthread_clock_gettime != NULL)
 	  {
-	    retval = __pthread_clock_gettime (freq, tp);
+	    retval = __pthread_clock_gettime (clock_id, freq, tp);
 	    break;
 	  }
 
@@ -95,10 +117,6 @@
       }
     break;
 #endif
-
-    default:
-      __set_errno (EINVAL);
-      break;
     }
 
   return retval;
diff -Nur sysdeps/unix/clock_nanosleep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_nanosleep.c
--- sysdeps/unix/clock_nanosleep.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_nanosleep.c	2004-12-06 23:28:49.000000000 +0100
@@ -1,5 +1,5 @@
 /* High-resolution sleep with the specified clock.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,14 +21,19 @@
 #include <errno.h>
 #include <time.h>
 #include <hp-timing.h>
-
+#include <sysdep-cancel.h>
 
 #if HP_TIMING_AVAIL
-# define CLOCK_P(clock) \
-  (clock) != CLOCK_PROCESS_CPUTIME_ID					      \
-  && (clock) != CLOCK_THREAD_CPUTIME_ID
+# define CPUCLOCK_P(clock) \
+  ((clock) == CLOCK_PROCESS_CPUTIME_ID					      \
+   || ((clock) & ((1 << CLOCK_IDFIELD_SIZE) - 1)) == CLOCK_THREAD_CPUTIME_ID)
 #else
-# define CLOCK_P(clock) 0
+# define CPUCLOCK_P(clock) 0
+#endif
+
+#ifndef INVALID_CLOCK_P
+# define INVALID_CLOCK_P(cl) \
+  ((cl) < CLOCK_REALTIME || (cl) > CLOCK_THREAD_CPUTIME_ID)
 #endif
 
 
@@ -44,6 +49,19 @@
       || __builtin_expect (req->tv_nsec, 0) >= 1000000000)
     return EINVAL;
 
+  if (clock_id == CLOCK_THREAD_CPUTIME_ID)
+    return EINVAL;		/* POSIX specifies EINVAL for this case.  */
+
+#ifdef SYSDEP_NANOSLEEP
+  SYSDEP_NANOSLEEP;
+#endif
+
+  if (CPUCLOCK_P (clock_id))
+    return ENOTSUP;
+
+  if (INVALID_CLOCK_P (clock_id))
+    return EINVAL;
+
   /* If we got an absolute time, remap it.  */
   if (flags == TIMER_ABSTIME)
     {
@@ -76,11 +94,8 @@
   else if (__builtin_expect (flags, 0) != 0)
     return EINVAL;
   else if (clock_id != CLOCK_REALTIME)
-    {
-      /* Make sure the clock ID is correct.  */
-      if (__builtin_expect (! CLOCK_P (clock_id), 0))
-	return EINVAL;
-    }
+    /* Not supported.  */
+    return ENOTSUP;
 
   return __builtin_expect (nanosleep (req, rem), 0) ? errno : 0;
 }
diff -Nur sysdeps/unix/clock_settime.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_settime.c
--- sysdeps/unix/clock_settime.c	2002-02-01 00:40:41.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/clock_settime.c	2004-02-19 10:00:43.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999,2000,2001,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,7 +31,7 @@
 
 
 /* This function is defined in the thread library.  */
-extern void __pthread_clock_settime (hp_timing_t offset)
+extern void __pthread_clock_settime (clockid_t clock_id, hp_timing_t offset)
      __attribute__ ((__weak__));
 #endif
 
@@ -40,7 +40,6 @@
 int
 clock_settime (clockid_t clock_id, const struct timespec *tp)
 {
-  struct timeval tv;
   int retval;
 
   /* Make sure the time cvalue is OK.  */
@@ -52,15 +51,38 @@
 
   switch (clock_id)
     {
-    case CLOCK_REALTIME:
-      TIMESPEC_TO_TIMEVAL (&tv, tp);
+#define HANDLE_REALTIME \
+      do {								      \
+	struct timeval tv;						      \
+	TIMESPEC_TO_TIMEVAL (&tv, tp);					      \
+									      \
+	retval = settimeofday (&tv, NULL);				      \
+      } while (0)
+
+#ifdef SYSDEP_SETTIME
+      SYSDEP_SETTIME;
+#endif
 
-      retval = settimeofday (&tv, NULL);
+#ifndef HANDLED_REALTIME
+    case CLOCK_REALTIME:
+      HANDLE_REALTIME;
       break;
+#endif
 
+    default:
 #if HP_TIMING_AVAIL
+      if ((clock_id & ((1 << CLOCK_IDFIELD_SIZE) - 1))
+	  != CLOCK_THREAD_CPUTIME_ID)
+#endif
+	{
+	  __set_errno (EINVAL);
+	  retval = -1;
+	  break;
+	}
+
+#if HP_TIMING_AVAIL
+      /* FALLTHROUGH.  */
     case CLOCK_PROCESS_CPUTIME_ID:
-    case CLOCK_THREAD_CPUTIME_ID:
       {
 	hp_timing_t tsc;
 	hp_timing_t usertime;
@@ -87,21 +109,16 @@
 	usertime = tp->tv_sec * freq + (tp->tv_nsec * freq) / 1000000000ull;
 
 	/* Determine the offset and use it as the new base value.  */
-	if (clock_id != CLOCK_THREAD_CPUTIME_ID
+	if (clock_id == CLOCK_PROCESS_CPUTIME_ID
 	    || __pthread_clock_settime == NULL)
 	  GL(dl_cpuclock_offset) = tsc - usertime;
 	else
-	  __pthread_clock_settime (tsc - usertime);
+	  __pthread_clock_settime (clock_id, tsc - usertime);
 
 	retval = 0;
       }
       break;
 #endif
-
-    default:
-      __set_errno (EINVAL);
-      retval = -1;
-      break;
     }
 
   return retval;
diff -Nur sysdeps/unix/closedir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/closedir.c
--- sysdeps/unix/closedir.c	2002-04-08 09:02:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/closedir.c	2003-07-15 09:03:05.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991, 1993, 1995, 1996, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1993,1995,1996,1998,2002,2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,6 +23,8 @@
 #include <dirent.h>
 #include <unistd.h>
 #include <dirstream.h>
+#include <not-cancel.h>
+
 
 /* Close the directory stream DIRP.
    Return 0 if successful, -1 if not.  */
@@ -36,7 +39,9 @@
       return -1;
     }
 
-  __libc_lock_lock (dirp->lock);
+  /* We do not try to synchronize access here.  If some other thread
+     still uses this handle it is a big mistake and that thread
+     deserves all the bad data it gets.  */
 
   fd = dirp->fd;
 
@@ -44,6 +49,6 @@
 
   free ((void *) dirp);
 
-  return __close (fd);
+  return close_not_cancel (fd);
 }
 weak_alias (__closedir, closedir)
diff -Nur sysdeps/unix/common/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/bits/fcntl.h
--- sysdeps/unix/common/bits/fcntl.h	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/bits/fcntl.h	2004-05-03 23:39:37.000000000 +0200
@@ -1,5 +1,6 @@
 /* O_*, F_*, FD_* bit values for general Unix system.
-   Copyright (C) 1991, 1992, 1995, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1995, 1997, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -79,7 +80,7 @@
 #define	F_SETFD		2	/* Set file descriptor flags.  */
 #define	F_GETFL		3	/* Get file status flags.  */
 #define	F_SETFL		4	/* Set file status flags.  */
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_GETOWN	23	/* Get owner (receiver of SIGIO).  */
 # define F_SETOWN	24	/* Set owner (receiver of SIGIO).  */
 #endif
diff -Nur sysdeps/unix/common/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/configure
--- sysdeps/unix/common/configure	2002-09-29 19:58:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,105 +1,195 @@
- 
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+
 if test -z "$inhibit_glue"; then
 
 # Find out what this system calls `sys_siglist'.
-echo $ac_n "checking for sys_siglist""... $ac_c" 1>&6
-echo "configure:7: checking for sys_siglist" >&5
-if eval "test \"`echo '$''{'ac_cv_check_symbol_sys_siglist'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 12 "configure"
-#include "confdefs.h"
 
-int main() {
+echo "$as_me:$LINENO: checking for sys_siglist" >&5
+echo $ECHO_N "checking for sys_siglist... $ECHO_C" >&6
+if test "${ac_cv_check_symbol_sys_siglist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
 extern char *sys_siglist[]; puts(*sys_siglist);
-; return 0; }
-EOF
-if { (eval echo configure:19: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   	    ac_cv_check_symbol_sys_siglist=yes
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  ac_cv_check_symbol_sys_siglist=no
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_check_symbol_sys_siglist=no
 fi
-rm -f conftest*
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 
 if test "$ac_cv_check_symbol_sys_siglist" = yes; then
   ac_tr_symbol=`echo sys_siglist | tr '[a-z]' '[A-Z]'`
-  cat >> confdefs.h <<EOF
+  cat >>confdefs.h <<_ACEOF
 #define HAVE_${ac_tr_symbol} 1
-EOF
+_ACEOF
 
 fi
-echo "$ac_t""$ac_cv_check_symbol_sys_siglist" 1>&6
-echo $ac_n "checking for _sys_siglist""... $ac_c" 1>&6
-echo "configure:40: checking for _sys_siglist" >&5
-if eval "test \"`echo '$''{'ac_cv_check_symbol__sys_siglist'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 45 "configure"
-#include "confdefs.h"
-
-int main() {
+echo "$as_me:$LINENO: result: $ac_cv_check_symbol_sys_siglist" >&5
+echo "${ECHO_T}$ac_cv_check_symbol_sys_siglist" >&6
+echo "$as_me:$LINENO: checking for _sys_siglist" >&5
+echo $ECHO_N "checking for _sys_siglist... $ECHO_C" >&6
+if test "${ac_cv_check_symbol__sys_siglist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
 extern char *_sys_siglist[]; puts(*_sys_siglist);
-; return 0; }
-EOF
-if { (eval echo configure:52: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   	    ac_cv_check_symbol__sys_siglist=yes
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  ac_cv_check_symbol__sys_siglist=no
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_check_symbol__sys_siglist=no
 fi
-rm -f conftest*
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 
 if test "$ac_cv_check_symbol__sys_siglist" = yes; then
   ac_tr_symbol=`echo _sys_siglist | tr '[a-z]' '[A-Z]'`
-  cat >> confdefs.h <<EOF
+  cat >>confdefs.h <<_ACEOF
 #define HAVE_${ac_tr_symbol} 1
-EOF
+_ACEOF
 
 fi
-echo "$ac_t""$ac_cv_check_symbol__sys_siglist" 1>&6
+echo "$as_me:$LINENO: result: $ac_cv_check_symbol__sys_siglist" >&5
+echo "${ECHO_T}$ac_cv_check_symbol__sys_siglist" >&6
 
 # Find out the name of the table the system's <ctype.h> uses for character
 # classification.  This is used by sysdeps/unix/common/glue-ctype.c.
-echo $ac_n "checking ctype array name for glue""... $ac_c" 1>&6
-echo "configure:76: checking ctype array name for glue" >&5
-if eval "test \"`echo '$''{'libc_cv_ctype_glue'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
+echo "$as_me:$LINENO: checking ctype array name for glue" >&5
+echo $ECHO_N "checking ctype array name for glue... $ECHO_C" >&6
+if test "${libc_cv_ctype_glue+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   for ctype in _ctype_ __ctype_ __ctype _ctype__ _ctype _locp; do
-cat > conftest.$ac_ext <<EOF
-#line 82 "configure"
-#include "confdefs.h"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <ctype.h>
-int main() {
+int
+main ()
+{
 $ctype[13];
-; return 0; }
-EOF
-if { (eval echo configure:89: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   libc_cv_ctype_glue="$ctype"; break
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
-rm -f conftest*
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 done
 fi
 
-echo "$ac_t""$libc_cv_ctype_glue" 1>&6
-cat >> confdefs.h <<EOF
+echo "$as_me:$LINENO: result: $libc_cv_ctype_glue" >&5
+echo "${ECHO_T}$libc_cv_ctype_glue" >&6
+cat >>confdefs.h <<_ACEOF
 #define HAVE_`echo $libc_cv_ctype_glue | tr 'a-z' 'A-Z'` 1
-EOF
+_ACEOF
 
 
 fi
diff -Nur sysdeps/unix/common/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/configure.in
--- sysdeps/unix/common/configure.in	1994-12-08 10:02:26.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/configure.in	2002-10-18 21:38:00.000000000 +0200
@@ -1,4 +1,3 @@
-sinclude(./aclocal.m4)dnl
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 
 if test -z "$inhibit_glue"; then
diff -Nur sysdeps/unix/common/.cvsignore /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/.cvsignore
--- sysdeps/unix/common/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/.cvsignore	1995-02-18 01:06:02.000000000 +0100
@@ -0,0 +1,4 @@
+*.gz *.Z *.tar *.tgz
+=*
+TODO COPYING* AUTHORS copyr-* copying.*
+glibc-*
diff -Nur sysdeps/unix/common/pause.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/pause.c
--- sysdeps/unix/common/pause.c	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/pause.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* Copyright (C) 1991, 1996 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <signal.h>
-#include <unistd.h>
-
-
-/* Suspend the process until a signal arrives.
-   This always returns -1 and sets errno to EINTR.  */
-
-int
-__libc_pause (void)
-{
-  return __sigpause (__sigblock (0), 0);
-}
-weak_alias (__libc_pause, pause)
diff -Nur sysdeps/unix/common/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/syscalls.list
--- sysdeps/unix/common/syscalls.list	2002-08-26 23:16:15.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/common/syscalls.list	2004-06-30 09:37:08.000000000 +0200
@@ -12,5 +12,5 @@
 setreuid	-	setreuid	i:ii	__setreuid	setreuid
 sigaction	-	sigaction	i:ipp	__sigaction	sigaction
 sys_lstat	lxstat	lstat		i:sp	__syscall_lstat
-truncate	-	truncate	i:si	truncate
+truncate	-	truncate	i:si	__truncate	truncate
 vhangup		-	vhangup		i:i	vhangup
diff -Nur sysdeps/unix/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/configure
--- sysdeps/unix/configure	2002-09-29 19:59:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,59 +1,108 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
  # Local configure fragment for sysdeps/unix.
 
 if test -z "$inhibit_glue"; then
 # For make_errlist.c, used in make_errlist.
+
+
 for ac_func in strerror
 do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:9: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat > conftest.$ac_ext <<EOF
-#line 14 "configure"
-#include "confdefs.h"
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 
-int main() {
+#undef $ac_func
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-$ac_func();
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
-; return 0; }
-EOF
-if { (eval echo configure:37: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
 fi
-rm -f conftest*
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
 fi
 done
 
diff -Nur sysdeps/unix/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/configure.in
--- sysdeps/unix/configure.in	1996-02-07 22:24:17.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/configure.in	2002-10-18 21:38:01.000000000 +0200
@@ -1,4 +1,3 @@
-sinclude(./aclocal.m4)dnl Autoconf lossage
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 # Local configure fragment for sysdeps/unix.
 
diff -Nur sysdeps/unix/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/Dist
--- sysdeps/unix/Dist	2002-08-28 10:41:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/Dist	2003-02-21 08:00:52.000000000 +0100
@@ -10,3 +10,5 @@
 i386/dl-brk.S
 mips/dl-brk.S
 sparc/dl-brk.S
+s-proto-bp.S
+s-proto-cancel.S
diff -Nur sysdeps/unix/fork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/fork.S
--- sysdeps/unix/fork.S	2002-08-26 23:16:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/fork.S	2002-12-31 21:37:25.000000000 +0100
@@ -29,5 +29,6 @@
 	andl r1, r0
 	ret
 PSEUDO_END (__fork)
+libc_hidden_def (__fork)
 
 weak_alias (__fork, fork)
diff -Nur sysdeps/unix/getlogin_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/getlogin_r.c
--- sysdeps/unix/getlogin_r.c	2002-08-12 10:54:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/getlogin_r.c	2002-10-16 05:02:55.000000000 +0200
@@ -25,6 +25,7 @@
 #include <fcntl.h>
 
 #include <utmp.h>
+#include "../login/utmp-private.h"
 
 /* Return at most NAME_LEN characters of the login name of the user in NAME.
    If it cannot be determined or some other error occurred, return the error
@@ -37,7 +38,7 @@
 {
   char tty_pathname[2 + 2 * NAME_MAX];
   char *real_tty_path = tty_pathname;
-  int result = 0;
+  int result;
   struct utmp *ut, line, buffer;
 
   /* Get name of tty connected to fd 0.  Return if not a tty or
@@ -56,10 +57,16 @@
     return result;
 
   real_tty_path += 5;		/* Remove "/dev/".  */
-
-  __setutent ();
   strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);
-  if (__getutline_r (&line, &buffer, &ut) < 0)
+
+  /* We don't use the normal entry points __setutent et al, because we
+     want setutent + getutline_r + endutent all to happen with the lock
+     held so that our search is thread-safe.  */
+
+  __libc_lock_lock (__libc_utmp_lock);
+  (*__libc_utmp_jump_table->setutent) ();
+  result = (*__libc_utmp_jump_table->getutline_r) (&line, &buffer, &ut);
+  if (result < 0)
     {
       if (errno == ESRCH)
 	/* The caller expects ENOENT if nothing is found.  */
@@ -67,7 +74,11 @@
       else
 	result = errno;
     }
-  else
+  (*__libc_utmp_jump_table->endutent) ();
+  __libc_utmp_jump_table = &__libc_utmp_unknown_functions;
+  __libc_lock_unlock (__libc_utmp_lock);
+
+  if (result == 0)
     {
       size_t needed = strlen (ut->ut_user) + 1;
 
@@ -82,7 +93,6 @@
 	  result = 0;
 	}
     }
-  __endutent ();
 
   return result;
 }
diff -Nur sysdeps/unix/i386/fork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/i386/fork.S
--- sysdeps/unix/i386/fork.S	2002-08-26 23:16:16.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/i386/fork.S	2002-12-31 21:37:27.000000000 +0100
@@ -27,5 +27,6 @@
 	andl r1, r0
 	ret
 PSEUDO_END (__fork)
+libc_hidden_def (__fork)
 
 weak_alias (__fork, fork)
diff -Nur sysdeps/unix/i386/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/i386/sysdep.S
--- sysdeps/unix/i386/sysdep.S	2002-10-01 00:03:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/i386/sysdep.S	2005-02-16 12:07:20.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 2000, 2002
+/* Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 2000, 2002, 2004
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -23,6 +23,10 @@
 #include <bp-asm.h>
 #include <bp-sym.h>
 
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+
 .globl C_SYMBOL_NAME(errno)
 .globl syscall_error
 
@@ -42,8 +46,13 @@
 notb:
 #endif
 #ifndef	PIC
-# if USE_TLS && HAVE___THREAD
+# if USE___THREAD
+#  ifndef NO_TLS_DIRECT_SEG_REFS
 	movl %eax, %gs:C_SYMBOL_NAME(errno@NTPOFF)
+#  else
+	movl %gs:0, %ecx
+	movl %eax, C_SYMBOL_NAME(errno@NTPOFF)(%ecx)
+#  endif
 # elif !defined _LIBC_REENTRANT
 	movl %eax, C_SYMBOL_NAME(errno)
 # else
@@ -57,12 +66,22 @@
 #else
 	/* The caller has pushed %ebx and then set it up to
 	   point to the GOT before calling us through the PLT.  */
-# if USE_TLS && HAVE___THREAD
+# if USE___THREAD
 	movl C_SYMBOL_NAME(errno@GOTNTPOFF)(%ebx), %ecx
 
 	/* Pop %ebx value saved before jumping here.  */
 	popl %ebx
+#  ifndef NO_TLS_DIRECT_SEG_REFS
+	addl %gs:0, %ecx
+	movl %eax, (%ecx)
+#  else
 	movl %eax, %gs:0(%ecx)
+#  endif
+# elif RTLD_PRIVATE_ERRNO
+	movl %eax, C_SYMBOL_NAME(rtld_errno@GOTOFF)(%ebx)
+
+	/* Pop %ebx value saved before jumping here.  */
+	popl %ebx
 # elif !defined _LIBC_REENTRANT
 	movl C_SYMBOL_NAME(errno@GOT)(%ebx), %ecx
 
diff -Nur sysdeps/unix/inet/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/inet/syscalls.list
--- sysdeps/unix/inet/syscalls.list	2002-08-26 23:16:16.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/inet/syscalls.list	2003-01-31 04:40:09.000000000 +0100
@@ -1,27 +1,23 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
-accept		-	accept		i:iBN	__libc_accept	accept
+accept		-	accept		Ci:iBN	__libc_accept	accept
 bind		-	bind		i:ipi	__bind		bind
-connect		-	connect		i:ipi	__libc_connect	__connect __connect_internal connect
+connect		-	connect		Ci:ipi	__libc_connect	__connect __connect_internal connect
 gethostid	-	gethostid	i:	gethostid
 gethostname	-	gethostname	i:bn	__gethostname	gethostname
 getpeername	-	getpeername	i:ibN	__getpeername	getpeername
 getsockname	-	getsockname	i:ibN	__getsockname	getsockname
 getsockopt	-	getsockopt	i:iiiBN	getsockopt
 listen		-	listen		i:ii	__listen	listen
-recv		-	recv		i:ibni	__libc_recv	recv
-recvfrom	-	recvfrom	i:ibniBN	__libc_recvfrom __recvfrom recvfrom
-recvmsg		-	recvmsg		i:ipi	__libc_recvmsg	__recvmsg recvmsg
-send		-	send		i:ibni	__libc_send	__send send 
-sendmsg		-	sendmsg		i:ipi	__libc_sendmsg	__sendmsg sendmsg
-sendto		-	sendto		i:ibnibn	__libc_sendto	__sendto sendto
+recv		-	recv		Ci:ibni	__libc_recv	recv
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom __recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send 
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
 sethostid	-	sethostid	i:i	sethostid
 sethostname	-	sethostname	i:pi	sethostname
 setsockopt	-	setsockopt	i:iiibn	setsockopt	__setsockopt
 shutdown	-	shutdown	i:ii	shutdown
 socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	socketpair
-
-
-
-
diff -Nur sysdeps/unix/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/Makefile
--- sysdeps/unix/Makefile	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/Makefile	2003-05-02 04:20:58.000000000 +0200
@@ -1,4 +1,5 @@
-# Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
+# Copyright (C) 1991,1992,1993,1994,1995,1996,1997,1998,1999,2003
+#	Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -281,11 +282,49 @@
 
 ifeq (misc,$(subdir))
 sysdep_routines += $(unix-extra-syscalls)
+
+ifdef unix-stub-syscalls
+# The system call entry points in this list are supposed to be additional
+# functions not overriding any other sysdeps/.../call.c implementation, but
+# their system call numbers are unavailable in the kernel headers we're
+# using.  Instead of a system call stub, these get a function that fails
+# with ENOSYS.  We just generate a single module defining one function and
+# making all these entry point names aliases for it.
+sysdep_routines += stub-syscalls
+$(objpfx)stub-syscalls.c: $(common-objpfx)sysd-syscalls \
+			  $(..)sysdeps/unix/Makefile
+	$(make-target-directory)
+	(echo '#include <errno.h>'; \
+	 echo 'long int _no_syscall (void)'; \
+	 echo '{ __set_errno (ENOSYS); return -1L; }'; \
+	 for call in $(unix-stub-syscalls); do \
+	   case $$call in \
+	   *@@*) ver=$${call##*@}; call=$${call%%*@}; \
+		 echo "strong_alias (_no_syscall, $${call}_$${ver})"; \
+		 echo "default_symbol_version \
+		         ($${call}_$${ver}, $$call, $$ver);" ;; \
+	   *@@*) ver=$${call##*@}; call=$${call%%*@}; \
+		 echo "strong_alias (_no_syscall, $${call}_$${ver})"; \
+		 echo "symbol_version ($${call}_$${ver}, $$call, $$ver);" ;; \
+	   *) echo "weak_alias (_no_syscall, $$call)"; \
+	      echo "stub_warning ($$call)"; \
+	      echo "weak_alias (_no_syscall, __GI_$$call)" ;; \
+	   esac; \
+	 echo '#include <stub-tag.h>'; \
+	 done) > $@T
+	mv -f $@T $@
+generated += stub-syscalls.c
+endif
 endif
 
 export sysdirs
 export asm_CPP := $(COMPILE.S) -E -x assembler-with-cpp
 
+# This is the end of the pipeline for compiling the syscall stubs.
+# The stdin in assembler with cpp using sysdep.h macros.
+# Be sure to disable debugging info since it would all just say "<stdin>".
+compile-syscall = $(filter-out -g%,$(COMPILE.S)) -x assembler-with-cpp -o $@ -
+
 ifndef avoid-generated
 $(common-objpfx)sysd-syscalls: $(..)sysdeps/unix/make-syscalls.sh \
 			       $(wildcard $(+sysdep_dirs:%=%/syscalls.list))
@@ -297,22 +336,24 @@
 	mv -f $@T $@
 endif
 
-# This syscall objects depend on s-proto.d, which is generated to
-# specify dependencies generated syscalls with have on headers.
-ifdef subdir
-ifndef no_deps
+# The syscall objects depend on s-proto.d or s-proto-cancel.d, which
+# are generated to specify dependencies generated syscalls have on
+# headers.
 # These deps use file names relative to a subdir, so don't
 # include them in the parent directory.
+ifneq (,$(filter $(unix-syscalls),$(routines) $(sysdep_routines) $(aux)))
+ifndef no_deps
 -include $(common-objpfx)s-proto.d
+-include $(common-objpfx)s-proto-bp.d
+-include $(common-objpfx)s-proto-cancel.d
 endif
 endif
 
-$(common-objpfx)s-proto.d: $(common-objpfx)%.d: $(..)sysdeps/unix/%.S \
-			   $(wildcard $(+sysdep_dirs:%=%/syscalls.list))
-# Don't try to use compat.h in the db2 subdir
-	$(subst -include ./compat.h,,$(+make-deps))
+$(common-objpfx)s-%.d: $(..)sysdeps/unix/s-%.S \
+		       $(wildcard $(+sysdep_dirs:%=%/syscalls.list))
+	$(+make-deps)
 
-common-generated += s-proto.d
+common-generated += s-proto.d s-proto-bp.d s-proto-cancel.d
 postclean-generated += sysd-syscalls
 
 endif
diff -Nur sysdeps/unix/make-syscalls.sh /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/make-syscalls.sh
--- sysdeps/unix/make-syscalls.sh	2002-08-05 11:21:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/make-syscalls.sh	2003-08-16 08:13:21.000000000 +0200
@@ -83,6 +83,14 @@
   ;;
   esac
 
+  cancellable=
+  noerrno=
+  case $args in
+  C*) cancellable=-cancel; args=`echo $args | sed 's/C:\?//'`;;
+  E*) noerrno=_NOERRNO; args=`echo $args | sed 's/E:\?//'`;;
+  V*) noerrno=_ERRVAL; args=`echo $args | sed 's/V:\?//'`;;
+  esac
+
   # Derive the number of arguments from the argument signature
   case $args in
   [0-9]) nargs=$args;;
@@ -104,6 +112,16 @@
   echo "#### CALL=$file NUMBER=$callnum ARGS=$args SOURCE=$srcfile"
 
  case x$srcfile"$callnum" in
+ x--)
+  # Undefined callnum for an extra syscall.
+  if [ x$caller != x- ]; then
+    if [ x$noerrno != x ]; then
+      echo >&2 "$0: no number for $fileno, no-error syscall ($strong $weak)"
+      exit 2
+    fi
+    echo "unix-stub-syscalls += $strong $weak"
+  fi
+  ;;
  x*-) ;; ### Do nothing for undefined callnum
  x-*)
   echo "ifeq (,\$(filter $file,\$(unix-syscalls)))"
@@ -128,11 +146,13 @@
     ;;
   *)
     echo "\
-\$(foreach o,\$(object-suffixes),\$(objpfx)$file\$o): \\"
+\$(foreach o,\$(object-suffixes),\$(objpfx)$file\$o) \
+\$(foreach o,\$(object-suffixes),\$(objpfx)ptw-$file\$o) \
+\$(objpfx)rtld-$file.os: \\"
     ;;
   esac
 
-  echo '		$(common-objpfx)s-proto.d'
+  echo "		\$(common-objpfx)s-proto$cancellable.d"
   case x"$callnum" in
   x_)
   echo "\
@@ -140,10 +160,11 @@
   ;;
   x*)
   echo "\
-	(echo '#include <sysdep.h>'; \\
-	 echo 'PSEUDO ($strong, $syscall, $nargs)'; \\
-	 echo '	ret'; \\
-	 echo 'PSEUDO_END($strong)'; \\
+	\$(make-target-directory)
+	(echo '#include <sysdep$cancellable.h>'; \\
+	 echo 'PSEUDO$noerrno ($strong, $syscall, $nargs)'; \\
+	 echo '	ret$noerrno'; \\
+	 echo 'PSEUDO_END$noerrno($strong)'; \\
 	 echo 'libc_hidden_def ($strong)'; \\"
   ;;
   esac
@@ -182,6 +203,11 @@
 	fi
 	echo "	 echo 'symbol_version($source, $base, $ver)'; \\"
 	;;
+      !*)
+	name=`echo $name | sed 's/.//'`
+	echo "	 echo 'strong_alias ($strong, $name)'; \\"
+	echo "	 echo 'libc_hidden_def ($name)'; \\"
+	;;
       *)
 	echo "	 echo 'weak_alias ($strong, $name)'; \\"
 	echo "	 echo 'libc_hidden_weak ($name)'; \\"
@@ -190,7 +216,7 @@
   done
 
   # And finally, pipe this all into the compiler.
-  echo '	) | $(COMPILE.S) -x assembler-with-cpp -o $@ -'
+  echo '	) | $(compile-syscall)'
 
   case $weak in
   *@*)
@@ -240,7 +266,7 @@
     # generate makefile envelope & rule head
     echo "ifeq (,\$(filter $file,\$(bp-thunks)))"
     echo "bp-thunks += $file"
-    echo "\$(objpfx)\$(bppfx)$file.ob: \$(common-objpfx)s-proto.d"
+    echo "\$(objpfx)\$(bppfx)$file.ob: \$(common-objpfx)s-proto-bp.d"
 
     # generate macro head
     echo "	(echo '#define $callname(`echo $arglist | \
diff -Nur sysdeps/unix/mips/brk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/brk.S
--- sysdeps/unix/mips/brk.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/brk.S	2003-03-17 16:47:12.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Brendan Kehoe (brendan@zen.org).
 
@@ -18,6 +18,7 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
+#include <sys/asm.h>
 
 #ifndef SYS_brk
 #define SYS_brk 17
@@ -37,11 +38,11 @@
 	.set	reorder
 	/* Handle the query case.  */
 	bnez a0, 1f
-	move a0,v0
+	move a0, v0
 1:	/* Update __curbrk and exit cleanly.  */
-	sw a0, __curbrk
+	PTR_S a0, __curbrk
 	move v0, zero
 	jr ra
-	.end __brk
+PSEUDO_END(__brk)
 
 weak_alias (__brk, brk)
diff -Nur sysdeps/unix/mips/fork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/fork.S
--- sysdeps/unix/mips/fork.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/fork.S	2003-01-11 16:26:35.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Brendan Kehoe (brendan@zen.org).
 
@@ -26,6 +26,7 @@
 	move v0, zero
 parent:
 	ret
-	.end __fork
+PSEUDO_END(__fork)
 
+libc_hidden_def (__fork)
 weak_alias (__fork, fork)
diff -Nur sysdeps/unix/mips/mips32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips32/sysdep.h
--- sysdeps/unix/mips/mips32/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips32/sysdep.h	2003-03-29 09:15:28.000000000 +0100
@@ -0,0 +1,52 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/mips/sysdep.h>
+
+/* Note that while it's better structurally, going back to call __syscall_error
+   can make things confusing if you're debugging---it looks like it's jumping
+   backwards into the previous fn.  */
+#ifdef __PIC__
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;								      \
+  99: la t9,__syscall_error;						      \
+  jr t9;								      \
+  ENTRY(name)								      \
+  .set noreorder;							      \
+  .cpload t9;								      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  .set reorder;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#else
+#define PSEUDO(name, syscall_name, args) \
+  .set noreorder;							      \
+  .align 2;								      \
+  99: j __syscall_error;						      \
+  nop;									      \
+  ENTRY(name)								      \
+  .set noreorder;							      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  .set reorder;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#endif
diff -Nur sysdeps/unix/mips/mips64/n32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips64/n32/sysdep.h
--- sysdeps/unix/mips/mips64/n32/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips64/n32/sysdep.h	2003-03-29 09:15:28.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Alexandre Oliva <aoliva@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/mips/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+/* Note that while it's better structurally, going back to call __syscall_error
+   can make things confusing if you're debugging---it looks like it's jumping
+   backwards into the previous fn.  */
+#ifdef __PIC__
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;								      \
+  99:;									      \
+  .set noat;								      \
+  .cpsetup t9, $1, name;						      \
+  .set at;								      \
+  la t9,__syscall_error;						      \
+  .cpreturn;								      \
+  jr t9;								      \
+  ENTRY(name)								      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#else
+#define PSEUDO(name, syscall_name, args) \
+  .set noreorder;							      \
+  .align 2;								      \
+  99: j __syscall_error;						      \
+  ENTRY(name)								      \
+  .set noreorder;							      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  .set reorder;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#endif
+
+#endif
diff -Nur sysdeps/unix/mips/mips64/n64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips64/n64/sysdep.h
--- sysdeps/unix/mips/mips64/n64/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/mips64/n64/sysdep.h	2003-03-29 09:15:28.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Alexandre Oliva <aoliva@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/mips/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+/* Note that while it's better structurally, going back to call __syscall_error
+   can make things confusing if you're debugging---it looks like it's jumping
+   backwards into the previous fn.  */
+#ifdef __PIC__
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;								      \
+  99:;									      \
+  .set noat;								      \
+  .cpsetup t9, $1, name;						      \
+  .set at;								      \
+  dla t9,__syscall_error;						      \
+  .cpreturn;								      \
+  jr t9;								      \
+  ENTRY(name)								      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#else
+#define PSEUDO(name, syscall_name, args) \
+  .set noreorder;							      \
+  .align 2;								      \
+  99: j __syscall_error;						      \
+  ENTRY(name)								      \
+  .set noreorder;							      \
+  li v0, SYS_ify(syscall_name);						      \
+  syscall;								      \
+  .set reorder;								      \
+  bne a3, zero, 99b;							      \
+L(syse1):
+#endif
+
+#endif
diff -Nur sysdeps/unix/mips/pipe.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/pipe.S
--- sysdeps/unix/mips/pipe.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/pipe.S	2003-01-11 16:26:35.000000000 +0100
@@ -27,7 +27,7 @@
 	/* Go out with a clean status.  */
 	move v0, zero
 	j ra
-	.end __pipe
+PSEUDO_END(__pipe)
 
 libc_hidden_def (__pipe)
 weak_alias (__pipe, pipe)
diff -Nur sysdeps/unix/mips/rt-sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/rt-sysdep.S
--- sysdeps/unix/mips/rt-sysdep.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/rt-sysdep.S	2004-12-20 09:34:02.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdep.S>
diff -Nur sysdeps/unix/mips/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/sysdep.h
--- sysdeps/unix/mips/sysdep.h	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/sysdep.h	2004-11-24 05:36:10.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,95,97,99,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Brendan Kehoe (brendan@zen.org).
 
@@ -17,6 +18,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <sgidefs.h>
 #include <sysdeps/unix/sysdep.h>
 
 #ifdef __ASSEMBLER__
@@ -29,47 +31,49 @@
   .ent name,0;								      \
   name##:
 
-/* Note that while it's better structurally, going back to call __syscall_error
-   can make things confusing if you're debugging---it looks like it's jumping
-   backwards into the previous fn.  */
-#ifdef __PIC__
- #define PSEUDO(name, syscall_name, args) \
-  .align 2;								      \
-  99: la t9,__syscall_error;						      \
-  jr t9;								      \
-  ENTRY(name)								      \
-  .set noreorder;							      \
-  .cpload t9;								      \
-  li v0, SYS_ify(syscall_name);						      \
-  syscall;								      \
-  .set reorder;								      \
-  bne a3, zero, 99b;							      \
-syse1:
-#else
-#define PSEUDO(name, syscall_name, args) \
-  .set noreorder;							      \
-  .align 2;								      \
-  99: j __syscall_error;							      \
-  ENTRY(name)								      \
-  .set noreorder;							      \
-  li v0, SYS_ify(syscall_name);						      \
-  syscall;								      \
-  .set reorder;								      \
-  bne a3, zero, 99b;							      \
-syse1:
-#endif
+#undef END
+#define	END(function)                                   \
+		.end	function;		        \
+		.size	function,.-function
+
+#define ret	j ra ; nop
 
 #undef PSEUDO_END
-#define PSEUDO_END(sym) .end sym
+#define PSEUDO_END(sym) .end sym; .size sym,.-sym
 
-#define ret	j ra ; nop
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  .set noreorder;					\
+  li v0, SYS_ify(syscall_name);				\
+  syscall
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym) .end sym; .size sym,.-sym
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  .set noreorder;					\
+  li v0, SYS_ify(syscall_name);				\
+  syscall
 
-#undef END
-#define END(sym)        .end sym
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym) .end sym; .size sym,.-sym
+
+#define ret_ERRVAL ret
 
 #define r0	v0
 #define r1	v1
 /* The mips move insn is d,s.  */
 #define MOVE(x,y)	move y , x
 
+#if _MIPS_SIM == _ABIO32
+# define L(label) $L ## label
+#else
+# define L(label) .L ## label
+#endif
+
 #endif
diff -Nur sysdeps/unix/mips/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/sysdep.S
--- sysdeps/unix/mips/sysdep.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/sysdep.S	2003-04-09 04:51:04.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,93,94,97,98,99,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2002, 2003 
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Brendan Kehoe (brendan@zen.org).
 
@@ -20,50 +21,52 @@
 #include <sysdep.h>
 #define _ERRNO_H
 #include <bits/errno.h>
+#include <sys/asm.h>
 
 #ifdef _LIBC_REENTRANT
 
+LOCALSZ= 3
+FRAMESZ= (((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK
+RAOFF= FRAMESZ-(1*SZREG)
+GPOFF= FRAMESZ-(2*SZREG)
+V0OFF= FRAMESZ-(3*SZREG)
+	
 ENTRY(__syscall_error)
 #ifdef __PIC__
-	.set noreorder
-	.set	noat
-	move	$1, $31
-	bltzal	$0, 0f
-	nop
-0:	.cpload	$31
-	move	$31, $1
-	.set	at
-	.set	reorder
+	.set noat
+	SETUP_GPX (AT)
+	.set at
 #endif
-	subu	sp, 32
+	PTR_SUBU sp, FRAMESZ
+	.set noat
+	SETUP_GPX64(GPOFF,AT)
+	.set at
 #ifdef __PIC__
-	.cprestore 16
+	SAVE_GP(GPOFF)
 #endif
-	sw	v0, 20(sp)
-	sw	ra, 24(sp)
+	REG_S	v0, V0OFF(sp)
+	REG_S	ra, RAOFF(sp)
 
 #if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
 	/* We translate the system's EWOULDBLOCK error into EAGAIN.
 	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
 	   EWOULDBLOCK_sys is the original number.  */
-	bne	v0, EWOULDBLOCK_sys, skip
+	bne	v0, EWOULDBLOCK_sys, L(skip)
 	nop
 	li	v0, EAGAIN
-skip:
+L(skip):
 #endif
-	/* Store it in the "real" variable ... */
-	sw v0, errno
-
 	/* Find our per-thread errno address  */
 	jal	__errno_location
 
 	/* Store the error value.  */
-	lw	t0, 20(sp)
+	REG_L	t0, V0OFF(sp)
 	sw	t0, 0(v0)
 
 	/* And just kick back a -1.  */
-	lw	ra, 24(sp)
-	addiu	sp, 32
+	REG_L	ra, RAOFF(sp)
+	RESTORE_GP64
+	PTR_ADDU sp, FRAMESZ
 	li	v0, -1
 	j	ra
 	END(__syscall_error)
@@ -73,29 +76,25 @@
 
 ENTRY(__syscall_error)
 #ifdef __PIC__
-	.set	noreorder
-	.set	noat
-	move	$1, $31
-	bltzal	$0, 0f
-	nop
-0:	.cpload	$31
-	move	$31, $1
-	.set	at
-	.set	reorder
+	SETUP_GPX (AT)
 #endif
+	SETUP_GPX64 (t9, AT)
+	
 #if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
 	/* We translate the system's EWOULDBLOCK error into EAGAIN.
 	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
 	   EWOULDBLOCK_sys is the original number.  */
-	bne v0, EWOULDBLOCK_sys, skip
+	bne v0, EWOULDBLOCK_sys, L(skip)
 	li v0, EAGAIN
-skip:
+L(skip):
 #endif
 	/* Store it in errno... */
 	sw v0, errno
 
 	/* And just kick back a -1.  */
 	li v0, -1
+
+	RESTORE_GP64
 	j ra
 	END(__syscall_error)
 #endif  /* _LIBC_REENTRANT  */
diff -Nur sysdeps/unix/mips/wait.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/wait.S
--- sysdeps/unix/mips/wait.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mips/wait.S	2003-03-14 04:59:37.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992, 1994, 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1994, 1995, 1997, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Brendan Kehoe (brendan@zen.org).
 
@@ -28,18 +29,18 @@
 
 	li v0, SYS_wait
 	syscall
-	beqz a3, noerror
+	beqz a3, L(noerror)
 	nop
 	j __syscall_error
 	nop
 
-noerror:
+L(noerror):
 	/* If the arg is not NULL, store v1 there.  */
-	beqz a0, noarg
+	beqz a0, L(noarg)
 	nop
 	sw v1, 0(a0)
 	nop
-noarg:
+L(noarg):
 	ret
 	.end __wait
 
diff -Nur sysdeps/unix/mman/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mman/syscalls.list
--- sysdeps/unix/mman/syscalls.list	2000-07-18 03:57:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/mman/syscalls.list	2002-12-15 01:49:14.000000000 +0100
@@ -7,5 +7,5 @@
 madvise		-	madvise		i:pii	madvise
 mmap		-	mmap		b:aniiii __mmap		mmap
 mprotect	-	mprotect	i:aii	__mprotect	mprotect
-msync		-	msync		i:aii	__libc_msync	msync
+msync		-	msync		Ci:aii	__libc_msync	msync
 munmap		-	munmap		i:ai	__munmap	munmap
diff -Nur sysdeps/unix/opendir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/opendir.c
--- sysdeps/unix/opendir.c	2002-08-26 23:16:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/opendir.c	2003-09-22 23:14:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991-1996,98,2000-2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991-1996,98,2000-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,8 +26,11 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <stdio.h>
+#include <string.h>
 
 #include <dirstream.h>
+#include <not-cancel.h>
+
 
 /* opendir() must not accidentally open something other than a directory.
    Some OS's have kernel support for that, some don't.  In the worst
@@ -50,11 +53,11 @@
 tryopen_o_directory (void)
 {
   int serrno = errno;
-  int x = __open ("/dev/null", O_RDONLY|O_NDELAY|O_DIRECTORY);
+  int x = open_not_cancel_2 ("/dev/null", O_RDONLY|O_NDELAY|O_DIRECTORY);
 
   if (x >= 0)
     {
-      __close (x);
+      close_not_cancel_no_status (x);
       o_directory_works = -1;
     }
   else if (errno != ENOTDIR)
@@ -110,7 +113,7 @@
 	 }
     }
 
-  fd = __open64 (name, O_RDONLY|O_NDELAY|EXTRA_FLAGS);
+  fd = open_not_cancel_2 (name, O_RDONLY|O_NDELAY|EXTRA_FLAGS|O_LARGEFILE);
   if (__builtin_expect (fd, 0) < 0)
     return NULL;
 
@@ -135,24 +138,27 @@
     goto lose;
 
 #ifdef _STATBUF_ST_BLKSIZE
-  if (__builtin_expect ((size_t) statbuf.st_blksize >= sizeof (struct dirent),
+  if (__builtin_expect ((size_t) statbuf.st_blksize >= sizeof (struct dirent64),
 			1))
     allocation = statbuf.st_blksize;
   else
 #endif
-    allocation = (BUFSIZ < sizeof (struct dirent)
-		  ? sizeof (struct dirent) : BUFSIZ);
+    allocation = (BUFSIZ < sizeof (struct dirent64)
+		  ? sizeof (struct dirent64) : BUFSIZ);
+
+  const int pad = -sizeof (DIR) % __alignof__ (struct dirent64);
 
-  dirp = (DIR *) calloc (1, sizeof (DIR) + allocation); /* Zero-fill.  */
+  dirp = (DIR *) malloc (sizeof (DIR) + allocation + pad);
   if (dirp == NULL)
   lose:
     {
       save_errno = errno;
-      (void) __close (fd);
+      close_not_cancel_no_status (fd);
       __set_errno (save_errno);
       return NULL;
     }
-  dirp->data = (char *) (dirp + 1);
+  memset (dirp, '\0', sizeof (DIR));
+  dirp->data = (char *) (dirp + 1) + pad;
   dirp->allocation = allocation;
   dirp->fd = fd;
 
diff -Nur sysdeps/unix/rewinddir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/rewinddir.c
--- sysdeps/unix/rewinddir.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/rewinddir.c	2005-02-16 11:43:02.000000000 +0100
@@ -30,6 +30,7 @@
 {
   __libc_lock_lock (dirp->lock);
   (void) __lseek (dirp->fd, (off_t) 0, SEEK_SET);
+  dirp->filepos = 0;
   dirp->offset = 0;
   dirp->size = 0;
   __libc_lock_unlock (dirp->lock);
diff -Nur sysdeps/unix/setxid.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/setxid.h
--- sysdeps/unix/setxid.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/setxid.h	2004-11-12 02:17:42.000000000 +0100
@@ -0,0 +1,4 @@
+#include <sysdep.h>
+
+#define INLINE_SETXID_SYSCALL(name, nr, args...) \
+  INLINE_SYSCALL (name, nr, args)
diff -Nur sysdeps/unix/sparc/fork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/fork.S
--- sysdeps/unix/sparc/fork.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/fork.S	2002-12-31 21:37:29.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 94, 95, 97, 99 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 92, 94, 95, 97, 99, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,5 +26,6 @@
 	sub %o1, 1, %o1
 	retl
 	and %o0, %o1, %o0
+libc_hidden_def (__fork)
 
 weak_alias (__fork, fork)
diff -Nur sysdeps/unix/sparc/start.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/start.c
--- sysdeps/unix/sparc/start.c	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/start.c	2004-09-14 06:24:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,94,95,96,97,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -6,6 +6,23 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -39,17 +56,13 @@
 weak_alias (__data_start, data_start)
 #endif
 
-VOLATILE int __errno;
-strong_alias (__errno, errno)
-
-
-extern void __libc_init __P ((int argc, char **argv, char **envp));
-extern int main __P ((int argc, char **argv, char **envp));
+extern void __libc_init (int argc, char **argv, char **envp) __THROW;
+extern int main (int argc, char **argv, char **envp) __THROW;
 
 register long int sp asm("%sp"), fp asm("%fp");
 
 #ifndef NO_SHLIB
-static void init_shlib __P ((void));
+static void init_shlib (void) __THROW;
 #endif
 
 #ifndef NO_EXPLICIT_START
diff -Nur sysdeps/unix/sparc/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/sysdep.h
--- sysdeps/unix/sparc/sysdep.h	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/sysdep.h	2003-08-17 02:33:13.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1994, 1995, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1993, 1994, 1995, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -52,7 +52,21 @@
   jmp %g1 + %lo(syscall_error);	nop;		\
 1:
 
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+  .global syscall_error;			\
+  ENTRY (name)					\
+  mov SYS_ify(syscall_name), %g1;		\
+  ta 0
+
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .global syscall_error;			\
+  ENTRY (name)					\
+  mov SYS_ify(syscall_name), %g1;		\
+  ta 0
+
 #define	ret		retl; nop
+#define	ret_NOERRNO	retl; nop
+#define	ret_ERRVAL	retl; nop
 #define	r0		%o0
 #define	r1		%o1
 #define	MOVE(x,y)	mov x, y
diff -Nur sysdeps/unix/sparc/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/vfork.S
--- sysdeps/unix/sparc/vfork.S	2001-07-07 21:21:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sparc/vfork.S	2002-12-31 21:37:29.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 94, 95, 97, 99 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 92, 94, 95, 97, 99, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,5 +30,6 @@
 	sub %o1, 1, %o1
 	retl
 	and %o0, %o1, %o0
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/s-proto-bp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/s-proto-bp.S
--- sysdeps/unix/s-proto-bp.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/s-proto-bp.S	2003-01-15 23:10:08.000000000 +0100
@@ -0,0 +1,4 @@
+/* This file exists just to have its dependencies determined.
+   Those dependencies are then used for the bp thunk objects.  */
+
+#include <bp-thunks.h>
diff -Nur sysdeps/unix/s-proto-cancel.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/s-proto-cancel.S
--- sysdeps/unix/s-proto-cancel.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/s-proto-cancel.S	2002-12-30 01:12:47.000000000 +0100
@@ -0,0 +1,5 @@
+/* This file exists just to have its dependencies determined.
+   Those dependencies are then used for the objects of the cancellable
+   system calls.  */
+
+#include <sysdep-cancel.h>
diff -Nur sysdeps/unix/start.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/start.c
--- sysdeps/unix/start.c	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/start.c	2004-08-16 06:51:03.000000000 +0200
@@ -6,6 +6,23 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -35,13 +52,6 @@
 #define	DECL_DUMMIES
 #endif
 
-#ifndef errno
-/* __errno must be initialized since otherwise one cannot create an
-   alias (at least on some platforms).  */
-volatile int __errno = 0;
-strong_alias (__errno, errno)
-#endif
-
 extern void __libc_init (int argc, char **argv, char **envp);
 extern int main (int argc, char **argv, char **envp);
 
diff -Nur sysdeps/unix/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/syscalls.list
--- sysdeps/unix/syscalls.list	2002-08-26 23:16:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/syscalls.list	2003-07-27 20:24:21.000000000 +0200
@@ -6,36 +6,36 @@
 chmod		-	chmod		i:si	__chmod		chmod
 chown		-	chown		i:sii	__chown		__chown_internal chown
 chroot		-	chroot		i:s	chroot
-close		-	close		i:i	__libc_close	__close close
+close		-	close		Ci:i	__libc_close	__close close
 dup		-	dup		i:i	__dup		dup
 dup2		-	dup2		i:ii	__dup2		dup2
 fchdir		-	fchdir		i:i	__fchdir	fchdir
-fcntl		-	fcntl		i:iiF	__libc_fcntl	__fcntl __fcntl_internal fcntl
+fcntl		-	fcntl		Ci:iiF	__libc_fcntl	__fcntl __fcntl_internal fcntl
 fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs
-fsync		-	fsync		i:i	__libc_fsync	fsync
+fsync		-	fsync		Ci:i	__libc_fsync	fsync
 getdomain	-	getdomainname	i:si	getdomainname
-getgid		-	getgid		i:	__getgid	getgid
+getgid		-	getgid		Ei:	__getgid	getgid
 getgroups	-	getgroups	i:ip	__getgroups	getgroups
 getitimer	-	getitimer	i:ip	__getitimer	getitimer
-getpid		-	getpid		i:	__getpid	getpid
+getpid		-	getpid		Ei:	__getpid	getpid
 getpriority	-	getpriority	i:ii	getpriority
 getrlimit	-	getrlimit	i:ip	__getrlimit	getrlimit
-getuid		-	getuid		i:	__getuid	getuid
+getuid		-	getuid		Ei:	__getuid	getuid
 ioctl		-	ioctl		i:iiI	__ioctl		ioctl
 kill		-	kill		i:ii	__kill		kill
 link		-	link		i:ss	__link		link
 lseek		-	lseek		i:iii	__libc_lseek	__lseek lseek
 mkdir		-	mkdir		i:si	__mkdir		mkdir
-open		-	open		i:siv	__libc_open __open open
+open		-	open		Ci:siv	__libc_open __open open
 profil		-	profil		i:piii	__profil	profil
 ptrace		-	ptrace		i:iiii	ptrace
-read		-	read		i:ibn	__libc_read	__read read
+read		-	read		Ci:ibn	__libc_read	__read read
 readlink	-	readlink	i:spi	__readlink	readlink
-readv		-	readv		i:ipi	__readv		readv
+readv		-	readv		Ci:ipi	__readv		readv
 reboot		-	reboot		i:i	reboot
 rename		-	rename		i:ss	rename
 rmdir		-	rmdir		i:s	__rmdir		rmdir
-select		-	select		i:iPPPP	__select	select
+select		-	select		Ci:iPPPP	__select	__libc_select select
 setdomain	-	setdomainname	i:si	setdomainname
 setegid		-	setegid		i:i	__setegid	setegid
 seteuid		-	seteuid		i:i	__seteuid	seteuid
@@ -47,7 +47,7 @@
 setsid		-	setsid		i:	__setsid	setsid
 settimeofday	-	settimeofday	i:PP	__settimeofday	settimeofday
 setuid		-	setuid		i:i	__setuid	setuid
-sigsuspend	-	sigsuspend	i:p	sigsuspend
+sigsuspend	-	sigsuspend	Ci:p	sigsuspend
 sstk		-	sstk		b:i	sstk
 statfs		-	statfs		i:sp	__statfs	statfs
 swapoff		-	swapoff		i:s	swapoff
@@ -57,9 +57,9 @@
 sys_fstat	fxstat	fstat		i:ip	__syscall_fstat
 sys_mknod	xmknod	mknod		i:sii	__syscall_mknod
 sys_stat	xstat	stat		i:sp	__syscall_stat
-umask		-	umask		i:i	__umask		umask
+umask		-	umask		Ei:i	__umask		umask
 uname		-	uname		i:p	__uname		uname
 unlink		-	unlink		i:s	__unlink	unlink
 utimes		-	utimes		i:sp	__utimes	utimes
-write		-	write		i:ibn	__libc_write	__write write
-writev		-	writev		i:ipi	__writev	writev
+write		-	write		Ci:ibn	__libc_write	__write write
+writev		-	writev		Ci:ipi	__writev	writev
diff -Nur sysdeps/unix/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysdep.h
--- sysdeps/unix/sysdep.h	2001-07-07 21:21:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysdep.h	2003-08-17 02:33:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 92, 93, 96, 98 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 92, 93, 96, 98, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -47,6 +47,12 @@
 #ifndef PSEUDO_END
 #define PSEUDO_END(sym)
 #endif
+#ifndef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym)	PSEUDO_END(sym)
+#endif
+#ifndef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym)	PSEUDO_END(sym)
+#endif
 
 /* Wrappers around system calls should normally inline the system call code.
    But sometimes it is not possible or implemented and we use this code.  */
diff -Nur sysdeps/unix/sysv/linux/bits/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/a.out.h
--- sysdeps/unix/sysv/linux/bits/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/a.out.h	2003-07-25 11:04:57.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
+
+/* Signal to users of this header that this architecture really doesn't
+   support a.out binary format.  */
+#define __NO_A_OUT_SUPPORT 1
diff -Nur sysdeps/unix/sysv/linux/bits/in.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/in.h
--- sysdeps/unix/sysv/linux/bits/in.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/in.h	2004-07-21 00:14:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991-1999, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,13 +25,36 @@
 /* Options for use with `getsockopt' and `setsockopt' at the IP level.
    The first word in the comment at the right is the data type used;
    "bool" means a boolean value stored in an `int'.  */
-#define IP_TOS             1	/* int; IP type of service and precedence.  */
-#define IP_TTL             2	/* int; IP time to live.  */
-#define IP_HDRINCL         3	/* int; Header is included with data.  */
-#define IP_OPTIONS         4	/* ip_opts; IP per-packet options.  */
+#define        IP_OPTIONS      4       /* ip_opts; IP per-packet options.  */
+#define        IP_HDRINCL      3       /* int; Header is included with data.  */
+#define        IP_TOS          1       /* int; IP type of service and precedence.  */
+#define        IP_TTL          2       /* int; IP time to live.  */
+#define        IP_RECVOPTS     6       /* bool; Receive all IP options w/datagram.  */
+/* For BSD compatibility.  */
+#define        IP_RECVRETOPTS  IP_RETOPTS       /* bool; Receive IP options for response.  */
+#define        IP_RETOPTS      7       /* ip_opts; Set/get IP per-packet options.  */
+#define IP_MULTICAST_IF 32	/* in_addr; set/get IP multicast i/f */
+#define IP_MULTICAST_TTL 33	/* u_char; set/get IP multicast ttl */
+#define IP_MULTICAST_LOOP 34	/* i_char; set/get IP multicast loopback */
+#define IP_ADD_MEMBERSHIP 35	/* ip_mreq; add an IP group membership */
+#define IP_DROP_MEMBERSHIP 36	/* ip_mreq; drop an IP group membership */
+#define IP_UNBLOCK_SOURCE 37	/* ip_mreq_source: unblock data from source */
+#define IP_BLOCK_SOURCE 38	/* ip_mreq_source: block data from source */
+#define IP_ADD_SOURCE_MEMBERSHIP 39 /* ip_mreq_source: join source group */
+#define IP_DROP_SOURCE_MEMBERSHIP 40 /* ip_mreq_source: leave source group */
+#define IP_MSFILTER 41
+#define MCAST_JOIN_GROUP 42	/* group_req: join any-source group */
+#define MCAST_BLOCK_SOURCE 43	/* group_source_req: block from given group */
+#define MCAST_UNBLOCK_SOURCE 44	/* group_source_req: unblock from given group*/
+#define MCAST_LEAVE_GROUP 45	/* group_req: leave any-source group */
+#define MCAST_JOIN_SOURCE_GROUP 46 /* group_source_req: join source-spec gr */
+#define MCAST_LEAVE_SOURCE_GROUP 47 /* group_source_req: leave source-spec gr*/
+#define MCAST_MSFILTER 48
+
+#define MCAST_EXCLUDE   0
+#define MCAST_INCLUDE   1
+
 #define IP_ROUTER_ALERT    5	/* bool */
-#define IP_RECVOPTS        6	/* bool */
-#define IP_RETOPTS         7	/* bool */
 #define IP_PKTINFO         8	/* bool */
 #define IP_PKTOPTIONS      9
 #define IP_PMTUDISC        10	/* obsolete name? */
@@ -39,14 +62,7 @@
 #define IP_RECVERR         11	/* bool */
 #define IP_RECVTTL         12	/* bool */
 #define IP_RECVTOS         13	/* bool */
-#define IP_MULTICAST_IF    32	/* in_addr; set/get IP multicast i/f */
-#define IP_MULTICAST_TTL   33	/* u_char; set/get IP multicast ttl */
-#define IP_MULTICAST_LOOP  34	/* i_char; set/get IP multicast loopback */
-#define IP_ADD_MEMBERSHIP  35	/* ip_mreq; add an IP group membership */
-#define IP_DROP_MEMBERSHIP 36	/* ip_mreq; drop an IP group membership */
 
-/* For BSD compatibility.  */
-#define IP_RECVRETOPTS	IP_RETOPTS
 
 /* IP_MTU_DISCOVER arguments.  */
 #define IP_PMTUDISC_DONT   0	/* Never send DF frames.  */
@@ -60,23 +76,16 @@
 #define IP_DEFAULT_MULTICAST_LOOP       1
 #define IP_MAX_MEMBERSHIPS              20
 
-/* Structure used to describe IP options for IP_OPTIONS. The `ip_dst'
-   field is used for the first-hop gateway when using a source route
-   (this gets put into the header proper).  */
+/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
+   The `ip_dst' field is used for the first-hop gateway when using a
+   source route (this gets put into the header proper).  */
 struct ip_opts
   {
     struct in_addr ip_dst;	/* First hop; zero without source route.  */
     char ip_opts[40];		/* Actually variable in size.  */
   };
 
-/* Structure used for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP. */
-struct ip_mreq
-  {
-    struct in_addr imr_multiaddr;	/* IP multicast address of group */
-    struct in_addr imr_interface;	/* local IP address of interface */
-  };
-
-/* As above but including interface specification by index.  */
+/* Like `struct ip_mreq' but including interface specification by index.  */
 struct ip_mreqn
   {
     struct in_addr imr_multiaddr;	/* IP multicast address of group */
@@ -103,6 +112,9 @@
 #define IPV6_PKTOPTIONS		6
 #define IPV6_CHECKSUM		7
 #define IPV6_HOPLIMIT		8
+
+#define SCM_SRCRT		IPV6_RXSRCRT
+
 #define IPV6_NEXTHOP		9
 #define IPV6_AUTHHDR		10
 #define IPV6_UNICAST_HOPS	16
@@ -115,15 +127,17 @@
 #define IPV6_MTU_DISCOVER	23
 #define IPV6_MTU		24
 #define IPV6_RECVERR		25
-
-#define SCM_SRCRT		IPV6_RXSRCRT
+#define IPV6_V6ONLY		26
+#define IPV6_JOIN_ANYCAST	27
+#define IPV6_LEAVE_ANYCAST	28
+#define IPV6_IPSEC_POLICY	34
+#define IPV6_XFRM_POLICY	35
 
 /* Obsolete synonyms for the above.  */
-#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
-#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
 #define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
 #define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
-
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
 
 /* IPV6_MTU_DISCOVER values.  */
 #define IPV6_PMTUDISC_DONT	0	/* Never send DF frames.  */
diff -Nur sysdeps/unix/sysv/linux/bits/ioctls.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/ioctls.h
--- sysdeps/unix/sysv/linux/bits/ioctls.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/ioctls.h	2003-01-28 09:29:37.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -48,6 +48,7 @@
 #define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
 #define SIOCGIFMTU	0x8921		/* get MTU size			*/
 #define SIOCSIFMTU	0x8922		/* set MTU size			*/
+#define SIOCSIFNAME	0x8923		/* set interface name		*/
 #define	SIOCSIFHWADDR	0x8924		/* set hardware address 	*/
 #define SIOCGIFENCAP	0x8925		/* get/set encapsulations       */
 #define SIOCSIFENCAP	0x8926
diff -Nur sysdeps/unix/sysv/linux/bits/local_lim.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/local_lim.h
--- sysdeps/unix/sysv/linux/bits/local_lim.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/local_lim.h	2004-04-13 04:12:03.000000000 +0200
@@ -1,5 +1,5 @@
 /* Minimum guaranteed maximum values for system limits.  Linux version.
-   Copyright (C) 1993, 94, 95, 96, 97, 98, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1993-1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -54,3 +54,15 @@
 /* Maximum amount by which a process can descrease its asynchronous I/O
    priority level.  */
 #define AIO_PRIO_DELTA_MAX	20
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX		32
+
+/* Maximum login name length.  This is arbitrary.  */
+#define LOGIN_NAME_MAX		256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX		64
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX		32768
diff -Nur sysdeps/unix/sysv/linux/bits/mqueue.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/mqueue.h
--- sysdeps/unix/sysv/linux/bits/mqueue.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/mqueue.h	2004-04-13 04:11:46.000000000 +0200
@@ -0,0 +1,32 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MQUEUE_H
+# error "Never use <bits/mqueue.h> directly; include <mqueue.h> instead."
+#endif
+
+typedef int mqd_t;
+
+struct mq_attr
+{
+  long int mq_flags;	/* Message queue flags.  */
+  long int mq_maxmsg;	/* Maximum number of messages.  */
+  long int mq_msgsize;	/* Maximum message size.  */
+  long int mq_curmsgs;	/* Number of messages currently queued.  */
+  long int __pad[4];
+};
diff -Nur sysdeps/unix/sysv/linux/bits/posix_opt.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/posix_opt.h
--- sysdeps/unix/sysv/linux/bits/posix_opt.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/posix_opt.h	2003-03-03 05:52:01.000000000 +0100
@@ -1,5 +1,5 @@
 /* Define POSIX options for Linux.
-   Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996,1997,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,31 +31,25 @@
 #define	_POSIX_SAVED_IDS	1
 
 /* Priority scheduling is supported.  */
-#define	_POSIX_PRIORITY_SCHEDULING	1
+#define	_POSIX_PRIORITY_SCHEDULING	200112L
 
 /* Synchronizing file data is supported.  */
-#define	_POSIX_SYNCHRONIZED_IO	1
+#define	_POSIX_SYNCHRONIZED_IO	200112L
 
 /* The fsync function is present.  */
-#define	_POSIX_FSYNC	1
+#define	_POSIX_FSYNC	200112L
 
 /* Mapping of files to memory is supported.  */
-#define	_POSIX_MAPPED_FILES	1
+#define	_POSIX_MAPPED_FILES	200112L
 
 /* Locking of all memory is supported.  */
-#define	_POSIX_MEMLOCK	1
+#define	_POSIX_MEMLOCK	200112L
 
 /* Locking of ranges of memory is supported.  */
-#define	_POSIX_MEMLOCK_RANGE	1
+#define	_POSIX_MEMLOCK_RANGE	200112L
 
 /* Setting of memory protections is supported.  */
-#define	_POSIX_MEMORY_PROTECTION	1
-
-/* Implementation supports `poll' function.  */
-#define	_POSIX_POLL	1
-
-/* Implementation supports `select' and `pselect' functions.  */
-#define	_POSIX_SELECT	1
+#define	_POSIX_MEMORY_PROTECTION	200112L
 
 /* Only root can change owner of file.  */
 #define	_POSIX_CHOWN_RESTRICTED	1
@@ -74,7 +68,7 @@
 #define	_XOPEN_SHM	1
 
 /* Real-time signals are supported.  */
-#define _POSIX_REALTIME_SIGNALS	1
+#define _POSIX_REALTIME_SIGNALS	200112L
 
 /* The LFS interface is available, except for the asynchronous I/O.  */
 #define _LFS_LARGEFILE		1
@@ -82,10 +76,10 @@
 #define _LFS64_STDIO		1
 
 /* POSIX timers are available.  */
-#define _POSIX_TIMERS	1
+#define _POSIX_TIMERS	200112L
 
 /* POSIX shared memory objects are implemented.  */
-#define _POSIX_SHARED_MEMORY_OBJECTS	1
+#define _POSIX_SHARED_MEMORY_OBJECTS	200112L
 
 /* GNU libc provides regular expression handling.  */
 #define _POSIX_REGEXP	1
@@ -94,6 +88,9 @@
 #define _POSIX_SHELL	1
 
 /* The `spawn' function family is supported.  */
-#define _POSIX_SPAWN	200912L
+#define _POSIX_SPAWN	200112L
+
+/* The monotonic clock might be available.  */
+#define _POSIX_MONOTONIC_CLOCK	0
 
 #endif /* bits/posix_opt.h */
diff -Nur sysdeps/unix/sysv/linux/bits/pthreadtypes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/pthreadtypes.h
--- sysdeps/unix/sysv/linux/bits/pthreadtypes.h	1998-06-30 14:04:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* No thread support.  */
diff -Nur sysdeps/unix/sysv/linux/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/resource.h
--- sysdeps/unix/sysv/linux/bits/resource.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/resource.h	2004-08-16 10:51:45.000000000 +0200
@@ -1,5 +1,6 @@
 /* Bit values & structures for resource limits.  Linux version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -55,45 +56,54 @@
      This affects swapping; processes that are exceeding their
      resident set size will be more likely to have physical memory
      taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
 
   /* Number of open files.  */
   RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
 #define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
 
-  /* Address space limit (?) */
+  /* Address space limit.  */
   RLIMIT_AS = 9,
 #define RLIMIT_AS RLIMIT_AS
 
   /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
+  __RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC __RLIMIT_NPROC
 
   /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+  __RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
 
   /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
 
-  RLIM_NLIMITS = 11
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  __RLIMIT_NLIMITS = 13,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
 };
 
 /* Value to indicate that there is no limit.  */
 #ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((long int)(~0UL >> 1))
+# define RLIM_INFINITY ((unsigned long int)(~0UL))
 #else
-# define RLIM_INFINITY 0x7fffffffffffffffLL
+# define RLIM_INFINITY 0xffffffffffffffffuLL
 #endif
 
 #ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0x7fffffffffffffffLL
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
 #endif
 
 /* We can represent all limits.  */
@@ -137,12 +147,8 @@
 #define RUSAGE_SELF RUSAGE_SELF
 
   /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
+  RUSAGE_CHILDREN = -1
 #define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
 };
 
 #define __need_timeval
diff -Nur sysdeps/unix/sysv/linux/bits/sched.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/sched.h
--- sysdeps/unix/sysv/linux/bits/sched.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/sched.h	2003-07-22 05:41:53.000000000 +0200
@@ -1,6 +1,6 @@
 /* Definitions of constants and data structure for POSIX 1003.1b-1993
    scheduling interface.
-   Copyright (C) 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996-1999,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,10 +37,25 @@
 # define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
 # define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
 # define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
-# define CLONE_PID     0x00001000 /* Set if pid shared.  */
 # define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
 # define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
 				     wake it up on mm_release.  */
+# define CLONE_PARENT  0x00008000 /* Set if we want to have the same
+				     parent as the cloner.  */
+# define CLONE_THREAD  0x00010000 /* Set to add to same thread group.  */
+# define CLONE_NEWNS   0x00020000 /* Set to create new namespace.  */
+# define CLONE_SYSVSEM 0x00040000 /* Set to shared SVID SEM_UNDO semantics.  */
+# define CLONE_SETTLS  0x00080000 /* Set TLS info.  */
+# define CLONE_PARENT_SETTID 0x00100000 /* Store TID in userlevel buffer
+					   before MM copy.  */
+# define CLONE_CHILD_CLEARTID 0x00200000 /* Register exit futex and memory
+					    location to clear.  */
+# define CLONE_DETACHED 0x00400000 /* Create clone detached.  */
+# define CLONE_UNTRACED 0x00800000 /* Set if the tracing process can't
+				      force CLONE_PTRACE on this clone.  */
+# define CLONE_CHILD_SETTID 0x01000000 /* Store TID in userlevel buffer in
+					  the child.  */
+# define CLONE_STOPPED	0x02000000 /* Start in stopped state.  */
 #endif
 
 /* The official definition.  */
@@ -71,3 +86,39 @@
   };
 # undef __need_schedparam
 #endif
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	1024
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# define __CPU_ZERO(cpusetp) \
+  do {									      \
+    unsigned int __i;							      \
+    cpu_set_t *__arr = (cpusetp);					      \
+    for (__i = 0; __i < sizeof (cpu_set_t) / sizeof (__cpu_mask); ++__i)      \
+      __arr->__bits[__i] = 0;						      \
+  } while (0)
+# define __CPU_SET(cpu, cpusetp) \
+  ((cpusetp)->__bits[__CPUELT (cpu)] |= __CPUMASK (cpu))
+# define __CPU_CLR(cpu, cpusetp) \
+  ((cpusetp)->__bits[__CPUELT (cpu)] &= ~__CPUMASK (cpu))
+# define __CPU_ISSET(cpu, cpusetp) \
+  (((cpusetp)->__bits[__CPUELT (cpu)] & __CPUMASK (cpu)) != 0)
+#endif
diff -Nur sysdeps/unix/sysv/linux/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/shm.h
--- sysdeps/unix/sysv/linux/bits/shm.h	2002-08-24 00:19:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/shm.h	2004-08-12 19:26:28.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,2000,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -35,6 +35,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -70,6 +72,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST	01000	/* segment will be destroyed on last detach */
 # define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
 
 struct	shminfo
   {
@@ -95,3 +98,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/bits/siginfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/siginfo.h
--- sysdeps/unix/sysv/linux/bits/siginfo.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/siginfo.h	2003-04-21 09:27:10.000000000 +0200
@@ -1,5 +1,5 @@
-/* siginfo_t, sigevent and constants.  Linux/SPARC version.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* siginfo_t, sigevent and constants.  Linux version.
+   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -69,8 +69,9 @@
 	/* POSIX.1b timers.  */
 	struct
 	  {
-	    unsigned int _timer1;
-	    unsigned int _timer2;
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
 	  } _timer;
 
 	/* POSIX.1b signals.  */
@@ -110,8 +111,8 @@
 /* X/Open requires some more fields with fixed names.  */
 # define si_pid		_sifields._kill.si_pid
 # define si_uid		_sifields._kill.si_uid
-# define si_timer1	_sifields._timer._timer1
-# define si_timer2	_sifields._timer._timer2
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
 # define si_status	_sifields._sigchld.si_status
 # define si_utime	_sifields._sigchld.si_utime
 # define si_stime	_sifields._sigchld.si_stime
@@ -127,8 +128,10 @@
    signals.  */
 enum
 {
-  SI_ASYNCNL = -6,		/* Sent by asynch name lookup completion.  */
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
 # define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
   SI_SIGIO,			/* Sent by queued SIGIO. */
 # define SI_SIGIO	SI_SIGIO
   SI_ASYNCIO,			/* Sent by AIO completion.  */
@@ -267,9 +270,6 @@
 #  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
 # endif
 
-/* Forward declaration of the `pthread_attr_t' type.  */
-struct __pthread_attr_s;
-
 typedef struct sigevent
   {
     sigval_t sigev_value;
@@ -280,10 +280,14 @@
       {
 	int _pad[__SIGEV_PAD_SIZE];
 
+	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
+	   thread to receive the signal.  */
+	__pid_t _tid;
+
 	struct
 	  {
-	    void (*_function) (sigval_t);	  /* Function to start.  */
-	    struct __pthread_attr_s *_attribute;  /* Really pthread_attr_t.  */
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
 	  } _sigev_thread;
       } _sigev_un;
   } sigevent_t;
@@ -299,8 +303,11 @@
 # define SIGEV_SIGNAL	SIGEV_SIGNAL
   SIGEV_NONE,			/* Other notification: meaningless.  */
 # define SIGEV_NONE	SIGEV_NONE
-  SIGEV_THREAD			/* Deliver via thread creation.  */
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
 # define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
 };
 
 #endif	/* have _SIGNAL_H.  */
diff -Nur sysdeps/unix/sysv/linux/bits/signum.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/signum.h
--- sysdeps/unix/sysv/linux/bits/signum.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/signum.h	2003-04-01 07:51:57.000000000 +0200
@@ -1,5 +1,5 @@
 /* Signal number definitions.  Linux version.
-   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1995,1996,1997,1998,1999,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -66,7 +66,7 @@
 #define SIGSYS		31	/* Bad system call.  */
 #define SIGUNUSED	31
 
-#define	_NSIG		64	/* Biggest signal number + 1
+#define	_NSIG		65	/* Biggest signal number + 1
 				   (including real-time signals).  */
 
 #define SIGRTMIN        (__libc_current_sigrtmin ())
diff -Nur sysdeps/unix/sysv/linux/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/socket.h
--- sysdeps/unix/sysv/linux/bits/socket.h	2001-09-26 07:21:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/socket.h	2004-11-20 08:04:23.000000000 +0100
@@ -1,5 +1,5 @@
 /* System-specific socket constants and types.  Linux version.
-   Copyright (C) 1991,1992,1994-1999,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1991,1992,1994-2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -218,10 +218,10 @@
     socklen_t msg_namelen;	/* Length of address data.  */
 
     struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
-    int msg_iovlen;		/* Number of elements in the vector.  */
+    size_t msg_iovlen;		/* Number of elements in the vector.  */
 
     void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+    size_t msg_controllen;	/* Ancillary data buffer length.  */
 
     int msg_flags;		/* Flags on received message.  */
   };
@@ -261,7 +261,7 @@
 #  define _EXTERN_INLINE extern __inline
 # endif
 _EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
     /* The kernel header does this so there may be a reason.  */
@@ -283,13 +283,12 @@
    <linux/socket.h>.  */
 enum
   {
-    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
+    SCM_RIGHTS = 0x01		/* Transfer file descriptors.  */
 #define SCM_RIGHTS SCM_RIGHTS
 #ifdef __USE_BSD
-    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
+    , SCM_CREDENTIALS = 0x02	/* Credentials passing.  */
 # define SCM_CREDENTIALS SCM_CREDENTIALS
 #endif
-    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
   };
 
 /* User visible structure for SCM_CREDENTIALS message */
diff -Nur sysdeps/unix/sysv/linux/bits/statfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/statfs.h
--- sysdeps/unix/sysv/linux/bits/statfs.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/statfs.h	2003-07-12 20:59:47.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,12 +20,12 @@
 # error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
 #endif
 
-#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t*/
+#include <bits/types.h>
 
 struct statfs
   {
-    int f_type;
-    int f_bsize;
+    __SWORD_TYPE f_type;
+    __SWORD_TYPE f_bsize;
 #ifndef __USE_FILE_OFFSET64
     __fsblkcnt_t f_blocks;
     __fsblkcnt_t f_bfree;
@@ -40,25 +40,28 @@
     __fsfilcnt64_t f_ffree;
 #endif
     __fsid_t f_fsid;
-    int f_namelen;
-    int f_spare[6];
+    __SWORD_TYPE f_namelen;
+    __SWORD_TYPE f_frsize;
+    __SWORD_TYPE f_spare[5];
   };
 
 #ifdef __USE_LARGEFILE64
 struct statfs64
   {
-    int f_type;
-    int f_bsize;
+    __SWORD_TYPE f_type;
+    __SWORD_TYPE f_bsize;
     __fsblkcnt64_t f_blocks;
     __fsblkcnt64_t f_bfree;
     __fsblkcnt64_t f_bavail;
     __fsfilcnt64_t f_files;
     __fsfilcnt64_t f_ffree;
     __fsid_t f_fsid;
-    int f_namelen;
-    int f_spare[6];
+    __SWORD_TYPE f_namelen;
+    __SWORD_TYPE f_frsize;
+    __SWORD_TYPE f_spare[5];
   };
 #endif
 
-/* Tell code we have this member.  */
+/* Tell code we have these members.  */
 #define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
diff -Nur sysdeps/unix/sysv/linux/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/stat.h
--- sysdeps/unix/sysv/linux/bits/stat.h	2002-02-08 08:47:55.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -60,12 +60,27 @@
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 #endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
 #ifndef __USE_FILE_OFFSET64
     unsigned long int __unused4;
     unsigned long int __unused5;
@@ -91,12 +106,24 @@
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
 
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     __ino64_t st_ino;			/* File serial number.		*/
   };
 #endif
@@ -104,6 +131,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/bits/statvfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/statvfs.h
--- sysdeps/unix/sysv/linux/bits/statvfs.h	2002-07-10 09:24:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/statvfs.h	2002-10-24 01:48:58.000000000 +0200
@@ -22,6 +22,10 @@
 
 #include <bits/types.h>  /* For __fsblkcnt_t and __fsfilcnt_t.  */
 
+#if __WORDSIZE == 32
+#define _STATVFSBUF_F_UNUSED
+#endif
+
 struct statvfs
   {
     unsigned long int f_bsize;
@@ -42,12 +46,13 @@
     __fsfilcnt64_t f_favail;
 #endif
     unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
     int __f_unused;
+#endif
     unsigned long int f_flag;
     unsigned long int f_namemax;
     int __f_spare[6];
   };
-#define _STATVFSBUF_F_UNUSED
 
 #ifdef __USE_LARGEFILE64
 struct statvfs64
@@ -61,7 +66,9 @@
     __fsfilcnt64_t f_ffree;
     __fsfilcnt64_t f_favail;
     unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
     int __f_unused;
+#endif
     unsigned long int f_flag;
     unsigned long int f_namemax;
     int __f_spare[6];
diff -Nur sysdeps/unix/sysv/linux/bits/termios.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/termios.h
--- sysdeps/unix/sysv/linux/bits/termios.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/termios.h	2004-03-31 10:53:29.000000000 +0200
@@ -1,5 +1,6 @@
 /* termios type and macro definitions.  Linux version.
-   Copyright (C) 1993, 94, 95, 96, 97, 98, 99 Free Software Foundation, Inc.
+   Copyright (C) 1993,1994,1995,1996,1997,1998,1999,2003
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,6 +37,8 @@
     cc_t c_cc[NCCS];		/* control characters */
     speed_t c_ispeed;		/* input speed */
     speed_t c_ospeed;		/* output speed */
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
   };
 
 /* c_cc characters */
@@ -72,6 +75,7 @@
 #define IXANY	0004000
 #define IXOFF	0010000
 #define IMAXBEL	0020000
+#define IUTF8	0040000
 
 /* c_oflag bits */
 #define OPOST	0000001
diff -Nur sysdeps/unix/sysv/linux/bits/time.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/time.h
--- sysdeps/unix/sysv/linux/bits/time.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/time.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/* System-dependent timing definitions.  Linux version.
-   Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <time.h> instead.
- */
-
-#ifndef __need_timeval
-# ifndef _BITS_TIME_H
-#  define _BITS_TIME_H	1
-
-/* ISO/IEC 9899:1990 7.12.1: <time.h>
-   The macro `CLOCKS_PER_SEC' is the number per second of the value
-   returned by the `clock' function. */
-/* CAE XSH, Issue 4, Version 2: <time.h>
-   The value of CLOCKS_PER_SEC is required to be 1 million on all
-   XSI-conformant systems. */
-#  define CLOCKS_PER_SEC  1000000l
-
-#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
-/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
-   presents the real value for clock ticks per second for the system.  */
-#   include <bits/types.h>
-extern long int __sysconf (int);
-#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
-#  endif
-
-#  ifdef __USE_POSIX199309
-/* Identifier for system-wide realtime clock.  */
-#   define CLOCK_REALTIME	0
-
-/* Flag to indicate time is absolute.  */
-#   define TIMER_ABSTIME	1
-#  endif
-
-# endif	/* bits/time.h */
-#endif
-
-#ifdef __need_timeval
-# undef __need_timeval
-# ifndef _STRUCT_TIMEVAL
-#  define _STRUCT_TIMEVAL	1
-#  include <bits/types.h>
-
-/* A time value that is accurate to the nearest
-   microsecond but also has a range of years.  */
-struct timeval
-  {
-    __time_t tv_sec;		/* Seconds.  */
-    __suseconds_t tv_usec;	/* Microseconds.  */
-  };
-# endif	/* struct timeval */
-#endif	/* need timeval */
diff -Nur sysdeps/unix/sysv/linux/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/types.h
--- sysdeps/unix/sysv/linux/bits/types.h	2001-11-19 19:37:05.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,146 +0,0 @@
-/* Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <sys/types.h> instead.
- */
-
-#ifndef	_BITS_TYPES_H
-#define	_BITS_TYPES_H	1
-
-#include <features.h>
-
-#define __need_size_t
-#include <stddef.h>
-
-/* Convenience types.  */
-typedef unsigned char __u_char;
-typedef unsigned short __u_short;
-typedef unsigned int __u_int;
-typedef unsigned long __u_long;
-#ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef unsigned long long int __u_quad_t;
-__extension__ typedef long long int __quad_t;
-#else
-typedef struct
-  {
-    long int __val[2];
-  } __quad_t;
-typedef struct
-  {
-    __u_long __val[2];
-  } __u_quad_t;
-#endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef signed long long int __int64_t;
-__extension__ typedef unsigned long long int __uint64_t;
-#endif
-typedef __quad_t *__qaddr_t;
-
-typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
-typedef __u_int __uid_t;		/* Type of user identifications.  */
-typedef __u_int __gid_t;		/* Type of group identifications.  */
-typedef __u_long __ino_t;		/* Type of file serial numbers.  */
-typedef __u_int __mode_t;		/* Type of file attribute bitmasks.  */
-typedef __u_int __nlink_t;		/* Type of file link counts.  */
-typedef long int __off_t;		/* Type of file sizes and offsets.  */
-typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
-typedef int __pid_t;			/* Type of process identifications.  */
-typedef int __ssize_t;			/* Type of a byte count, or error.  */
-typedef __u_long __rlim_t;		/* Type of resource counts.  */
-typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
-typedef __u_int __id_t;			/* General type for ID.  */
-
-typedef struct
-  {
-    int __val[2];
-  } __fsid_t;				/* Type of file system IDs.  */
-
-/* Everythin' else.  */
-typedef int __daddr_t;			/* The type of a disk address.  */
-typedef char *__caddr_t;
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef long int __suseconds_t;
-typedef long int __swblk_t;		/* Type of a swap block maybe?  */
-
-typedef long int __clock_t;
-
-/* Clock ID used in clock and timer functions.  */
-typedef int __clockid_t;
-
-/* Timer ID returned by `timer_create'.  */
-typedef int __timer_t;
-
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define __FD_SETSIZE	1024
-
-
-typedef int __key_t;
-
-/* Used in `struct shmid_ds'.  */
-typedef unsigned short int __ipc_pid_t;
-
-
-/* Type to represent block size.  */
-typedef long int __blksize_t;
-
-/* Types from the Large File Support interface.  */
-
-/* Type to count number os disk blocks.  */
-typedef long int __blkcnt_t;
-typedef __quad_t __blkcnt64_t;
-
-/* Type to count file system blocks.  */
-typedef __u_long __fsblkcnt_t;
-typedef __u_quad_t __fsblkcnt64_t;
-
-/* Type to count file system inodes.  */
-typedef __u_long __fsfilcnt_t;
-typedef __u_quad_t __fsfilcnt64_t;
-
-/* Type of file serial numbers.  */
-typedef __u_quad_t __ino64_t;
-
-/* Type of file sizes and offsets.  */
-typedef __loff_t __off64_t;
-
-/* Used in XTI.  */
-typedef long int __t_scalar_t;
-typedef unsigned long int __t_uscalar_t;
-
-/* Duplicates info from stdint.h but this is used in unistd.h.  */
-typedef int __intptr_t;
-
-/* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
-
-
-/* Now add the thread types.  */
-#if defined __USE_POSIX199506 || defined __USE_UNIX98
-# include <bits/pthreadtypes.h>
-#endif
-
-#endif /* bits/types.h */
diff -Nur sysdeps/unix/sysv/linux/bits/waitflags.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/waitflags.h
--- sysdeps/unix/sysv/linux/bits/waitflags.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/bits/waitflags.h	2004-09-01 21:39:07.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions of flag bits for `waitpid' et al.
-   Copyright (C) 1992, 1996, 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1992, 1996, 1997, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,5 +26,11 @@
 #define	WNOHANG		1	/* Don't block waiting.  */
 #define	WUNTRACED	2	/* Report status of stopped children.  */
 
+/* Bits in the fourth argument to `waitid'.  */
+#define WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
+#define WEXITED		4	/* Report dead child.  */
+#define WCONTINUED	8	/* Report continued child.  */
+#define WNOWAIT		0x01000000 /* Don't reap, just poll status.  */
+
 #define __WALL		0x40000000 /* Wait for any child.  */
 #define __WCLONE	0x80000000 /* Wait for cloned process.  */
diff -Nur sysdeps/unix/sysv/linux/check_pf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/check_pf.c
--- sysdeps/unix/sysv/linux/check_pf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/check_pf.c	2003-11-14 00:38:45.000000000 +0100
@@ -0,0 +1,193 @@
+/* Determine protocol families for which interfaces exist.  Linux version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <ifaddrs.h>
+#include <netdb.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/socket.h>
+
+#include <asm/types.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include "kernel-features.h"
+
+
+static int
+make_request (int fd, pid_t pid, bool *seen_ipv4, bool *seen_ipv6)
+{
+  struct
+  {
+    struct nlmsghdr nlh;
+    struct rtgenmsg g;
+  } req;
+  struct sockaddr_nl nladdr;
+
+  req.nlh.nlmsg_len = sizeof (req);
+  req.nlh.nlmsg_type = RTM_GETADDR;
+  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+  req.nlh.nlmsg_pid = 0;
+  req.nlh.nlmsg_seq = time (NULL);
+  req.g.rtgen_family = AF_UNSPEC;
+
+  memset (&nladdr, '\0', sizeof (nladdr));
+  nladdr.nl_family = AF_NETLINK;
+
+  if (TEMP_FAILURE_RETRY (__sendto (fd, (void *) &req, sizeof (req), 0,
+				    (struct sockaddr *) &nladdr,
+				    sizeof (nladdr))) < 0)
+    return -1;
+
+  *seen_ipv4 = false;
+  *seen_ipv6 = false;
+
+  bool done = false;
+  char buf[4096];
+  struct iovec iov = { buf, sizeof (buf) };
+
+  do
+    {
+      struct msghdr msg =
+	{
+	  (void *) &nladdr, sizeof (nladdr),
+	  &iov, 1,
+	  NULL, 0,
+	  0
+	};
+
+      ssize_t read_len = TEMP_FAILURE_RETRY (__recvmsg (fd, &msg, 0));
+      if (read_len < 0)
+	return -1;
+
+      if (msg.msg_flags & MSG_TRUNC)
+	return -1;
+
+      struct nlmsghdr *nlmh;
+      for (nlmh = (struct nlmsghdr *) buf;
+	   NLMSG_OK (nlmh, (size_t) read_len);
+	   nlmh = (struct nlmsghdr *) NLMSG_NEXT (nlmh, read_len))
+	{
+	  if (nladdr.nl_pid != 0 || (pid_t) nlmh->nlmsg_pid != pid
+	      || nlmh->nlmsg_seq != req.nlh.nlmsg_seq)
+	    continue;
+
+	  if (nlmh->nlmsg_type == RTM_NEWADDR)
+	    {
+	      struct ifaddrmsg *ifam = (struct ifaddrmsg *) NLMSG_DATA (nlmh);
+
+	      switch (ifam->ifa_family)
+		{
+		case AF_INET:
+		  *seen_ipv4 = true;
+		  break;
+		case AF_INET6:
+		  *seen_ipv6 = true;
+		  break;
+		default:
+		  /* Ignore.  */
+		  break;
+		}
+	    }
+	  else if (nlmh->nlmsg_type == NLMSG_DONE)
+	    /* We found the end, leave the loop.  */
+	    done = true;
+	  else ;
+	}
+    }
+  while (! done);
+
+  __close (fd);
+
+  return 0;
+}
+
+
+/* We don't know if we have NETLINK support compiled in in our
+   Kernel.  */
+#if __ASSUME_NETLINK_SUPPORT == 0
+/* Define in ifaddrs.h.  */
+extern int __no_netlink_support attribute_hidden;
+#else
+# define __no_netlink_support 0
+#endif
+
+
+void
+attribute_hidden
+__check_pf (bool *seen_ipv4, bool *seen_ipv6)
+{
+  if (! __no_netlink_support)
+    {
+      int fd = __socket (PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+
+      struct sockaddr_nl nladdr;
+      memset (&nladdr, '\0', sizeof (nladdr));
+      nladdr.nl_family = AF_NETLINK;
+
+      socklen_t addr_len = sizeof (nladdr);
+
+      if (fd >= 0
+	  && __bind (fd, (struct sockaddr *) &nladdr, sizeof (nladdr)) == 0
+	  && __getsockname (fd, (struct sockaddr *) &nladdr, &addr_len) == 0
+	  && make_request (fd, nladdr.nl_pid, seen_ipv4, seen_ipv6) == 0)
+	/* It worked.  */
+	return;
+
+      if (fd >= 0)
+	__close (fd);
+
+#if __ASSUME_NETLINK_SUPPORT == 0
+      /* Remember that there is no netlink support.  */
+      __no_netlink_support = 1;
+#else
+      /* We cannot determine what interfaces are available.  Be
+	 pessimistic.  */
+      *seen_ipv4 = true;
+      *seen_ipv6 = true;
+#endif
+    }
+
+#if __ASSUME_NETLINK_SUPPORT == 0
+  /* No netlink.  Get the interface list via getifaddrs.  */
+  struct ifaddrs *ifa = NULL;
+  if (getifaddrs (&ifa) != 0)
+    {
+      /* We cannot determine what interfaces are available.  Be
+	 pessimistic.  */
+      *seen_ipv4 = true;
+      *seen_ipv6 = true;
+      return;
+    }
+
+  *seen_ipv4 = false;
+  *seen_ipv6 = false;
+
+  struct ifaddrs *runp;
+  for (runp = ifa; runp != NULL; runp = runp->ifa_next)
+    if (runp->ifa_addr->sa_family == PF_INET)
+      *seen_ipv4 = true;
+    else if (runp->ifa_addr->sa_family == PF_INET6)
+      *seen_ipv6 = true;
+
+  (void) freeifaddrs (ifa);
+#endif
+}
diff -Nur sysdeps/unix/sysv/linux/clock_getres.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_getres.c
--- sysdeps/unix/sysv/linux/clock_getres.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_getres.c	2003-03-03 05:48:47.000000000 +0100
@@ -0,0 +1,76 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include "kernel-features.h"
+
+
+#ifdef __ASSUME_POSIX_TIMERS
+/* This means the REALTIME and MONOTONIC clock are definitely
+   supported in the kernel.  */
+# define SYSDEP_GETRES \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    retval = INLINE_SYSCALL (clock_getres, 2, clock_id, res);		      \
+    break
+#elif defined __NR_clock_getres
+/* Is the syscall known to exist?  */
+extern int __libc_missing_posix_timers attribute_hidden;
+
+/* The REALTIME and MONOTONIC clock might be available.  Try the
+   syscall first.  */
+# define SYSDEP_GETRES \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    {									      \
+      int e = EINVAL;							      \
+									      \
+      if (!__libc_missing_posix_timers)					      \
+	{								      \
+	  INTERNAL_SYSCALL_DECL (err);					      \
+	  int r = INTERNAL_SYSCALL (clock_getres, err, 2, clock_id, res);     \
+	  if (!INTERNAL_SYSCALL_ERROR_P (r, err))			      \
+	    {								      \
+	      retval = 0;						      \
+	      break;							      \
+	    }								      \
+									      \
+	  e = INTERNAL_SYSCALL_ERRNO (r, err);				      \
+	  if (e == ENOSYS)						      \
+	    {								      \
+	      __libc_missing_posix_timers = 1;				      \
+	      e = EINVAL;						      \
+	    }								      \
+	}								      \
+									      \
+      /* Fallback code.  */						      \
+      if (e == EINVAL && clock_id == CLOCK_REALTIME)			      \
+	HANDLE_REALTIME;						      \
+      else								      \
+	__set_errno (e);						      \
+    }									      \
+    break
+#endif
+
+#ifdef __NR_clock_getres
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#endif
+
+#include <sysdeps/posix/clock_getres.c>
diff -Nur sysdeps/unix/sysv/linux/clock_gettime.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_gettime.c
--- sysdeps/unix/sysv/linux/clock_gettime.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_gettime.c	2003-03-03 05:49:06.000000000 +0100
@@ -0,0 +1,76 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include "kernel-features.h"
+
+
+#ifdef __ASSUME_POSIX_TIMERS
+/* This means the REALTIME and MONOTONIC clock are definitely
+   supported in the kernel.  */
+# define SYSDEP_GETTIME \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    retval = INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);		      \
+    break
+#elif defined __NR_clock_gettime
+/* Is the syscall known to exist?  */
+int __libc_missing_posix_timers attribute_hidden;
+
+/* The REALTIME and MONOTONIC clock might be available.  Try the
+   syscall first.  */
+# define SYSDEP_GETTIME \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    {									      \
+      int e = EINVAL;							      \
+									      \
+      if (!__libc_missing_posix_timers)					      \
+	{								      \
+	  INTERNAL_SYSCALL_DECL (err);					      \
+	  int r = INTERNAL_SYSCALL (clock_gettime, err, 2, clock_id, tp);     \
+	  if (!INTERNAL_SYSCALL_ERROR_P (r, err))			      \
+	    {								      \
+	      retval = 0;						      \
+	      break;							      \
+	    }								      \
+									      \
+	  e = INTERNAL_SYSCALL_ERRNO (r, err);				      \
+	  if (e == ENOSYS)						      \
+	    {								      \
+	      __libc_missing_posix_timers = 1;				      \
+	      e = EINVAL;						      \
+	    }								      \
+	}								      \
+									      \
+      /* Fallback code.  */						      \
+      if (e == EINVAL && clock_id == CLOCK_REALTIME)			      \
+	HANDLE_REALTIME;						      \
+      else								      \
+	__set_errno (e);						      \
+    }									      \
+    break
+#endif
+
+#ifdef __NR_clock_gettime
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#endif
+
+#include <sysdeps/unix/clock_gettime.c>
diff -Nur sysdeps/unix/sysv/linux/clock_nanosleep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_nanosleep.c
--- sysdeps/unix/sysv/linux/clock_nanosleep.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_nanosleep.c	2003-06-15 23:21:46.000000000 +0200
@@ -0,0 +1,81 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+
+#include <sysdep-cancel.h>
+#include "kernel-features.h"
+
+
+#ifdef __ASSUME_POSIX_TIMERS
+/* We can simply use the syscall.  The CPU clocks are not supported
+   with this function.  */
+int
+clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,
+		 struct timespec *rem)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  int r;
+
+  if (SINGLE_THREAD_P)
+    r = INTERNAL_SYSCALL (clock_nanosleep, err, 4, clock_id, flags, req, rem);
+  else
+    {
+      int oldstate = LIBC_CANCEL_ASYNC ();
+
+      r = INTERNAL_SYSCALL (clock_nanosleep, err, 4, clock_id, flags, req,
+			    rem);
+
+      LIBC_CANCEL_RESET (oldstate);
+    }
+
+  return (INTERNAL_SYSCALL_ERROR_P (r, err)
+	  ? INTERNAL_SYSCALL_ERRNO (r, err) : 0);
+}
+
+#else
+# ifdef __NR_clock_nanosleep
+/* Is the syscall known to exist?  */
+extern int __libc_missing_posix_timers attribute_hidden;
+
+/* The REALTIME and MONOTONIC clock might be available.  Try the
+   syscall first.  */
+#  define SYSDEP_NANOSLEEP \
+  if (!__libc_missing_posix_timers)					      \
+    {									      \
+      INTERNAL_SYSCALL_DECL (err);					      \
+									      \
+      int oldstate = LIBC_CANCEL_ASYNC ();				      \
+									      \
+      int r = INTERNAL_SYSCALL (clock_nanosleep, err, 4, clock_id, flags,     \
+				req, rem);				      \
+									      \
+      LIBC_CANCEL_RESET (oldstate);					      \
+									      \
+      if (!INTERNAL_SYSCALL_ERROR_P (r, err))				      \
+	return 0;							      \
+									      \
+      if (INTERNAL_SYSCALL_ERRNO (r, err) != ENOSYS)			      \
+	return INTERNAL_SYSCALL_ERRNO (r, err);				      \
+									      \
+      __libc_missing_posix_timers = 1;					      \
+    }
+# endif
+
+# include <sysdeps/unix/clock_nanosleep.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/clock_settime.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_settime.c
--- sysdeps/unix/sysv/linux/clock_settime.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/clock_settime.c	2004-02-26 22:35:29.000000000 +0100
@@ -0,0 +1,76 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include "kernel-features.h"
+
+
+#ifdef __ASSUME_POSIX_TIMERS
+/* This means the REALTIME clock is definitely supported in the
+   kernel.  */
+# define SYSDEP_SETTIME \
+  case CLOCK_REALTIME:							      \
+    retval = INLINE_SYSCALL (clock_settime, 2, clock_id, tp);		      \
+    break
+#elif defined __NR_clock_settime
+/* Is the syscall known to exist?  */
+extern int __libc_missing_posix_timers attribute_hidden;
+
+/* The REALTIME clock might be available.  Try the syscall first.  */
+# define SYSDEP_SETTIME \
+  case CLOCK_REALTIME:							      \
+    {									      \
+      int e = EINVAL;							      \
+									      \
+      if (!__libc_missing_posix_timers)					      \
+	{								      \
+	  INTERNAL_SYSCALL_DECL (err);					      \
+	  int r = INTERNAL_SYSCALL (clock_settime, err, 2, clock_id, tp);     \
+	  if (!INTERNAL_SYSCALL_ERROR_P (r, err))			      \
+	    {								      \
+	      retval = 0;						      \
+	      break;							      \
+	    }								      \
+									      \
+	  e = INTERNAL_SYSCALL_ERRNO (r, err);				      \
+	  if (e == ENOSYS)						      \
+	    {								      \
+	      __libc_missing_posix_timers = 1;				      \
+	      e = EINVAL;						      \
+	    }								      \
+	}								      \
+									      \
+      /* Fallback code.  */						      \
+      if (e == EINVAL && clock_id == CLOCK_REALTIME)			      \
+	HANDLE_REALTIME;						      \
+      else								      \
+	{								      \
+	  __set_errno (e);						      \
+	  retval = -1;							      \
+	}								      \
+    }									      \
+    break
+#endif
+
+#ifdef __NR_clock_settime
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#endif
+
+#include <sysdeps/unix/clock_settime.c>
diff -Nur sysdeps/unix/sysv/linux/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/configure
--- sysdeps/unix/sysv/linux/configure	2002-09-29 19:58:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,9 +1,11 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
  # Local configure fragment for sysdeps/unix/sysv/linux.
 
 # The Linux kernel headers can be found in
 #   /lib/modules/$(uname -r)/build/include
 # Check whether this directory is available.
 if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
    test -d /lib/modules/`uname -r`/build/include; then
   sysheaders="/lib/modules/`uname -r`/build/include"
   ccheaders=`$CC -print-file-name=include`
@@ -18,46 +20,77 @@
   OLD_CPPFLAGS=$CPPFLAGS
   CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
 fi
-echo $ac_n "checking installed Linux kernel header files""... $ac_c" 1>&6
-echo "configure:23: checking installed Linux kernel header files" >&5
-if eval "test \"`echo '$''{'libc_cv_linux2010'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat > conftest.$ac_ext <<EOF
-#line 28 "configure"
-#include "confdefs.h"
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking installed Linux kernel header files" >&5
+echo $ECHO_N "checking installed Linux kernel header files... $ECHO_C" >&6
+if test "${libc_cv_linux2010+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <linux/version.h>
 #if !defined LINUX_VERSION_CODE || LINUX_VERSION_CODE <  (2 *65536+ 0 *256+ 10) /* 2.0.10 */
 eat flaming death
 #endif
-EOF
+_ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "eat flaming death" >/dev/null 2>&1; then
-  rm -rf conftest*
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
   libc_cv_linux2010='TOO OLD!'
 else
-  rm -rf conftest*
   libc_cv_linux2010='2.0.10 or later'
 fi
 rm -f conftest*
 
 fi
-
-echo "$ac_t""$libc_cv_linux2010" 1>&6
+echo "$as_me:$LINENO: result: $libc_cv_linux2010" >&5
+echo "${ECHO_T}$libc_cv_linux2010" >&6
 if test "$libc_cv_linux2010" != '2.0.10 or later'; then
-  { echo "configure: error: GNU libc requires kernel header files from
+  { { echo "$as_me:$LINENO: error: GNU libc requires kernel header files from
+Linux 2.0.10 or later to be installed before configuring.
+The kernel header files are found usually in /usr/include/asm and
+/usr/include/linux; make sure these directories use files from
+Linux 2.0.10 or later.  This check uses <linux/version.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/include/linux, use the
+configure option --with-headers." >&5
+echo "$as_me: error: GNU libc requires kernel header files from
 Linux 2.0.10 or later to be installed before configuring.
 The kernel header files are found usually in /usr/include/asm and
 /usr/include/linux; make sure these directories use files from
 Linux 2.0.10 or later.  This check uses <linux/version.h>, so
 make sure that file was built correctly when installing the kernel header
 files.  To use kernel headers not from /usr/include/linux, use the
-configure option --with-headers." 1>&2; exit 1; }
+configure option --with-headers." >&2;}
+   { (exit 1); exit 1; }; }
 fi
 
 # If the user gave a minimal version number test whether the available
 # kernel headers are young enough.  Additionally we have minimal
-# kernel versions for some architectures.
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
 case "$machine" in
   alpha*)
     arch_minimum_kernel=2.1.100
@@ -75,7 +108,8 @@
     arch_minimum_kernel=2.4.0
     ;;
   hppa*)
-    arch_minimum_kernel=2.3.99
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=2.4.19
     ;;
   m68k*)
     arch_minimum_kernel=2.0.10
@@ -116,12 +150,13 @@
     ;;
 esac
 if test -n "$minimum_kernel"; then
-  
+
   user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
   arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
-  
+
   if test $user_version -lt $arch_version; then
-    echo "configure: warning: minimum kernel version reset to $arch_minimum_kernel" 1>&2
+    { echo "$as_me:$LINENO: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&5
+echo "$as_me: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&2;}
     minimum_kernel=$arch_minimum_kernel
   fi
 else
@@ -131,41 +166,46 @@
 fi
 
 if test -n "$minimum_kernel"; then
-  echo $ac_n "checking for kernel header at least $minimum_kernel""... $ac_c" 1>&6
-echo "configure:136: checking for kernel header at least $minimum_kernel" >&5
+  echo "$as_me:$LINENO: checking for kernel header at least $minimum_kernel" >&5
+echo $ECHO_N "checking for kernel header at least $minimum_kernel... $ECHO_C" >&6
   decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 65536 + \2 * 256 + \3)/'`;
   abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
-  cat > conftest.$ac_ext <<EOF
-#line 140 "configure"
-#include "confdefs.h"
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < $decnum
 eat flaming death
 #endif
-EOF
+_ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "eat flaming death" >/dev/null 2>&1; then
-  rm -rf conftest*
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
   libc_minimum_kernel='too old!'
 else
-  rm -rf conftest*
   libc_minimum_kernel=ok
 fi
 rm -f conftest*
 
-  echo "$ac_t""$libc_minimum_kernel" 1>&6
+  echo "$as_me:$LINENO: result: $libc_minimum_kernel" >&5
+echo "${ECHO_T}$libc_minimum_kernel" >&6
   if test "$libc_minimum_kernel" = ok; then
-    cat >> confdefs.h <<EOF
+    cat >>confdefs.h <<_ACEOF
 #define __LINUX_KERNEL_VERSION $decnum
-EOF
+_ACEOF
 
-    cat >> confdefs.h <<EOF
+    cat >>confdefs.h <<_ACEOF
 #define __ABI_TAG_VERSION $abinum
-EOF
+_ACEOF
 
   else
-    { echo "configure: error: *** The available kernel headers are older than the requested
-*** compatible kernel version" 1>&2; exit 1; }
+    { { echo "$as_me:$LINENO: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&5
+echo "$as_me: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&2;}
+   { (exit 1); exit 1; }; }
   fi
 fi
 
@@ -182,19 +222,31 @@
 # files.  I.e., when the installation prefix is "/usr" we have to place
 # shared library objects and the configuration files on the root partition
 # in /lib and /etc.
-if test "$prefix" = "/usr" -o "$prefix" = "/usr/"; then
-  # 64bit libraries on sparc go to /lib64 and not /lib
-  if test "$machine" = "sparc/sparc64" -o "$machine" = "x86_64" \
-	  -o "$machine" = "powerpc/powerpc64"; then
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
       # Locale data can be shared between 32bit and 64bit libraries
       libc_cv_localedir='${exec_prefix}/lib/locale'
     fi
-  else
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
     libc_cv_slibdir="/lib"
-  fi
+    ;;
+  esac
   # Allow the user to override the path with --sysconfdir
   if test $sysconfdir = '${prefix}/etc'; then
     libc_cv_sysconfdir=/etc
@@ -202,7 +254,8 @@
     libc_cv_sysconfdir=$sysconfdir
    fi
   libc_cv_rootsbindir="/sbin"
-fi
+  ;;
+esac
 
 # Under Linux the LinuxThreads or NPTL add-on should be available.
 case $add_ons in
@@ -269,6 +322,9 @@
   ia64*)
     ldd_rewrite_script=../sysdeps/unix/sysv/linux/ia64/ldd-rewrite.sed
     ;;
+  mips/*64*)
+    ldd_rewrite_script=../sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed
+    ;;
   s390*)
     ldd_rewrite_script=../sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed
     ;;
@@ -295,8 +351,8 @@
   else
     ac_prefix=$ac_default_prefix
   fi
-  echo $ac_n "checking for symlinks in ${ac_prefix}/include""... $ac_c" 1>&6
-echo "configure:300: checking for symlinks in ${ac_prefix}/include" >&5
+  echo "$as_me:$LINENO: checking for symlinks in ${ac_prefix}/include" >&5
+echo $ECHO_N "checking for symlinks in ${ac_prefix}/include... $ECHO_C" >&6
   ac_message=
   if test -L ${ac_prefix}/include/net; then
     ac_message="$ac_message
@@ -307,11 +363,23 @@
    ${ac_prefix}/include/scsi is a symlink"
   fi
   if test -n "$ac_message"; then
-    { echo "configure: error: $ac_message
+    { { echo "$as_me:$LINENO: error: $ac_message
 \`make install' will destroy the target of the link(s).
 Delete the links and re-run configure, or better still, move the entire
-${ac_prefix}/include directory out of the way." 1>&2; exit 1; }
+${ac_prefix}/include directory out of the way." >&5
+echo "$as_me: error: $ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." >&2;}
+   { (exit 1); exit 1; }; }
   else
-    echo "$ac_t""ok" 1>&6
+    echo "$as_me:$LINENO: result: ok" >&5
+echo "${ECHO_T}ok" >&6
   fi
 fi
+
+# We have inlined syscalls.
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_INLINED_SYSCALLS 1
+_ACEOF
+
diff -Nur sysdeps/unix/sysv/linux/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/configure.in
--- sysdeps/unix/sysv/linux/configure.in	2002-09-25 08:36:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/configure.in	2004-07-06 06:11:40.000000000 +0200
@@ -1,4 +1,3 @@
-sinclude(./aclocal.m4)dnl Autoconf lossage
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 # Local configure fragment for sysdeps/unix/sysv/linux.
 
@@ -6,6 +5,7 @@
 #   /lib/modules/$(uname -r)/build/include
 # Check whether this directory is available.
 if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
    test -d /lib/modules/`uname -r`/build/include; then
   sysheaders="/lib/modules/`uname -r`/build/include"
   ccheaders=`$CC -print-file-name=include`
@@ -46,7 +46,11 @@
 
 # If the user gave a minimal version number test whether the available
 # kernel headers are young enough.  Additionally we have minimal
-# kernel versions for some architectures.
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
 case "$machine" in
   alpha*)
     arch_minimum_kernel=2.1.100
@@ -64,7 +68,8 @@
     arch_minimum_kernel=2.4.0
     ;;
   hppa*)
-    arch_minimum_kernel=2.3.99
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=2.4.19
     ;;
   m68k*)
     arch_minimum_kernel=2.0.10
@@ -152,19 +157,31 @@
 # files.  I.e., when the installation prefix is "/usr" we have to place
 # shared library objects and the configuration files on the root partition
 # in /lib and /etc.
-if test "$prefix" = "/usr" -o "$prefix" = "/usr/"; then
-  # 64bit libraries on sparc go to /lib64 and not /lib
-  if test "$machine" = "sparc/sparc64" -o "$machine" = "x86_64" \
-	  -o "$machine" = "powerpc/powerpc64"; then
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
       # Locale data can be shared between 32bit and 64bit libraries
       libc_cv_localedir='${exec_prefix}/lib/locale'
     fi
-  else
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
     libc_cv_slibdir="/lib"
-  fi
+    ;;
+  esac
   # Allow the user to override the path with --sysconfdir
   if test $sysconfdir = '${prefix}/etc'; then
     libc_cv_sysconfdir=/etc
@@ -172,7 +189,8 @@
     libc_cv_sysconfdir=$sysconfdir
    fi
   libc_cv_rootsbindir="/sbin"
-fi
+  ;;
+esac
 
 # Under Linux the LinuxThreads or NPTL add-on should be available.
 case $add_ons in
@@ -239,6 +257,9 @@
   ia64*)
     ldd_rewrite_script=../sysdeps/unix/sysv/linux/ia64/ldd-rewrite.sed
     ;;
+  mips/*64*)
+    ldd_rewrite_script=../sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed
+    ;;
   s390*)
     ldd_rewrite_script=../sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed
     ;;
@@ -284,3 +305,6 @@
     AC_MSG_RESULT(ok)
   fi
 fi
+
+# We have inlined syscalls.
+AC_DEFINE(HAVE_INLINED_SYSCALLS)
diff -Nur sysdeps/unix/sysv/linux/connect.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/connect.S
--- sysdeps/unix/sysv/linux/connect.S	2002-04-09 08:58:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/connect.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,6 +1,7 @@
 #define	socket	connect
 #define __socket __libc_connect
 #define	NARGS	3
+#define NEED_CANCELLATION
 #include <socket.S>
 strong_alias (__libc_connect, __connect_internal)
 weak_alias (__libc_connect, __connect)
diff -Nur sysdeps/unix/sysv/linux/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Dist
--- sysdeps/unix/sysv/linux/Dist	2002-09-19 08:28:15.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Dist	2004-06-30 09:58:38.000000000 +0200
@@ -1,9 +1,9 @@
 bits/initspin.h
-bits/pthreadtypes.h
 cmsg_nxthdr.c
 dl-brk.c
 dl-sbrk.c
 exit-thread.S
+fatal-prepare.h
 getdirentries.c
 getdirentries64.c
 ipc_priv.h
@@ -11,11 +11,11 @@
 kernel_sigaction.h
 kernel_stat.h
 kernel_termios.h
-internal_statvfs.c
 ldd-rewrite.sed
 lddlibc4.c
 linux_fsinfo.h
 llseek.c
+makedev.c
 ntp_gettime.c
 readahead.c
 s_pread64.c
@@ -25,6 +25,7 @@
 socketcall.h
 sysctl.c
 termio.h
+netlinkaccess.h
 net/ethernet.h
 net/if_arp.h
 net/if_packet.h
@@ -40,12 +41,12 @@
 neteconet/ec.h
 netinet/if_fddi.h
 netinet/if_tr.h
-netinet/igmp.h
 netpacket/packet.h
 netipx/ipx.h
 netrom/netrom.h
 netrose/rose.h
 nfs/nfs.h
+pathconf.h
 rt_sigaction.c
 rt_sigpending.c
 rt_sigprocmask.c
@@ -58,6 +59,7 @@
 scsi/scsi.h
 scsi/scsi_ioctl.h
 sys/acct.h
+sys/epoll.h
 sys/fsuid.h
 sys/kd.h
 sys/kdaemon.h
@@ -77,6 +79,7 @@
 sys/user.h
 sys/vt.h
 xstatconv.c
+xstatconv.h
 getdents64.c
 umount.S
 umount2.S
diff -Nur sysdeps/unix/sysv/linux/dl-execstack.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-execstack.c
--- sysdeps/unix/sysv/linux/dl-execstack.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-execstack.c	2004-09-21 04:30:12.000000000 +0200
@@ -0,0 +1,138 @@
+/* Stack executability handling for GNU dynamic linker.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <libintl.h>
+#include <stdbool.h>
+#include <stackinfo.h>
+#include <caller.h>
+
+#include "kernel-features.h"
+
+
+extern int __stack_prot attribute_relro attribute_hidden;
+
+
+int
+internal_function
+_dl_make_stack_executable (void **stack_endp)
+{
+  /* This gives us the highest/lowest page that needs to be changed.  */
+  uintptr_t page = ((uintptr_t) *stack_endp
+		    & -(intptr_t) GLRO(dl_pagesize));
+
+  /* Challenge the caller.  */
+  if (__builtin_expect (__check_caller (RETURN_ADDRESS (0),
+					allow_ldso|allow_libpthread) != 0, 0)
+      || __builtin_expect (*stack_endp != __libc_stack_end, 0))
+    return EPERM;
+
+  /* Newer Linux kernels support a flag to make our job easy.  */
+#if defined  PROT_GROWSDOWN || defined PROT_GROWSUP
+# if __ASSUME_PROT_GROWSUPDOWN == 0
+  static bool no_growsupdown;
+  if (! no_growsupdown)
+# endif
+    {
+      if (__builtin_expect (__mprotect ((void *) page, GLRO(dl_pagesize),
+					__stack_prot) == 0, 1))
+	goto return_success;
+# if __ASSUME_PROT_GROWSUPDOWN == 0
+      if (errno == EINVAL)
+	no_growsupdown = true;
+      else
+# endif
+	return errno;
+    }
+#endif
+
+  /* There is always a hole in the address space below the bottom of the
+     stack.  So when we make an mprotect call that starts below the bottom
+     of the stack, it will include the hole and fail with ENOMEM.
+
+     We start with a random guess at how deep the stack might have gotten
+     so as to have extended the GROWSDOWN mapping to lower pages.  */
+
+#if __ASSUME_PROT_GROWSUPDOWN == 0
+  size_t size = GLRO(dl_pagesize) * 8;
+
+# if _STACK_GROWS_DOWN
+  page = page + GLRO(dl_pagesize) - size;
+  while (1)
+    {
+      if (__mprotect ((void *) page, size,
+		      __stack_prot & ~PROT_GROWSDOWN) == 0)
+	/* We got this chunk changed; loop to do another chunk below.  */
+	page -= size;
+      else
+	{
+	  if (errno != ENOMEM)	/* Unexpected failure mode.  */
+	    return errno;
+
+	  if (size == GLRO(dl_pagesize))
+	    /* We just tried to mprotect the top hole page and failed.
+	       We are done.  */
+	    break;
+
+	  /* Our mprotect call failed because it started below the lowest
+	     stack page.  Try again on just the top half of that region.  */
+	  size /= 2;
+	  page += size;
+	}
+    }
+
+# elif _STACK_GROWS_UP
+  while (1)
+    {
+      if (__mprotect ((void *) page, size, __stack_prot & ~PROT_GROWSUP) == 0)
+	/* We got this chunk changed; loop to do another chunk below.  */
+	page += size;
+      else
+	{
+	  if (errno != ENOMEM)	/* Unexpected failure mode.  */
+	    return errno;
+
+	  if (size == GLRO(dl_pagesize))
+	    /* We just tried to mprotect the lowest hole page and failed.
+	       We are done.  */
+	    break;
+
+	  /* Our mprotect call failed because it extended past the highest
+	     stack page.  Try again on just the bottom half of that region.  */
+	  size /= 2;
+	}
+    }
+
+# else
+#  error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
+# endif
+#endif
+
+ return_success:
+  /* Clear the address.  */
+  *stack_endp = NULL;
+
+  /* Remember that we changed the permission.  */
+  GL(dl_stack_flags) |= PF_X;
+
+  return 0;
+}
+rtld_hidden_def (_dl_make_stack_executable)
diff -Nur sysdeps/unix/sysv/linux/dl-librecon.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-librecon.h
--- sysdeps/unix/sysv/linux/dl-librecon.h	2002-01-30 23:21:45.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-librecon.h	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Optional code to distinguish library flavours.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2001.
 
@@ -21,29 +21,41 @@
 #ifndef _DL_LIBRECON_H
 #define _DL_LIBRECON_H	1
 
+static inline void __attribute__ ((unused, always_inline))
+_dl_osversion_init (char *assume_kernel)
+{
+  unsigned long int i, j, osversion = 0;
+  char *p = assume_kernel, *q;
+
+  for (i = 0; i < 3; i++, p = q + 1)
+    {
+      j = __strtoul_internal (p, &q, 0, 0);
+      if (j >= 255 || p == q || (i < 2 && *q && *q != '.'))
+	{
+	  osversion = 0;
+	  break;
+	}
+      osversion |= j << (16 - 8 * i);
+      if (!*q)
+	break;
+    }
+  if (osversion)
+    GLRO(dl_osversion) = osversion;
+}
+
 /* Recognizing extra environment variables.  */
-#define EXTRA_LD_ENVVARS \
-  case 13:								      \
+#define EXTRA_LD_ENVVARS_13 \
     if (memcmp (envline, "ASSUME_KERNEL", 13) == 0)			      \
       {									      \
-	unsigned long int i, j, osversion = 0;				      \
-	char *p = &envline[14], *q;					      \
-									      \
-	for (i = 0; i < 3; i++, p = q + 1)				      \
-	  {								      \
-	    j = __strtoul_internal (p, &q, 0, 0);			      \
-	    if (j >= 255 || p == q || (i < 2 && *q && *q != '.'))	      \
-	      {								      \
-		osversion = 0;						      \
-		break;							      \
-	      }								      \
-	    osversion |= j << (16 - 8 * i);				      \
-	    if (!*q)							      \
-	      break;							      \
-	  }								      \
-	if (osversion)							      \
-	  GL(dl_osversion) = osversion;					      \
+	_dl_osversion_init (&envline[14]);				      \
 	break;								      \
       }
 
+#define DL_OSVERSION_INIT \
+  do {									      \
+    char *assume_kernel = getenv ("LD_ASSUME_KERNEL");			      \
+    if (assume_kernel)							      \
+      _dl_osversion_init (assume_kernel);				      \
+  } while (0)
+
 #endif /* dl-librecon.h */
diff -Nur sysdeps/unix/sysv/linux/dl-origin.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-origin.c
--- sysdeps/unix/sysv/linux/dl-origin.c	2002-03-01 06:44:26.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-origin.c	2004-07-06 06:08:55.000000000 +0200
@@ -1,5 +1,5 @@
 /* Find path of executable.
-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -24,6 +24,7 @@
 #include <unistd.h>
 #include <sys/param.h>
 #include <ldsodefs.h>
+#include <sysdep.h>
 
 #include <dl-dst.h>
 
@@ -31,16 +32,17 @@
    the path of the application from the /proc/self/exe symlink.  Try this
    first and fall back on the generic method if necessary.  */
 
-#undef _dl_get_origin
 const char *
 _dl_get_origin (void)
 {
   char linkval[PATH_MAX];
   char *result;
   int len;
+  INTERNAL_SYSCALL_DECL (err);
 
-  if ((len = __readlink ("/proc/self/exe", linkval, sizeof (linkval))) > 0
-      && linkval[0] != '[')
+  len = INTERNAL_SYSCALL (readlink, err, 3, "/proc/self/exe", linkval,
+			  sizeof (linkval));
+  if (! INTERNAL_SYSCALL_ERROR_P (len, err) && len > 0 && linkval[0] != '[')
     {
       /* We can use this value.  */
       assert (linkval[0] == '/');
@@ -59,15 +61,15 @@
       result = (char *) -1;
       /* We use the environment variable LD_ORIGIN_PATH.  If it is set make
 	 a copy and strip out trailing slashes.  */
-      if (GL(dl_origin_path) != NULL)
+      if (GLRO(dl_origin_path) != NULL)
 	{
-	  size_t len = strlen (GL(dl_origin_path));
+	  size_t len = strlen (GLRO(dl_origin_path));
 	  result = (char *) malloc (len + 1);
 	  if (result == NULL)
 	    result = (char *) -1;
 	  else
 	    {
-	      char *cp = __mempcpy (result, GL(dl_origin_path), len);
+	      char *cp = __mempcpy (result, GLRO(dl_origin_path), len);
 	      while (cp > result + 1 && cp[-1] == '/')
 		--cp;
 	      *cp = '\0';
@@ -77,4 +79,3 @@
 
   return result;
 }
-INTDEF(_dl_get_origin)
diff -Nur sysdeps/unix/sysv/linux/dl-osinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-osinfo.h
--- sysdeps/unix/sysv/linux/dl-osinfo.h	2002-01-30 08:38:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-osinfo.h	2004-12-17 04:31:50.000000000 +0100
@@ -1,5 +1,5 @@
 /* Operating system specific code  for generic dynamic loader functions.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,6 +18,7 @@
    02111-1307 USA.  */
 
 #include <string.h>
+#include <fcntl.h>
 #include <sys/sysctl.h>
 #include <sys/utsname.h>
 #include "kernel-features.h"
@@ -64,7 +65,7 @@
 		|| (reslen = __read (fd, bufmem, sizeof (bufmem))) <= 0)      \
   	      /* This also didn't work.  We give up since we cannot	      \
 		 make sure the library can actually work.  */		      \
-	      FATAL ("FATAL: cannot determine library version\n");	      \
+	      FATAL ("FATAL: cannot determine kernel version\n");	      \
 	    __close (fd);						      \
 	    buf[MIN (reslen, (ssize_t) sizeof (bufmem) - 1)] = '\0';	      \
 	  }								      \
@@ -103,6 +104,6 @@
 	  /* Not sufficent.  */						      \
 	  FATAL ("FATAL: kernel too old\n");				      \
 									      \
-	GL(dl_osversion) = version;					      \
+	GLRO(dl_osversion) = version;					      \
       }									      \
   } while (0)
diff -Nur sysdeps/unix/sysv/linux/dl-sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-sysdep.c
--- sysdeps/unix/sysv/linux/dl-sysdep.c	2002-05-16 07:43:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/dl-sysdep.c	2004-08-16 01:33:02.000000000 +0200
@@ -1,5 +1,5 @@
 /* Dynamic linker system dependencies for Linux.
-   Copyright (C) 1995, 1997, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,8 @@
    the generic dynamic linker system interface code.  */
 
 #include <unistd.h>
+#include <ldsodefs.h>
+#include "kernel-features.h"
 
 #define DL_SYSDEP_INIT frob_brk ()
 
@@ -28,6 +30,27 @@
 frob_brk (void)
 {
   __brk (0);			/* Initialize the break.  */
+
+#if ! __ASSUME_BRK_PAGE_ROUNDED
+  /* If the dynamic linker was executed as a program, then the break may
+     start immediately after our data segment.  However, dl-minimal.c has
+     already stolen the remainder of the page for internal allocations.
+     If we don't adjust the break location recorded by the kernel, the
+     normal program startup will inquire, find the value at our &_end,
+     and start allocating its own data there, clobbering dynamic linker
+     data structures allocated there during startup.
+
+     Later Linux kernels have changed this behavior so that the initial
+     break value is rounded up to the page boundary before we start.  */
+
+  extern void *__curbrk attribute_hidden;
+  extern void _end attribute_hidden;
+  void *const endpage = (void *) 0 + (((__curbrk - (void *) 0)
+				       + GLRO(dl_pagesize) - 1)
+				      & -GLRO(dl_pagesize));
+  if (__builtin_expect (__curbrk >= &_end && __curbrk < endpage, 0))
+    __brk (endpage);
+#endif
 }
 
 #include <sysdeps/generic/dl-sysdep.c>
diff -Nur sysdeps/unix/sysv/linux/execve.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/execve.c
--- sysdeps/unix/sysv/linux/execve.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/execve.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,22 +24,12 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_execve (const char *__unbounded file,
-			     char *__unbounded const *__unbounded argv,
-			     char *__unbounded const *__unbounded envp);
-extern void __pthread_kill_other_threads_np (void);
-weak_extern (__pthread_kill_other_threads_np)
-
-
 int
 __execve (file, argv, envp)
      const char *file;
      char *const argv[];
      char *const envp[];
 {
-  /* If this is a threaded application kill all other threads.  */
-  if (__pthread_kill_other_threads_np)
-    __pthread_kill_other_threads_np ();
 #if __BOUNDED_POINTERS__
   {
     char *const *v;
diff -Nur sysdeps/unix/sysv/linux/_exit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/_exit.c
--- sysdeps/unix/sysv/linux/_exit.c	2002-09-20 06:36:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/_exit.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
diff -Nur sysdeps/unix/sysv/linux/fatal-prepare.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fatal-prepare.h
--- sysdeps/unix/sysv/linux/fatal-prepare.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fatal-prepare.h	2003-04-19 18:53:22.000000000 +0200
@@ -0,0 +1,39 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <pthread.h>
+
+/* We have to completely disable cancellation.  assert() must not be a
+   cancellation point but the implementation uses write() etc.  */
+#ifdef SHARED
+# include <pthread-functions.h>
+# define FATAL_PREPARE \
+  {									      \
+    int (*fp) (int, int *);						      \
+    fp = __libc_pthread_functions.ptr_pthread_setcancelstate;		      \
+    if (fp != NULL)							      \
+      fp (PTHREAD_CANCEL_DISABLE, NULL);				      \
+  }
+#else
+# pragma weak pthread_setcancelstate
+# define FATAL_PREPARE \
+  {									      \
+    if (pthread_setcancelstate != NULL)					      \
+      pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);		      \
+  }
+#endif
diff -Nur sysdeps/unix/sysv/linux/fcntl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fcntl.c
--- sysdeps/unix/sysv/linux/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fcntl.c	2004-07-16 20:09:46.000000000 +0200
@@ -0,0 +1,69 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <sysdep-cancel.h>	/* Must come before <fcntl.h>.  */
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sys/syscall.h>
+
+
+#ifndef NO_CANCELLATION
+int
+__fcntl_nocancel (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+}
+#endif
+
+
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (SINGLE_THREAD_P || cmd != F_SETLKW)
+    return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__libc_fcntl)
+
+weak_alias (__libc_fcntl, __fcntl)
+libc_hidden_weak (__fcntl)
+weak_alias (__libc_fcntl, fcntl)
diff -Nur sysdeps/unix/sysv/linux/fexecve.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fexecve.c
--- sysdeps/unix/sysv/linux/fexecve.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fexecve.c	2002-12-07 00:30:54.000000000 +0100
@@ -0,0 +1,59 @@
+/* Copyright (C) 1994, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+
+/* Execute the file FD refers to, overlaying the running program image.
+   ARGV and ENVP are passed to the new program, as for `execve'.  */
+int
+fexecve (fd, argv, envp)
+     int fd;
+     char *const argv[];
+     char *const envp[];
+{
+  if (fd < 0 || argv == NULL || envp == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* We use the /proc filesystem to get the information.  If it is not
+     mounted we fail.  */
+  char buf[sizeof "/proc/self/fd/" + sizeof (int) * 3];
+  __snprintf (buf, sizeof (buf), "/proc/self/fd/%d", fd);
+
+  /* We do not need the return value.  */
+  __execve (buf, argv, envp);
+
+  int save = errno;
+
+  /* We come here only if the 'execve' call fails.  Determine whether
+     /proc is mounted.  If not we return ENOSYS.  */
+  struct stat st;
+  if (stat ("/proc/self/fd", &st) != 0 && errno == ENOENT)
+    save = ENOSYS;
+
+  __set_errno (save);
+
+  return -1;
+}
diff -Nur sysdeps/unix/sysv/linux/fpathconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fpathconf.c
--- sysdeps/unix/sysv/linux/fpathconf.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fpathconf.c	2003-08-08 09:22:03.000000000 +0200
@@ -1,5 +1,5 @@
-/* Linux specific extensions to fpathconf.
-   Copyright (C) 1991,95,96,98,99,2000,2001 Free Software Foundation, Inc.
+/* Get file-specific information about descriptor FD.  Linux version.
+   Copyright (C) 1991,1995,1996,1998-2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,19 +17,14 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <errno.h>
-#include <unistd.h>
-#include <limits.h>
-#include <sys/statfs.h>
-
-#include "linux_fsinfo.h"
-
-
-/* The Linux kernel header mentioned this as a kind of generic value.  */
-#define LINUX_LINK_MAX	127
+#include "pathconf.h"
 
 static long int posix_fpathconf (int fd, int name);
 
+/* Define this first, so it can be inlined.  */
+#define __fpathconf static posix_fpathconf
+#include <sysdeps/posix/fpathconf.c>
+
 
 /* Get file-specific information about descriptor FD.  */
 long int
@@ -37,58 +32,20 @@
      int fd;
      int name;
 {
-  if (name == _PC_LINK_MAX)
+  struct statfs fsbuf;
+
+  switch (name)
     {
-      struct statfs fsbuf;
+    case _PC_LINK_MAX:
+      return __statfs_link_max (__fstatfs (fd, &fsbuf), &fsbuf);
 
-      /* Determine the filesystem type.  */
-      if (__fstatfs (fd, &fsbuf) < 0)
-	{
-	  if (errno == ENOSYS)
-	    /* not possible, return the default value.  */
-	    return LINUX_LINK_MAX;
-
-	  /* Some error occured.  */
-          return -1;
-	}
-
-      switch (fsbuf.f_type)
-	{
-	case EXT2_SUPER_MAGIC:
-	  return EXT2_LINK_MAX;
-
-	case MINIX_SUPER_MAGIC:
-	case MINIX_SUPER_MAGIC2:
-	  return MINIX_LINK_MAX;
-
-	case MINIX2_SUPER_MAGIC:
-	case MINIX2_SUPER_MAGIC2:
-	  return MINIX2_LINK_MAX;
-
-	case XENIX_SUPER_MAGIC:
-	  return XENIX_LINK_MAX;
-
-	case SYSV4_SUPER_MAGIC:
-	case SYSV2_SUPER_MAGIC:
-	  return SYSV_LINK_MAX;
-
-	case COH_SUPER_MAGIC:
-	  return COH_LINK_MAX;
-
-	case UFS_MAGIC:
-	case UFS_CIGAM:
-	  return UFS_LINK_MAX;
-
-	case REISERFS_SUPER_MAGIC:
-	  return REISERFS_LINK_MAX;
-
-	default:
-	  return LINUX_LINK_MAX;
-	}
-    }
+    case _PC_FILESIZEBITS:
+      return __statfs_filesize_max (__fstatfs (fd, &fsbuf), &fsbuf);
 
-  return posix_fpathconf (fd, name);
-}
+    case _PC_2_SYMLINKS:
+      return __statfs_symlinks (__fstatfs (fd, &fsbuf), &fsbuf);
 
-#define __fpathconf static posix_fpathconf
-#include <sysdeps/posix/fpathconf.c>
+    default:
+      return posix_fpathconf (fd, name);
+    }
+}
diff -Nur sysdeps/unix/sysv/linux/fstatfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatfs64.c
--- sysdeps/unix/sysv/linux/fstatfs64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatfs64.c	2003-06-24 20:58:15.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return information about the filesystem on which FD resides.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996,1997,1998,1999,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,11 +21,34 @@
 #include <string.h>
 #include <sys/statfs.h>
 #include <stddef.h>
+#include <sysdep.h>
+
+/* Defined in statfs64.c.  */
+extern int __no_statfs64 attribute_hidden;
 
 /* Return information about the filesystem on which FD resides.  */
 int
 __fstatfs64 (int fd, struct statfs64 *buf)
 {
+#ifdef __NR_fstatfs64
+# if __ASSUME_STATFS64 == 0
+  if (! __no_statfs64)
+# endif
+    {
+      int result = INLINE_SYSCALL (fstatfs64, 3, fd, sizeof (*buf), buf);
+
+# if __ASSUME_STATFS64 == 0
+      if (result == 0 || errno != ENOSYS)
+# endif
+	return result;
+
+# if __ASSUME_STATFS64 == 0
+      __no_statfs64 = 1;
+# endif
+    }
+#endif
+
+#if __ASSUME_STATFS64 == 0
   struct statfs buf32;
 
   if (__fstatfs (fd, &buf32) < 0)
@@ -40,8 +63,10 @@
   buf->f_ffree = buf32.f_ffree;
   buf->f_fsid = buf32.f_fsid;
   buf->f_namelen = buf32.f_namelen;
+  buf->f_frsize = buf32.f_frsize;
   memcpy (buf->f_spare, buf32.f_spare, sizeof (buf32.f_spare));
 
   return 0;
+#endif
 }
 weak_alias (__fstatfs64, fstatfs64)
diff -Nur sysdeps/unix/sysv/linux/fstatvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatvfs64.c
--- sysdeps/unix/sysv/linux/fstatvfs64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatvfs64.c	2004-04-03 09:49:22.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return information about the filesystem on which FD resides.
-   Copyright (C) 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996,1997,1998,2000,2001,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,31 +18,56 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/statvfs.h>
 #include <string.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/statvfs.h>
+#include "kernel-features.h"
+
+
+extern void __internal_statvfs64 (const char *name, struct statvfs64 *buf,
+				  struct statfs64 *fsbuf, struct stat64 *st);
+
 
 /* Return information about the filesystem on which FD resides.  */
 int
 __fstatvfs64 (int fd, struct statvfs64 *buf)
 {
-  struct statvfs buf32;
-
-  if (fstatvfs (fd, &buf32) < 0)
-    return -1;
+  struct statfs64 fsbuf;
+  int res = __fstatfs64 (fd, &fsbuf);
 
-  buf->f_bsize = buf32.f_bsize;
-  buf->f_frsize = buf32.f_frsize;
-  buf->f_blocks = buf32.f_blocks;
-  buf->f_bfree = buf32.f_bfree;
-  buf->f_bavail = buf32.f_bavail;
-  buf->f_files = buf32.f_files;
-  buf->f_ffree = buf32.f_ffree;
-  buf->f_favail = buf32.f_favail;
-  buf->f_fsid = buf32.f_fsid;
-  buf->f_flag = buf32.f_flag;
-  buf->f_namemax = buf32.f_namemax;
-  memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
+#ifndef __ASSUME_STATFS64
+  if (res < 0 && errno == ENOSYS)
+    {
+      struct statvfs buf32;
+
+      res = fstatvfs (fd, &buf32);
+      if (res == 0)
+	{
+	  buf->f_bsize = buf32.f_bsize;
+	  buf->f_frsize = buf32.f_frsize;
+	  buf->f_blocks = buf32.f_blocks;
+	  buf->f_bfree = buf32.f_bfree;
+	  buf->f_bavail = buf32.f_bavail;
+	  buf->f_files = buf32.f_files;
+	  buf->f_ffree = buf32.f_ffree;
+	  buf->f_favail = buf32.f_favail;
+	  buf->f_fsid = buf32.f_fsid;
+	  buf->f_flag = buf32.f_flag;
+	  buf->f_namemax = buf32.f_namemax;
+	  memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
+	}
+    }
+#endif
+
+  if (res == 0)
+    {
+      /* Convert the result.  */
+      struct stat64 st;
+      __internal_statvfs64 (NULL, buf, &fsbuf,
+			    fstat64 (fd, &st) == -1 ? NULL : &st);
+    }
 
-  return 0;
+  return res;
 }
 weak_alias (__fstatvfs64, fstatvfs64)
diff -Nur sysdeps/unix/sysv/linux/fstatvfs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatvfs.c
--- sysdeps/unix/sysv/linux/fstatvfs.c	2002-09-21 07:37:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fstatvfs.c	2003-09-17 02:46:04.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -17,16 +17,14 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <errno.h>
-#include <mntent.h>
-#include <paths.h>
-#include <stdio_ext.h>
-#include <string.h>
-#include <sys/mount.h>
+#include <stddef.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
 #include <sys/statvfs.h>
 
+extern void __internal_statvfs (const char *name, struct statvfs *buf,
+				struct statfs *fsbuf, struct stat64 *st);
+
 
 int
 fstatvfs (int fd, struct statvfs *buf)
@@ -38,8 +36,8 @@
   if (__fstatfs (fd, &fsbuf) < 0)
     return -1;
 
-#define STAT(st) fstat64 (fd, st)
-#include "internal_statvfs.c"
+  /* Convert the result.  */
+  __internal_statvfs (NULL, buf, &fsbuf, fstat64 (fd, &st) == -1 ? NULL : &st);
 
   /* We signal success if the statfs call succeeded.  */
   return 0;
diff -Nur sysdeps/unix/sysv/linux/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ftruncate64.c
--- sysdeps/unix/sysv/linux/ftruncate64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ftruncate64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,9 +32,6 @@
 extern int __have_no_truncate64;
 #endif
 
-/* The order of hight, low depends on endianness.  */
-extern int __syscall_ftruncate64 (int fd, int high_length, int low_length);
-
 
 /* Truncate the file FD refers to to LENGTH bytes.  */
 int
diff -Nur sysdeps/unix/sysv/linux/futimes.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/futimes.c
--- sysdeps/unix/sysv/linux/futimes.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/futimes.c	2005-02-16 11:47:26.000000000 +0100
@@ -0,0 +1,98 @@
+/* futimes -- change access and modification times of open file.  Linux version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <string.h>
+#include <utime.h>
+#include <sys/time.h>
+#include <stdio-common/_itoa.h>
+#include <fcntl.h>
+
+#include "kernel-features.h"
+
+/* Change the access time of FILE to TVP[0] and
+   the modification time of FILE to TVP[1], but do not follow symlinks.
+
+   The Linux kernel has no futimes() syscall so we use the /proc
+   filesystem.  */
+int
+__futimes (int fd, const struct timeval tvp[2])
+{
+  static const char selffd[] = "/proc/self/fd/";
+  char fname[sizeof (selffd) + 3 * sizeof (int)];
+  fname[sizeof (fname) - 1] = '\0';
+  char *cp = _itoa_word ((unsigned int) fd, fname + sizeof (fname) - 1, 10, 0);
+  cp = memcpy (cp - sizeof (selffd) + 1, selffd, sizeof (selffd) - 1);
+
+  int result;
+#ifdef __NR_utimes
+  result = INLINE_SYSCALL (utimes, 2, cp, tvp);
+# ifndef __ASSUME_UTIMES
+  if (result == -1 && errno == ENOSYS)
+# endif
+#endif
+    {
+      /* The utimes() syscall does not exist or is not available in the
+	 used kernel.  Use utime().  For this we have to convert to the
+	 data format utime() expects.  */
+#ifndef __ASSUME_UTIMES
+      struct utimbuf buf;
+      struct utimbuf *times;
+
+      if (tvp != NULL)
+	{
+	  times = &buf;
+	  buf.actime = tvp[0].tv_sec + (tvp[0].tv_usec + 500000) / 1000000;
+	  buf.modtime = tvp[1].tv_sec + (tvp[1].tv_usec + 500000) / 1000000;
+	}
+      else
+	times = NULL;
+
+      result = INLINE_SYSCALL (utime, 2, cp, times);
+#endif
+    }
+
+  if (result == -1)
+    /* Check for errors that result from failing to find /proc.
+       This means we can't do futimes at all, so return ENOSYS
+       rather than some confusing error.  */
+    switch (errno)
+      {
+      case EACCES:
+	if (tvp == NULL)  /* Could be a path problem or a file problem.  */
+	  break;
+	/*FALLTHROUGH*/
+      case ELOOP:
+      case ENAMETOOLONG:
+      case ENOTDIR:
+	__set_errno (ENOSYS);
+	break;
+
+      case ENOENT:
+	/* Validate the file descriptor by letting fcntl set errno to
+	   EBADF if it's bogus.  Otherwise it's a /proc issue.  */
+	if (INLINE_SYSCALL (fcntl, 3, fd, F_GETFD, 0) != -1)
+	  __set_errno (ENOSYS);
+	break;
+      }
+
+  return result;
+}
+weak_alias (__futimes, futimes)
diff -Nur sysdeps/unix/sysv/linux/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fxstat64.c
--- sysdeps/unix/sysv/linux/fxstat64.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fxstat64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* fxstat64 using old-style Unix fstat system call.
-   Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,13 +29,10 @@
 #include "kernel-features.h"
 
 #if __ASSUME_STAT64_SYSCALL == 0
-# include <xstatconv.c>
+# include <xstatconv.h>
 #endif
 
-extern int __syscall_fstat (int, struct kernel_stat *__unbounded);
-
 #ifdef __NR_fstat64
-extern int __syscall_fstat64 (int, struct stat64 *__unbounded);
 # if  __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.  */
 extern int __have_no_stat64;
@@ -78,23 +75,20 @@
 # endif
   result = INLINE_SYSCALL (fstat, 2, fd, __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat64_conv (vers, &kbuf, buf);
+    result = __xstat64_conv (vers, &kbuf, buf);
 
   return result;
 #endif
 }
 
-#ifndef RTLD_STAT64
-# include <shlib-compat.h>
+#include <shlib-compat.h>
 
+#if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
 versioned_symbol (libc, ___fxstat64, __fxstat64, GLIBC_2_2);
-
-# if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
 strong_alias (___fxstat64, __old__fxstat64)
 compat_symbol (libc, __old__fxstat64, __fxstat64, GLIBC_2_1);
-# endif
-
+hidden_ver (___fxstat64, __fxstat64)
 #else
-strong_alias (___fxstat64, __fxstat64);
+strong_alias (___fxstat64, __fxstat64)
+hidden_def (__fxstat64)
 #endif
-hidden_ver (___fxstat64, __fxstat64)
diff -Nur sysdeps/unix/sysv/linux/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fxstat.c
--- sysdeps/unix/sysv/linux/fxstat.c	2002-10-02 10:53:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/fxstat.c	2003-06-28 10:10:46.000000000 +0200
@@ -1,5 +1,5 @@
 /* fxstat using old-style Unix fstat system call.
-   Copyright (C) 1991,1995-1998,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-1998,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,9 +31,7 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-#include <xstatconv.c>
-
-extern int __syscall_fstat (int, struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 /* Get information about the file FD in BUF.  */
 int
@@ -51,7 +49,7 @@
 
   result = INLINE_SYSCALL (fstat, 2, fd, __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif
diff -Nur sysdeps/unix/sysv/linux/gai_sigqueue.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/gai_sigqueue.c
--- sysdeps/unix/sysv/linux/gai_sigqueue.c	2001-08-17 08:41:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/gai_sigqueue.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,8 +28,6 @@
 #include "gai_misc.h"
 
 #ifdef __NR_rt_sigqueueinfo
-extern int __syscall_rt_sigqueueinfo (int, int, siginfo_t *__unbounded);
-
 
 /* Return any pending signal or wait for one for the given time.  */
 int
diff -Nur sysdeps/unix/sysv/linux/getclktck.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getclktck.c
--- sysdeps/unix/sysv/linux/getclktck.c	2002-03-11 09:32:01.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getclktck.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,5 +28,5 @@
 int
 __getclktck ()
 {
-  return GL(dl_clktck) ?: SYSTEM_CLK_TCK;
+  return GLRO(dl_clktck) ?: SYSTEM_CLK_TCK;
 }
diff -Nur sysdeps/unix/sysv/linux/getcwd.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getcwd.c
--- sysdeps/unix/sysv/linux/getcwd.c	2002-09-24 07:12:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getcwd.c	2003-09-20 03:05:49.000000000 +0200
@@ -1,5 +1,5 @@
 /* Determine current working directory.  Linux version.
-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -31,11 +31,17 @@
 #include "kernel-features.h"
 
 
+/* If we compile the file for use in ld.so we don't need the feature
+   that getcwd() allocates the buffers itself.  */
+#ifdef IS_IN_rtld
+# define NO_ALLOCATION	1
+#endif
+
+
 #if __ASSUME_GETCWD_SYSCALL > 0
 /* Kernel 2.1.92 introduced a third way to get the current working
    directory: a syscall.  We've got to be careful that even when
    compiling under 2.1.92+ the libc still runs under older kernels. */
-extern int __syscall_getcwd (char *__unbounded buf, unsigned long size);
 # define no_syscall_getcwd 0
 # define have_new_dcache 1
 /* This is a trick since we don't define generic_getcwd.  */
@@ -52,7 +58,6 @@
 /* Kernel 2.1.92 introduced a third way to get the current working
    directory: a syscall.  We've got to be careful that even when
    compiling under 2.1.92+ the libc still runs under older kernels. */
-extern int __syscall_getcwd (char *__unbounded buf, unsigned long size);
 static int no_syscall_getcwd;
 static int have_new_dcache;
 # else
@@ -67,11 +72,12 @@
   char *path;
   int n;
   char *result;
-  size_t alloc_size = size;
 
   if (no_syscall_getcwd && !have_new_dcache)
     return generic_getcwd (buf, size);
 
+#ifndef NO_ALLOCATION
+  size_t alloc_size = size;
   if (size == 0)
     {
       if (buf != NULL)
@@ -83,14 +89,17 @@
       alloc_size = PATH_MAX;
     }
 
-  if (buf != NULL)
-    path = buf;
-  else
+  if (buf == NULL)
     {
       path = malloc (alloc_size);
       if (path == NULL)
 	return NULL;
     }
+  else
+#else
+# define alloc_size size
+#endif
+    path = buf;
 
 #if defined __NR_getcwd || __LINUX_GETCWD_SYSCALL > 0
   if (!no_syscall_getcwd)
@@ -100,6 +109,7 @@
       retval = INLINE_SYSCALL (getcwd, 2, CHECK_STRING (path), alloc_size);
       if (retval >= 0)
 	{
+# ifndef NO_ALLOCATION
 	  if (buf == NULL && size == 0)
 	    /* Ensure that the buffer is only as large as necessary.  */
 	    buf = realloc (path, (size_t) retval);
@@ -108,6 +118,7 @@
 	    /* Either buf was NULL all along, or `realloc' failed but
 	       we still have the original string.  */
 	    buf = path;
+# endif
 
 	  return buf;
 	}
@@ -118,8 +129,10 @@
 	 large enough.  */
       assert (errno != ERANGE || buf != NULL || size != 0);
 
+#  ifndef NO_ALLOCATION
       if (buf == NULL)
 	free (path);
+#  endif
 
       return NULL;
 # else
@@ -130,8 +143,10 @@
 	}
       else if (errno != ERANGE || buf != NULL)
 	{
+#  ifndef NO_ALLOCATION
 	  if (buf == NULL)
 	    free (path);
+#  endif
 	  return NULL;
 	}
 # endif
@@ -145,12 +160,15 @@
 	{
 	  if ((size_t) n >= alloc_size - 1)
 	    {
+#ifndef NO_ALLOCATION
 	      if (buf == NULL)
 		free (path);
+#endif
 	      return NULL;
 	    }
 
 	  path[n] = '\0';
+#ifndef NO_ALLOCATION
 	  if (buf == NULL && size == 0)
 	    /* Ensure that the buffer is only as large as necessary.  */
 	    buf = realloc (path, (size_t) n + 1);
@@ -158,6 +176,7 @@
 	    /* Either buf was NULL all along, or `realloc' failed but
 	       we still have the original string.  */
 	    buf = path;
+#endif
 
 	  return buf;
 	}
@@ -174,17 +193,21 @@
     have_new_dcache = 0;
 #endif
 
+#ifndef NO_ALLOCATION
   /* Don't put restrictions on the length of the path unless the user does.  */
   if (size == 0)
     {
       free (path);
       path = NULL;
     }
+#endif
 
   result = generic_getcwd (path, size);
 
+#ifndef NO_ALLOCATION
   if (result == NULL && buf == NULL && size != 0)
     free (path);
+#endif
 
   return result;
 }
diff -Nur sysdeps/unix/sysv/linux/getdents.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getdents.c
--- sysdeps/unix/sysv/linux/getdents.c	2002-06-22 07:40:19.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getdents.c	2004-03-01 22:21:38.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1995-2002 Free Software Foundation, Inc.
+/* Copyright (C) 1993, 1995-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,21 +36,22 @@
 #include "kernel-features.h"
 
 #ifdef __NR_getdents64
-#ifndef __ASSUME_GETDENTS64_SYSCALL
-#ifndef __GETDENTS
+# ifndef __ASSUME_GETDENTS64_SYSCALL
+#  ifndef __GETDENTS
 /* The variable is shared between all *getdents* calls.  */
 int __have_no_getdents64;
-#else
+#  else
 extern int __have_no_getdents64;
+#  endif
+#  define have_no_getdents64_defined 1
+# endif
 #endif
-#endif
+#ifndef have_no_getdents64_defined
+# define __have_no_getdents64 0
 #endif
 
 #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
 
-extern int __syscall_getdents (int fd, char *__unbounded buf, unsigned int nbytes);
-extern int __syscall_getdents64 (int fd, char *__unbounded buf, unsigned int nbytes);
-
 /* For Linux we need a special version of this file since the
    definition of `struct dirent' is not the same for the kernel and
    the libc.  There is one additional field which might be introduced
@@ -97,19 +98,52 @@
 internal_function
 __GETDENTS (int fd, char *buf, size_t nbytes)
 {
-  DIRENT_TYPE *dp;
-  off64_t last_offset = -1;
   ssize_t retval;
 
+#ifdef __ASSUME_GETDENTS32_D_TYPE
+  if (sizeof (DIRENT_TYPE) == sizeof (struct dirent))
+    {
+      retval = INLINE_SYSCALL (getdents, 3, fd, CHECK_N(buf, nbytes), nbytes);
+
+      /* The kernel added the d_type value after the name.  Change
+	 this now.  */
+      if (retval != -1)
+	{
+	  union
+	  {
+	    struct kernel_dirent k;
+	    struct dirent u;
+	  } *kbuf = (void *) buf;
+
+	  while ((char *) kbuf < buf + retval)
+	    {
+	      char d_type = *((char *) kbuf + kbuf->k.d_reclen - 1);
+	      memmove (kbuf->u.d_name, kbuf->k.d_name,
+		       strlen (kbuf->k.d_name) + 1);
+	      kbuf->u.d_type = d_type;
+
+	      kbuf = (void *) ((char *) kbuf + kbuf->k.d_reclen);
+	    }
+	}
+
+      return retval;
+    }
+#endif
+
+  off64_t last_offset = -1;
+
 #ifdef __NR_getdents64
-# ifndef __ASSUME_GETDENTS64_SYSCALL
   if (!__have_no_getdents64)
-# endif
     {
 # ifndef __ASSUME_GETDENTS64_SYSCALL
       int saved_errno = errno;
 # endif
-      char *kbuf = buf;
+      union
+      {
+	struct kernel_dirent64 k;
+	DIRENT_TYPE u;
+	char b[1];
+      } *kbuf = (void *) buf, *outp, *inp;
       size_t kbytes = nbytes;
       if (offsetof (DIRENT_TYPE, d_name)
 	  < offsetof (struct kernel_dirent64, d_name)
@@ -122,10 +156,9 @@
       retval = INLINE_SYSCALL (getdents64, 3, fd, CHECK_N(kbuf, kbytes),
 			       kbytes);
 # ifndef __ASSUME_GETDENTS64_SYSCALL
-      if (retval != -1 && errno != -EINVAL)
+      if (retval != -1 || (errno != EINVAL && errno != ENOSYS))
 # endif
 	{
-	  struct kernel_dirent64 *kdp;
 	  const size_t size_diff = (offsetof (struct kernel_dirent64, d_name)
 				    - offsetof (DIRENT_TYPE, d_name));
 
@@ -137,31 +170,43 @@
 	     need, don't do any conversions.  */
 	  if (offsetof (DIRENT_TYPE, d_name)
 	      == offsetof (struct kernel_dirent64, d_name)
-	      && sizeof (dp->d_ino) == sizeof (kdp->d_ino)
-	      && sizeof (dp->d_off) == sizeof (kdp->d_off))
+	      && sizeof (outp->u.d_ino) == sizeof (inp->k.d_ino)
+	      && sizeof (outp->u.d_off) == sizeof (inp->k.d_off))
 	    return retval;
 
-	  dp = (DIRENT_TYPE *)buf;
-	  kdp = (struct kernel_dirent64 *) kbuf;
-	  while ((char *) kdp < kbuf + retval)
+	  /* These two pointers might alias the same memory buffer.
+	     Standard C requires that we always use the same type for them,
+	     so we must use the union type.  */
+	  inp = kbuf;
+	  outp = (void *) buf;
+
+	  while (&inp->b < &kbuf->b + retval)
 	    {
 	      const size_t alignment = __alignof__ (DIRENT_TYPE);
-	      /* Since kdp->d_reclen is already aligned for the kernel
+	      /* Since inp->k.d_reclen is already aligned for the kernel
 		 structure this may compute a value that is bigger
 		 than necessary.  */
-	      size_t old_reclen = kdp->d_reclen;
+	      size_t old_reclen = inp->k.d_reclen;
 	      size_t new_reclen = ((old_reclen - size_diff + alignment - 1)
 				  & ~(alignment - 1));
-	      uint64_t d_ino = kdp->d_ino;
-	      int64_t d_off = kdp->d_off;
-	      unsigned char d_type = kdp->d_type;
-
-	      DIRENT_SET_DP_INO (dp, d_ino);
-	      dp->d_off = d_off;
-	      if ((sizeof (dp->d_ino) != sizeof (kdp->d_ino)
-		   && dp->d_ino != d_ino)
-		  || (sizeof (dp->d_off) != sizeof (kdp->d_off)
-		      && dp->d_off != d_off))
+
+	      /* Copy the data out of the old structure into temporary space.
+		 Then copy the name, which may overlap if BUF == KBUF.  */
+	      const uint64_t d_ino = inp->k.d_ino;
+	      const int64_t d_off = inp->k.d_off;
+	      const uint8_t d_type = inp->k.d_type;
+
+	      memmove (outp->u.d_name, inp->k.d_name,
+		       old_reclen - offsetof (struct kernel_dirent64, d_name));
+
+	      /* Now we have copied the data from INP and access only OUTP.  */
+
+	      DIRENT_SET_DP_INO (&outp->u, d_ino);
+	      outp->u.d_off = d_off;
+	      if ((sizeof (outp->u.d_ino) != sizeof (inp->k.d_ino)
+		   && outp->u.d_ino != d_ino)
+		  || (sizeof (outp->u.d_off) != sizeof (inp->k.d_off)
+		      && outp->u.d_off != d_off))
 		{
 		  /* Overflow.  If there was at least one entry
 		     before this one, return them without error,
@@ -169,23 +214,21 @@
 		  if (last_offset != -1)
 		    {
 		      __lseek64 (fd, last_offset, SEEK_SET);
-		      return (char *) dp - buf;
+		      return outp->b - buf;
 		    }
 		  __set_errno (EOVERFLOW);
 		  return -1;
 		}
 
 	      last_offset = d_off;
-	      dp->d_reclen = new_reclen;
-	      dp->d_type = d_type;
-	      memmove (dp->d_name, kdp->d_name,
-		       old_reclen - offsetof (struct kernel_dirent64, d_name));
+	      outp->u.d_reclen = new_reclen;
+	      outp->u.d_type = d_type;
 
-	      dp = (DIRENT_TYPE *) ((char *) dp + new_reclen);
-	      kdp = (struct kernel_dirent64 *) ((char *) kdp + old_reclen);
+	      inp = (void *) inp + old_reclen;
+	      outp = (void *) outp + new_reclen;
 	    }
 
-	  return (char *) dp - buf;
+	  return outp->b - buf;
 	}
 
 # ifndef __ASSUME_GETDENTS64_SYSCALL
@@ -205,7 +248,6 @@
 			 * size_diff),
 		      nbytes - size_diff);
 
-    dp = (DIRENT_TYPE *) buf;
     skdp = kdp = __alloca (red_nbytes);
 
     retval = INLINE_SYSCALL (getdents, 3, fd,
@@ -214,6 +256,7 @@
     if (retval == -1)
       return -1;
 
+    DIRENT_TYPE *dp = (DIRENT_TYPE *) buf;
     while ((char *) kdp < (char *) skdp + retval)
       {
 	const size_t alignment = __alignof__ (DIRENT_TYPE);
@@ -250,7 +293,7 @@
 	dp = (DIRENT_TYPE *) ((char *) dp + new_reclen);
 	kdp = (struct kernel_dirent *) (((char *) kdp) + kdp->d_reclen);
       }
-    }
 
-  return (char *) dp - buf;
+    return (char *) dp - buf;
+  }
 }
diff -Nur sysdeps/unix/sysv/linux/gethostid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/gethostid.c
--- sysdeps/unix/sysv/linux/gethostid.c	2002-09-24 07:12:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/gethostid.c	2004-12-16 05:12:57.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995,1996,1998,1999,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1998-2001,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,7 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <netdb.h>
+#include <not-cancel.h>
 
 #define HOSTIDFILE "/etc/hostid"
 #define OLD_HOSTIDFILE "/etc/hostid"
@@ -32,6 +33,7 @@
 {
   int fd;
   ssize_t written;
+  int32_t id32 = id;
 
   /* Test for appropriate rights to set host ID.  */
   if (__libc_enable_secure)
@@ -40,16 +42,23 @@
       return -1;
     }
 
+  /* Make sure the ID is not too large.  Needed for bi-arch support.   */
+  if (id32 != id)
+    {
+      __set_errno (EOVERFLOW);
+      return -1;
+    }
+
   /* Open file for writing.  Everybody is allowed to read this file.  */
-  fd = __open64 (HOSTIDFILE, O_CREAT|O_WRONLY|O_TRUNC, 0644);
+  fd = open_not_cancel (HOSTIDFILE, O_CREAT|O_WRONLY|O_TRUNC, 0644);
   if (fd < 0)
     return -1;
 
-  written = __write (fd, &id, sizeof (id));
+  written = write_not_cancel (fd, &id32, sizeof (id32));
 
-  __close (fd);
+  close_not_cancel_no_status (fd);
 
-  return written != sizeof (id) ? -1 : 0;
+  return written != sizeof (id32) ? -1 : 0;
 }
 
 #else
@@ -65,20 +74,20 @@
   size_t buflen;
   char *buffer;
   struct hostent hostbuf, *hp;
-  unsigned long int id;
+  int32_t id;
   struct in_addr in;
   int herr;
   int fd;
 
   /* First try to get the ID from a former invocation of sethostid.  */
-  fd = __open64 (HOSTIDFILE, O_RDONLY);
+  fd = open_not_cancel (HOSTIDFILE, O_RDONLY|O_LARGEFILE, 0);
   if (fd < 0)
-    fd = __open64 (OLD_HOSTIDFILE, O_RDONLY);
+    fd = open_not_cancel (OLD_HOSTIDFILE, O_RDONLY|O_LARGEFILE, 0);
   if (fd >= 0)
     {
-      ssize_t n = __read (fd, &id, sizeof (id));
+      ssize_t n = read_not_cancel (fd, &id, sizeof (id));
 
-      __close (fd);
+      close_not_cancel_no_status (fd);
 
       if (n == sizeof (id))
 	return id;
@@ -100,11 +109,8 @@
     if (herr != NETDB_INTERNAL || errno != ERANGE)
       return 0;
     else
-      {
-	/* Enlarge buffer.  */
-	buflen *= 2;
-	buffer = __alloca (buflen);
-      }
+      /* Enlarge buffer.  */
+      buffer = extend_alloca (buffer, buflen, 2 * buflen);
 
   in.s_addr = 0;
   memcpy (&in, hp->h_addr,
@@ -112,6 +118,6 @@
 
   /* For the return value to be not exactly the IP address we do some
      bit fiddling.  */
-  return in.s_addr << 16 | in.s_addr >> 16;
+  return (int32_t) (in.s_addr << 16 | in.s_addr >> 16);
 }
 #endif
diff -Nur sysdeps/unix/sysv/linux/getipv4sourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getipv4sourcefilter.c
--- sysdeps/unix/sysv/linux/getipv4sourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getipv4sourcefilter.c	2004-08-06 09:42:44.000000000 +0200
@@ -0,0 +1,73 @@
+/* Get IPv4 source filter.  Linux version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+
+
+int
+getipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,
+		     uint32_t *fmode, uint32_t *numsrc, struct in_addr *slist)
+{
+  /* We have to create an struct ip_msfilter object which we can pass
+     to the kernel.  */
+  socklen_t needed = IP_MSFILTER_SIZE (*numsrc);
+  int use_alloca = __libc_use_alloca (needed);
+
+  struct ip_msfilter *imsf;
+  if (use_alloca)
+    imsf = (struct ip_msfilter *) alloca (needed);
+  else
+    {
+      imsf = (struct ip_msfilter *) malloc (needed);
+      if (imsf == NULL)
+	return -1;
+    }
+
+  imsf->imsf_multiaddr = group;
+  imsf->imsf_interface = interface;
+  imsf->imsf_numsrc = *numsrc;
+
+  int result = __getsockopt (s, SOL_IP, IP_MSFILTER, imsf, &needed);
+
+  /* If successful, copy the results to the places the caller wants
+     them in.  */
+  if (result == 0)
+    {
+      *fmode = imsf->imsf_fmode;
+      memcpy (slist, imsf->imsf_slist,
+	      MIN (*numsrc, imsf->imsf_numsrc) * sizeof (struct in_addr));
+      *numsrc = imsf->imsf_numsrc;
+    }
+
+  if (! use_alloca)
+    {
+      int save_errno = errno;
+      free (imsf);
+      __set_errno (save_errno);
+    }
+
+  return result;
+}
diff -Nur sysdeps/unix/sysv/linux/getloadavg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getloadavg.c
--- sysdeps/unix/sysv/linux/getloadavg.c	2002-04-08 09:02:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getloadavg.c	2004-07-13 02:23:00.000000000 +0200
@@ -1,5 +1,5 @@
 /* Get system load averages.  Linux (/proc/loadavg) version.
-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,6 +22,7 @@
 #include <locale.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <not-cancel.h>
 
 /* Put the 1 minute, 5 minute and 15 minute load averages
    into the first NELEM elements of LOADAVG.
@@ -33,7 +34,7 @@
 {
   int fd;
 
-  fd = __open ("/proc/loadavg", O_RDONLY);
+  fd = open_not_cancel_2 ("/proc/loadavg", O_RDONLY);
   if (fd < 0)
     return -1;
   else
@@ -42,9 +43,9 @@
       ssize_t nread;
       int i;
 
-      nread = __read (fd, buf, sizeof buf - 1);
-      __close (fd);
-      if (nread < 0)
+      nread = read_not_cancel (fd, buf, sizeof buf - 1);
+      close_not_cancel_no_status (fd);
+      if (nread <= 0)
 	return -1;
       buf[nread - 1] = '\0';
 
@@ -55,7 +56,7 @@
 	{
 	  char *endp;
 	  loadavg[i] = __strtod_l (p, &endp, &_nl_C_locobj);
-	  if (endp == NULL || endp == p)
+	  if (endp == p)
 	    /* This should not happen.  The format of /proc/loadavg
 	       must have changed.  Don't return with what we have,
 	       signal an error.  */
diff -Nur sysdeps/unix/sysv/linux/getpagesize.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getpagesize.c
--- sysdeps/unix/sysv/linux/getpagesize.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getpagesize.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991,1992,1995-1997,2000,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,1992,1995-1997,2000,2002,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,8 +26,8 @@
 int
 __getpagesize ()
 {
-  if (GL(dl_pagesize) != 0)
-    return GL(dl_pagesize);
+  if (GLRO(dl_pagesize) != 0)
+    return GLRO(dl_pagesize);
 
 #ifdef	EXEC_PAGESIZE
   return EXEC_PAGESIZE;
diff -Nur sysdeps/unix/sysv/linux/getpriority.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getpriority.c
--- sysdeps/unix/sysv/linux/getpriority.c	2002-08-04 06:32:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getpriority.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* getpriority for Linux.
-   Copyright (C) 1996,98,2000,02 Free Software Foundation, Inc.
+   Copyright (C) 1996,98,2000,02,03 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,9 +23,7 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_getpriority (int, id_t);
-
-/* The return value of __syscall_getpriority is biased by this value
+/* The return value of getpriority syscall is biased by this value
    to avoid returning negative values.  */
 #define PZERO 20
 
diff -Nur sysdeps/unix/sysv/linux/getsourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getsourcefilter.c
--- sysdeps/unix/sysv/linux/getsourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getsourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,142 @@
+/* Get source filter.  Linux version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <assert.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netatalk/at.h>
+#include <netax25/ax25.h>
+#include <netinet/in.h>
+#include <netipx/ipx.h>
+#include <netpacket/packet.h>
+#include <netrose/rose.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+
+
+static const struct
+{
+  int sol;
+  int af;
+  socklen_t size;
+}  sol_map[] =
+  {
+    /* Sort the array according to importance of the protocols.  Add
+       more protocols when they become available.  */
+    { SOL_IP, AF_INET, sizeof (struct sockaddr_in) },
+    { SOL_IPV6, AF_INET6, sizeof (struct sockaddr_in6) },
+    { SOL_AX25, AF_AX25, sizeof (struct sockaddr_ax25) },
+    { SOL_IPX, AF_IPX, sizeof (struct sockaddr_ipx) },
+    { SOL_ATALK, AF_APPLETALK, sizeof (struct sockaddr_at) },
+    { SOL_ROSE, AF_ROSE, sizeof (struct sockaddr_rose) },
+    { SOL_PACKET, AF_PACKET, sizeof (struct sockaddr_ll) }
+  };
+#define NSOL_MAP (sizeof (sol_map) / sizeof (sol_map[0]))
+
+
+/* Try to determine the socket level value.  Ideally both side and
+   family are set.  But sometimes only the size is correct and the
+   family value might be bogus.  Loop over the array entries and look
+   for a perfect match or the first match based on size.  */
+int
+__get_sol (int af, socklen_t len)
+{
+  int first_size_sol = -1;
+
+  for (size_t cnt = 0; cnt < NSOL_MAP; ++cnt)
+    {
+      /* Just a test so that we make sure the special value used to
+	 signal the "we have so far no socket level value" is OK.  */
+      assert (sol_map[cnt].sol != -1);
+
+      if (len == sol_map[cnt].size)
+	{
+	  /* The size matches, which is a requirement.  If the family
+	     matches, too, we have a winner.  Otherwise we remember the
+	     socket level value for this protocol if it is the first
+	     match.  */
+	  if (af == sol_map[cnt].af)
+	    /* Bingo!  */
+	    return sol_map[cnt].sol;
+
+	  if (first_size_sol == -1)
+	    first_size_sol = sol_map[cnt].sol;
+      }
+    }
+
+  return first_size_sol;
+}
+
+
+int
+getsourcefilter (int s, uint32_t interface, const struct sockaddr *group,
+		 socklen_t grouplen, uint32_t *fmode, uint32_t *numsrc,
+		 struct sockaddr_storage *slist)
+{
+  /* We have to create an struct ip_msfilter object which we can pass
+     to the kernel.  */
+  socklen_t needed = GROUP_FILTER_SIZE (*numsrc);
+  int use_alloca = __libc_use_alloca (needed);
+
+  struct group_filter *gf;
+  if (use_alloca)
+    gf = (struct group_filter *) alloca (needed);
+  else
+    {
+      gf = (struct group_filter *) malloc (needed);
+      if (gf == NULL)
+	return -1;
+    }
+
+  gf->gf_interface = interface;
+  memcpy (&gf->gf_group, group, grouplen);
+  gf->gf_numsrc = *numsrc;
+
+  /* We need to provide the appropriate socket level value.  */
+  int sol = __get_sol (group->sa_family, grouplen);
+  if (sol == -1)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  int result = __getsockopt (s, sol, MCAST_MSFILTER, gf, &needed);
+
+  /* If successful, copy the results to the places the caller wants
+     them in.  */
+  if (result == 0)
+    {
+      *fmode = gf->gf_fmode;
+      memcpy (slist, gf->gf_slist,
+	      MIN (*numsrc, gf->gf_numsrc) * sizeof (struct sockaddr_storage));
+      *numsrc = gf->gf_numsrc;
+    }
+
+  if (! use_alloca)
+    {
+      int save_errno = errno;
+      free (gf);
+      __set_errno (save_errno);
+    }
+
+  return result;
+}
diff -Nur sysdeps/unix/sysv/linux/getsysstats.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getsysstats.c
--- sysdeps/unix/sysv/linux/getsysstats.c	2002-09-21 07:24:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/getsysstats.c	2003-09-04 10:25:11.000000000 +0200
@@ -1,5 +1,5 @@
 /* Determine various system internal values, Linux version.
-   Copyright (C) 1996-2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1996-2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -31,14 +31,14 @@
 #include <unistd.h>
 #include <sys/sysinfo.h>
 
-#include <atomicity.h>
+#include <atomic.h>
 
 
 /* The default value for the /proc filesystem mount point.  */
 static const char path_proc[] = "/proc";
 
 /* Actual mount point of /proc filesystem.  */
-static char *mount_proc;
+libc_freeres_ptr (static char *mount_proc);
 
 /* Determine the path to the /proc filesystem if available.  */
 static const char *
@@ -85,8 +85,7 @@
 
   /* Now store the copied value.  But do it atomically.  */
   assert (sizeof (long int) == sizeof (void *__unbounded));
-  if (compare_and_swap ((long int *) &mount_proc, (long int) 0,
-			(long int) copy_result) == 0)
+  if (atomic_compare_and_exchange_bool_acq (&mount_proc, copy_result, NULL))
     /* Replacing the value failed.  This means another thread was
        faster and we don't need the copy anymore.  */
     free (copy_result);
@@ -155,7 +154,7 @@
       /* The /proc/stat format is more uniform, use it by default.  */
       __stpcpy (__stpcpy (proc_fname, proc_path), "/stat");
 
-      fp = fopen (proc_fname, "r");
+      fp = fopen (proc_fname, "rc");
       if (fp != NULL)
 	{
 	  /* No threads use this stream.  */
@@ -172,7 +171,7 @@
 	{
 	  __stpcpy (__stpcpy (proc_fname, proc_path), "/cpuinfo");
 
-	  fp = fopen (proc_fname, "r");
+	  fp = fopen (proc_fname, "rc");
 	  if (fp != NULL)
 	    {
 	      /* No threads use this stream.  */
@@ -210,7 +209,7 @@
       char *proc_cpuinfo = alloca (strlen (proc_path) + sizeof ("/cpuinfo"));
       __stpcpy (__stpcpy (proc_cpuinfo, proc_path), "/cpuinfo");
 
-      fp = fopen (proc_cpuinfo, "r");
+      fp = fopen (proc_cpuinfo, "rc");
       if (fp != NULL)
 	{
 	  /* No threads use this stream.  */
@@ -250,7 +249,7 @@
       char *proc_meminfo = alloca (strlen (proc_path) + sizeof ("/meminfo"));
       __stpcpy (__stpcpy (proc_meminfo, proc_path), "/meminfo");
 
-      fp = fopen (proc_meminfo, "r");
+      fp = fopen (proc_meminfo, "rc");
       if (fp != NULL)
 	{
 	  /* No threads use this stream.  */
@@ -319,11 +318,3 @@
   return phys_pages_info ("MemFree: %ld kB");
 }
 weak_alias (__get_avphys_pages, get_avphys_pages)
-
-
-static void
-free_mem (void)
-{
-  free (mount_proc);
-}
-text_set_element (__libc_subfreeres, free_mem);
diff -Nur sysdeps/unix/sysv/linux/i386/alphasort64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/alphasort64.c
--- sysdeps/unix/sysv/linux/i386/alphasort64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/alphasort64.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1997, 1998, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -38,6 +38,7 @@
 __old_alphasort64 (const void *a, const void *b);
 
 int
+attribute_compat_text_section
 __old_alphasort64 (const void *a, const void *b)
 {
   return strcoll ((*(const struct __old_dirent64 **) a)->d_name,
diff -Nur sysdeps/unix/sysv/linux/i386/bits/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/a.out.h
--- sysdeps/unix/sysv/linux/i386/bits/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/a.out.h	2003-07-25 11:04:57.000000000 +0200
@@ -0,0 +1,3 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/environments.h
--- sysdeps/unix/sysv/linux/i386/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/environments.h	2004-11-26 09:11:06.000000000 +0100
@@ -0,0 +1,62 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+#define _POSIX_V6_ILP32_OFF32	1
+#define _POSIX_V6_ILP32_OFFBIG	1
+#define _XBS5_ILP32_OFF32	1
+#define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* Environments with 64-bit wide pointers can be provided,
+   so these macros aren't defined:
+   # undef _POSIX_V6_LP64_OFF64
+   # undef _POSIX_V6_LPBIG_OFFBIG
+   # undef _XBS5_LP64_OFF64
+   # undef _XBS5_LPBIG_OFFBIG
+   and sysconf tests for it at runtime.  */
+
+#define __ILP32_OFF32_CFLAGS	"-m32"
+#define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+#define __ILP32_OFF32_LDFLAGS	"-m32"
+#define __ILP32_OFFBIG_LDFLAGS	"-m32"
+#define __LP64_OFF64_CFLAGS	"-m64"
+#define __LP64_OFF64_LDFLAGS	"-m64"
diff -Nur sysdeps/unix/sysv/linux/i386/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/fcntl.h
--- sysdeps/unix/sysv/linux/i386/bits/fcntl.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/fcntl.h	2004-08-23 09:28:44.000000000 +0200
@@ -1,5 +1,6 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,6 +46,7 @@
 # define O_DIRECT	 040000	/* Direct disk access.	*/
 # define O_DIRECTORY	0200000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_NOATIME     01000000 /* Do not set atime.  */
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
@@ -78,7 +80,7 @@
 #define F_SETLK64	13	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	14	/* Set record locking info (blocking).	*/
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -177,3 +179,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/i386/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/mman.h
--- sysdeps/unix/sysv/linux/i386/bits/mman.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/mman.h	2003-09-25 18:39:38.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/i386 version.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
@@ -52,11 +56,13 @@
 
 /* These are Linux-specific.  */
 #ifdef __USE_MISC
-# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
-# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
-# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
-# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
 #endif
 
 /* Flags to `msync'.  */
diff -Nur sysdeps/unix/sysv/linux/i386/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/resource.h
--- sysdeps/unix/sysv/linux/i386/bits/resource.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* Bit values & structures for resource limits.  Linux/x86 version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((unsigned long int)(~0UL))
-#else
-# define RLIM_INFINITY 0xffffffffffffffffuLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0xffffffffffffffffuLL
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#ifndef __USE_FILE_OFFSET64
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/i386/bits/time.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/time.h
--- sysdeps/unix/sysv/linux/i386/bits/time.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bits/time.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* System-dependent timing definitions.  Linux/x86 version.
-   Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <time.h> instead.
- */
-
-#ifndef __need_timeval
-# ifndef _BITS_TIME_H
-#  define _BITS_TIME_H	1
-
-/* ISO/IEC 9899:1990 7.12.1: <time.h>
-   The macro `CLOCKS_PER_SEC' is the number per second of the value
-   returned by the `clock' function. */
-/* CAE XSH, Issue 4, Version 2: <time.h>
-   The value of CLOCKS_PER_SEC is required to be 1 million on all
-   XSI-conformant systems. */
-#  define CLOCKS_PER_SEC  1000000l
-
-#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
-/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
-   presents the real value for clock ticks per second for the system.  */
-#   include <bits/types.h>
-extern long int __sysconf (int);
-#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
-#  endif
-
-#  ifdef __USE_POSIX199309
-/* Identifier for system-wide realtime clock.  */
-#   define CLOCK_REALTIME		0
-/* High-resolution timer from the CPU.  */
-#   define CLOCK_PROCESS_CPUTIME_ID	2
-/* Thread-specific CPU-time clock.  */
-#   define CLOCK_THREAD_CPUTIME_ID	3
-
-/* Flag to indicate time is absolute.  */
-#   define TIMER_ABSTIME		1
-#  endif
-
-# endif	/* bits/time.h */
-#endif
-
-#ifdef __need_timeval
-# undef __need_timeval
-# ifndef _STRUCT_TIMEVAL
-#  define _STRUCT_TIMEVAL	1
-#  include <bits/types.h>
-
-/* A time value that is accurate to the nearest
-   microsecond but also has a range of years.  */
-struct timeval
-  {
-    __time_t tv_sec;		/* Seconds.  */
-    __suseconds_t tv_usec;	/* Microseconds.  */
-  };
-# endif	/* struct timeval */
-#endif	/* need timeval */
diff -Nur sysdeps/unix/sysv/linux/i386/bp-thunks.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bp-thunks.h
--- sysdeps/unix/sysv/linux/i386/bp-thunks.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/bp-thunks.h	2003-05-02 04:20:50.000000000 +0200
@@ -0,0 +1,4 @@
+#ifndef __ASSEMBLER__
+# include <sysdeps/generic/bp-thunks.h>
+# include <sys/vm86.h>
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/brk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/brk.c
--- sysdeps/unix/sysv/linux/i386/brk.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/brk.c	2003-01-09 05:06:05.000000000 +0100
@@ -1,5 +1,5 @@
 /* brk system call for Linux/i386.
-   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,14 +34,11 @@
 int
 __brk (void *addr)
 {
-  void *__unbounded newbrk, *__unbounded scratch;
+  void *__unbounded newbrk;
 
-  asm ("movl %%ebx, %1\n"	/* Save %ebx in scratch register.  */
-       "movl %3, %%ebx\n"	/* Put ADDR in %ebx to be syscall arg.  */
-       "int $0x80 # %2\n"	/* Perform the system call.  */
-       "movl %1, %%ebx\n"	/* Restore %ebx from scratch register.  */
-       : "=a" (newbrk), "=r" (scratch)
-       : "0" (SYS_ify (brk)), "g" (__ptrvalue (addr)));
+  INTERNAL_SYSCALL_DECL (err);
+  newbrk = (void *__unbounded) INTERNAL_SYSCALL (brk, err, 1,
+						 __ptrvalue (addr));
 
   __curbrk = newbrk;
 
diff -Nur sysdeps/unix/sysv/linux/i386/chown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/chown.c
--- sysdeps/unix/sysv/linux/i386/chown.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/chown.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998,1999,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,9 +37,6 @@
   has therefore to route calls to chown to the old chown function.
 */
 
-extern int __syscall_chown (const char *__file,
-			    __kernel_uid_t __owner, __kernel_gid_t __group);
-
 extern int __chown_is_lchown (const char *__file, uid_t __owner,
 			      gid_t __group);
 extern int __real_chown (const char *__file, uid_t __owner, gid_t __group);
@@ -49,8 +46,6 @@
 /* Running under Linux > 2.1.80.  */
 
 # ifdef __NR_chown32
-extern int __syscall_chown32 (const char *__file,
-			      __kernel_uid32_t owner, __kernel_gid32_t group);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -141,6 +136,7 @@
 #elif SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
 /* Compiling for compatibiity.  */
 int
+attribute_compat_text_section
 __chown_is_lchown (const char *file, uid_t owner, gid_t group)
 {
   return __lchown (file, owner, group);
@@ -148,20 +144,15 @@
 #endif
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
-strong_alias (__chown_is_lchown, _chown_is_lchown)
-compat_symbol (libc, __chown_is_lchown, __chown, GLIBC_2_0);
-compat_symbol (libc, _chown_is_lchown, chown, GLIBC_2_0);
+compat_symbol (libc, __chown_is_lchown, chown, GLIBC_2_0);
 #endif
 
 #ifdef __NR_lchown
-strong_alias (__real_chown, _real_chown)
-versioned_symbol (libc, __real_chown, __chown, GLIBC_2_1);
-versioned_symbol (libc, _real_chown, chown, GLIBC_2_1);
-libc_hidden_ver (__real_chown, __chown)
+versioned_symbol (libc, __real_chown, chown, GLIBC_2_1);
+strong_alias (__real_chown, __chown)
 #else
 strong_alias (__chown_is_lchown, __chown_is_lchown21)
-strong_alias (__chown_is_lchown, _chown_is_lchown21)
-versioned_symbol (libc, __chown_is_lchown21, __chown, GLIBC_2_1);
-versioned_symbol (libc, _chown_is_lchown21, chown, GLIBC_2_1);
-libc_hidden_ver (__chown_is_lchown, __chown)
+versioned_symbol (libc, __chown_is_lchown21, chown, GLIBC_2_1);
+strong_alias (__chown_is_lchown, __chown)
 #endif
+libc_hidden_def (__chown)
diff -Nur sysdeps/unix/sysv/linux/i386/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/clone.S
--- sysdeps/unix/sysv/linux/i386/clone.S	2002-09-18 09:20:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/clone.S	2005-02-16 09:45:38.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997,98,99,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1996,1997,98,99,2000,02,03,04 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson (rth@tamu.edu)
 
@@ -28,19 +28,23 @@
 #include <bp-asm.h>
 
 /* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
-	     pid_t *tid, struct user_desc *tls); */
+	     pid_t *ptid, struct user_desc *tls, pid_t *ctid); */
 
 #define PARMS	LINKAGE		/* no space for saved regs */
 #define FUNC	PARMS
 #define STACK	FUNC+4
 #define FLAGS	STACK+PTR_SIZE
 #define ARG	FLAGS+4
-#define TID	ARG+PTR_SIZE
-#define TLS	TID+PTR_SIZE
+#define PTID	ARG+PTR_SIZE
+#define TLS	PTID+PTR_SIZE
+#define CTID	TLS+PTR_SIZE
 
 #define __NR_clone 120
 #define SYS_clone 120
 
+#define CLONE_VM	0x00000100
+#define CLONE_THREAD	0x00010000
+
         .text
 ENTRY (BP_SYM (__clone))
 	/* Sanity check arguments.  */
@@ -60,24 +64,40 @@
 	jz	SYSCALL_ERROR_LABEL
 #endif
 
-	/* Insert the argument onto the new stack.  */
-	subl	$12,%ecx
+	/* Insert the argument onto the new stack.  Make sure the new
+	   thread is started with an alignment of (mod 16).  */
+	andl	$0xfffffff0, %ecx
+	subl	$28,%ecx
 	movl	ARG(%esp),%eax		/* no negative argument counts */
-	movl	%eax,8(%ecx)
+	movl	%eax,12(%ecx)
 
 	/* Save the function pointer as the zeroth argument.
 	   It will be popped off in the child in the ebx frobbing below.  */
 	movl	FUNC(%esp),%eax
-	movl	%eax,4(%ecx)
+	movl	%eax,8(%ecx)
+	/* Don't leak any information.  */
+	movl	$0,4(%ecx)
+#ifndef RESET_PID
+	movl	$0,(%ecx)
+#endif
 
 	/* Do the system call */
 	pushl	%ebx
 	pushl	%esi
-	movl	TLS+8(%esp),%esi
-	movl	TID+8(%esp),%edx
-	movl	FLAGS+8(%esp),%ebx
+	pushl	%edi
+	movl	TLS+12(%esp),%esi
+	movl	PTID+12(%esp),%edx
+	movl	FLAGS+12(%esp),%ebx
+	movl	CTID+12(%esp),%edi
 	movl	$SYS_ify(clone),%eax
+
+#ifdef RESET_PID
+	/* Remember the flag value.  */
+	movl	%ebx, (%ecx)
+#endif
+
 	int	$0x80
+	popl	%edi
 	popl	%esi
 	popl	%ebx
 
@@ -89,7 +109,13 @@
 	ret
 
 L(thread_start):
-	subl	%ebp,%ebp	/* terminate the stack frame */
+	/* Note: %esi is zero.  */
+	movl	%esi,%ebp	/* terminate the stack frame */
+#ifdef RESET_PID
+	testl	$CLONE_THREAD, %edi
+	je	L(newpid)
+L(haspid):
+#endif
 	call	*%ebx
 #ifdef PIC
 	call	L(here)
@@ -101,6 +127,21 @@
 	movl	$SYS_ify(exit), %eax
 	int	$0x80
 
+#ifdef RESET_PID
+	.subsection 2
+L(newpid):
+	testl	$CLONE_VM, %edi
+	movl	$-1, %eax
+	jne	L(nomoregetpid)
+	movl	$SYS_ify(getpid), %eax
+	ENTER_KERNEL
+L(nomoregetpid):
+	movl	%eax, %gs:PID
+	movl	%eax, %gs:TID
+	jmp	L(haspid)
+	.previous
+#endif
+
 PSEUDO_END (BP_SYM (__clone))
 
 weak_alias (BP_SYM (__clone), BP_SYM (clone))
diff -Nur sysdeps/unix/sysv/linux/i386/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Dist
--- sysdeps/unix/sysv/linux/i386/Dist	2002-02-01 20:10:12.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Dist	2003-02-21 08:03:18.000000000 +0100
@@ -1,3 +1,4 @@
+bp-thunks.h
 clone.S
 olddirent.h
 oldgetrlimit64.c
diff -Nur sysdeps/unix/sysv/linux/i386/dl-librecon.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-librecon.h
--- sysdeps/unix/sysv/linux/i386/dl-librecon.h	2002-01-30 08:30:54.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-librecon.h	2004-10-14 03:53:55.000000000 +0200
@@ -1,5 +1,5 @@
 /* Optional code to distinguish library flavours.
-   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -19,7 +19,8 @@
    02111-1307 USA.  */
 
 #ifndef _DL_LIBRECON_H
-#define _DL_LIBRECON_H	1
+
+#include <sysdeps/unix/sysv/linux/dl-librecon.h>
 
 #define DISTINGUISH_LIB_VERSIONS \
   do									      \
@@ -27,15 +28,15 @@
       /* We have to find out whether the binary is linked against	      \
 	 libc 5 or glibc.  We do this by looking at all the DT_NEEDED	      \
 	 entries.  If one is libc.so.5 this is a libc 5 linked binary.  */    \
-      if (GL(dl_loaded)->l_info[DT_NEEDED])				      \
+      if (main_map->l_info[DT_NEEDED])					      \
 	{								      \
 	  /* We have dependencies.  */					      \
 	  const ElfW(Dyn) *d;						      \
 	  const char *strtab;						      \
 									      \
-	  strtab = (const char *) D_PTR (GL(dl_loaded), l_info[DT_STRTAB]);   \
+	  strtab = (const char *) D_PTR (main_map, l_info[DT_STRTAB]);	      \
 									      \
-	  for (d = GL(dl_loaded)->l_ld; d->d_tag != DT_NULL; ++d)	      \
+	  for (d = main_map->l_ld; d->d_tag != DT_NULL; ++d)		      \
 	    if (d->d_tag == DT_NEEDED					      \
 		&& strcmp (strtab + d->d_un.d_val, "libc.so.5") == 0)	      \
 	      break;							      \
@@ -48,35 +49,10 @@
 
 /* Recognizing extra environment variables.  */
 #define EXTRA_LD_ENVVARS \
-  case 13:								      \
-    if (memcmp (envline, "ASSUME_KERNEL", 13) == 0)			      \
-      {									      \
-	unsigned long int i, j, osversion = 0;				      \
-	char *p = &envline[14], *q;					      \
-									      \
-	for (i = 0; i < 3; i++, p = q + 1)				      \
-	  {								      \
-	    j = __strtoul_internal (p, &q, 0, 0);			      \
-	    if (j >= 255 || p == q || (i < 2 && *q && *q != '.'))	      \
-	      {								      \
-		osversion = 0;						      \
-		break;							      \
-	      }								      \
-	    osversion |= j << (16 - 8 * i);				      \
-	    if (!*q)							      \
-	      break;							      \
-	  }								      \
-	if (osversion)							      \
-	  GL(dl_osversion) = osversion;					      \
-	break;								      \
-      }									      \
-									      \
   case 15:								      \
     if (memcmp (envline, "LIBRARY_VERSION", 15) == 0)			      \
-      {									      \
-	GL(dl_correct_cache_id) = envline[16] == '5' ? 2 : 3;		      \
-	break;								      \
-      }
+      GLRO(dl_correct_cache_id) = envline[16] == '5' ? 2 : 3;		      \
+    break;								      \
 
 /* Extra unsecure variables.  The names are all stuffed in a single
    string which means they have to be terminated with a '\0' explicitly.  */
diff -Nur sysdeps/unix/sysv/linux/i386/dl-procinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-procinfo.c
--- sysdeps/unix/sysv/linux/i386/dl-procinfo.c	2002-02-01 07:22:51.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-procinfo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-/* Data for Linux/i386 version of processor capability information.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This information must be kept in sync with the _DL_HWCAP_COUNT and
-   _DL_PLATFORM_COUNT definitions in procinfo.h.
-
-   If anything should be added here check whether the size of each string
-   is still ok with the given array size.
-
-   All the #ifdefs in the definitions ar equite irritating but
-   necessary if we want to avoid duplicating the information.  There
-   are three different modes:
-
-   - PROCINFO_DECL is defined.  This means we are only interested in
-     declarations.
-
-   - PROCINFO_DECL is not defined:
-
-     + if SHARED is defined the file is included in an array
-       initializer.  The .element = { ... } syntax is needed.
-
-     + if SHARED is not defined a normal array initialization is
-       needed.
-  */
-
-#ifdef PROCINFO_DECL
-EXTERN
-#endif
-#if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_cap_flags
-#else
-const char _dl_x86_cap_flags[32][8]
-#endif
-#ifndef PROCINFO_DECL
-= {
-    "fpu", "vme", "de", "pse", "tsc", "msr", "pae", "mce",
-    "cx8", "apic", "10", "sep", "mtrr", "pge", "mca", "cmov",
-    "pat", "pse36", "pn", "clflush", "20", "dts", "acpi", "mmx",
-    "fxsr", "sse", "sse2", "ss", "ht", "tm", "ia64", "amd3d"
-  }
-#endif
-#if !defined SHARED || defined PROCINFO_DECL
-;
-#else
-,
-#endif
-
-#ifdef PROCINFO_DECL
-EXTERN
-#endif
-#if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_platforms
-#else
-const char _dl_x86_platforms[4][5]
-#endif
-#ifndef PROCINFO_DECL
-= {
-    "i386", "i486", "i586", "i686"
-  }
-#endif
-#if !defined SHARED || defined PROCINFO_DECL
-;
-#else
-,
-#endif
-
-#undef PROCINFO_DECL
diff -Nur sysdeps/unix/sysv/linux/i386/dl-procinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-procinfo.h
--- sysdeps/unix/sysv/linux/i386/dl-procinfo.h	2002-09-24 02:00:49.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/dl-procinfo.h	2004-03-07 09:38:42.000000000 +0100
@@ -1,5 +1,5 @@
 /* Linux/i386 version of processor capability information handling macros.
-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -18,22 +18,11 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#ifndef _DL_PROCINFO_H
-#define _DL_PROCINFO_H	1
-
+#include <sysdeps/i386/dl-procinfo.h>
 #include <ldsodefs.h>
 
-#define _DL_HWCAP_COUNT 32
-
-#define _DL_PLATFORMS_COUNT	4
-
-/* Start at 48 to reserve some space.  */
-#define _DL_FIRST_PLATFORM	48
-/* Mask to filter out platforms.  */
-#define _DL_HWCAP_PLATFORM	(((1ULL << _DL_PLATFORMS_COUNT) - 1) \
-				 << _DL_FIRST_PLATFORM)
-
 
+#undef _dl_procinfo
 static inline int
 __attribute__ ((unused))
 _dl_procinfo (int word)
@@ -46,84 +35,9 @@
 
   for (i = 0; i < _DL_HWCAP_COUNT; ++i)
     if (word & (1 << i))
-      _dl_printf (" %s", GL(dl_x86_cap_flags)[i]);
+      _dl_printf (" %s", GLRO(dl_x86_cap_flags)[i]);
 
   _dl_printf ("\n");
 
   return 0;
 }
-
-static inline const char *
-__attribute__ ((unused))
-_dl_hwcap_string (int idx)
-{
-  return GL(dl_x86_cap_flags)[idx];
-};
-
-static inline const char *
-__attribute__ ((unused))
-_dl_platform_string (int idx)
-{
-  return GL(dl_x86_platforms)[idx - _DL_FIRST_PLATFORM];
-};
-
-enum
-{
-  HWCAP_I386_FPU   = 1 << 0,
-  HWCAP_I386_VME   = 1 << 1,
-  HWCAP_I386_DE    = 1 << 2,
-  HWCAP_I386_PSE   = 1 << 3,
-  HWCAP_I386_TSC   = 1 << 4,
-  HWCAP_I386_MSR   = 1 << 5,
-  HWCAP_I386_PAE   = 1 << 6,
-  HWCAP_I386_MCE   = 1 << 7,
-  HWCAP_I386_CX8   = 1 << 8,
-  HWCAP_I386_APIC  = 1 << 9,
-  HWCAP_I386_SEP   = 1 << 11,
-  HWCAP_I386_MTRR  = 1 << 12,
-  HWCAP_I386_PGE   = 1 << 13,
-  HWCAP_I386_MCA   = 1 << 14,
-  HWCAP_I386_CMOV  = 1 << 15,
-  HWCAP_I386_FCMOV = 1 << 16,
-  HWCAP_I386_MMX   = 1 << 23,
-  HWCAP_I386_OSFXSR = 1 << 24,
-  HWCAP_I386_XMM   = 1 << 25,
-  HWCAP_I386_XMM2  = 1 << 26,
-  HWCAP_I386_AMD3D = 1 << 31,
-
-  /* XXX Which others to add here?  */
-  HWCAP_IMPORTANT = (HWCAP_I386_MMX)
-
-};
-
-static inline int
-__attribute__ ((unused))
-_dl_string_hwcap (const char *str)
-{
-  int i;
-
-  for (i = 0; i < _DL_HWCAP_COUNT; i++)
-    {
-      if (strcmp (str, GL(dl_x86_cap_flags)[i]) == 0)
-	return i;
-    }
-  return -1;
-};
-
-
-static inline int
-__attribute__ ((unused))
-_dl_string_platform (const char *str)
-{
-  int i;
-
-  if (str != NULL)
-    for (i = 0; i < _DL_PLATFORMS_COUNT; ++i)
-      {
-	if (strcmp (str, GL(dl_x86_platforms)[i]) == 0)
-	  return _DL_FIRST_PLATFORM + i;
-      }
-  return -1;
-};
-
-#endif /* dl-procinfo.h */
diff -Nur sysdeps/unix/sysv/linux/i386/_exit.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/_exit.S
--- sysdeps/unix/sysv/linux/i386/_exit.S	2002-09-17 18:46:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/_exit.S	2002-12-20 08:04:18.000000000 +0100
@@ -27,11 +27,13 @@
 	/* Try the new syscall first.  */
 #ifdef __NR_exit_group
 	movl	$__NR_exit_group, %eax
-	int	$0x80
+	ENTER_KERNEL
 #endif
 
 	/* Not available.  Now the old one.  */
 	movl	$__NR_exit, %eax
+	/* Don't bother using ENTER_KERNEL here.  If the exit_group
+	   syscall is not available AT_SYSINFO isn't either.  */
 	int	$0x80
 
 	/* This must not fail.  Be sure we don't return.  */
diff -Nur sysdeps/unix/sysv/linux/i386/fchown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fchown.c
--- sysdeps/unix/sysv/linux/i386/fchown.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fchown.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,12 +25,7 @@
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
-extern int __syscall_fchown (int __fd,
-			     __kernel_uid_t __owner, __kernel_gid_t __group);
-
 #ifdef __NR_fchown32
-extern int __syscall_fchown32 (int __fd,
-			       __kernel_uid32_t __owner, __kernel_gid32_t __group);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
diff -Nur sysdeps/unix/sysv/linux/i386/fcntl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fcntl.c
--- sysdeps/unix/sysv/linux/i386/fcntl.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fcntl.c	2004-07-16 20:11:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,25 +18,25 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <sysdep-cancel.h>	/* Must come before <fcntl.h>.  */
 #include <fcntl.h>
 #include <stdarg.h>
 
-#include <sysdep.h>
 #include <sys/syscall.h>
 #include "../kernel-features.h"
 
-extern int __syscall_fcntl (int __fd, int __cmd, ...);
-#ifdef __NR_fcntl64
-extern int __syscall_fcntl64 (int __fd, int __cmd, ...);
-#endif
-
 #if __ASSUME_FCNTL64 == 0
 /* This variable is shared with all files that check for fcntl64.  */
 int __have_no_fcntl64;
 #endif
 
+#if defined NO_CANCELLATION && __ASSUME_FCNTL64 == 0
+# define __fcntl_nocancel  __libc_fcntl
+#endif
+
+#if !defined NO_CANCELLATION || __ASSUME_FCNTL64 == 0
 int
-__libc_fcntl (int fd, int cmd, ...)
+__fcntl_nocancel (int fd, int cmd, ...)
 {
   va_list ap;
   void *arg;
@@ -45,9 +45,7 @@
   arg = va_arg (ap, void *);
   va_end (ap);
 
-#if __ASSUME_FCNTL64 > 0
-  return INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
-#else
+#if __ASSUME_FCNTL64 == 0
 # ifdef __NR_fcntl64
   if (! __have_no_fcntl64)
     {
@@ -71,16 +69,15 @@
 	/* Check if we can represent the values with the smaller type.  */
 	if ((off64_t) fl.l_start != fl64->l_start)
 	  {
+	  eoverflow:
 	    __set_errno (EOVERFLOW);
 	    return -1;
 	  }
 	fl.l_len = (off_t) fl64->l_len;
 	/* Check if we can represent the values with the smaller type.  */
 	if ((off64_t) fl.l_len != fl64->l_len)
-	  {
-	    __set_errno (EOVERFLOW);
-	    return -1;
-	  }
+	  goto eoverflow;
+
 	fl.l_type = fl64->l_type;
 	fl.l_whence = fl64->l_whence;
 	fl.l_pid = fl64->l_pid;
@@ -107,10 +104,8 @@
 	fl.l_start = (off_t) fl64->l_start;
 	/* Check if we can represent the values with the smaller type.  */
 	if ((off64_t) fl.l_start != fl64->l_start)
-	  {
-	    __set_errno (EOVERFLOW);
-	    return -1;
-	  }
+	  goto eoverflow;
+
 	fl.l_len = (off_t)fl64->l_len;
 	/* Check if we can represent the values with the smaller type.  */
 	if ((off64_t) fl.l_len != fl64->l_len)
@@ -128,8 +123,45 @@
       return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
     }
   return -1;
-#endif  /* __ASSUME_FCNTL64  */
+#else
+  return INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
+#endif  /* !__ASSUME_FCNTL64  */
+}
+#endif /* NO_CANCELLATION || !__ASSUME_FCNTL64 */
+
+
+#ifndef __fcntl_nocancel
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+#if __ASSUME_FCNTL64 > 0
+  if (SINGLE_THREAD_P || (cmd != F_SETLKW && cmd != F_SETLKW64))
+    return INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
+#else
+  if (SINGLE_THREAD_P || (cmd != F_SETLKW && cmd != F_SETLKW64))
+    return __fcntl_nocancel (fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __fcntl_nocancel (fd, cmd, arg);
+#endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
+#endif
 libc_hidden_def (__libc_fcntl)
 
 weak_alias (__libc_fcntl, __fcntl)
diff -Nur sysdeps/unix/sysv/linux/i386/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fxstat.c
--- sysdeps/unix/sysv/linux/i386/fxstat.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/fxstat.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,5 +1,5 @@
 /* fxstat using old-style Unix fstat system call.
-   Copyright (C) 1991,95,96,97,98,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-1998,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,12 +32,9 @@
 
 #include "kernel-features.h"
 
-#include <xstatconv.c>
-
-extern int __syscall_fstat (int, struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 #ifdef __NR_stat64
-extern int __syscall_fstat64 (int, struct stat64 *__unbounded);
 # if  __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.  */
 extern int __have_no_stat64;
@@ -62,7 +59,7 @@
 
     result = INLINE_SYSCALL (fstat64, 2, fd, __ptrvalue (&buf64));
     if (result == 0)
-      result = xstat32_conv (vers, &buf64, buf);
+      result = __xstat32_conv (vers, &buf64, buf);
     return result;
   }
 #else
@@ -77,7 +74,7 @@
       result = INLINE_SYSCALL (fstat64, 2, fd, __ptrvalue (&buf64));
 
       if (result == 0)
-	result = xstat32_conv (vers, &buf64, buf);
+	result = __xstat32_conv (vers, &buf64, buf);
 
       if (result != -1 || errno != ENOSYS)
 	return result;
@@ -88,7 +85,7 @@
 
   result = INLINE_SYSCALL (fstat, 2, fd, __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif  /* __ASSUME_STAT64_SYSCALL  */
diff -Nur sysdeps/unix/sysv/linux/i386/getcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getcontext.S
--- sysdeps/unix/sysv/linux/i386/getcontext.S	2001-07-31 22:49:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getcontext.S	2003-06-24 11:01:25.000000000 +0200
@@ -1,5 +1,5 @@
 /* Save current context.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
 
@@ -56,6 +56,10 @@
 	movl	%ecx, oFPREGS(%eax)
 	/* Save the floating-point context.  */
 	fnstenv	(%ecx)
+	/* And load it right back since the processor changes the mask.
+	   Intel thought this opcode to be used in interrupt handlers which
+	   would block all exceptions.  */
+	fldenv	(%ecx)
 
 	/* Save the current signal mask.  */
 	pushl	%ebx
@@ -63,7 +67,7 @@
 	xorl	%ecx, %ecx
 	movl	$SIG_BLOCK, %ebx
 	movl	$__NR_sigprocmask, %eax
-	int	$0x80
+	ENTER_KERNEL
 	popl	%ebx
 	cmpl	$-4095, %eax		/* Check %eax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
diff -Nur sysdeps/unix/sysv/linux/i386/getegid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getegid.c
--- sysdeps/unix/sysv/linux/i386/getegid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getegid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,39 +23,38 @@
 #include <sys/syscall.h>
 #include "kernel-features.h"
 
-extern int __syscall_getegid (void);
-
 #ifdef __NR_getegid32
-extern int __syscall_getegid32 (void);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 # endif
 #endif /* __NR_getegid32 */
 
 gid_t
 __getegid (void)
 {
+  INTERNAL_SYSCALL_DECL (err);
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (getegid32, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getegid32, err, 0);
 #else
 # ifdef __NR_getegid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (getegid32, 0);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (getegid32, err, 0);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 # endif /* __NR_getegid32 */
 
-  return INLINE_SYSCALL (getegid, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getegid, err, 0);
 #endif
 }
 
diff -Nur sysdeps/unix/sysv/linux/i386/geteuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/geteuid.c
--- sysdeps/unix/sysv/linux/i386/geteuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/geteuid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,39 +23,38 @@
 #include <sys/syscall.h>
 #include "kernel-features.h"
 
-extern int __syscall_geteuid (void);
-
 #ifdef __NR_geteuid32
-extern int __syscall_geteuid32 (void);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 # endif
 #endif /* __NR_geteuid32 */
 
 uid_t
 __geteuid (void)
 {
+  INTERNAL_SYSCALL_DECL (err);
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (geteuid32, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (geteuid32, err, 0);
 #else
 # ifdef __NR_geteuid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (geteuid32, 0);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (geteuid32, err, 0);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 # endif /* __NR_geteuid32 */
 
-  return INLINE_SYSCALL (geteuid, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (geteuid, err, 0);
 #endif
 }
 
diff -Nur sysdeps/unix/sysv/linux/i386/getgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getgid.c
--- sysdeps/unix/sysv/linux/i386/getgid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getgid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,39 +24,38 @@
 
 #include "kernel-features.h"
 
-extern int __syscall_getgid (void);
-
 #ifdef __NR_getgid32
-extern int __syscall_getgid32 (void);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 # endif
 #endif /* __NR_getgid32 */
 
 gid_t
 __getgid (void)
 {
+  INTERNAL_SYSCALL_DECL (err);
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (getgid32, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getgid32, err, 0);
 #else
 # ifdef __NR_getgid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (getgid32, 0);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (getgid32, err, 0);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 # endif /* __NR_getgid32 */
 
-  return INLINE_SYSCALL (getgid, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getgid, err, 0);
 #endif
 }
 
diff -Nur sysdeps/unix/sysv/linux/i386/getgroups.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getgroups.c
--- sysdeps/unix/sysv/linux/i386/getgroups.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getgroups.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,14 +29,11 @@
 #include <kernel-features.h>
 
 
-extern int __syscall_getgroups (int, __kernel_gid_t *__unbounded);
-
 #ifdef __NR_getgroups32
-extern int __syscall_getgroups32 (int, __kernel_gid32_t *__unbounded);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 # endif
 #endif /* __NR_getgroups32 */
 
@@ -64,7 +61,7 @@
 	  int saved_errno = errno;
 
 	  result = INLINE_SYSCALL (getgroups32, 2, n, CHECK_N (groups, n));
-	  if (result == 0 || errno != ENOSYS)
+	  if (result != -1 || errno != ENOSYS)
 	    return result;
 
 	  __set_errno (saved_errno);
diff -Nur sysdeps/unix/sysv/linux/i386/getmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getmsg.c
--- sysdeps/unix/sysv/linux/i386/getmsg.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getmsg.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,9 +23,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_getpmsg (int fildes, struct strbuf *ctlptr,
-			      struct strbuf *dataptr, int *bandp, int *flagsp);
-
 #ifdef __NR_getpmsg
 int
 getmsg (fildes, ctlptr, dataptr, flagsp)
diff -Nur sysdeps/unix/sysv/linux/i386/getpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getpmsg.c
--- sysdeps/unix/sysv/linux/i386/getpmsg.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <stropts.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-extern int __syscall_getpmsg (int fildes, struct strbuf *ctlptr,
-			      struct strbuf *dataptr, int *bandp, int *flagsp);
-
-#ifdef __NR_getpmsg
-int
-getpmsg (fildes, ctlptr, dataptr, bandp, flagsp)
-     int fildes;
-     struct strbuf *ctlptr;
-     struct strbuf *dataptr;
-     int *bandp;
-     int *flagsp;
-{
-  return INLINE_SYSCALL (getpmsg, 5, fildes, ctlptr, dataptr, bandp, flagsp);
-}
-#else
-# include <sysdeps/generic/getpmsg.c>
-#endif
diff -Nur sysdeps/unix/sysv/linux/i386/getresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getresgid.c
--- sysdeps/unix/sysv/linux/i386/getresgid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getresgid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,15 +30,7 @@
 
 #ifdef __NR_getresgid
 
-extern int __syscall_getresgid (__kernel_gid_t *__unbounded rgid,
-				__kernel_gid_t *__unbounded egid,
-				__kernel_gid_t *__unbounded sgid);
-
 # ifdef __NR_getresgid32
-extern int __syscall_getresgid32 (__kernel_gid32_t *__unbounded rgid,
-				  __kernel_gid32_t *__unbounded egid,
-				  __kernel_gid32_t *__unbounded sgid);
-
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -48,7 +40,7 @@
 
 
 int
-getresgid (gid_t *rgid, gid_t *egid, gid_t *sgid)
+__getresgid (gid_t *rgid, gid_t *egid, gid_t *sgid)
 {
 # if __ASSUME_32BITUIDS > 0
   return INLINE_SYSCALL (getresgid32, 3, CHECK_1 (rgid),
@@ -85,6 +77,9 @@
   return result;
 # endif
 }
+libc_hidden_def (__getresgid)
+weak_alias (__getresgid, getresgid)
+
 #else
 # include <sysdeps/generic/getresgid.c>
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/getresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getresuid.c
--- sysdeps/unix/sysv/linux/i386/getresuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getresuid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,14 +30,7 @@
 
 #ifdef __NR_getresuid
 
-extern int __syscall_getresuid (__kernel_uid_t *__unbounded ruid,
-				__kernel_uid_t *__unbounded euid,
-				__kernel_uid_t *__unbounded suid);
-
 # ifdef __NR_getresuid32
-extern int __syscall_getresuid32 (__kernel_uid32_t *__unbounded ruid,
-				  __kernel_uid32_t *__unbounded euid,
-				  __kernel_uid32_t *__unbounded suid);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -46,7 +39,7 @@
 # endif /* __NR_getresuid32 */
 
 int
-getresuid (uid_t *ruid, uid_t *euid, uid_t *suid)
+__getresuid (uid_t *ruid, uid_t *euid, uid_t *suid)
 {
 # if __ASSUME_32BITUIDS > 0
   return INLINE_SYSCALL (getresuid32, 3, CHECK_1 (ruid),
@@ -83,6 +76,9 @@
   return result;
 # endif
 }
+libc_hidden_def (__getresuid)
+weak_alias (__getresuid, getresuid)
+
 #else
 # include <sysdeps/generic/getresuid.c>
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/getrlimit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getrlimit.c
--- sysdeps/unix/sysv/linux/i386/getrlimit.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getrlimit.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,11 +26,6 @@
 
 #include "kernel-features.h"
 
-extern int __syscall_ugetrlimit (unsigned int resource,
-				 struct rlimit *__unbounded rlimits);
-extern int __syscall_getrlimit (unsigned int resource,
-				struct rlimit *__unbounded rlimits);
-
 extern int __new_getrlimit (enum __rlimit_resource resource,
 			    struct rlimit *__unbounded rlimits);
 
diff -Nur sysdeps/unix/sysv/linux/i386/getuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getuid.c
--- sysdeps/unix/sysv/linux/i386/getuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/getuid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,42 +24,41 @@
 
 #include "kernel-features.h"
 
-extern int __syscall_getuid (void);
-
 #ifdef __NR_getuid32
-extern int __syscall_getuid32 (void);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  This is the definition.
    -1 if libc does not know yet whether kernel has 32bit uids or not.
    0 if it does have them.
    1 if it does not have them.  */
-int __libc_missing_32bit_uids = -1;
+int __libc_missing_32bit_uids attribute_hidden = -1;
 # endif
 #endif /* __NR_getuid32 */
 
 uid_t
 __getuid (void)
 {
+  INTERNAL_SYSCALL_DECL (err);
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (getuid32, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getuid32, err, 0);
 #else
 # ifdef __NR_getuid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (getuid32, 0);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (getuid32, err, 0);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 # endif /* __NR_getuid32 */
 
-  return INLINE_SYSCALL (getuid, 0);
+  /* No error checking.  */
+  return INTERNAL_SYSCALL (getuid, err, 0);
 #endif
 }
 
diff -Nur sysdeps/unix/sysv/linux/i386/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/glob64.c
--- sysdeps/unix/sysv/linux/i386/glob64.c	2002-08-05 02:30:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/glob64.c	2004-07-05 01:08:04.000000000 +0200
@@ -26,6 +26,7 @@
 libc_hidden_def (globfree64)
 
 versioned_symbol (libc, __glob64, glob64, GLIBC_2_2);
+libc_hidden_ver (__glob64, glob64)
 
 #if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
 
@@ -43,6 +44,7 @@
 #define glob(pattern, flags, errfunc, pglob) \
   __old_glob64 (pattern, flags, errfunc, pglob)
 #define glob_in_dir __old_glob_in_dir
+#define GLOB_ATTRIBUTE attribute_compat_text_section
 
 #define GLOB_ONLY_P 1
 
diff -Nur sysdeps/unix/sysv/linux/i386/lchown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lchown.c
--- sysdeps/unix/sysv/linux/i386/lchown.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lchown.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -27,12 +27,7 @@
 #include "kernel-features.h"
 
 #ifdef __NR_lchown
-extern int __syscall_lchown (const char *__unbounded __file,
-			     __kernel_uid_t __owner, __kernel_gid_t __group);
-
 # ifdef __NR_lchown32
-extern int __syscall_lchown32 (const char *__unbounded __file,
-			       __kernel_uid32_t __owner, __kernel_gid32_t __group);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
diff -Nur sysdeps/unix/sysv/linux/i386/lockf64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lockf64.c
--- sysdeps/unix/sysv/linux/i386/lockf64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lockf64.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,8 +29,6 @@
 /* lockf is a simplified interface to fcntl's locking facilities.  */
 
 #ifdef __NR_fcntl64
-extern int __syscall_fcntl64 (int __fd, int __cmd, ...);
-
 # if __ASSUME_FCNTL64 == 0
 /* This variable is shared with all files that check for fcntl64. The
    declaration is in fcntl.c.  */
diff -Nur sysdeps/unix/sysv/linux/i386/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lxstat.c
--- sysdeps/unix/sysv/linux/i386/lxstat.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/lxstat.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,5 +1,6 @@
 /* lxstat using old-style Unix lstat system call.
-   Copyright (C) 1991,95,96,97,98,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1995, 1996, 1997, 1998, 2000, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,14 +33,9 @@
 
 #include "kernel-features.h"
 
-#include <xstatconv.c>
-
-extern int __syscall_lstat (const char *__unbounded,
-			    struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 #ifdef __NR_stat64
-extern int __syscall_lstat64 (const char *__unbounded,
-			      struct stat64 *__unbounded);
 # if  __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.  */
 extern int __have_no_stat64;
@@ -65,7 +61,7 @@
 
     result = INLINE_SYSCALL (lstat64, 2, CHECK_STRING (name), __ptrvalue (&buf64));
     if (result == 0)
-      result = xstat32_conv (vers, &buf64, buf);
+      result = __xstat32_conv (vers, &buf64, buf);
     return result;
   }
 #else
@@ -79,7 +75,7 @@
       result = INLINE_SYSCALL (lstat64, 2, CHECK_STRING (name), __ptrvalue (&buf64));
 
       if (result == 0)
-	result = xstat32_conv (vers, &buf64, buf);
+	result = __xstat32_conv (vers, &buf64, buf);
 
       if (result != -1 || errno != ENOSYS)
 	return result;
@@ -90,7 +86,7 @@
 
   result = INLINE_SYSCALL (lstat, 2, CHECK_STRING (name), __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Makefile
--- sysdeps/unix/sysv/linux/i386/Makefile	2002-03-29 00:41:51.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Makefile	2003-08-17 02:35:31.000000000 +0200
@@ -1,5 +1,5 @@
 ifeq ($(subdir),misc)
-sysdep_routines += ioperm iopl vm86 setfsgid setfsuid setresgid setresuid
+sysdep_routines += ioperm iopl vm86
 sysdep_headers += sys/elf.h sys/perm.h sys/reg.h sys/vm86.h sys/debugreg.h sys/io.h
 endif
 
diff -Nur sysdeps/unix/sysv/linux/i386/mmap64.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/mmap64.S
--- sysdeps/unix/sysv/linux/i386/mmap64.S	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/mmap64.S	2002-12-18 12:55:22.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995,96,97,98,99,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -65,7 +65,7 @@
 
 	/* Do the system call trap.  */
 L(do_syscall):
-	int $0x80
+	ENTER_KERNEL
 
 	/* Restore registers.  */
 	popl %edi
@@ -110,7 +110,7 @@
 	lea ADDR-SVRSP(%esp), %ebx	/* Address of args is 1st arg.  */
 
 	/* Do the system call trap.  */
-	int $0x80
+	ENTER_KERNEL
 
 	/* Restore registers.  */
 	movl %edx, %ebx
diff -Nur sysdeps/unix/sysv/linux/i386/mmap.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/mmap.S
--- sysdeps/unix/sysv/linux/i386/mmap.S	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/mmap.S	2002-12-18 12:55:22.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995,96,97,98,99,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -50,7 +50,7 @@
 	movl $SYS_ify(mmap2), %eax	/* System call number in %eax.  */
 
 	/* Do the system call trap.  */
-	int $0x80
+	ENTER_KERNEL
 L(skip):
 	/* Restore registers.  */
 	popl %edi
diff -Nur sysdeps/unix/sysv/linux/i386/msgctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/msgctl.c
--- sysdeps/unix/sysv/linux/i386/msgctl.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/msgctl.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -63,6 +63,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_msgctl (int msqid, int cmd, struct __old_msqid_ds *buf)
 {
   return INLINE_SYSCALL (ipc, 5, IPCOP_msgctl,
diff -Nur sysdeps/unix/sysv/linux/i386/oldgetrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/oldgetrlimit64.c
--- sysdeps/unix/sysv/linux/i386/oldgetrlimit64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/oldgetrlimit64.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1995-1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1995-1999, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,6 +33,7 @@
 /* Put the soft and hard limits for RESOURCE in *RLIMITS.
    Returns 0 if successful, -1 if not (and sets errno).  */
 int
+attribute_compat_text_section
 __old_getrlimit64 (enum __rlimit_resource resource, struct rlimit64 *rlimits)
 {
   struct rlimit rlimits32;
diff -Nur sysdeps/unix/sysv/linux/i386/posix_fadvise64.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/posix_fadvise64.S
--- sysdeps/unix/sysv/linux/i386/posix_fadvise64.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/posix_fadvise64.S	2004-03-10 10:28:24.000000000 +0100
@@ -0,0 +1,133 @@
+/* Copyright (C) 1995-2000,2002,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+
+#include "kernel-features.h"
+
+#define EINVAL	22
+#define ENOSYS	38
+#define EOVERFLOW 75
+
+#define SVRSP	16		/* saved register space */
+#define PARMS	LINKAGE+SVRSP	/* space for 4 saved regs */
+#define FD	PARMS
+#define OFFLO	FD+4
+#define OFFHI	OFFLO+4
+#define LENLO	OFFHI+4
+#define LENHI	LENLO+4
+#define FLAGS	LENHI+4
+
+	.text
+ENTRY (BP_SYM (__posix_fadvise64_l64))
+
+#ifdef __NR_fadvise64_64
+
+	/* Save registers.  */
+	pushl	%ebp
+	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
+
+	movl	FD(%esp), %ebx
+	movl	OFFLO(%esp), %ecx
+	movl	OFFHI(%esp), %edx
+	movl	LENLO(%esp), %esi
+	movl	LENHI(%esp), %edi
+	movl	FLAGS(%esp), %ebp
+
+	movl	$SYS_ify(fadvise64_64), %eax
+	ENTER_KERNEL
+
+	/* Restore registers.  */
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+
+#ifndef __ASSUME_FADVISE64_64_SYSCALL
+	cmpl	$-ENOSYS, %eax
+	je	1f
+#endif
+
+	/* The function returns zero, or the error number.  So all we
+	   have to do is negate the value passed back from the kernel.  */
+	/* If 0 > %eax > -4096 there was an error.  */
+	negl	%eax
+
+	/* Successful; return the syscall's value.  */
+	ret
+#endif
+
+#if defined __NR_fadvise64 \
+    && (!defined __ASSUME_FADVISE64_64_SYSCALL || !defined __NR_fadvise64_64)
+1:	/* Save registers.  */
+	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
+
+	/* Overflow check.  */
+	cmpl	$0, LENHI(%esp)
+	movl	$-EOVERFLOW, %eax
+	jne	L(overflow)
+
+	movl	FD(%esp), %ebx
+	movl	OFFLO(%esp), %ecx
+	movl	OFFHI(%esp), %edx
+	movl	LENLO(%esp), %esi
+	movl	FLAGS(%esp), %edi
+
+	movl	$SYS_ify(fadvise64), %eax
+	ENTER_KERNEL
+
+	/* Restore registers.  */
+L(overflow):
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+
+	/* If 0 > %eax > -4096 there was an error.  */
+	negl	%eax
+
+	/* Successful; return the syscall's value.  */
+	ret
+#else
+	movl	$ENOSYS, %eax
+	ret
+#endif
+
+END (BP_SYM (__posix_fadvise64_l64))
+
+#ifdef __NR_fadvise64
+	.section	.text.compat, "ax"
+ENTRY (__posix_fadvise64_l32)
+	DO_CALL (fadvise64, 5)
+	negl %eax
+	ret
+PSEUDO_END_ERRVAL (__posix_fadvise64_l32)
+#else
+ENTRY (BP_SYM (__posix_fadvise64_l32))
+	movl	$ENOSYS, %eax
+	ret
+END (BP_SYM (__posix_fadvise64_l32))
+#endif
+
+default_symbol_version (__posix_fadvise64_l64, posix_fadvise64, GLIBC_2.3.3)
+symbol_version (__posix_fadvise64_l32, posix_fadvise64, GLIBC_2.2)
diff -Nur sysdeps/unix/sysv/linux/i386/profil-counter.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/profil-counter.h
--- sysdeps/unix/sysv/linux/i386/profil-counter.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/profil-counter.h	2002-10-11 20:56:32.000000000 +0200
@@ -1,5 +1,5 @@
 /* Low-level statistical profiling support function.  Linux/i386 version.
-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,7 +21,12 @@
 #include <sigcontextinfo.h>
 
 static void
-profil_counter (int signo, SIGCONTEXT scp)
+profil_counter (int signo, const SIGCONTEXT scp)
 {
   profil_count ((void *) GET_PC (scp));
+
+  /* This is a hack to prevent the compiler from implementing the
+     above function call as a sibcall.  The sibcall would overwrite
+     the signal context.  */
+  asm volatile ("");
 }
diff -Nur sysdeps/unix/sysv/linux/i386/putmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/putmsg.c
--- sysdeps/unix/sysv/linux/i386/putmsg.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/putmsg.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,10 +23,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_putpmsg (int fildes, const struct strbuf *ctlptr,
-			      const struct strbuf *dataptr, int band,
-			      int flags);
-
 #ifdef __NR_putpmsg
 int
 putmsg (fildes, ctlptr, dataptr, flags)
diff -Nur sysdeps/unix/sysv/linux/i386/putpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/putpmsg.c
--- sysdeps/unix/sysv/linux/i386/putpmsg.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/putpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <stropts.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-extern int __syscall_putpmsg (int fildes, const struct strbuf *ctlptr,
-			      const struct strbuf *dataptr, int band,
-			      int flags);
-
-#ifdef __NR_putpmsg
-int
-putpmsg (fildes, ctlptr, dataptr, band, flags)
-     int fildes;
-     const struct strbuf *ctlptr;
-     const struct strbuf *dataptr;
-     int band;
-     int flags;
-{
-  return INLINE_SYSCALL (putpmsg, 5, fildes, ctlptr, dataptr, band, flags);
-}
-#else
-# include <sysdeps/generic/putpmsg.c>
-#endif
diff -Nur sysdeps/unix/sysv/linux/i386/readdir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/readdir64.c
--- sysdeps/unix/sysv/linux/i386/readdir64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/readdir64.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,7 +34,7 @@
 
 #include <sysdeps/unix/sysv/linux/i386/olddirent.h>
 
-#define __READDIR __old_readdir64
+#define __READDIR attribute_compat_text_section __old_readdir64
 #define __GETDENTS __old_getdents64
 #define DIRENT_TYPE struct __old_dirent64
 
diff -Nur sysdeps/unix/sysv/linux/i386/readdir64_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/readdir64_r.c
--- sysdeps/unix/sysv/linux/i386/readdir64_r.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/readdir64_r.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,7 +34,7 @@
 
 #include <sysdeps/unix/sysv/linux/i386/olddirent.h>
 
-#define __READDIR_R __old_readdir64_r
+#define __READDIR_R attribute_compat_text_section __old_readdir64_r
 #define __GETDENTS __old_getdents64
 #define DIRENT_TYPE struct __old_dirent64
 
diff -Nur sysdeps/unix/sysv/linux/i386/scandir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/scandir64.c
--- sysdeps/unix/sysv/linux/i386/scandir64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/scandir64.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,7 +36,7 @@
 
 #include <sysdeps/unix/sysv/linux/i386/olddirent.h>
 
-#define SCANDIR __old_scandir64
+#define SCANDIR attribute_compat_text_section __old_scandir64
 #define READDIR __old_readdir64
 #define DIRENT_TYPE struct __old_dirent64
 
diff -Nur sysdeps/unix/sysv/linux/i386/semctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/semctl.c
--- sysdeps/unix/sysv/linux/i386/semctl.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/semctl.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1997,1998,2000,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -48,6 +48,7 @@
   struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
   unsigned short int *array;	/* array for GETALL & SETALL */
   struct seminfo *__buf;	/* buffer for IPC_INFO */
+  struct __old_semid_ds *__old_buf;
 };
 
 #include <bp-checks.h>
@@ -70,6 +71,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_semctl (int semid, int semnum, int cmd, ...)
 {
   union semun arg;
@@ -145,7 +147,7 @@
 #endif
 
     buf = arg.buf;
-    arg.buf = (struct semid_ds *)&old;
+    arg.__old_buf = &old;
     if (cmd == IPC_SET)
       {
 	old.sem_perm.uid = buf->sem_perm.uid;
diff -Nur sysdeps/unix/sysv/linux/i386/semtimedop.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/semtimedop.S
--- sysdeps/unix/sysv/linux/i386/semtimedop.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/semtimedop.S	2003-04-03 01:46:19.000000000 +0200
@@ -0,0 +1,63 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#define SYSOP_semtimedop 4
+
+#define SVRSP	12		/* saved register space */
+#define PARMS	LINKAGE+SVRSP	/* space for 3 saved regs */
+#define SEMID	PARMS
+#define SOPS	SEMID+4
+#define NSOPS	SOPS+PTR_SIZE
+#define TIMEOUT	NSOPS+4
+
+	.text
+ENTRY (BP_SYM (semtimedop))
+
+	pushl	%ebp
+	pushl	%ebx
+	pushl	%edi
+
+	movl	$SYSOP_semtimedop, %ebx
+	movl	SEMID(%esp), %ecx
+	movl	NSOPS(%esp), %edx
+	movl	SOPS(%esp), %edi
+	movl	TIMEOUT(%esp), %ebp
+	movl	$__NR_ipc, %eax
+
+	ENTER_KERNEL
+
+	/* Restore registers.  */
+	popl	%edi
+	popl	%ebx
+	popl	%ebp
+
+	/* If 0 > %eax > -4096 there was an error.  */
+	cmpl $-4096, %eax
+	ja SYSCALL_ERROR_LABEL
+
+	/* Successful; return the syscall's value.  */
+L(pseudo_end):
+	ret
+
+#ifdef PIC
+	.align	4
+#endif
+PSEUDO_END (BP_SYM (semtimedop))
diff -Nur sysdeps/unix/sysv/linux/i386/setcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setcontext.S
--- sysdeps/unix/sysv/linux/i386/setcontext.S	2001-07-31 22:48:09.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setcontext.S	2003-04-06 00:02:22.000000000 +0200
@@ -1,5 +1,5 @@
 /* Install given context.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
 
@@ -35,7 +35,7 @@
 	leal	oSIGMASK(%eax), %ecx
 	movl	$SIG_SETMASK, %ebx
 	movl	$__NR_sigprocmask, %eax
-	int	$0x80
+	ENTER_KERNEL
 	popl	%ebx
 	cmpl	$-4095, %eax		/* Check %eax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
@@ -53,39 +53,26 @@
 	movl	oFS(%eax), %ecx
 	movw	%cx, %fs
 
+	/* Fetch the address to return to.  */
+	movl	oEIP(%eax), %ecx
+
 	/* Load the new stack pointer.  */
-	movl	oESP(%eax), %ecx
-	/* Make room for 8 registers and the return address.  We will load
-	   the values from the stack.  */
-	subl	$36, %ecx
-
-	/* Move the values of all the 32-bit registers (except ESP) on
-	   the stack.  This happens in the form the 'popa' instruction
-	   expects it.  Before this block put the address of the code
-	   to execute.  */
-	movl	oEDI(%eax), %ebx
-	movl	oESI(%eax), %edx
-	movl	oEBP(%eax), %esi
-	movl	oEBX(%eax), %edi
-	movl	%ebx, (%ecx)
-	movl	%edx, 4(%ecx)
-	movl	%esi, 8(%ecx)
-	movl	%edi, 16(%ecx)
-	movl	oEDX(%eax), %ebx
-	movl	oECX(%eax), %edx
-	movl	oEAX(%eax), %esi
-	movl	oEIP(%eax), %edi
-	movl	%ebx, 20(%ecx)
-	movl	%edx, 24(%ecx)
-	movl	%esi, 28(%ecx)
-	movl	%edi, 32(%ecx)
-
-	/* Set the new stack address.  The stack points now to the block
-	   we put the register content in.  */
-	movl	%ecx, %esp
-	/* Restore the register content.  */
-	popa
-	/* The following 'ret' will pop the addres of the code and jump
+	movl	oESP(%eax), %esp
+
+	/* Push the return address on the new stack so we can return there.  */
+	pushl	%ecx
+
+	/* Load the values of all the 32-bit registers (except ESP).
+	   Since we are loading from EAX, it must be last.  */
+	movl	oEDI(%eax), %edi
+	movl	oESI(%eax), %esi
+	movl	oEBP(%eax), %ebp
+	movl	oEBX(%eax), %ebx
+	movl	oEDX(%eax), %edx
+	movl	oECX(%eax), %ecx
+	movl	oEAX(%eax), %eax
+
+	/* The following 'ret' will pop the address of the code and jump
 	   to it.  */
 
 L(pseudo_end):
diff -Nur sysdeps/unix/sysv/linux/i386/setegid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setegid.c
--- sysdeps/unix/sysv/linux/i386/setegid.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setegid.c	2004-11-12 02:15:06.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 96, 97, 98, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995-1998,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,13 +16,46 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
 #include <unistd.h>
-#include <sys/types.h>
+#include <setxid.h>
+#include "kernel-features.h"
+
+
+#ifdef __NR_setresgid
+extern int __setresgid (uid_t rgid, uid_t egid, uid_t sgid);
+#endif
 
 int
 setegid (gid)
      gid_t gid;
 {
-  return __setregid (-1, gid);
+  int result;
+
+  if (gid == (gid_t) ~0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+#if __ASSUME_32BITUIDS > 0
+  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);
+#else
+  /* First try the syscall.  */
+# ifdef __NR_setresgid
+  result = __setresgid (-1, gid, -1);
+#  if __ASSUME_SETRESGID_SYSCALL > 0
+  if (0)
+#  else
+  if (result == -1 && errno == ENOSYS)
+#  endif
+    /* No system call available.  Use emulation.  This may not work
+       since `setregid' also sets the saved user ID when GID is not
+       equal to the real user ID, making it impossible to switch back.  */
+# endif
+    result = __setregid (-1, gid);
+#endif
+
+  return result;
 }
 libc_hidden_def (setegid)
diff -Nur sysdeps/unix/sysv/linux/i386/seteuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/seteuid.c
--- sysdeps/unix/sysv/linux/i386/seteuid.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/seteuid.c	2004-11-12 02:15:06.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,9 +17,9 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
 #include <unistd.h>
+#include <setxid.h>
+#include "kernel-features.h"
 
 
 #ifdef __NR_setresuid
@@ -30,19 +30,30 @@
 seteuid (uid_t uid)
 {
   int result;
+
+  if (uid == (uid_t) ~0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+#if __ASSUME_32BITUIDS > 0
+  result = INLINE_SETXID_SYSCALL (setresuid32, 3, -1, uid, -1);
+#else
   /* First try the syscall.  */
-#ifdef __NR_setresuid
+# ifdef __NR_setresuid
   result = __setresuid (-1, uid, -1);
-#if __ASSUME_SETRESUID_SYSCALL > 0
+#  if __ASSUME_SETRESUID_SYSCALL > 0
   if (0)
-#else
+#  else
   if (result == -1 && errno == ENOSYS)
-#endif
+#  endif
     /* No system call available.  Use emulation.  This may not work
        since `setreuid' also sets the saved user ID when UID is not
        equal to the real user ID, making it impossible to switch back.  */
-#endif
+# endif
     result = __setreuid (-1, uid);
+#endif
 
   return result;
 }
diff -Nur sysdeps/unix/sysv/linux/i386/setfsgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setfsgid.c
--- sysdeps/unix/sysv/linux/i386/setfsgid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setfsgid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,34 +28,32 @@
 
 #ifdef __NR_setfsgid
 
-extern int __syscall_setfsgid (__kernel_gid_t);
-
 # ifdef __NR_setfsgid32
-extern int __syscall_setfsgid32 (__kernel_gid32_t);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 #  endif
 # endif /* __NR_setfsgid32 */
 
 int
 setfsgid (gid_t gid)
 {
+  INTERNAL_SYSCALL_DECL (err);
 # if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setfsgid32, 1, gid);
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsgid32, err, 1, gid);
 # else
 #  ifdef __NR_setfsgid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setfsgid32, 1, gid);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (setfsgid32, err, 1, gid);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 #  endif /* __NR_setfsgid32 */
@@ -65,7 +63,8 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setfsgid, 1, gid);
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsgid, err, 1, gid);
 # endif
 }
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/setfsuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setfsuid.c
--- sysdeps/unix/sysv/linux/i386/setfsuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setfsuid.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,34 +28,32 @@
 
 #ifdef __NR_setfsuid
 
-extern int __syscall_setfsuid (__kernel_uid_t);
-
 # ifdef __NR_setfsuid32
-extern int __syscall_setfsuid32 (__kernel_uid32_t);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
-extern int __libc_missing_32bit_uids;
+extern int __libc_missing_32bit_uids attribute_hidden;
 #  endif
 # endif /* __NR_setfsuid32 */
 
 int
 setfsuid (uid_t uid)
 {
+  INTERNAL_SYSCALL_DECL (err);
 # if  __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setfsuid32, 1, uid);
-# else  
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsuid32, err, 1, uid);
+# else
 #  ifdef __NR_setfsuid32
   if (__libc_missing_32bit_uids <= 0)
     {
       int result;
-      int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setfsuid32, 1, uid);
-      if (result == 0 || errno != ENOSYS)
+      result = INTERNAL_SYSCALL (setfsuid32, err, 1, uid);
+      if (! INTERNAL_SYSCALL_ERROR_P (result, err)
+	  || INTERNAL_SYSCALL_ERRNO (result, err) != ENOSYS)
 	return result;
 
-      __set_errno (saved_errno);
       __libc_missing_32bit_uids = 1;
     }
 #  endif /* __NR_setfsuid32 */
@@ -66,7 +64,8 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setfsuid, 1, uid);
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsuid, err, 1, uid);
 # endif
 }
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/setgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setgid.c
--- sysdeps/unix/sysv/linux/i386/setgid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setgid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,19 +18,12 @@
 
 #include <errno.h>
 #include <unistd.h>
-#include <sys/types.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
-
 #include "kernel-features.h"
 
-extern int __syscall_setgid (__kernel_gid_t);
 
 #ifdef __NR_setgid32
-extern int __syscall_setgid32 (__kernel_gid32_t);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -41,18 +34,21 @@
 int
 __setgid (gid_t gid)
 {
+  int result;
+
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setgid32, 1, gid);
+  result = INLINE_SETXID_SYSCALL (setgid32, 1, gid);
 #else
 # ifdef __NR_setgid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setgid32, 1, gid);
+      result = INLINE_SETXID_SYSCALL (setgid32, 1, gid);
 
-      if (result == 0 || errno != ENOSYS)
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -67,7 +63,14 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setgid, 1, gid);
+  result = INLINE_SETXID_SYSCALL (setgid, 1, gid);
+# ifdef __NR_setgid32
+ out:
+# endif
 #endif
+
+  return result;
 }
+#ifndef __setgid
 weak_alias (__setgid, setgid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/setgroups.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setgroups.c
--- sysdeps/unix/sysv/linux/i386/setgroups.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setgroups.c	2004-03-31 01:14:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997,98,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,10 +29,7 @@
 #include "kernel-features.h"
 
 
-extern int __syscall_setgroups (int, const __kernel_gid_t *__unbounded);
-
 #ifdef __NR_setgroups32
-extern int __syscall_setgroups32 (int, const __kernel_gid32_t *__unbounded);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -46,6 +43,9 @@
 int
 setgroups (size_t n, const gid_t *groups)
 {
+#if __ASSUME_32BITUIDS > 0
+  return INLINE_SYSCALL (setgroups32, 2, n, CHECK_N (groups, n));
+#else
   if (n > (size_t) __sysconf (_SC_NGROUPS_MAX))
     {
       __set_errno (EINVAL);
@@ -53,9 +53,6 @@
     }
   else
     {
-#if __ASSUME_32BITUIDS > 0
-      return INLINE_SYSCALL (setgroups32, 2, n, CHECK_N (groups, n));
-#else
       size_t i;
       __kernel_gid_t kernel_groups[n];
 
@@ -84,7 +81,7 @@
 	}
 
       return INLINE_SYSCALL (setgroups, 2, n, CHECK_N (kernel_groups, n));
-#endif
     }
+#endif
 }
 libc_hidden_def (setgroups)
diff -Nur sysdeps/unix/sysv/linux/i386/setregid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setregid.c
--- sysdeps/unix/sysv/linux/i386/setregid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setregid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,20 +17,13 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/types.h>
 #include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
 
-extern int __syscall_setregid (__kernel_gid_t, __kernel_gid_t);
-
 #ifdef __NR_setregid32
-extern int __syscall_setregid32 (__kernel_gid32_t, __kernel_gid32_t);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -41,18 +34,21 @@
 int
 __setregid (gid_t rgid, gid_t egid)
 {
+  int result;
+
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setregid32, 2, rgid, egid);
+  result = INLINE_SETXID_SYSCALL (setregid32, 2, rgid, egid);
 #else
 # ifdef __NR_setregid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setregid32, 2, rgid, egid);
+      result = INLINE_SETXID_SYSCALL (setregid32, 2, rgid, egid);
 
-      if (result == 0 || errno != ENOSYS)
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -66,7 +62,14 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setregid, 2, rgid, egid);
+  result = INLINE_SETXID_SYSCALL (setregid, 2, rgid, egid);
+# ifdef __NR_setregid32
+ out:
+# endif
 #endif
+
+  return result;
 }
+#ifndef __setregid
 weak_alias (__setregid, setregid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/setresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setresgid.c
--- sysdeps/unix/sysv/linux/i386/setresgid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setresgid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,22 +18,14 @@
 
 #include <errno.h>
 #include <unistd.h>
-#include <sys/types.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
 #include "kernel-features.h"
 
-#ifdef __NR_setresgid
 
-extern int __syscall_setresgid (__kernel_gid_t rgid, __kernel_gid_t egid,
-				__kernel_gid_t sgid);
+#if defined __NR_setresgid || defined __NR_setresgid32
 
 # ifdef __NR_setresgid32
-extern int __syscall_setresgid32 (__kernel_gid32_t rgid, __kernel_gid32_t egid,
-				  __kernel_gid32_t sgid);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -41,22 +33,23 @@
 #  endif
 # endif /* __NR_setresgid32 */
 
-extern int setresgid (gid_t rgid, gid_t egid, gid_t sgid);
-
 int
-setresgid (gid_t rgid, gid_t egid, gid_t sgid)
+__setresgid (gid_t rgid, gid_t egid, gid_t sgid)
 {
-# if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setresgid32, 3, rgid, egid, sgid);
+  int result;
+
+# if __ASSUME_32BITUIDS > 0 || !defined __NR_setresgid
+  result = INLINE_SETXID_SYSCALL (setresgid32, 3, rgid, egid, sgid);
 # else
 #  ifdef __NR_setresgid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setresgid32, 3, rgid, egid, sgid);
-      if (result == 0 || errno != ENOSYS)
+      result = INLINE_SETXID_SYSCALL (setresgid32, 3, rgid, egid, sgid);
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -72,7 +65,21 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setresgid, 3, rgid, egid, sgid);
+  result = INLINE_SETXID_SYSCALL (setresgid, 3, rgid, egid, sgid);
+#  ifdef __NR_setresgid32
+ out:
+#  endif
 # endif
+
+  return result;
 }
+libc_hidden_def (__setresgid)
+#ifndef __setresgid
+weak_alias (__setresgid, setresgid)
+#endif
+
+#else
+
+#include <sysdeps/generic/setresgid.c>
+
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/setresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setresuid.c
--- sysdeps/unix/sysv/linux/i386/setresuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setresuid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,22 +18,14 @@
 
 #include <errno.h>
 #include <unistd.h>
-#include <sys/types.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
 #include "kernel-features.h"
 
-#ifdef __NR_setresuid
 
-extern int __syscall_setresuid (__kernel_uid_t rgid, __kernel_uid_t egid,
-				__kernel_uid_t sgid);
+#if defined __NR_setresuid || defined __NR_setresuid32
 
 # ifdef __NR_setresuid32
-extern int __syscall_setresuid32 (__kernel_uid32_t rgid, __kernel_uid32_t egid,
-				  __kernel_uid32_t sgid);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -41,22 +33,23 @@
 #  endif
 # endif /* __NR_setresuid32 */
 
-extern int __setresuid (uid_t ruid, uid_t euid, uid_t suid);
-
 int
 __setresuid (uid_t ruid, uid_t euid, uid_t suid)
 {
-# if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setresuid32, 3, ruid, euid, suid);
+  int result;
+
+# if __ASSUME_32BITUIDS > 0 || !defined __NR_setresuid
+  result = INLINE_SETXID_SYSCALL (setresuid32, 3, ruid, euid, suid);
 # else
 #  ifdef __NR_setresuid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setresuid32, 3, ruid, euid, suid);
-      if (result == 0 || errno != ENOSYS)
+      result = INLINE_SETXID_SYSCALL (setresuid32, 3, ruid, euid, suid);
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -72,8 +65,21 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setresuid, 3, ruid, euid, suid);
+  result = INLINE_SETXID_SYSCALL (setresuid, 3, ruid, euid, suid);
+#  ifdef __NR_setresuid32
+ out:
+#  endif
 # endif
+
+  return result;
 }
+libc_hidden_def (__setresuid)
+#ifndef __setresuid
 weak_alias (__setresuid, setresuid)
 #endif
+
+#else
+
+#include <sysdeps/generic/setresuid.c>
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/setreuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setreuid.c
--- sysdeps/unix/sysv/linux/i386/setreuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setreuid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,20 +17,13 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/types.h>
 #include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
 
-extern int __syscall_setreuid (__kernel_uid_t, __kernel_uid_t);
-
 #ifdef __NR_setreuid32
-extern int __syscall_setreuid32 (__kernel_uid32_t, __kernel_uid32_t);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -41,18 +34,21 @@
 int
 __setreuid (uid_t ruid, uid_t euid)
 {
+  int result;
+
 #if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setreuid32, 2, ruid, euid);
+  result = INLINE_SETXID_SYSCALL (setreuid32, 2, ruid, euid);
 #else
 # ifdef __NR_setreuid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setreuid32, 2, ruid, euid);
+      result = INLINE_SETXID_SYSCALL (setreuid32, 2, ruid, euid);
 
-      if (result == 0 || errno != ENOSYS)
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -66,7 +62,14 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setreuid, 2, ruid, euid);
+  result = INLINE_SETXID_SYSCALL (setreuid, 2, ruid, euid);
+# ifdef __NR_setreuid32
+ out:
+# endif
 #endif
+
+  return result;
 }
+#ifndef __setreuid
 weak_alias (__setreuid, setreuid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/setrlimit.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setrlimit.c
--- sysdeps/unix/sysv/linux/i386/setrlimit.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setrlimit.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -27,10 +27,6 @@
 
 #include "kernel-features.h"
 
-extern int __syscall_setrlimit (unsigned int resource,
-				const struct rlimit *__unbounded rlimits);
-extern int __syscall_ugetrlimit (unsigned int resource,
-				 const struct rlimit *__unbounded rlimits);
 extern int __new_setrlimit (enum __rlimit_resource resource,
 			    const struct rlimit *__unboundedrlimits);
 
diff -Nur sysdeps/unix/sysv/linux/i386/setuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setuid.c
--- sysdeps/unix/sysv/linux/i386/setuid.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/setuid.c	2004-11-12 20:21:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,18 +18,12 @@
 
 #include <errno.h>
 #include <unistd.h>
-#include <sys/types.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
+#include <setxid.h>
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
-extern int __syscall_setuid (__kernel_uid_t);
 
 #ifdef __NR_setuid32
-extern int __syscall_setuid32 (__kernel_uid32_t);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -40,17 +34,20 @@
 int
 __setuid (uid_t uid)
 {
-#if __ASSUME_32BITUIDS > 0
-  return INLINE_SYSCALL (setuid32, 1, uid);
+  int result;
+
+#if __ASSUME_32BITUIDS > 0 && defined __NR_setuid32
+  result = INLINE_SETXID_SYSCALL (setuid32, 1, uid);
 #else
 # ifdef __NR_setuid32
   if (__libc_missing_32bit_uids <= 0)
     {
-      int result;
       int saved_errno = errno;
 
-      result = INLINE_SYSCALL (setuid32, 1, uid);
-      if (result == 0 || errno != ENOSYS)
+      result = INLINE_SETXID_SYSCALL (setuid32, 1, uid);
+      if (result == 0)
+	goto out;
+      if (errno != ENOSYS)
 	return result;
 
       __set_errno (saved_errno);
@@ -65,7 +62,14 @@
       return -1;
     }
 
-  return INLINE_SYSCALL (setuid, 1, uid);
+  result = INLINE_SETXID_SYSCALL (setuid, 1, uid);
+# ifdef __NR_setuid32
+ out:
+# endif
 #endif
+
+  return result;
 }
+#ifndef __setuid
 weak_alias (__setuid, setuid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/i386/shmctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/shmctl.c
--- sysdeps/unix/sysv/linux/i386/shmctl.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/shmctl.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -70,6 +70,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_shmctl (int shmid, int cmd, struct __old_shmid_ds *buf)
 {
   return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl,
diff -Nur sysdeps/unix/sysv/linux/i386/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sigaction.c
--- sysdeps/unix/sysv/linux/i386/sigaction.c	2002-09-18 19:59:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sigaction.c	2004-03-05 11:14:47.000000000 +0100
@@ -1,5 +1,5 @@
 /* POSIX.1 `sigaction' call for Linux/i386.
-   Copyright (C) 1991,95,96,97,98,99,2000,02 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-2000,02,03, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,6 +25,7 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <ldsodefs.h>
 
 #include <kernel-features.h>
 
@@ -37,9 +38,6 @@
 #define SA_RESTORER 0x04000000
 
 
-extern int __syscall_rt_sigaction (int, const struct kernel_sigaction *__unbounded,
-				   struct kernel_sigaction *__unbounded, size_t);
-
 #if __ASSUME_REALTIME_SIGNALS == 0
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  */
@@ -48,7 +46,8 @@
 
 /* Using the hidden attribute here does not change the code but it
    helps to avoid warnings.  */
-#if defined HAVE_HIDDEN && !defined HAVE_BROKEN_VISIBILITY_ATTRIBUTE
+#if defined HAVE_HIDDEN && defined HAVE_VISIBILITY_ATTRIBUTE \
+    && !defined HAVE_BROKEN_VISIBILITY_ATTRIBUTE
 # ifdef __NR_rt_sigaction
 extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
 # endif
@@ -86,11 +85,16 @@
       if (act)
 	{
 	  kact.k_sa_handler = act->sa_handler;
+	  kact.sa_flags = act->sa_flags;
 	  memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));
-	  kact.sa_flags = act->sa_flags | SA_RESTORER;
 
-	  kact.sa_restorer = ((act->sa_flags & SA_SIGINFO)
-			      ? &restore_rt : &restore);
+	  if (GLRO(dl_sysinfo_dso) == NULL)
+	    {
+	      kact.sa_flags |= SA_RESTORER;
+
+	      kact.sa_restorer = ((act->sa_flags & SA_SIGINFO)
+				  ? &restore_rt : &restore);
+	    }
 	}
 
       /* XXX The size argument hopefully will have to be changed to the
@@ -130,20 +134,12 @@
       k_newact.sa_restorer = &restore;
     }
 
-  asm volatile ("pushl %%ebx\n"
-		"movl %2, %%ebx\n"
-		"int $0x80\n"
-		"popl %%ebx"
-		: "=a" (result)
-		: "0" (SYS_ify (sigaction)), "mr" (sig),
-		  "c" (act ? __ptrvalue (&k_newact) : 0),
-		  "d" (oact ? __ptrvalue (&k_oldact) : 0));
+  result = INLINE_SYSCALL (sigaction, 3, sig,
+			   act ? __ptrvalue (&k_newact) : 0,
+			   oact ? __ptrvalue (&k_oldact) : 0);
 
   if (result < 0)
-    {
-      __set_errno (-result);
-      return -1;
-    }
+    return -1;
 
   if (oact)
     {
@@ -158,27 +154,10 @@
 }
 libc_hidden_def (__libc_sigaction)
 
-#ifndef SIGCANCEL
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction)
-#else
-int
-__sigaction (sig, act, oact)
-     int sig;
-     const struct sigaction *act;
-     struct sigaction *oact;
-{
-  if (sig == SIGCANCEL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  return __libc_sigaction (sig, act, oact);
-}
-libc_hidden_weak (__sigaction)
-weak_alias (__sigaction, sigaction)
 #endif
 
 /* NOTE: Please think twice before making any changes to the bits of
@@ -206,8 +185,8 @@
 #endif
 
 /* For the boring old signals.  */
-# undef RESTORE2
-# define RESTORE2(name, syscall) \
+#undef RESTORE2
+#define RESTORE2(name, syscall) \
 asm						\
   (						\
    ".text\n"					\
diff -Nur sysdeps/unix/sysv/linux/i386/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/socket.S
--- sysdeps/unix/sysv/linux/i386/socket.S	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/socket.S	2003-06-17 01:06:41.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,8 +16,9 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <tls.h>
 
 #define P(a, b) P2(a, b)
 #define P2(a, b) a##b
@@ -32,18 +33,24 @@
    The .S files for the other calls just #define socket and #include this.  */
 
 #ifndef __socket
-#ifndef NO_WEAK_ALIAS
-#define __socket P(__,socket)
-#else
-#define __socket socket
-#endif
+# ifndef NO_WEAK_ALIAS
+#  define __socket P(__,socket)
+# else
+#  define __socket socket
+# endif
 #endif
 
 .globl __socket
+	cfi_startproc
 ENTRY (__socket)
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	jne 1f
+#endif
 
 	/* Save registers.  */
 	movl %ebx, %edx
+	cfi_register (3, 2)
 
 	movl $SYS_ify(socketcall), %eax	/* System call number in %eax.  */
 
@@ -52,10 +59,11 @@
 	lea 4(%esp), %ecx		/* Address of args is 2nd arg.  */
 
         /* Do the system call trap.  */
-	int $0x80
+	ENTER_KERNEL
 
 	/* Restore registers.  */
 	movl %edx, %ebx
+	cfi_restore (3)
 
 	/* %eax is < 0 if there was an error.  */
 	cmpl $-125, %eax
@@ -65,6 +73,52 @@
 L(pseudo_end):
 	ret
 
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	/* We need one more register.  */
+1:	pushl %esi
+	cfi_adjust_cfa_offset(4)
+
+	/* Enable asynchronous cancellation.  */
+	CENABLE
+	movl %eax, %esi
+	cfi_offset(6, -8)		/* %esi */
+
+	/* Save registers.  */
+	movl %ebx, %edx
+	cfi_register (3, 2)
+
+	movl $SYS_ify(socketcall), %eax	/* System call number in %eax.  */
+
+	/* Use ## so `socket' is a separate token that might be #define'd.  */
+	movl $P(SOCKOP_,socket), %ebx	/* Subcode is first arg to syscall.  */
+	lea 8(%esp), %ecx		/* Address of args is 2nd arg.  */
+
+        /* Do the system call trap.  */
+	ENTER_KERNEL
+
+	/* Restore registers.  */
+	movl %edx, %ebx
+	cfi_restore (3)
+
+	/* Restore the cancellation.  */
+	xchgl %esi, %eax
+	CDISABLE
+
+	/* Restore registers.  */
+	movl %esi, %eax
+	popl %esi
+	cfi_restore (6)
+	cfi_adjust_cfa_offset(-4)
+
+	/* %eax is < 0 if there was an error.  */
+	cmpl $-125, %eax
+	jae SYSCALL_ERROR_LABEL
+
+	/* Successful; return the syscall's value.  */
+	ret
+#endif
+	cfi_endproc
 PSEUDO_END (__socket)
 
 #ifndef NO_WEAK_ALIAS
diff -Nur sysdeps/unix/sysv/linux/i386/swapcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/swapcontext.S
--- sysdeps/unix/sysv/linux/i386/swapcontext.S	2001-07-31 22:52:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/swapcontext.S	2003-04-06 22:59:45.000000000 +0200
@@ -1,5 +1,5 @@
 /* Save current context and install the given one.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
 
@@ -65,7 +65,7 @@
 	leal	oSIGMASK(%ecx), %ecx
 	movl	$SIG_SETMASK, %ebx
 	movl	$__NR_sigprocmask, %eax
-	int	$0x80
+	ENTER_KERNEL
 	popl	%ebx
 	cmpl	$-4095, %eax		/* Check %eax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
@@ -78,43 +78,31 @@
 	movl	oFPREGS(%eax), %ecx
 	fldenv	(%ecx)
 
-	/* Restore the FS segment registers.  */
+	/* Restore the FS segment register.  We don't touch the GS register
+	   since it is used for threads.  */
 	movl	oFS(%eax), %edx
 	movw	%dx, %fs
 
+	/* Fetch the address to return to.  */
+	movl	oEIP(%eax), %ecx
+
 	/* Load the new stack pointer.  */
-	movl	oESP(%eax), %ecx
-	/* Make room for 8 registers and the return address.  We will load
-	   the values from the stack.  */
-	subl	$36, %ecx
-
-	/* Move the values of all the 32-bit registers (except ESP) on
-	   the stack.  This happens in the form the 'popa' instruction
-	   expects it.  Before this block put the address of the code
-	   to execute.  */
-	movl	oEDI(%eax), %ebx
-	movl	oESI(%eax), %edx
-	movl	oEBP(%eax), %esi
-	movl	oEBX(%eax), %edi
-	movl	%ebx, (%ecx)
-	movl	%edx, 4(%ecx)
-	movl	%esi, 8(%ecx)
-	movl	%edi, 16(%ecx)
-	movl	oEDX(%eax), %ebx
-	movl	oECX(%eax), %edx
-	movl	oEAX(%eax), %esi
-	movl	oEIP(%eax), %edi
-	movl	%ebx, 20(%ecx)
-	movl	%edx, 24(%ecx)
-	movl	%esi, 28(%ecx)
-	movl	%edi, 32(%ecx)
-
-	/* Set the new stack address.  The stack points now to the block
-	   we put the register content in.  */
-	movl	%ecx, %esp
-	/* Restore the register content.  */
-	popa
-	/* The following 'ret' will pop the addres of the code and jump
+	movl	oESP(%eax), %esp
+
+	/* Push the return address on the new stack so we can return there.  */
+	pushl	%ecx
+
+	/* Load the values of all the 32-bit registers (except ESP).
+	   Since we are loading from EAX, it must be last.  */
+	movl	oEDI(%eax), %edi
+	movl	oESI(%eax), %esi
+	movl	oEBP(%eax), %ebp
+	movl	oEBX(%eax), %ebx
+	movl	oEDX(%eax), %edx
+	movl	oECX(%eax), %ecx
+	movl	oEAX(%eax), %eax
+
+	/* The following 'ret' will pop the address of the code and jump
 	   to it.  */
 
 L(pseudo_end):
diff -Nur sysdeps/unix/sysv/linux/i386/sys/vm86.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sys/vm86.h
--- sysdeps/unix/sysv/linux/i386/sys/vm86.h	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sys/vm86.h	2004-02-09 22:46:35.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -27,7 +27,8 @@
 __BEGIN_DECLS
 
 /* Enter virtual 8086 mode.  */
-extern int vm86 (struct vm86_struct *__info) __THROW;
+extern int vm86 (unsigned long int __subfunction,
+		 struct vm86plus_struct *__info) __THROW;
 
 __END_DECLS
 
diff -Nur sysdeps/unix/sysv/linux/i386/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/syscall.S
--- sysdeps/unix/sysv/linux/i386/syscall.S	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/syscall.S	2004-10-15 23:30:57.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1998, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,11 +24,11 @@
 	.text
 ENTRY (syscall)
 
-	PUSHARGS_5		/* Save register contents.  */
-	_DOARGS_5(36)		/* Load arguments.  */
-	movl 16(%esp), %eax	/* Load syscall number into %eax.  */
-	int $0x80		/* Do the system call.  */
-	POPARGS_5		/* Restore register contents.  */
+	PUSHARGS_6		/* Save register contents.  */
+	_DOARGS_6(44)		/* Load arguments.  */
+	movl 20(%esp), %eax	/* Load syscall number into %eax.  */
+	ENTER_KERNEL		/* Do the system call.  */
+	POPARGS_6		/* Restore register contents.  */
 	cmpl $-4095, %eax	/* Check %eax for error.  */
 	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 L(pseudo_end):
diff -Nur sysdeps/unix/sysv/linux/i386/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/syscalls.list
--- sysdeps/unix/sysv/linux/i386/syscalls.list	2000-06-13 08:49:41.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/syscalls.list	2004-03-10 09:38:15.000000000 +0100
@@ -1,6 +1,9 @@
 # File name	Caller	Syscall name	Args	Strong name	Weak names
 
 modify_ldt	EXTRA	modify_ldt	i:ipi	__modify_ldt	modify_ldt
-vm86		-	vm86		i:p	__vm86		vm86
+vm86old		EXTRA	vm86old		i:p	__vm86old	vm86@GLIBC_2.0
+vm86		-	vm86		i:ip	__vm86		vm86@@GLIBC_2.3.4
 oldgetrlimit	EXTRA	getrlimit	i:ip	__old_getrlimit	getrlimit@GLIBC_2.0
 oldsetrlimit	EXTRA	setrlimit	i:ip	__old_setrlimit	setrlimit@GLIBC_2.0
+time		-	time		Ei:p	time
+waitpid		-	waitpid		Ci:ipi	__waitpid	waitpid	__libc_waitpid
diff -Nur sysdeps/unix/sysv/linux/i386/sysconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysconf.c
--- sysdeps/unix/sysv/linux/i386/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysconf.c	2004-10-05 11:20:50.000000000 +0200
@@ -0,0 +1,407 @@
+/* Get file-specific information about a file.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <hp-timing.h>
+
+static long int linux_sysconf (int name);
+
+
+static long int
+handle_i486 (int name)
+{
+  /* The processor only has a unified level 1 cache of 8k.  */
+  switch (name)
+    {
+    case _SC_LEVEL1_ICACHE_SIZE:
+    case _SC_LEVEL1_DCACHE_SIZE:
+      return 8 * 1024;
+
+    case _SC_LEVEL1_ICACHE_ASSOC:
+    case _SC_LEVEL1_DCACHE_ASSOC:
+      // XXX Anybody know this?
+      return 0;
+
+    case _SC_LEVEL1_ICACHE_LINESIZE:
+    case _SC_LEVEL1_DCACHE_LINESIZE:
+      // XXX Anybody know for sure?
+      return 16;
+
+    case _SC_LEVEL2_CACHE_SIZE:
+    case _SC_LEVEL2_CACHE_ASSOC:
+    case _SC_LEVEL2_CACHE_LINESIZE:
+    case _SC_LEVEL3_CACHE_SIZE:
+    case _SC_LEVEL3_CACHE_ASSOC:
+    case _SC_LEVEL3_CACHE_LINESIZE:
+    case _SC_LEVEL4_CACHE_SIZE:
+    case _SC_LEVEL4_CACHE_ASSOC:
+      /* Not available.  */
+      break;
+
+    default:
+      assert (! "cannot happen");
+    }
+
+  return -1;
+}
+
+
+static const struct intel_02_cache_info
+{
+  unsigned int idx;
+  int name;
+  long int size;
+  long int assoc;
+  long int linesize;
+} intel_02_known[] =
+  {
+    { 0x06, _SC_LEVEL1_ICACHE_SIZE, 8192, 4, 32 },
+    { 0x08, _SC_LEVEL1_ICACHE_SIZE, 16384, 4, 32 },
+    { 0x0a, _SC_LEVEL1_DCACHE_SIZE, 8192, 2, 32 },
+    { 0x0c, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 32 },
+    { 0x22, _SC_LEVEL3_CACHE_SIZE, 524288, 4, 64 },
+    { 0x23, _SC_LEVEL3_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x25, _SC_LEVEL3_CACHE_SIZE, 2097152, 8, 64 },
+    { 0x29, _SC_LEVEL3_CACHE_SIZE, 4194304, 8, 64 },
+    { 0x2c, _SC_LEVEL1_DCACHE_SIZE, 32768, 8, 64 },
+    { 0x30, _SC_LEVEL1_ICACHE_SIZE, 32768, 8, 64 },
+    { 0x41, _SC_LEVEL2_CACHE_SIZE, 131072, 4, 32 },
+    { 0x42, _SC_LEVEL2_CACHE_SIZE, 262144, 4, 32 },
+    { 0x43, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 32 },
+    { 0x44, _SC_LEVEL2_CACHE_SIZE, 1048576, 4, 32 },
+    { 0x45, _SC_LEVEL2_CACHE_SIZE, 2097152, 4, 32 },
+    { 0x60, _SC_LEVEL1_DCACHE_SIZE, 16384, 8, 64 },
+    { 0x66, _SC_LEVEL1_DCACHE_SIZE, 8192, 4, 64 },
+    { 0x67, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 64 },
+    { 0x68, _SC_LEVEL1_DCACHE_SIZE, 32768, 4, 64 },
+    { 0x78, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x79, _SC_LEVEL2_CACHE_SIZE, 131072, 8, 64 },
+    { 0x7a, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 64 },
+    { 0x7b, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 64 },
+    { 0x7c, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x7d, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 64 },
+    { 0x82, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 32 },
+    { 0x83, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 32 },
+    { 0x84, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 32 },
+    { 0x85, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 32 },
+    { 0x86, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 64 },
+    { 0x87, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+  };
+#define nintel_02_known (sizeof (intel_02_known) / sizeof (intel_02_known[0]))
+
+
+static int
+intel_02_known_compare (const void *p1, const void *p2)
+{
+  const struct intel_02_cache_info *i1;
+  const struct intel_02_cache_info *i2;
+
+  i1 = (const struct intel_02_cache_info *) p1;
+  i2 = (const struct intel_02_cache_info *) p2;
+
+  if (i1->idx == i2->idx)
+    return 0;
+
+  return i1->idx < i2->idx ? -1 : 1;
+}
+
+
+static long int
+intel_check_word (int name, unsigned int value, bool *has_level_2,
+		  bool *no_level_2_or_3)
+{
+  if ((value & 0x80000000) != 0)
+    /* The register value is reserved.  */
+    return 0;
+
+  /* Fold the name.  The _SC_ constants are always in the order SIZE,
+     ASSOC, LINESIZE.  */
+  int folded_name = (_SC_LEVEL1_ICACHE_SIZE
+		     + ((name - _SC_LEVEL1_ICACHE_SIZE) / 3) * 3);
+
+  while (value != 0)
+    {
+      unsigned int byte = value & 0xff;
+
+      if (byte == 0x40)
+	{
+	  *no_level_2_or_3 = true;
+
+	  if (folded_name == _SC_LEVEL3_CACHE_SIZE)
+	    /* No need to look further.  */
+	    break;
+	}
+      else
+	{
+	  struct intel_02_cache_info *found;
+	  struct intel_02_cache_info search;
+
+	  search.idx = byte;
+	  found = bsearch (&search, intel_02_known, nintel_02_known,
+			   sizeof (intel_02_known[0]), intel_02_known_compare);
+	  if (found != NULL)
+	    {
+	      if (found->name == folded_name)
+		{
+		  unsigned int offset = name - folded_name;
+
+		  if (offset == 0)
+		    /* Cache size.  */
+		    return found->size;
+		  if (offset == 1)
+		    return found->assoc;
+
+		  assert (offset == 2);
+		  return found->linesize;
+		}
+
+	      if (found->name == _SC_LEVEL2_CACHE_SIZE)
+		*has_level_2 = true;
+	    }
+	}
+
+      /* Next byte for the next round.  */
+      value >>= 8;
+    }
+
+  /* Nothing found.  */
+  return 0;
+}
+
+
+static long int
+handle_intel (int name, unsigned int maxidx)
+{
+  if (maxidx < 2)
+    {
+      // XXX Do such processors exist?  When we know we can fill in some
+      // values.
+      return 0;
+    }
+
+  /* OK, we can use the CPUID instruction to get all info about the
+     caches.  */
+  unsigned int cnt = 0;
+  unsigned int max = 1;
+  long int result = 0;
+  bool no_level_2_or_3 = false;
+  bool has_level_2 = false;
+  while (cnt++ < max)
+    {
+      unsigned int eax;
+      unsigned int ebx;
+      unsigned int ecx;
+      unsigned int edx;
+      asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		    : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		    : "0" (2));
+
+      /* The low byte of EAX in the first round contain the number of
+	 rounds we have to make.  At least one, the one we are already
+	 doing.  */
+      if (cnt == 1)
+	{
+	  max = eax & 0xff;
+	  eax &= 0xffffff00;
+	}
+
+      /* Process the individual registers' value.  */
+      result = intel_check_word (name, eax, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ebx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ecx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, edx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+    }
+
+  if (name >= _SC_LEVEL2_CACHE_SIZE && name <= _SC_LEVEL3_CACHE_LINESIZE
+      && no_level_2_or_3)
+    return -1;
+
+  return 0;
+}
+
+
+static long int
+handle_amd (int name)
+{
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0x80000000));
+
+  if (name >= _SC_LEVEL3_CACHE_SIZE)
+    return 0;
+
+  unsigned int fn = 0x80000005 + (name >= _SC_LEVEL2_CACHE_SIZE);
+  if (eax < fn)
+    return 0;
+
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (fn));
+
+  if (name < _SC_LEVEL1_DCACHE_SIZE)
+    {
+      name += _SC_LEVEL1_DCACHE_SIZE - _SC_LEVEL1_ICACHE_SIZE;
+      ecx = edx;
+    }
+
+  switch (name)
+    {
+    case _SC_LEVEL1_DCACHE_SIZE:
+      return (ecx >> 14) & 0x3fc00;
+    case _SC_LEVEL1_DCACHE_ASSOC:
+      ecx >>= 16;
+      if ((ecx & 0xff) == 0xff)
+	/* Fully associative.  */
+	return (ecx << 2) & 0x3fc00;
+      return ecx & 0xff;
+    case _SC_LEVEL1_DCACHE_LINESIZE:
+      return ecx & 0xff;
+    case _SC_LEVEL2_CACHE_SIZE:
+      return (ecx & 0xf000) == 0 ? 0 : (ecx >> 6) & 0x3fffc00;
+    case _SC_LEVEL2_CACHE_ASSOC:
+      ecx >>= 12;
+      switch (ecx & 0xf)
+        {
+        case 0:
+        case 1:
+        case 2:
+        case 4:
+	  return ecx & 0xf;
+	case 6:
+	  return 8;
+	case 8:
+	  return 16;
+	case 0xf:
+	  return (ecx << 6) & 0x3fffc00;
+	default:
+	  return 0;
+        }
+    case _SC_LEVEL2_CACHE_LINESIZE:
+      return (ecx & 0xf000) == 0 ? 0 : ecx & 0xff;
+    default:
+      assert (! "cannot happen");
+    }
+  return -1;
+}
+
+
+static int
+i386_i486_test (void)
+{
+  int eflags;
+  int ac;
+  asm volatile ("pushfl;\n\t"
+		"popl %0;\n\t"
+		"movl $0x240000, %1;\n\t"
+		"xorl %0, %1;\n\t"
+		"pushl %1;\n\t"
+		"popfl;\n\t"
+		"pushfl;\n\t"
+		"popl %1;\n\t"
+		"xorl %0, %1;\n\t"
+		"pushl %0;\n\t"
+		"popfl"
+		: "=r" (eflags), "=r" (ac));
+
+  return ac;
+}
+
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  if (name == _SC_CPUTIME || name == _SC_THREAD_CPUTIME)
+    {
+#if HP_TIMING_AVAIL
+      // XXX We can add  here test for machines which cannot support a
+      // XXX usable TSC.
+      return 200112L;
+#else
+      return -1;
+#endif
+    }
+
+  /* All the remainder, except the cache information, is handled in
+     the generic code.  */
+  if (name < _SC_LEVEL1_ICACHE_SIZE || name > _SC_LEVEL4_CACHE_LINESIZE)
+    return linux_sysconf (name);
+
+  /* Recognize i386 and compatible.  These don't have any cache on
+     board.  */
+  int ac = i386_i486_test ();
+
+  if (ac == 0)
+    /* This is an i386.  */
+    // XXX Is this true for all brands?
+    return -1;
+
+  /* Detect i486, the last Intel processor without CPUID.  */
+  if ((ac & (1 << 21)) == 0)
+    {
+      /* No CPUID.  */
+      // XXX Fill in info about other brands.  For now only Intel.
+      return handle_i486 (name);
+    }
+
+  /* Find out what brand of processor.  */
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0));
+
+  /* This spells out "GenuineIntel".  */
+  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
+    return handle_intel (name, eax);
+
+  /* This spells out "AuthenticAMD".  */
+  if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
+    return handle_amd (name);
+
+  // XXX Fill in more vendors.
+
+  /* CPU not known, we have no information.  */
+  return 0;
+}
+
+/* Now the generic Linux version.  */
+#undef __sysconf
+#define __sysconf static linux_sysconf
+#include "../sysconf.c"
diff -Nur sysdeps/unix/sysv/linux/i386/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysdep.h
--- sysdeps/unix/sysv/linux/i386/sysdep.h	2002-10-01 00:03:09.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysdep.h	2005-02-16 12:20:22.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,93,95,96,97,98,99,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1992,1993,1995-2000,2002,2003,2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.org>, August 1995.
 
@@ -24,8 +25,11 @@
 #include <sysdeps/unix/i386/sysdep.h>
 #include <bp-sym.h>
 #include <bp-asm.h>
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
 #include <tls.h>
 
+
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
    of the kernel.  But these symbols do not follow the SYS_* syntax
@@ -33,6 +37,13 @@
 #undef SYS_ify
 #define SYS_ify(syscall_name)	__NR_##syscall_name
 
+#if defined USE_DL_SYSINFO \
+    && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+# define I386_USE_SYSENTER	1
+#else
+# undef I386_USE_SYSENTER
+#endif
+
 #ifdef __ASSEMBLER__
 
 /* Linux uses a negative return value to indicate syscall errors,
@@ -68,6 +79,32 @@
   SYSCALL_ERROR_HANDLER							      \
   END (name)
 
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#define ret_NOERRNO ret
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    negl %eax
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
 #ifndef PIC
 # define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
 #else
@@ -88,23 +125,46 @@
 __i686.get_pc_thunk.reg:						      \
   movl (%esp), %e##reg;							      \
   ret;									      \
+  .size __i686.get_pc_thunk.reg, . - __i686.get_pc_thunk.reg;		      \
   .previous;								      \
   call __i686.get_pc_thunk.reg
 # endif
 
-/* Store (- %eax) into errno through the GOT.  */
-# ifdef _LIBC_REENTRANT
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  xorl %edx, %edx;							      \
+  subl %eax, %edx;							      \
+  movl %edx, rtld_errno@GOTOFF(%ecx);					      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+
+# elif defined _LIBC_REENTRANT
 
-#  if USE_TLS && HAVE___THREAD
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
 #   define SYSCALL_ERROR_HANDLER					      \
 0:SETUP_PIC_REG (cx);							      \
   addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
-  movl errno@gotntpoff(%ecx), %ecx;					      \
+  movl SYSCALL_ERROR_ERRNO@GOTNTPOFF(%ecx), %ecx;			      \
   xorl %edx, %edx;							      \
   subl %eax, %edx;							      \
-  movl %edx, %gs:0(%ecx);						      \
+  SYSCALL_ERROR_HANDLER_TLS_STORE (%edx, %ecx);				      \
   orl $-1, %eax;							      \
   jmp L(pseudo_end);
+#   ifndef NO_TLS_DIRECT_SEG_REFS
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  movl src, %gs:(destoff)
+#   else
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  addl %gs:0, destoff;							      \
+  movl src, (destoff)
+#   endif
 #  else
 #   define SYSCALL_ERROR_HANDLER					      \
 0:pushl %ebx;								      \
@@ -125,8 +185,9 @@
    not modify the stack!  */
 #  endif
 # else
+/* Store (- %eax) into errno through the GOT.  */
 #  define SYSCALL_ERROR_HANDLER						      \
-0:SETUP_PIC_REG(cx);						      \
+0:SETUP_PIC_REG(cx);							      \
   addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
   xorl %edx, %edx;							      \
   subl %eax, %edx;							      \
@@ -137,6 +198,19 @@
 # endif	/* _LIBC_REENTRANT */
 #endif	/* PIC */
 
+
+/* The original calling convention for system calls on Linux/i386 is
+   to use int $0x80.  */
+#ifdef I386_USE_SYSENTER
+# ifdef SHARED
+#  define ENTER_KERNEL call *%gs:SYSINFO_OFFSET
+# else
+#  define ENTER_KERNEL call *_dl_sysinfo
+# endif
+#else
+# define ENTER_KERNEL int $0x80
+#endif
+
 /* Linux takes system call arguments in registers:
 
 	syscall number	%eax	     call-clobbered
@@ -186,7 +260,7 @@
     PUSHARGS_##args							      \
     DOARGS_##args							      \
     movl $SYS_ify (syscall_name), %eax;					      \
-    int $0x80								      \
+    ENTER_KERNEL							      \
     POPARGS_##args
 
 #define PUSHARGS_0	/* No arguments to push.  */
@@ -196,12 +270,12 @@
 #define _DOARGS_0(n)	/* No arguments to frob.  */
 #define	_POPARGS_0	/* No arguments to pop.  */
 
-#define PUSHARGS_1	movl %ebx, %edx; PUSHARGS_0
+#define PUSHARGS_1	movl %ebx, %edx; L(SAVEBX1): PUSHARGS_0
 #define	DOARGS_1	_DOARGS_1 (4)
-#define	POPARGS_1	POPARGS_0; movl %edx, %ebx
-#define	_PUSHARGS_1	pushl %ebx; _PUSHARGS_0
+#define	POPARGS_1	POPARGS_0; movl %edx, %ebx; L(RESTBX1):
+#define	_PUSHARGS_1	pushl %ebx; L(PUSHBX1): _PUSHARGS_0
 #define _DOARGS_1(n)	movl n(%esp), %ebx; _DOARGS_0(n-4)
-#define	_POPARGS_1	_POPARGS_0; popl %ebx
+#define	_POPARGS_1	_POPARGS_0; popl %ebx; L(POPBX1):
 
 #define PUSHARGS_2	PUSHARGS_1
 #define	DOARGS_2	_DOARGS_2 (8)
@@ -220,16 +294,23 @@
 #define PUSHARGS_4	_PUSHARGS_4
 #define DOARGS_4	_DOARGS_4 (24)
 #define POPARGS_4	_POPARGS_4
-#define _PUSHARGS_4	pushl %esi; _PUSHARGS_3
+#define _PUSHARGS_4	pushl %esi; L(PUSHSI1): _PUSHARGS_3
 #define _DOARGS_4(n)	movl n(%esp), %esi; _DOARGS_3 (n-4)
-#define _POPARGS_4	_POPARGS_3; popl %esi
+#define _POPARGS_4	_POPARGS_3; popl %esi; L(POPSI1):
 
 #define PUSHARGS_5	_PUSHARGS_5
 #define DOARGS_5	_DOARGS_5 (32)
 #define POPARGS_5	_POPARGS_5
-#define _PUSHARGS_5	pushl %edi; _PUSHARGS_4
+#define _PUSHARGS_5	pushl %edi; L(PUSHDI1): _PUSHARGS_4
 #define _DOARGS_5(n)	movl n(%esp), %edi; _DOARGS_4 (n-4)
-#define _POPARGS_5	_POPARGS_4; popl %edi
+#define _POPARGS_5	_POPARGS_4; popl %edi; L(POPDI1):
+
+#define PUSHARGS_6	_PUSHARGS_6
+#define DOARGS_6	_DOARGS_6 (36)
+#define POPARGS_6	_POPARGS_6
+#define _PUSHARGS_6	pushl %ebp; L(PUSHBP1): _PUSHARGS_5
+#define _DOARGS_6(n)	movl n(%esp), %ebp; _DOARGS_5 (n-4)
+#define _POPARGS_6	_POPARGS_5; popl %ebp; L(POPBP1):
 
 #else	/* !__ASSEMBLER__ */
 
@@ -246,7 +327,7 @@
      ".macro bpushl name reg\n\t"
      ".if 1 - \\name\n\t"
      ".if 2 - \\name\n\t"
-     "pushl %ebx\n\t"
+     "error\n\t"
      ".else\n\t"
      "xchgl \\reg, %ebx\n\t"
      ".endif\n\t"
@@ -255,18 +336,11 @@
      ".macro bpopl name reg\n\t"
      ".if 1 - \\name\n\t"
      ".if 2 - \\name\n\t"
-     "popl %ebx\n\t"
+     "error\n\t"
      ".else\n\t"
      "xchgl \\reg, %ebx\n\t"
      ".endif\n\t"
      ".endif\n\t"
-     ".endm\n\t"
-     ".macro bmovl name reg\n\t"
-     ".if 1 - \\name\n\t"
-     ".if 2 - \\name\n\t"
-     "movl \\reg, %ebx\n\t"
-     ".endif\n\t"
-     ".endif\n\t"
      ".endm\n\t");
 
 /* Define a macro which expands inline into the wrapper code for a system
@@ -274,7 +348,79 @@
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) \
   ({									      \
-    unsigned int resultvar;						      \
+    unsigned int resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
+      {									      \
+	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
+	resultvar = 0xffffffff;						      \
+      }									      \
+    (int) resultvar; })
+
+/* Define a macro which expands inline into the wrapper code for a system
+   call.  This use is for internal calls that do not need to handle errors
+   normally.  It will never touch errno.  This returns just what the kernel
+   gave back.
+
+   The _NCS variant allows non-constant syscall numbers but it is not
+   possible to use more than four parameters.  */
+#undef INTERNAL_SYSCALL
+#ifdef I386_USE_SYSENTER
+# ifdef SHARED
+#  define INTERNAL_SYSCALL(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
+    asm volatile (							      \
+    LOADARGS_##nr							      \
+    "movl %1, %%eax\n\t"						      \
+    "call *%%gs:%P2\n\t"						      \
+    RESTOREARGS_##nr							      \
+    : "=a" (resultvar)							      \
+    : "i" (__NR_##name), "i" (offsetof (tcbhead_t, sysinfo))		      \
+      ASMFMT_##nr(args) : "memory", "cc");				      \
+    (int) resultvar; })
+#  define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
+    asm volatile (							      \
+    LOADARGS_##nr							      \
+    "call *%%gs:%P2\n\t"						      \
+    RESTOREARGS_##nr							      \
+    : "=a" (resultvar)							      \
+    : "0" (name), "i" (offsetof (tcbhead_t, sysinfo))			      \
+      ASMFMT_##nr(args) : "memory", "cc");				      \
+    (int) resultvar; })
+# else
+#  define INTERNAL_SYSCALL(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
+    asm volatile (							      \
+    LOADARGS_##nr							      \
+    "movl %1, %%eax\n\t"						      \
+    "call *_dl_sysinfo\n\t"						      \
+    RESTOREARGS_##nr							      \
+    : "=a" (resultvar)							      \
+    : "i" (__NR_##name) ASMFMT_##nr(args) : "memory", "cc");		      \
+    (int) resultvar; })
+#  define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
+    asm volatile (							      \
+    LOADARGS_##nr							      \
+    "call *_dl_sysinfo\n\t"						      \
+    RESTOREARGS_##nr							      \
+    : "=a" (resultvar)							      \
+    : "0" (name) ASMFMT_##nr(args) : "memory", "cc");			      \
+    (int) resultvar; })
+# endif
+#else
+# define INTERNAL_SYSCALL(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
     asm volatile (							      \
     LOADARGS_##nr							      \
     "movl %1, %%eax\n\t"						      \
@@ -282,41 +428,140 @@
     RESTOREARGS_##nr							      \
     : "=a" (resultvar)							      \
     : "i" (__NR_##name) ASMFMT_##nr(args) : "memory", "cc");		      \
-    if (resultvar >= 0xfffff001)					      \
-      {									      \
-	__set_errno (-resultvar);					      \
-	resultvar = 0xffffffff;						      \
-      }									      \
     (int) resultvar; })
+# define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    register unsigned int resultvar;					      \
+    EXTRAVAR_##nr							      \
+    asm volatile (							      \
+    LOADARGS_##nr							      \
+    "int $0x80\n\t"							      \
+    RESTOREARGS_##nr							      \
+    : "=a" (resultvar)							      \
+    : "0" (name) ASMFMT_##nr(args) : "memory", "cc");			      \
+    (int) resultvar; })
+#endif
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned int) (val) >= 0xfffff001u)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
 #define LOADARGS_0
-#define LOADARGS_1 \
-    "bpushl .L__X'%k2, %k2\n\t"						      \
-    "bmovl .L__X'%k2, %k2\n\t"
-#define LOADARGS_2	LOADARGS_1
-#define LOADARGS_3	LOADARGS_1
-#define LOADARGS_4	LOADARGS_1
-#define LOADARGS_5	LOADARGS_1
+#ifdef __PIC__
+# if defined I386_USE_SYSENTER
+#  define LOADARGS_1 \
+    "bpushl .L__X'%k3, %k3\n\t"
+#  define LOADARGS_5 \
+    "movl %%ebx, %4\n\t"						      \
+    "movl %3, %%ebx\n\t"
+# else
+#  define LOADARGS_1 \
+    "bpushl .L__X'%k2, %k2\n\t"
+#  define LOADARGS_5 \
+    "movl %%ebx, %3\n\t"						      \
+    "movl %2, %%ebx\n\t"
+# endif
+# define LOADARGS_2	LOADARGS_1
+# define LOADARGS_3 \
+    "xchgl %%ebx, %%edi\n\t"
+# define LOADARGS_4	LOADARGS_3
+#else
+# define LOADARGS_1
+# define LOADARGS_2
+# define LOADARGS_3
+# define LOADARGS_4
+# define LOADARGS_5
+#endif
 
 #define RESTOREARGS_0
-#define RESTOREARGS_1 \
+#ifdef __PIC__
+# if defined I386_USE_SYSENTER && defined SHARED
+#  define RESTOREARGS_1 \
+    "bpopl .L__X'%k3, %k3\n\t"
+#  define RESTOREARGS_5 \
+    "movl %4, %%ebx"
+# else
+#  define RESTOREARGS_1 \
     "bpopl .L__X'%k2, %k2\n\t"
-#define RESTOREARGS_2	RESTOREARGS_1
-#define RESTOREARGS_3	RESTOREARGS_1
-#define RESTOREARGS_4	RESTOREARGS_1
-#define RESTOREARGS_5	RESTOREARGS_1
+#  define RESTOREARGS_5 \
+    "movl %3, %%ebx"
+# endif
+# define RESTOREARGS_2	RESTOREARGS_1
+# define RESTOREARGS_3 \
+    "xchgl %%edi, %%ebx\n\t"
+# define RESTOREARGS_4	RESTOREARGS_3
+#else
+# define RESTOREARGS_1
+# define RESTOREARGS_2
+# define RESTOREARGS_3
+# define RESTOREARGS_4
+# define RESTOREARGS_5
+#endif
 
 #define ASMFMT_0()
-#define ASMFMT_1(arg1) \
-	, "acdSD" (arg1)
-#define ASMFMT_2(arg1, arg2) \
-	, "adCD" (arg1), "c" (arg2)
-#define ASMFMT_3(arg1, arg2, arg3) \
-	, "aCD" (arg1), "c" (arg2), "d" (arg3)
-#define ASMFMT_4(arg1, arg2, arg3, arg4) \
-	, "aD" (arg1), "c" (arg2), "d" (arg3), "S" (arg4)
-#define ASMFMT_5(arg1, arg2, arg3, arg4, arg5) \
-	, "a" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5)
+#ifdef __PIC__
+# define ASMFMT_1(arg1) \
+	, "cd" (arg1)
+# define ASMFMT_2(arg1, arg2) \
+	, "d" (arg1), "c" (arg2)
+# define ASMFMT_3(arg1, arg2, arg3) \
+	, "D" (arg1), "c" (arg2), "d" (arg3)
+# define ASMFMT_4(arg1, arg2, arg3, arg4) \
+	, "D" (arg1), "c" (arg2), "d" (arg3), "S" (arg4)
+# define ASMFMT_5(arg1, arg2, arg3, arg4, arg5) \
+	, "0" (arg1), "m" (_xv), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5)
+#else
+# define ASMFMT_1(arg1) \
+	, "b" (arg1)
+# define ASMFMT_2(arg1, arg2) \
+	, "b" (arg1), "c" (arg2)
+# define ASMFMT_3(arg1, arg2, arg3) \
+	, "b" (arg1), "c" (arg2), "d" (arg3)
+# define ASMFMT_4(arg1, arg2, arg3, arg4) \
+	, "b" (arg1), "c" (arg2), "d" (arg3), "S" (arg4)
+# define ASMFMT_5(arg1, arg2, arg3, arg4, arg5) \
+	, "b" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5)
+#endif
+
+#define EXTRAVAR_0
+#define EXTRAVAR_1
+#define EXTRAVAR_2
+#define EXTRAVAR_3
+#define EXTRAVAR_4
+#ifdef __PIC__
+# define EXTRAVAR_5 int _xv;
+#else
+# define EXTRAVAR_5
+#endif
+
+/* Consistency check for position-independent code.  */
+#ifdef __PIC__
+# define check_consistency()						      \
+  ({ int __res;								      \
+     __asm__ __volatile__						      \
+       ("call __i686.get_pc_thunk.cx;"					      \
+	"addl $_GLOBAL_OFFSET_TABLE_, %%ecx;"				      \
+	"subl %%ebx, %%ecx;"						      \
+	"je 1f;"							      \
+	"ud2;"								      \
+	"1:\n"								      \
+	".section .gnu.linkonce.t.__i686.get_pc_thunk.cx,\"ax\",@progbits;"   \
+	".globl __i686.get_pc_thunk.cx;"				      \
+	".hidden __i686.get_pc_thunk.cx;"				      \
+	".type __i686.get_pc_thunk.cx,@function;"			      \
+	"__i686.get_pc_thunk.cx:"					      \
+	"movl (%%esp), %%ecx;"						      \
+	"ret;"								      \
+	".previous"							      \
+	: "=c" (__res));						      \
+     __res; })
+#endif
 
 #endif	/* __ASSEMBLER__ */
 
diff -Nur sysdeps/unix/sysv/linux/i386/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysdep.S
--- sysdeps/unix/sysv/linux/i386/sysdep.S	2002-08-25 01:13:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/sysdep.S	2002-10-11 12:51:15.000000000 +0200
@@ -17,29 +17,6 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
-#include <tls.h>
-
-/* The Linux version is in fact i386/ELF and the start.? file for this
-   system (sysdeps/i386/elf/start.S) is also used by The Hurd.  This file
-   must not contain the definition of the `errno' variable, we have to
-   define it somewhere else.
-
-   ...and this place is here.  */
-#if USE_TLS && HAVE___THREAD
-	.section .tbss
-#else
-	.bss
-#endif
-	.globl	errno
-	.type errno,@object
-	.size errno,4
-	.globl	_errno
-	.type _errno,@object
-	.size _errno,4
-	.align 4
-errno:
-_errno:
-	.space	4
 
 /* The following code is only used in the shared library when we
    compile the reentrant version.  Otherwise each system call defines
diff -Nur sysdeps/unix/sysv/linux/i386/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Versions
--- sysdeps/unix/sysv/linux/i386/Versions	2002-08-25 09:43:06.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/Versions	2004-02-09 22:46:35.000000000 +0100
@@ -33,6 +33,14 @@
     # v*
     versionsort64;
   }
+  GLIBC_2.3.3 {
+    # p*
+    posix_fadvise64; posix_fallocate64;
+  }
+  GLIBC_2.3.4 {
+    # v*
+    vm86;
+  }
   GLIBC_PRIVATE {
     __modify_ldt;
   }
diff -Nur sysdeps/unix/sysv/linux/i386/versionsort64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/versionsort64.c
--- sysdeps/unix/sysv/linux/i386/versionsort64.c	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/versionsort64.c	2004-03-10 10:28:24.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1997, 1998, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -38,11 +38,12 @@
 __old_versionsort64 (const void *a, const void *b);
 
 int
+attribute_compat_text_section
 __old_versionsort64 (const void *a, const void *b)
 {
   return __strverscmp ((*(const struct __old_dirent64 **) a)->d_name,
 		       (*(const struct __old_dirent64 **) b)->d_name);
 }
-                      
+
 compat_symbol (libc, __old_versionsort64, versionsort64, GLIBC_2_1);
 #endif
diff -Nur sysdeps/unix/sysv/linux/i386/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/vfork.S
--- sysdeps/unix/sysv/linux/i386/vfork.S	2001-07-07 21:21:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/vfork.S	2004-03-09 07:13:52.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Schwab <schwab@gnu.org>.
 
@@ -20,6 +20,7 @@
 #include <sysdep.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
+#include <kernel-features.h>
 
 /* Clone the calling process, but without copying the whole address space.
    The calling process is suspended until the new process exits or is
@@ -33,25 +34,43 @@
 	/* Pop the return PC value into ECX.  */
 	popl	%ecx
 
+#ifdef SAVE_PID
+	SAVE_PID
+#endif
+
 	/* Stuff the syscall number in EAX and enter into the kernel.  */
 	movl	$SYS_ify (vfork), %eax
 	int	$0x80
+
+	/* Jump to the return PC.  Don't jump directly since this
+	   disturbs the branch target cache.  Instead push the return
+	   address back on the stack.  */
+	pushl	%ecx
+
+#ifdef RESTORE_PID
+	RESTORE_PID
+#endif
+
 	cmpl	$-4095, %eax
-	jae	.Lerror		/* Branch forward if it failed.  */
+	/* Branch forward if it failed.  */
+# ifdef __ASSUME_VFORK_SYSCALL
+	jae	SYSCALL_ERROR_LABEL
+.Lpseudo_end:
+# else
+	jae	.Lerror
+# endif
 
-	/* Jump to the return PC.  */
-	jmp	*%ecx
+	ret
 
+# ifndef __ASSUME_VFORK_SYSCALL
 .Lerror:
-	/* Push back the return PC.  */
-	pushl	%ecx
-
 	/* Check if vfork syscall is known at all.  */
 	cmpl	$-ENOSYS, %eax
 	jne	SYSCALL_ERROR_LABEL
-
+# endif
 #endif
 
+#ifndef __ASSUME_VFORK_SYSCALL
 	/* If we don't have vfork, fork is close enough.  */
 
 	movl	$SYS_ify (fork), %eax
@@ -60,7 +79,8 @@
 	jae	SYSCALL_ERROR_LABEL
 .Lpseudo_end:
 	ret
-
+#endif
 PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/i386/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/xstat.c
--- sysdeps/unix/sysv/linux/i386/xstat.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/i386/xstat.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,5 +1,5 @@
 /* xstat using old-style Unix stat system call.
-   Copyright (C) 1991,95,96,97,98,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,95,96,97,98,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,14 +32,9 @@
 
 #include "kernel-features.h"
 
-#include <xstatconv.c>
-
-extern int __syscall_stat (const char *__unbounded,
-			   struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 #ifdef __NR_stat64
-extern int __syscall_stat64 (const char *__unbounded,
-			     struct stat64 *__unbounded);
 # if __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.  */
 extern int __have_no_stat64;
@@ -65,7 +60,7 @@
 
     result = INLINE_SYSCALL (stat64, 2, CHECK_STRING (name), __ptrvalue (&buf64));
     if (result == 0)
-      result = xstat32_conv (vers, &buf64, buf);
+      result = __xstat32_conv (vers, &buf64, buf);
     return result;
   }
 #else
@@ -79,7 +74,7 @@
       result = INLINE_SYSCALL (stat64, 2, CHECK_STRING (name), __ptrvalue (&buf64));
 
       if (result == 0)
-	result = xstat32_conv (vers, &buf64, buf);
+	result = __xstat32_conv (vers, &buf64, buf);
 
       if (result != -1 || errno != ENOSYS)
 	return result;
@@ -89,7 +84,7 @@
 # endif
   result = INLINE_SYSCALL (stat, 2, CHECK_STRING (name), __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif  /* __ASSUME_STAT64_SYSCALL  */
diff -Nur sysdeps/unix/sysv/linux/ia64/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ia64/bits/fcntl.h
--- sysdeps/unix/sysv/linux/ia64/bits/fcntl.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ia64/bits/fcntl.h	2004-08-23 09:28:44.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux/IA64.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -43,8 +43,9 @@
 #define O_DIRECT	040000
 
 #ifdef __USE_GNU
-#define O_DIRECTORY	0200000	/* must be a directory */
-#define O_NOFOLLOW	0400000 /* don't follow links */
+# define O_DIRECTORY	0200000	/* must be a directory */
+# define O_NOFOLLOW	0400000 /* don't follow links */
+# define O_NOATIME	01000000 /* Do not set atime.  */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -75,7 +76,7 @@
 #define F_SETLK64	6	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	7	/* Set record locking info (blocking).	*/
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -169,6 +170,14 @@
 # define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
 # define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
 # define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
-# define POSIX_FADV_DONTNEED	6 /* Don't need these pages.  */
-# define POSIX_FADV_NOREUSE	7 /* Data will be accessed once.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/ifaddrs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifaddrs.c
--- sysdeps/unix/sysv/linux/ifaddrs.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifaddrs.c	2004-11-10 01:46:50.000000000 +0100
@@ -0,0 +1,786 @@
+/* getifaddrs -- get names and addresses of all network interfaces
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netpacket/packet.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "netlinkaccess.h"
+
+
+/* We don't know if we have NETLINK support compiled in in our
+   Kernel, so include the old implementation as fallback.  */
+#if __ASSUME_NETLINK_SUPPORT == 0
+int __no_netlink_support attribute_hidden;
+
+# define getifaddrs fallback_getifaddrs
+# include "sysdeps/gnu/ifaddrs.c"
+# undef getifaddrs
+#endif
+
+
+/* struct to hold the data for one ifaddrs entry, so we can allocate
+   everything at once.  */
+struct ifaddrs_storage
+{
+  struct ifaddrs ifa;
+  union
+  {
+    /* Save space for the biggest of the four used sockaddr types and
+       avoid a lot of casts.  */
+    struct sockaddr sa;
+    struct sockaddr_ll sl;
+    struct sockaddr_in s4;
+    struct sockaddr_in6 s6;
+  } addr, netmask, broadaddr;
+  char name[IF_NAMESIZE + 1];
+};
+
+
+void
+__netlink_free_handle (struct netlink_handle *h)
+{
+  struct netlink_res *ptr;
+  int saved_errno = errno;
+
+  ptr = h->nlm_list;
+  while (ptr != NULL)
+    {
+      struct netlink_res *tmpptr;
+
+      tmpptr = ptr->next;
+      free (ptr);
+      ptr = tmpptr;
+    }
+
+  __set_errno (saved_errno);
+}
+
+
+int
+__netlink_sendreq (struct netlink_handle *h, int type)
+{
+  struct
+  {
+    struct nlmsghdr nlh;
+    struct rtgenmsg g;
+  } req;
+  struct sockaddr_nl nladdr;
+
+  if (h->seq == 0)
+    h->seq = time (NULL);
+
+  req.nlh.nlmsg_len = sizeof (req);
+  req.nlh.nlmsg_type = type;
+  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+  req.nlh.nlmsg_pid = 0;
+  req.nlh.nlmsg_seq = h->seq;
+  req.g.rtgen_family = AF_UNSPEC;
+
+  memset (&nladdr, '\0', sizeof (nladdr));
+  nladdr.nl_family = AF_NETLINK;
+
+  return TEMP_FAILURE_RETRY (__sendto (h->fd, (void *) &req, sizeof (req), 0,
+				       (struct sockaddr *) &nladdr,
+				       sizeof (nladdr)));
+}
+
+
+int
+__netlink_receive (struct netlink_handle *h)
+{
+  struct netlink_res *nlm_next;
+  char buf[4096];
+  struct iovec iov = { buf, sizeof (buf) };
+  struct sockaddr_nl nladdr;
+  struct nlmsghdr *nlmh;
+  int read_len;
+  bool done = false;
+
+  while (! done)
+    {
+      struct msghdr msg =
+	{
+	  (void *) &nladdr, sizeof (nladdr),
+	  &iov, 1,
+	  NULL, 0,
+	  0
+	};
+
+      read_len = TEMP_FAILURE_RETRY (__recvmsg (h->fd, &msg, 0));
+      if (read_len < 0)
+	return -1;
+
+      if (msg.msg_flags & MSG_TRUNC)
+	return -1;
+
+      nlm_next = (struct netlink_res *) malloc (sizeof (struct netlink_res)
+						+ read_len);
+      if (nlm_next == NULL)
+	return -1;
+      nlm_next->next = NULL;
+      nlm_next->nlh = memcpy (nlm_next + 1, buf, read_len);
+      nlm_next->size = read_len;
+      nlm_next->seq = h->seq;
+      if (h->nlm_list == NULL)
+	h->nlm_list = nlm_next;
+      else
+	h->end_ptr->next = nlm_next;
+      h->end_ptr = nlm_next;
+
+      for (nlmh = (struct nlmsghdr *) buf;
+	   NLMSG_OK (nlmh, (size_t) read_len);
+	   nlmh = (struct nlmsghdr *) NLMSG_NEXT (nlmh, read_len))
+	{
+	  if (nladdr.nl_pid != 0 || (pid_t) nlmh->nlmsg_pid != h->pid
+	      || nlmh->nlmsg_seq != h->seq)
+	    continue;
+
+	  if (nlmh->nlmsg_type == NLMSG_DONE)
+	    {
+	      /* We found the end, leave the loop.  */
+	      done = true;
+	      break;
+	    }
+	  if (nlmh->nlmsg_type == NLMSG_ERROR)
+	    {
+	      struct nlmsgerr *nlerr = (struct nlmsgerr *) NLMSG_DATA (nlmh);
+	      if (nlmh->nlmsg_len < NLMSG_LENGTH (sizeof (struct nlmsgerr)))
+		errno = EIO;
+	      else
+		errno = -nlerr->error;
+	      return -1;
+	    }
+	}
+    }
+  return 0;
+}
+
+
+void
+__netlink_close (struct netlink_handle *h)
+{
+  /* Don't modify errno.  */
+  INTERNAL_SYSCALL_DECL (err);
+  (void) INTERNAL_SYSCALL (close, err, 1, h->fd);
+}
+
+
+/* Open a NETLINK socket.  */
+int
+__netlink_open (struct netlink_handle *h)
+{
+  struct sockaddr_nl nladdr;
+
+  h->fd = __socket (PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+  if (h->fd < 0)
+    goto out;
+
+  memset (&nladdr, '\0', sizeof (nladdr));
+  nladdr.nl_family = AF_NETLINK;
+  if (__bind (h->fd, (struct sockaddr *) &nladdr, sizeof (nladdr)) < 0)
+    {
+    close_and_out:
+      __netlink_close (h);
+    out:
+#if __ASSUME_NETLINK_SUPPORT == 0
+      __no_netlink_support = 1;
+#endif
+      return -1;
+    }
+  /* Determine the ID the kernel assigned for this netlink connection.
+     It is not necessarily the PID if there is more than one socket
+     open.  */
+  socklen_t addr_len = sizeof (nladdr);
+  if (__getsockname (h->fd, (struct sockaddr *) &nladdr, &addr_len) < 0)
+    goto close_and_out;
+  h->pid = nladdr.nl_pid;
+  return 0;
+}
+
+
+/* We know the number of RTM_NEWLINK entries, so we reserve the first
+   # of entries for this type. All RTM_NEWADDR entries have an index
+   pointer to the RTM_NEWLINK entry.  To find the entry, create
+   a table to map kernel index entries to our index numbers.
+   Since we get at first all RTM_NEWLINK entries, it can never happen
+   that a RTM_NEWADDR index is not known to this map.  */
+static int
+internal_function
+map_newlink (int index, struct ifaddrs_storage *ifas, int *map, int max)
+{
+  int i;
+
+  for (i = 0; i < max; i++)
+    {
+      if (map[i] == -1)
+	{
+	  map[i] = index;
+	  if (i > 0)
+	    ifas[i - 1].ifa.ifa_next = &ifas[i].ifa;
+	  return i;
+	}
+      else if (map[i] == index)
+	return i;
+    }
+  /* This should never be reached. If this will be reached, we have
+     a very big problem.  */
+  abort ();
+}
+
+
+/* Create a linked list of `struct ifaddrs' structures, one for each
+   network interface on the host machine.  If successful, store the
+   list in *IFAP and return 0.  On errors, return -1 and set `errno'.  */
+int
+getifaddrs (struct ifaddrs **ifap)
+{
+  struct netlink_handle nh = { 0, 0, 0, NULL, NULL };
+  struct netlink_res *nlp;
+  struct ifaddrs_storage *ifas;
+  unsigned int i, newlink, newaddr, newaddr_idx;
+  int *map_newlink_data;
+  size_t ifa_data_size = 0;  /* Size to allocate for all ifa_data.  */
+  char *ifa_data_ptr;        /* Pointer to the unused part of memory for
+				ifa_data.  */
+  int result = 0;
+
+  if (ifap)
+    *ifap = NULL;
+
+  if (! __no_netlink_support && __netlink_open (&nh) < 0)
+    {
+#if __ASSUME_NETLINK_SUPPORT != 0
+      return -1;
+#endif
+    }
+
+#if __ASSUME_NETLINK_SUPPORT == 0
+  if (__no_netlink_support)
+    return fallback_getifaddrs (ifap);
+#endif
+
+  /* Tell the kernel that we wish to get a list of all
+     active interfaces.  */
+  if (__netlink_sendreq (&nh, RTM_GETLINK) < 0)
+    {
+      result = -1;
+      goto exit_close;
+    }
+  /* Collect all data for every interface.  */
+  if (__netlink_receive (&nh) < 0)
+    {
+      result = -1;
+      goto exit_free;
+    }
+
+
+  /* Now ask the kernel for all addresses which are assigned
+     to an interface.  Since we store the addresses after the
+     interfaces in the list, we will later always find the
+     interface before the corresponding addresses.  */
+  ++nh.seq;
+  if (__netlink_sendreq (&nh, RTM_GETADDR) < 0
+      /* Collect all data for every interface.  */
+      || __netlink_receive (&nh) < 0)
+    {
+      result = -1;
+      goto exit_free;
+    }
+
+  /* Count all RTM_NEWLINK and RTM_NEWADDR entries to allocate
+     enough memory.  */
+  newlink = newaddr = 0;
+  for (nlp = nh.nlm_list; nlp; nlp = nlp->next)
+    {
+      struct nlmsghdr *nlh;
+      size_t size = nlp->size;
+
+      if (nlp->nlh == NULL)
+	continue;
+
+      /* Walk through all entries we got from the kernel and look, which
+         message type they contain.  */
+      for (nlh = nlp->nlh; NLMSG_OK (nlh, size); nlh = NLMSG_NEXT (nlh, size))
+	{
+	  /* Check if the message is what we want.  */
+	  if ((pid_t) nlh->nlmsg_pid != nh.pid || nlh->nlmsg_seq != nlp->seq)
+	    continue;
+
+	  if (nlh->nlmsg_type == NLMSG_DONE)
+	    break;		/* ok */
+
+	  if (nlh->nlmsg_type == RTM_NEWLINK)
+	    {
+	      /* A RTM_NEWLINK message can have IFLA_STATS data. We need to
+		 know the size before creating the list to allocate enough
+		 memory.  */
+	      struct ifinfomsg *ifim = (struct ifinfomsg *) NLMSG_DATA (nlh);
+	      struct rtattr *rta = IFLA_RTA (ifim);
+	      size_t rtasize = IFLA_PAYLOAD (nlh);
+
+	      while (RTA_OK (rta, rtasize))
+		{
+		  size_t rta_payload = RTA_PAYLOAD (rta);
+
+		  if (rta->rta_type == IFLA_STATS)
+		    {
+		      ifa_data_size += rta_payload;
+		      break;
+		    }
+		  else
+		    rta = RTA_NEXT (rta, rtasize);
+		}
+	      ++newlink;
+	    }
+	  else if (nlh->nlmsg_type == RTM_NEWADDR)
+	    ++newaddr;
+	}
+    }
+
+  /* Return if no interface is up.  */
+  if ((newlink + newaddr) == 0)
+    goto exit_free;
+
+  /* Allocate memory for all entries we have and initialize next
+     pointer.  */
+  ifas = (struct ifaddrs_storage *) calloc (1,
+					    (newlink + newaddr)
+					    * sizeof (struct ifaddrs_storage)
+					    + ifa_data_size);
+  if (ifas == NULL)
+    {
+      result = -1;
+      goto exit_free;
+    }
+
+  /* Table for mapping kernel index to entry in our list.  */
+  map_newlink_data = alloca (newlink * sizeof (int));
+  memset (map_newlink_data, '\xff', newlink * sizeof (int));
+
+  ifa_data_ptr = (char *) &ifas[newlink + newaddr];
+  newaddr_idx = 0;		/* Counter for newaddr index.  */
+
+  /* Walk through the list of data we got from the kernel.  */
+  for (nlp = nh.nlm_list; nlp; nlp = nlp->next)
+    {
+      struct nlmsghdr *nlh;
+      size_t size = nlp->size;
+
+      if (nlp->nlh == NULL)
+	continue;
+
+      /* Walk through one message and look at the type: If it is our
+	 message, we need RTM_NEWLINK/RTM_NEWADDR and stop if we reach
+	 the end or we find the end marker (in this case we ignore the
+	 following data.  */
+      for (nlh = nlp->nlh; NLMSG_OK (nlh, size); nlh = NLMSG_NEXT (nlh, size))
+	{
+	  int ifa_index = 0;
+
+	  /* Check if the message is the one we want */
+	  if ((pid_t) nlh->nlmsg_pid != nh.pid || nlh->nlmsg_seq != nlp->seq)
+	    continue;
+
+	  if (nlh->nlmsg_type == NLMSG_DONE)
+	    break;		/* ok */
+
+	  if (nlh->nlmsg_type == RTM_NEWLINK)
+	    {
+	      /* We found a new interface. Now extract everything from the
+		 interface data we got and need.  */
+	      struct ifinfomsg *ifim = (struct ifinfomsg *) NLMSG_DATA (nlh);
+	      struct rtattr *rta = IFLA_RTA (ifim);
+	      size_t rtasize = IFLA_PAYLOAD (nlh);
+
+	      /* Interfaces are stored in the first "newlink" entries
+		 of our list, starting in the order as we got from the
+		 kernel.  */
+              ifa_index = map_newlink (ifim->ifi_index - 1, ifas,
+				       map_newlink_data, newlink);
+	      ifas[ifa_index].ifa.ifa_flags = ifim->ifi_flags;
+
+	      while (RTA_OK (rta, rtasize))
+		{
+		  char *rta_data = RTA_DATA (rta);
+		  size_t rta_payload = RTA_PAYLOAD (rta);
+
+		  switch (rta->rta_type)
+		    {
+		    case IFLA_ADDRESS:
+		      if (rta_payload <= sizeof (ifas[ifa_index].addr))
+			{
+			  ifas[ifa_index].addr.sl.sll_family = AF_PACKET;
+			  memcpy (ifas[ifa_index].addr.sl.sll_addr,
+				  (char *) rta_data, rta_payload);
+			  ifas[ifa_index].addr.sl.sll_halen = rta_payload;
+			  ifas[ifa_index].addr.sl.sll_ifindex
+			    = ifim->ifi_index;
+			  ifas[ifa_index].addr.sl.sll_hatype = ifim->ifi_type;
+
+			  ifas[ifa_index].ifa.ifa_addr
+			    = &ifas[ifa_index].addr.sa;
+			}
+		      break;
+
+		    case IFLA_BROADCAST:
+		      if (rta_payload <= sizeof (ifas[ifa_index].broadaddr))
+			{
+			  ifas[ifa_index].broadaddr.sl.sll_family = AF_PACKET;
+			  memcpy (ifas[ifa_index].broadaddr.sl.sll_addr,
+				  (char *) rta_data, rta_payload);
+			  ifas[ifa_index].broadaddr.sl.sll_halen = rta_payload;
+			  ifas[ifa_index].broadaddr.sl.sll_ifindex
+			    = ifim->ifi_index;
+			  ifas[ifa_index].broadaddr.sl.sll_hatype
+			    = ifim->ifi_type;
+
+			  ifas[ifa_index].ifa.ifa_broadaddr
+			    = &ifas[ifa_index].broadaddr.sa;
+			}
+		      break;
+
+		    case IFLA_IFNAME:	/* Name of Interface */
+		      if ((rta_payload + 1) <= sizeof (ifas[ifa_index].name))
+			{
+			  ifas[ifa_index].ifa.ifa_name = ifas[ifa_index].name;
+			  *(char *) __mempcpy (ifas[ifa_index].name, rta_data,
+					       rta_payload) = '\0';
+			}
+		      break;
+
+		    case IFLA_STATS:	/* Statistics of Interface */
+		      ifas[ifa_index].ifa.ifa_data = ifa_data_ptr;
+		      ifa_data_ptr += rta_payload;
+		      memcpy (ifas[ifa_index].ifa.ifa_data, rta_data,
+			      rta_payload);
+		      break;
+
+		    case IFLA_UNSPEC:
+		      break;
+		    case IFLA_MTU:
+		      break;
+		    case IFLA_LINK:
+		      break;
+		    case IFLA_QDISC:
+		      break;
+		    default:
+		      break;
+		    }
+
+		  rta = RTA_NEXT (rta, rtasize);
+		}
+	    }
+	  else if (nlh->nlmsg_type == RTM_NEWADDR)
+	    {
+	      struct ifaddrmsg *ifam = (struct ifaddrmsg *) NLMSG_DATA (nlh);
+	      struct rtattr *rta = IFA_RTA (ifam);
+	      size_t rtasize = IFA_PAYLOAD (nlh);
+
+	      /* New Addresses are stored in the order we got them from
+		 the kernel after the interfaces. Theoretically it is possible
+		 that we have holes in the interface part of the list,
+		 but we always have already the interface for this address.  */
+	      ifa_index = newlink + newaddr_idx;
+	      ifas[ifa_index].ifa.ifa_flags
+		= ifas[map_newlink (ifam->ifa_index - 1, ifas,
+				    map_newlink_data, newlink)].ifa.ifa_flags;
+	      if (ifa_index > 0)
+		ifas[ifa_index - 1].ifa.ifa_next = &ifas[ifa_index].ifa;
+	      ++newaddr_idx;
+
+	      while (RTA_OK (rta, rtasize))
+		{
+		  char *rta_data = RTA_DATA (rta);
+		  size_t rta_payload = RTA_PAYLOAD (rta);
+
+		  switch (rta->rta_type)
+		    {
+		    case IFA_ADDRESS:
+		      {
+			struct sockaddr *sa;
+
+			if (ifas[ifa_index].ifa.ifa_addr != NULL)
+			  {
+			    /* In a point-to-poing network IFA_ADDRESS
+			       contains the destination address, local
+			       address is supplied in IFA_LOCAL attribute.
+			       destination address and broadcast address
+			       are stored in an union, so it doesn't matter
+			       which name we use.  */
+			    ifas[ifa_index].ifa.ifa_broadaddr
+			      = &ifas[ifa_index].broadaddr.sa;
+			    sa = &ifas[ifa_index].broadaddr.sa;
+			  }
+			else
+			  {
+			    ifas[ifa_index].ifa.ifa_addr
+			      = &ifas[ifa_index].addr.sa;
+			    sa = &ifas[ifa_index].addr.sa;
+			  }
+
+			sa->sa_family = ifam->ifa_family;
+
+			switch (ifam->ifa_family)
+			  {
+			  case AF_INET:
+			    /* Size must match that of an address for IPv4.  */
+			    if (rta_payload == 4)
+			      memcpy (&((struct sockaddr_in *) sa)->sin_addr,
+				      rta_data, rta_payload);
+			    break;
+
+			  case AF_INET6:
+			    /* Size must match that of an address for IPv6.  */
+			    if (rta_payload == 16)
+			      {
+				memcpy (&((struct sockaddr_in6 *) sa)->sin6_addr,
+					rta_data, rta_payload);
+				if (IN6_IS_ADDR_LINKLOCAL (rta_data)
+				    || IN6_IS_ADDR_MC_LINKLOCAL (rta_data))
+				  ((struct sockaddr_in6 *) sa)->sin6_scope_id
+				    = ifam->ifa_index;
+			      }
+			    break;
+
+			  default:
+			    if (rta_payload <= sizeof (ifas[ifa_index].addr))
+			      memcpy (sa->sa_data, rta_data, rta_payload);
+			    break;
+			  }
+		      }
+		      break;
+
+		    case IFA_LOCAL:
+		      if (ifas[ifa_index].ifa.ifa_addr != NULL)
+			{
+			  /* If ifa_addr is set and we get IFA_LOCAL,
+			     assume we have a point-to-point network.
+			     Move address to correct field.  */
+			  ifas[ifa_index].broadaddr = ifas[ifa_index].addr;
+			  ifas[ifa_index].ifa.ifa_broadaddr
+			    = &ifas[ifa_index].broadaddr.sa;
+			  memset (&ifas[ifa_index].addr, '\0',
+				  sizeof (ifas[ifa_index].addr));
+			}
+
+		      ifas[ifa_index].ifa.ifa_addr = &ifas[ifa_index].addr.sa;
+		      ifas[ifa_index].ifa.ifa_addr->sa_family
+			= ifam->ifa_family;
+
+		      switch (ifam->ifa_family)
+			{
+			case AF_INET:
+			  /* Size must match that of an address for IPv4.  */
+			  if (rta_payload == 4)
+			    memcpy (&ifas[ifa_index].addr.s4.sin_addr,
+				  rta_data, rta_payload);
+			  break;
+
+			case AF_INET6:
+			  /* Size must match that of an address for IPv6.  */
+			  if (rta_payload == 16)
+			    {
+			      memcpy (&ifas[ifa_index].addr.s6.sin6_addr,
+				      rta_data, rta_payload);
+			      if (IN6_IS_ADDR_LINKLOCAL (rta_data)
+				  || IN6_IS_ADDR_MC_LINKLOCAL (rta_data))
+				ifas[ifa_index].addr.s6.sin6_scope_id =
+				  ifam->ifa_index;
+			    }
+			  break;
+
+			default:
+			  if (rta_payload <= sizeof (ifas[ifa_index].addr))
+			    memcpy (ifas[ifa_index].addr.sa.sa_data,
+				    rta_data, rta_payload);
+			  break;
+			}
+		      break;
+
+		    case IFA_BROADCAST:
+		      /* We get IFA_BROADCAST, so IFA_LOCAL was too much.  */
+		      if (ifas[ifa_index].ifa.ifa_broadaddr != NULL)
+			memset (&ifas[ifa_index].broadaddr, '\0',
+				sizeof (ifas[ifa_index].broadaddr));
+
+		      ifas[ifa_index].ifa.ifa_broadaddr
+			= &ifas[ifa_index].broadaddr.sa;
+		      ifas[ifa_index].ifa.ifa_broadaddr->sa_family
+			= ifam->ifa_family;
+
+		      switch (ifam->ifa_family)
+			{
+			case AF_INET:
+			  /* Size must match that of an address for IPv4.  */
+			  if (rta_payload == 4)
+			    memcpy (&ifas[ifa_index].broadaddr.s4.sin_addr,
+				    rta_data, rta_payload);
+			  break;
+
+			case AF_INET6:
+			  /* Size must match that of an address for IPv6.  */
+			  if (rta_payload == 16)
+			    {
+			      memcpy (&ifas[ifa_index].broadaddr.s6.sin6_addr,
+				      rta_data, rta_payload);
+			      if (IN6_IS_ADDR_LINKLOCAL (rta_data)
+				  || IN6_IS_ADDR_MC_LINKLOCAL (rta_data))
+				ifas[ifa_index].broadaddr.s6.sin6_scope_id
+				  = ifam->ifa_index;
+			    }
+			  break;
+
+			default:
+			  if (rta_payload <= sizeof (ifas[ifa_index].addr))
+			    memcpy (&ifas[ifa_index].broadaddr.sa.sa_data,
+				    rta_data, rta_payload);
+			  break;
+			}
+		      break;
+
+		    case IFA_LABEL:
+		      if (rta_payload + 1 <= sizeof (ifas[ifa_index].name))
+			{
+			  ifas[ifa_index].ifa.ifa_name = ifas[ifa_index].name;
+			  *(char *) __mempcpy (ifas[ifa_index].name, rta_data,
+					       rta_payload) = '\0';
+			}
+		      else
+			abort ();
+		      break;
+
+		    case IFA_UNSPEC:
+		      break;
+		    case IFA_CACHEINFO:
+		      break;
+		    default:
+		      break;
+		    }
+
+		  rta = RTA_NEXT (rta, rtasize);
+		}
+
+	      /* If we didn't get the interface name with the
+		 address, use the name from the interface entry.  */
+	      if (ifas[ifa_index].ifa.ifa_name == NULL)
+		ifas[ifa_index].ifa.ifa_name
+		  = ifas[map_newlink (ifam->ifa_index - 1, ifas,
+				      map_newlink_data, newlink)].ifa.ifa_name;
+
+	      /* Calculate the netmask.  */
+	      if (ifas[ifa_index].ifa.ifa_addr
+		  && ifas[ifa_index].ifa.ifa_addr->sa_family != AF_UNSPEC
+		  && ifas[ifa_index].ifa.ifa_addr->sa_family != AF_PACKET)
+		{
+		  uint32_t max_prefixlen = 0;
+		  char *cp = NULL;
+
+		  ifas[ifa_index].ifa.ifa_netmask
+		    = &ifas[ifa_index].netmask.sa;
+
+		  switch (ifas[ifa_index].ifa.ifa_addr->sa_family)
+		    {
+		    case AF_INET:
+		      cp = (char *) &ifas[ifa_index].netmask.s4.sin_addr;
+		      max_prefixlen = 32;
+		      break;
+
+		    case AF_INET6:
+		      cp = (char *) &ifas[ifa_index].netmask.s6.sin6_addr;
+		      max_prefixlen = 128;
+		      break;
+		    }
+
+		  ifas[ifa_index].ifa.ifa_netmask->sa_family
+		    = ifas[ifa_index].ifa.ifa_addr->sa_family;
+
+		  if (cp != NULL)
+		    {
+		      char c;
+		      unsigned int preflen;
+
+		      if ((max_prefixlen > 0) &&
+			  (ifam->ifa_prefixlen > max_prefixlen))
+			preflen = max_prefixlen;
+		      else
+			preflen = ifam->ifa_prefixlen;
+
+		      for (i = 0; i < (preflen / 8); i++)
+			*cp++ = 0xff;
+		      c = 0xff;
+		      c <<= (8 - (preflen % 8));
+		      *cp = c;
+		    }
+		}
+	    }
+	}
+    }
+
+  assert (ifa_data_ptr <= (char *) &ifas[newlink + newaddr] + ifa_data_size);
+
+  if (newaddr_idx > 0)
+    {
+      for (i = 0; i < newlink; ++i)
+	if (map_newlink_data[i] == -1)
+	  {
+	    /* We have fewer links then we anticipated.  Adjust the
+	       forward pointer to the first address entry.  */
+	    ifas[i - 1].ifa.ifa_next = &ifas[newlink].ifa;
+	  }
+
+      if (i == 0 && newlink > 0)
+	/* No valid link, but we allocated memory.  We have to
+	   populate the first entry.  */
+	memmove (ifas, &ifas[newlink], sizeof (struct ifaddrs_storage));
+    }
+
+  if (ifap != NULL)
+    *ifap = &ifas[0].ifa;
+
+ exit_free:
+  __netlink_free_handle (&nh);
+
+ exit_close:
+  __netlink_close (&nh);
+
+  return result;
+}
+libc_hidden_def (getifaddrs)
+
+
+#if __ASSUME_NETLINK_SUPPORT != 0
+void
+freeifaddrs (struct ifaddrs *ifa)
+{
+  free (ifa);
+}
+libc_hidden_def (freeifaddrs)
+#endif
diff -Nur sysdeps/unix/sysv/linux/if_index.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/if_index.c
--- sysdeps/unix/sysv/linux/if_index.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/if_index.c	2004-06-30 09:42:42.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997,98,99,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1997,98,99,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,6 +16,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <alloca.h>
 #include <errno.h>
 #include <string.h>
 #include <stdio.h>
@@ -25,11 +26,13 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <bits/libc-lock.h>
+#include <not-cancel.h>
+
+#include "netlinkaccess.h"
 
-#include "kernel-features.h"
 
 /* Variable to signal whether SIOCGIFCONF is not available.  */
-#if __ASSUME_SIOCGIFNAME == 0
+# if __ASSUME_SIOCGIFNAME == 0
 static int old_siocgifconf;
 #else
 # define old_siocgifconf 0
@@ -53,12 +56,12 @@
   if (__ioctl (fd, SIOCGIFINDEX, &ifr) < 0)
     {
       int saved_errno = errno;
-      __close (fd);
+      close_not_cancel_no_status (fd);
       if (saved_errno == EINVAL)
 	__set_errno (ENOSYS);
       return 0;
     }
-  __close (fd);
+  close_not_cancel_no_status (fd);
   return ifr.ifr_ifindex;
 #endif
 }
@@ -71,20 +74,18 @@
   struct if_nameindex *ptr = ifn;
   while (ptr->if_name || ptr->if_index)
     {
-      if (ptr->if_name)
-	free (ptr->if_name);
+      free (ptr->if_name);
       ++ptr;
     }
   free (ifn);
 }
+libc_hidden_def (if_freenameindex)
 
-struct if_nameindex *
-if_nameindex (void)
+
+#if __ASSUME_NETLINK_SUPPORT == 0
+static struct if_nameindex *
+if_nameindex_ioctl (void)
 {
-#ifndef SIOCGIFINDEX
-  __set_errno (ENOSYS);
-  return NULL;
-#else
   int fd = __opensock ();
   struct ifconf ifc;
   unsigned int nifs, i;
@@ -117,24 +118,28 @@
     rq_len = RQ_IFS * sizeof (struct ifreq);
 
   /* Read all the interfaces out of the kernel.  */
-  do
+  ifc.ifc_buf = alloca (rq_len);
+  ifc.ifc_len = rq_len;
+  while (1)
     {
-      ifc.ifc_buf = alloca (ifc.ifc_len = rq_len);
-      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+        if (__ioctl (fd, SIOCGIFCONF, &ifc) < 0)
 	{
-	  __close (fd);
+	  close_not_cancel_no_status (fd);
 	  return NULL;
 	}
-      rq_len *= 2;
+      if (ifc.ifc_len < rq_len || ! old_siocgifconf)
+	break;
+
+      ifc.ifc_buf = extend_alloca (ifc.ifc_buf, rq_len, 2 * rq_len);
+      ifc.ifc_len = rq_len;
     }
-  while (ifc.ifc_len == rq_len && old_siocgifconf);
 
   nifs = ifc.ifc_len / sizeof (struct ifreq);
 
   idx = malloc ((nifs + 1) * sizeof (struct if_nameindex));
   if (idx == NULL)
     {
-      __close (fd);
+      close_not_cancel_no_status (fd);
       __set_errno (ENOBUFS);
       return NULL;
     }
@@ -152,7 +157,7 @@
 	  for (j =  0; j < i; ++j)
 	    free (idx[j].if_name);
 	  free (idx);
-	  __close (fd);
+	  close_not_cancel_no_status (fd);
 	  if (saved_errno == EINVAL)
 	    saved_errno = ENOSYS;
 	  else if (saved_errno == ENOMEM)
@@ -166,11 +171,150 @@
   idx[i].if_index = 0;
   idx[i].if_name = NULL;
 
-  __close (fd);
+  close_not_cancel_no_status (fd);
   return idx;
+}
 #endif
+
+
+static struct if_nameindex *
+if_nameindex_netlink (void)
+{
+  struct netlink_handle nh = { 0, 0, 0, NULL, NULL };
+  struct if_nameindex *idx = NULL;
+
+  if (__no_netlink_support || __netlink_open (&nh) < 0)
+    return NULL;
+
+
+  /* Tell the kernel that we wish to get a list of all
+     active interfaces.  */
+  if (__netlink_sendreq (&nh, RTM_GETLINK) < 0)
+    goto exit_close;
+
+  /* Collect all data for every interface.  */
+  if (__netlink_receive (&nh) < 0)
+    goto exit_free;
+
+  /* Count the interfaces.  */
+  unsigned int nifs = 0;
+  for (struct netlink_res *nlp = nh.nlm_list; nlp; nlp = nlp->next)
+    {
+      struct nlmsghdr *nlh;
+      size_t size = nlp->size;
+
+      if (nlp->nlh == NULL)
+	continue;
+
+      /* Walk through all entries we got from the kernel and look, which
+         message type they contain.  */
+      for (nlh = nlp->nlh; NLMSG_OK (nlh, size); nlh = NLMSG_NEXT (nlh, size))
+	{
+	  /* Check if the message is what we want.  */
+	  if ((pid_t) nlh->nlmsg_pid != nh.pid || nlh->nlmsg_seq != nlp->seq)
+	    continue;
+
+	  if (nlh->nlmsg_type == NLMSG_DONE)
+	    break;		/* ok */
+
+	  if (nlh->nlmsg_type == RTM_NEWLINK)
+	    ++nifs;
+	}
+    }
+
+  idx = malloc ((nifs + 1) * sizeof (struct if_nameindex));
+  if (idx == NULL)
+    {
+    nomem:
+      __set_errno (ENOBUFS);
+      goto exit_free;
+    }
+
+  /* Add the interfaces.  */
+  nifs = 0;
+  for (struct netlink_res *nlp = nh.nlm_list; nlp; nlp = nlp->next)
+    {
+      struct nlmsghdr *nlh;
+      size_t size = nlp->size;
+
+      if (nlp->nlh == NULL)
+	continue;
+
+      /* Walk through all entries we got from the kernel and look, which
+         message type they contain.  */
+      for (nlh = nlp->nlh; NLMSG_OK (nlh, size); nlh = NLMSG_NEXT (nlh, size))
+	{
+	  /* Check if the message is what we want.  */
+	  if ((pid_t) nlh->nlmsg_pid != nh.pid || nlh->nlmsg_seq != nlp->seq)
+	    continue;
+
+	  if (nlh->nlmsg_type == NLMSG_DONE)
+	    break;		/* ok */
+
+	  if (nlh->nlmsg_type == RTM_NEWLINK)
+	    {
+	      struct ifinfomsg *ifim = (struct ifinfomsg *) NLMSG_DATA (nlh);
+	      struct rtattr *rta = IFLA_RTA (ifim);
+	      size_t rtasize = IFLA_PAYLOAD (nlh);
+
+	      idx[nifs].if_index = ifim->ifi_index;
+
+	      while (RTA_OK (rta, rtasize))
+		{
+		  char *rta_data = RTA_DATA (rta);
+		  size_t rta_payload = RTA_PAYLOAD (rta);
+
+		  if (rta->rta_type == IFLA_IFNAME)
+		    {
+		      idx[nifs].if_name = __strndup (rta_data, rta_payload);
+		      if (idx[nifs].if_name == NULL)
+			{
+			  idx[nifs].if_index = 0;
+			  if_freenameindex (idx);
+			  idx = NULL;
+			  goto nomem;
+			}
+		      break;
+		    }
+
+		  rta = RTA_NEXT (rta, rtasize);
+		}
+
+	      ++nifs;
+	    }
+	}
+    }
+
+  idx[nifs].if_index = 0;
+  idx[nifs].if_name = NULL;
+
+ exit_free:
+  __netlink_free_handle (&nh);
+ exit_close:
+  __netlink_close (&nh);
+
+  return idx;
 }
 
+
+struct if_nameindex *
+if_nameindex (void)
+{
+#ifndef SIOCGIFINDEX
+  __set_errno (ENOSYS);
+  return NULL;
+#else
+  struct if_nameindex *result = if_nameindex_netlink ();
+# if __ASSUME_NETLINK_SUPPORT == 0
+  if (__no_netlink_support)
+    result = if_nameindex_ioctl ();
+# endif
+  return result;
+#endif
+}
+libc_hidden_def (if_nameindex)
+
+
 char *
 if_indextoname (unsigned int ifindex, char *ifname)
 {
@@ -208,20 +352,28 @@
       ifr.ifr_ifindex = ifindex;
       status = __ioctl (fd, SIOCGIFNAME, &ifr);
 
-      __close (fd);
+      close_not_cancel_no_status (fd);
 
-#  if __ASSUME_SIOCGIFNAME == 0
       if (status  < 0)
 	{
+#  if __ASSUME_SIOCGIFNAME == 0
 	  if (errno == EINVAL)
 	    siocgifname_works_not = 1; /* Don't make the same mistake twice. */
+	  else
+#  endif
+	    {
+	      if (errno == ENODEV)
+		/* POSIX requires ENXIO.  */
+		__set_errno (ENXIO);
+
+	      return NULL;
+	    }
 	}
       else
 	return strncpy (ifname, ifr.ifr_name, IFNAMSIZ);
 
+#  if __ASSUME_SIOCGIFNAME == 0
       __set_errno (serrno);
-#  else
-      return status < 0 ? NULL : strncpy (ifname, ifr.ifr_name, IFNAMSIZ);
 #  endif
     }
 # endif
@@ -239,6 +391,9 @@
 	  }
 
       if_freenameindex (idx);
+
+      if (result == NULL)
+	__set_errno (ENXIO);
     }
   return result;
 # endif
@@ -246,6 +401,7 @@
 }
 libc_hidden_def (if_indextoname)
 
+
 #if 0
 void
 internal_function
@@ -288,9 +444,9 @@
   do
     {
       ifc.ifc_buf = alloca (ifc.ifc_len = rq_len);
-      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+      if (__ioctl (fd, SIOCGIFCONF, &ifc) < 0)
 	{
-	  __close (fd);
+	  close_not_cancel_no_status (fd);
 	  return;
 	}
       rq_len *= 2;
@@ -317,6 +473,6 @@
 	  break;
       }
 
-  __close (fd);
+  close_not_cancel_no_status (fd);
 }
 #endif
diff -Nur sysdeps/unix/sysv/linux/ifreq.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifreq.c
--- sysdeps/unix/sysv/linux/ifreq.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifreq.c	2004-07-26 17:21:30.000000000 +0200
@@ -0,0 +1,100 @@
+/* Copyright (C) 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "ifreq.h"
+
+/* Variable to signal whether SIOCGIFCONF is not available.  */
+#if __ASSUME_SIOCGIFNAME == 0 || 1
+static int old_siocgifconf;
+#else
+# define old_siocgifconf 0
+#endif
+
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  int fd = sockfd;
+  struct ifconf ifc;
+  int rq_len;
+  int nifs;
+# define RQ_IFS	4
+
+  if (fd < 0)
+    fd = __opensock ();
+  if (fd < 0)
+    {
+      *num_ifs = 0;
+      *ifreqs = NULL;
+      return;
+    }
+
+  ifc.ifc_buf = NULL;
+
+  /* We may be able to get the needed buffer size directly, rather than
+     guessing.  */
+  if (! old_siocgifconf)
+    {
+      ifc.ifc_buf = NULL;
+      ifc.ifc_len = 0;
+      if (__ioctl (fd, SIOCGIFCONF, &ifc) < 0 || ifc.ifc_len == 0)
+	{
+# if __ASSUME_SIOCGIFNAME == 0
+	  old_siocgifconf = 1;
+# endif
+	  rq_len = RQ_IFS * sizeof (struct ifreq);
+	}
+      else
+	rq_len = ifc.ifc_len;
+    }
+  else
+    rq_len = RQ_IFS * sizeof (struct ifreq);
+
+  /* Read all the interfaces out of the kernel.  */
+  while (1)
+    {
+      ifc.ifc_len = rq_len;
+      void *newp = realloc (ifc.ifc_buf, ifc.ifc_len);
+      if (newp == NULL
+	  || (ifc.ifc_buf = newp, __ioctl (fd, SIOCGIFCONF, &ifc)) < 0)
+	{
+	  free (ifc.ifc_buf);
+
+	  if (fd != sockfd)
+	    __close (fd);
+
+	  *num_ifs = 0;
+	  *ifreqs = NULL;
+	  return;
+	}
+
+      if (!old_siocgifconf || ifc.ifc_len < rq_len)
+	break;
+
+      rq_len *= 2;
+    }
+
+  nifs = ifc.ifc_len / sizeof (struct ifreq);
+
+  if (fd != sockfd)
+    __close (fd);
+
+  *num_ifs = nifs;
+  *ifreqs = realloc (ifc.ifc_buf, nifs * sizeof (struct ifreq));
+}
diff -Nur sysdeps/unix/sysv/linux/ifreq.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifreq.h
--- sysdeps/unix/sysv/linux/ifreq.h	2002-09-21 02:28:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ifreq.h	2003-06-13 23:02:39.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>.
 
@@ -25,85 +25,8 @@
 #include <sys/ioctl.h>
 #include "kernel-features.h"
 
-/* Variable to signal whether SIOCGIFCONF is not available.  */
-#if __ASSUME_SIOCGIFNAME == 0 || 1
-static int old_siocgifconf;
-#else
-# define old_siocgifconf 0
-#endif
 
-
-static inline void
-__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
-{
-  int fd = sockfd;
-  struct ifconf ifc;
-  int rq_len;
-  int nifs;
-# define RQ_IFS	4
-
-  if (fd < 0)
-    fd = __opensock ();
-  if (fd < 0)
-    {
-      *num_ifs = 0;
-      *ifreqs = NULL;
-      return;
-    }
-
-  ifc.ifc_buf = NULL;
-
-  /* We may be able to get the needed buffer size directly, rather than
-     guessing.  */
-  if (! old_siocgifconf)
-    {
-      ifc.ifc_buf = NULL;
-      ifc.ifc_len = 0;
-      if (__ioctl (fd, SIOCGIFCONF, &ifc) < 0 || ifc.ifc_len == 0)
-	{
-# if __ASSUME_SIOCGIFNAME == 0
-	  old_siocgifconf = 1;
-# endif
-	  rq_len = RQ_IFS * sizeof (struct ifreq);
-	}
-      else
-	rq_len = ifc.ifc_len;
-    }
-  else
-    rq_len = RQ_IFS * sizeof (struct ifreq);
-
-  /* Read all the interfaces out of the kernel.  */
-  while (1)
-    {
-      ifc.ifc_len = rq_len;
-      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
-      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
-	{
-	  if (ifc.ifc_buf)
-	    free (ifc.ifc_buf);
-
-	  if (fd != sockfd)
-	    __close (fd);
-
-	  *num_ifs = 0;
-	  *ifreqs = NULL;
-	  return;
-	}
-
-      if (!old_siocgifconf || ifc.ifc_len < rq_len)
-	break;
-
-      rq_len *= 2;
-    }
-
-  nifs = ifc.ifc_len / sizeof (struct ifreq);
-
-  if (fd != sockfd)
-    __close (fd);
-
-  *num_ifs = nifs;
-  *ifreqs = realloc (ifc.ifc_buf, nifs * sizeof (struct ifreq));
-}
+extern void __ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd);
 
 static inline struct ifreq *
 __if_nextreq (struct ifreq *ifr)
diff -Nur sysdeps/unix/sysv/linux/init-first.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/init-first.c
--- sysdeps/unix/sysv/linux/init-first.c	2002-09-15 20:53:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/init-first.c	2004-03-05 11:14:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Initialization code run first thing by the ELF startup code.  Linux version.
-   Copyright (C) 1995-1999,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999,2000,01,02,03,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,15 +28,9 @@
 #include <libc-internal.h>
 
 #include <ldsodefs.h>
-#ifndef SHARED
-# include "dl-osinfo.h"
-#endif
 
 /* The function is called from assembly stubs the compiler can't see.  */
-static void init (int, char **, char **) __attribute__ ((unused));
-
-extern int _dl_starting_up;
-weak_extern (_dl_starting_up)
+static void init (int, char **, char **) __attribute__ ((used));
 
 /* Set nonzero if we have to be prepared for more then one libc being
    used in the process.  Safe assumption if initializer never runs.  */
@@ -54,25 +48,17 @@
 #ifdef USE_NONOPTION_FLAGS
   extern void __getopt_clean_environment (char **);
 #endif
-  /* The next variable is only here to work around a bug in gcc <= 2.7.2.2.
-     If the address would be taken inside the expression the optimizer
-     would try to be too smart and throws it away.  Grrr.  */
-  int *dummy_addr = &_dl_starting_up;
 
-  __libc_multiple_libcs = dummy_addr && !_dl_starting_up;
+  __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
 
   /* Make sure we don't initialize twice.  */
   if (!__libc_multiple_libcs)
     {
-#ifndef SHARED
-      DL_SYSDEP_OSCHECK (__libc_fatal);
-#endif
-
       /* Set the FPU control word to the proper default value if the
 	 kernel would use a different value.  (In a static program we
 	 don't have this information.)  */
 #ifdef SHARED
-      if (__fpu_control != GL(dl_fpu_control))
+      if (__fpu_control != GLRO(dl_fpu_control))
 #endif
 	__setfpucw (__fpu_control);
     }
diff -Nur sysdeps/unix/sysv/linux/internal_statvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/internal_statvfs64.c
--- sysdeps/unix/sysv/linux/internal_statvfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/internal_statvfs64.c	2004-04-03 09:44:23.000000000 +0200
@@ -0,0 +1,4 @@
+#define STATFS statfs64
+#define STATVFS statvfs64
+#define INTERNAL_STATVFS __internal_statvfs64
+#include "internal_statvfs.c"
diff -Nur sysdeps/unix/sysv/linux/internal_statvfs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/internal_statvfs.c
--- sysdeps/unix/sysv/linux/internal_statvfs.c	2002-09-21 07:36:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/internal_statvfs.c	2004-04-03 19:32:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -17,29 +17,187 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <assert.h>
+#include <errno.h>
+#include <mntent.h>
+#include <paths.h>
+#include <stdbool.h>
+#include <stdio_ext.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/statvfs.h>
+#include "linux_fsinfo.h"
+
+
+#ifndef STATFS
+# define STATFS statfs
+# define STATVFS statvfs
+# define INTERNAL_STATVFS __internal_statvfs
+
+
+int
+__statvfs_getflags (const char *name, int fstype, struct stat64 *st)
+{
+  if (st == NULL)
+    return 0;
+
+  const char *fsname = NULL;
+  const char *fsname2 = NULL;
+
+  /* Map the filesystem type we got from the statfs call to a string.  */
+  switch (fstype)
+    {
+    case EXT2_SUPER_MAGIC:
+      fsname = "ext3";
+      fsname2 = "ext2";
+      break;
+    case DEVPTS_SUPER_MAGIC:
+      fsname= "devpts";
+      break;
+    case SHMFS_SUPER_MAGIC:
+      fsname = "tmpfs";
+      break;
+    case PROC_SUPER_MAGIC:
+      fsname = "proc";
+      break;
+    case USBDEVFS_SUPER_MAGIC:
+      fsname = "usbdevfs";
+      break;
+    case AUTOFS_SUPER_MAGIC:
+      fsname = "autofs";
+      break;
+    case NFS_SUPER_MAGIC:
+      fsname = "nfs";
+      break;
+    }
+
+  FILE *mtab = __setmntent ("/proc/mounts", "r");
+  if (mtab == NULL)
+    mtab = __setmntent (_PATH_MOUNTED, "r");
+
+  int result = 0;
+  if (mtab != NULL)
+    {
+      bool success = false;
+      struct mntent mntbuf;
+      char tmpbuf[1024];
+
+      /* No locking needed.  */
+      (void) __fsetlocking (mtab, FSETLOCKING_BYCALLER);
+
+    again:
+      while (__getmntent_r (mtab, &mntbuf, tmpbuf, sizeof (tmpbuf)))
+	{
+	  /* In a first round we look for a given mount point, if
+	     we have a name.  */
+	  if (name != NULL && strcmp (name, mntbuf.mnt_dir) != 0)
+	    continue;
+	  /* We need to look at the entry only if the filesystem
+	     name matches.  If we have a filesystem name.  */
+	  else if (fsname != NULL
+		   && strcmp (fsname, mntbuf.mnt_type) != 0
+		   && (fsname2 == NULL
+		       || strcmp (fsname2, mntbuf.mnt_type) != 0))
+	    continue;
+
+	  /* Find out about the device the current entry is for.  */
+	  struct stat64 fsst;
+	  if (stat64 (mntbuf.mnt_dir, &fsst) >= 0
+	      && st->st_dev == fsst.st_dev)
+	    {
+	      /* Bingo, we found the entry for the device FD is on.
+		 Now interpret the option string.  */
+	      char *cp = mntbuf.mnt_opts;
+	      char *opt;
+
+	      while ((opt = strsep (&cp, ",")) != NULL)
+		if (strcmp (opt, "ro") == 0)
+		  result |= ST_RDONLY;
+		else if (strcmp (opt, "nosuid") == 0)
+		  result |= ST_NOSUID;
+		else if (strcmp (opt, "noexec") == 0)
+		  result |= ST_NOEXEC;
+		else if (strcmp (opt, "nodev") == 0)
+		  result |= ST_NODEV;
+		else if (strcmp (opt, "sync") == 0)
+		  result |= ST_SYNCHRONOUS;
+		else if (strcmp (opt, "mand") == 0)
+		  result |= ST_MANDLOCK;
+		else if (strcmp (opt, "noatime") == 0)
+		  result |= ST_NOATIME;
+		else if (strcmp (opt, "nodiratime") == 0)
+		  result |= ST_NODIRATIME;
+
+	      /* We can stop looking for more entries.  */
+	      success = true;
+	      break;
+	    }
+	}
+      /* Maybe the kernel names for the filesystems changed or the
+	 statvfs call got a name which was not the mount point.  Check
+	 again, this time without checking for name matches first.  */
+      if (! success && (name != NULL || fsname != NULL))
+	{
+	  if (name != NULL)
+	    /* Try without a mount point name.  */
+	    name = NULL;
+	  else
+	    {
+	      /* Try without a filesystem name.  */
+	      assert (fsname != NULL);
+	      fsname = fsname2 = NULL;
+	    }
+
+	  /* It is not strictly allowed to use rewind here.  But
+	     this code is part of the implementation so it is
+	     acceptable.  */
+	  rewind (mtab);
+
+	  goto again;
+	}
+
+      /* Close the file.  */
+      __endmntent (mtab);
+    }
+
+  return result;
+}
+#else
+extern int __statvfs_getflags (const char *name, int fstype,
+			       struct stat64 *st);
+#endif
+
+
+void
+INTERNAL_STATVFS (const char *name, struct STATVFS *buf,
+		  struct STATFS *fsbuf, struct stat64 *st)
+{
   /* Now fill in the fields we have information for.  */
-  buf->f_bsize = fsbuf.f_bsize;
-  /* Linux does not support f_frsize, so set it to the full block size.  */
-  buf->f_frsize = fsbuf.f_bsize;
-  buf->f_blocks = fsbuf.f_blocks;
-  buf->f_bfree = fsbuf.f_bfree;
-  buf->f_bavail = fsbuf.f_bavail;
-  buf->f_files = fsbuf.f_files;
-  buf->f_ffree = fsbuf.f_ffree;
-  if (sizeof (buf->f_fsid) == sizeof (fsbuf.f_fsid))
-    buf->f_fsid = (fsbuf.f_fsid.__val[0]
-		   | ((unsigned long int) fsbuf.f_fsid.__val[1]
+  buf->f_bsize = fsbuf->f_bsize;
+  /* Linux has the f_frsize size only in later version of the kernel.
+     If the value is not filled in use f_bsize.  */
+  buf->f_frsize = fsbuf->f_frsize ?: fsbuf->f_bsize;
+  buf->f_blocks = fsbuf->f_blocks;
+  buf->f_bfree = fsbuf->f_bfree;
+  buf->f_bavail = fsbuf->f_bavail;
+  buf->f_files = fsbuf->f_files;
+  buf->f_ffree = fsbuf->f_ffree;
+  if (sizeof (buf->f_fsid) == sizeof (fsbuf->f_fsid))
+    buf->f_fsid = (fsbuf->f_fsid.__val[0]
+		   | ((unsigned long int) fsbuf->f_fsid.__val[1]
 		      << (8 * (sizeof (buf->f_fsid)
-			       - sizeof (fsbuf.f_fsid.__val[0])))));
+			       - sizeof (fsbuf->f_fsid.__val[0])))));
   else
     /* We cannot help here.  The statvfs element is not large enough to
        contain both words of the statfs f_fsid field.  */
-    buf->f_fsid = fsbuf.f_fsid.__val[0];
+    buf->f_fsid = fsbuf->f_fsid.__val[0];
 #ifdef _STATVFSBUF_F_UNUSED
   buf->__f_unused = 0;
 #endif
-  buf->f_namemax = fsbuf.f_namelen;
-  memset (buf->__f_spare, '\0', 6 * sizeof (int));
+  buf->f_namemax = fsbuf->f_namelen;
+  memset (buf->__f_spare, '\0', sizeof (buf->__f_spare));
 
   /* What remains to do is to fill the fields f_favail and f_flag.  */
 
@@ -50,60 +208,5 @@
      the /etc/mtab file and search for the entry which matches the given
      file.  The way we can test for matching filesystem is using the
      device number.  */
-  buf->f_flag = 0;
-  if (STAT (&st) >= 0)
-    {
-      struct mntent mntbuf;
-      FILE *mtab;
-
-      mtab = __setmntent ("/proc/mounts", "r");
-      if (mtab == NULL)
-	mtab = __setmntent (_PATH_MOUNTED, "r");
-
-      if (mtab != NULL)
-	{
-	  char tmpbuf[1024];
-
-	  /* No locking needed.  */
-	  (void) __fsetlocking (mtab, FSETLOCKING_BYCALLER);
-
-	  while (__getmntent_r (mtab, &mntbuf, tmpbuf, sizeof (tmpbuf)))
-	    {
-	      struct stat64 fsst;
-
-	      /* Find out about the device the current entry is for.  */
-	      if (stat64 (mntbuf.mnt_dir, &fsst) >= 0
-		  && st.st_dev == fsst.st_dev)
-		{
-		  /* Bingo, we found the entry for the device FD is on.
-		     Now interpret the option string.  */
-		  char *cp = mntbuf.mnt_opts;
-		  char *opt;
-
-		  while ((opt = strsep (&cp, ",")) != NULL)
-		    if (strcmp (opt, "ro") == 0)
-		      buf->f_flag |= ST_RDONLY;
-		    else if (strcmp (opt, "nosuid") == 0)
-		      buf->f_flag |= ST_NOSUID;
-		    else if (strcmp (opt, "noexec") == 0)
-		      buf->f_flag |= ST_NOEXEC;
-		    else if (strcmp (opt, "nodev") == 0)
-		      buf->f_flag |= ST_NODEV;
-		    else if (strcmp (opt, "sync") == 0)
-		      buf->f_flag |= ST_SYNCHRONOUS;
-		    else if (strcmp (opt, "mand") == 0)
-		      buf->f_flag |= ST_MANDLOCK;
-		    else if (strcmp (opt, "noatime") == 0)
-		      buf->f_flag |= ST_NOATIME;
-		    else if (strcmp (opt, "nodiratime") == 0)
-		      buf->f_flag |= ST_NODIRATIME;
-
-		  /* We can stop looking for more entries.  */
-		  break;
-		}
-	    }
-
-	  /* Close the file.  */
-	  __endmntent (mtab);
-	}
-    }
+  buf->f_flag = __statvfs_getflags (name, fsbuf->f_type, st);
+}
diff -Nur sysdeps/unix/sysv/linux/ipc_priv.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ipc_priv.h
--- sysdeps/unix/sysv/linux/ipc_priv.h	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ipc_priv.h	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995-1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995-1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,18 +32,11 @@
 };
 
 
-__BEGIN_DECLS
-
-/* The actual system call: all functions are multiplexed by this.  */
-extern int __syscall_ipc (int __call, int __first, int __second,
-			  int __third, void *__ptr);
-
-__END_DECLS
-
-/* The codes for the functions to use the multiplexer `__syscall_ipc'.  */
+/* The codes for the functions to use the ipc syscall multiplexer.  */
 #define IPCOP_semop	 1
 #define IPCOP_semget	 2
 #define IPCOP_semctl	 3
+#define IPCOP_semtimedop 4
 #define IPCOP_msgsnd	11
 #define IPCOP_msgrcv	12
 #define IPCOP_msgget	13
diff -Nur sysdeps/unix/sysv/linux/kernel-features.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/kernel-features.h
--- sysdeps/unix/sysv/linux/kernel-features.h	2002-09-29 22:41:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/kernel-features.h	2005-02-16 12:00:21.000000000 +0100
@@ -1,6 +1,6 @@
 /* Set flags signalling availability of kernel features based on given
    kernel version number.
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,10 @@
 /* This file must not contain any C code.  At least it must be protected
    to allow using the file also in assembler files.  */
 
+#if defined __mips__
+# include <sgidefs.h>
+#endif
+
 #ifndef __LINUX_KERNEL_VERSION
 /* We assume the worst; all kernels should be supported.  */
 # define __LINUX_KERNEL_VERSION	0
@@ -75,6 +79,11 @@
 # define __ASSUME_SIOCGIFNAME		1
 #endif
 
+/* MSG_NOSIGNAL was at least available with Linux 2.2.0.  */
+#if __LINUX_KERNEL_VERSION >= 131584
+# define __ASSUME_MSG_NOSIGNAL		1
+#endif
+
 /* On x86 another `getrlimit' syscall was added in 2.3.25.  */
 #if __LINUX_KERNEL_VERSION >= 131865 && defined __i386__
 # define __ASSUME_NEW_GETRLIMIT_SYSCALL	1
@@ -127,16 +136,25 @@
 # define __ASSUME_SETRESUID_SYSCALL	1
 #endif
 
+#if __LINUX_KERNEL_VERSION >= 131879
+# define __ASSUME_SETRESGID_SYSCALL	1
+#endif
+
 /* Linux 2.3.39 introduced IPC64.  Except for powerpc.  */
 #if __LINUX_KERNEL_VERSION >= 131879 && !defined __powerpc__
 # define __ASSUME_IPC64		1
 #endif
 
-/* mips platforms had IPC64 all along.  */
+/* MIPS platforms had IPC64 all along.  */
 #if defined __mips__
 # define __ASSUME_IPC64		1
 #endif
 
+/* We can use the LDTs for threading with Linux 2.3.99 and newer.  */
+#if __LINUX_KERNEL_VERSION >= 131939
+# define __ASSUME_LDT_WORKS		1
+#endif
+
 /* Linux 2.4.0 on PPC introduced a correct IPC64. But PowerPC64 does not
    support a separate 64-bit sys call, already 64-bit */
 #if __LINUX_KERNEL_VERSION >= 132096 && defined __powerpc__ \
@@ -144,15 +162,18 @@
 # define __ASSUME_IPC64			1
 #endif
 
-/* We can use the LDTs for threading with Linux 2.3.99 and newer.  */
-#if __LINUX_KERNEL_VERSION >= 131939
-# define __ASSUME_LDT_WORKS		1
+/* SH kernels got stat64, mmap2, and truncate64 during 2.4.0-test.  */
+#if __LINUX_KERNEL_VERSION >= 132096 && defined __sh__
+# define __ASSUME_TRUNCATE64_SYSCALL	1
+# define __ASSUME_MMAP2_SYSCALL		1
+# define __ASSUME_STAT64_SYSCALL	1
 #endif
 
 /* The changed st_ino field appeared in 2.4.0-test6.  But we cannot
    distinguish this version from other 2.4.0 releases.  Therefore play
-   save and assume it available is for 2.4.1 and up.  */
-#if __LINUX_KERNEL_VERSION >= 132097
+   save and assume it available is for 2.4.1 and up.  However, SH is lame,
+   and still does not have a 64-bit inode field.  */
+#if __LINUX_KERNEL_VERSION >= 132097 && !defined __alpha__ && !defined __sh__
 # define __ASSUME_ST_INO_64_BIT		1
 #endif
 
@@ -163,6 +184,12 @@
 # define __ASSUME_FCNTL64		1
 #endif
 
+/* The AT_CLKTCK auxiliary vector entry was introduction in the 2.4.0
+   series.  */
+#if __LINUX_KERNEL_VERSION >= 132097
+# define __ASSUME_AT_CLKTCK		1
+#endif
+
 /* Arm got fcntl64 in 2.4.4, PowerPC and SH have it also in 2.4.4 (I
    don't know when it got introduced).  But PowerPC64 does not support
    separate FCNTL64 call, FCNTL is already 64-bit */
@@ -196,9 +223,11 @@
 # define __ASSUME_AT_XID		1
 #endif
 
-/* Starting with 2.4.5 kernels PPC passes the AUXV in the standard way.  */
+/* Starting with 2.4.5 kernels PPC passes the AUXV in the standard way
+   and the vfork syscall made it into the official kernel.  */
 #if __LINUX_KERNEL_VERSION >= (132096+5) && defined __powerpc__
 # define __ASSUME_STD_AUXV		1
+# define __ASSUME_VFORK_SYSCALL		1
 #endif
 
 /* Starting with 2.4.5 kernels the mmap2 syscall made it into the official
@@ -208,12 +237,36 @@
 # define __ASSUME_MMAP2_SYSCALL		1
 #endif
 
+/* Starting with 2.4.21 PowerPC implements the new prctl syscall.
+   This allows applications to get/set the Floating Point Exception Mode.  */
+#if __LINUX_KERNEL_VERSION >= (132096+21) && defined __powerpc__
+# define __ASSUME_NEW_PRCTL_SYSCALL		1
+#endif
+
+/* Starting with 2.4.21 the PowerPC32 clone syscall works as expected.  */
+#if __LINUX_KERNEL_VERSION >= (132096+21) && defined __powerpc__ \
+    && !defined __powerpc64__
+# define __ASSUME_FIXED_CLONE_SYSCALL		1
+#endif
+
+/* Starting with 2.4.21 PowerPC64 implements the new rt_sigreturn syscall.
+   The new rt_sigreturn takes an ucontext pointer allowing rt_sigreturn
+   to be used in the set/swapcontext implementation.  */
+#if __LINUX_KERNEL_VERSION >= (132096+21) && defined __powerpc64__
+# define __ASSUME_NEW_RT_SIGRETURN_SYSCALL		1
+#endif
+
 /* On x86, the set_thread_area syscall was introduced in 2.5.29, but its
-   semantics was changed in 2.5.30, and again after 2.3.31.  */
+   semantics was changed in 2.5.30, and again after 2.5.31.  */
 #if __LINUX_KERNEL_VERSION >= 132384 && defined __i386__
 # define __ASSUME_SET_THREAD_AREA_SYSCALL	1
 #endif
 
+/* The vfork syscall on x86 and arm was definitely available in 2.4.  */
+#if __LINUX_KERNEL_VERSION >= 132097 && (defined __i386__ || defined __arm__)
+# define __ASSUME_VFORK_SYSCALL		1
+#endif
+
 /* There are an infinite number of PA-RISC kernel versions numbered
    2.4.0.  But they've not really been released as such.  We require
    and expect the final version here.  */
@@ -227,3 +280,151 @@
 # define __ASSUME_FCNTL64		1
 # define __ASSUME_GETDENTS64_SYSCALL	1
 #endif
+
+/* Alpha switched to a 64-bit timeval sometime before 2.2.0.  */
+#if __LINUX_KERNEL_VERSION >= 131584 && defined __alpha__
+# define __ASSUME_TIMEVAL64		1
+#endif
+
+#if defined __mips__ && _MIPS_SIM == _ABIN32
+# define __ASSUME_FCNTL64		1
+#endif
+
+/* The late 2.5 kernels saw a lot of new CLONE_* flags.  Summarize
+   their availability with one define.  The changes were made first
+   for i386 and the have to be done separately for the other archs.
+   For i386 we pick 2.5.50 as the first version with support.  */
+#if __LINUX_KERNEL_VERSION >= 132402 && defined __i386__
+# define __ASSUME_CLONE_THREAD_FLAGS	1
+#endif
+
+/* These features were surely available with 2.4.12.  */
+#if __LINUX_KERNEL_VERSION >= 132108 && defined __mc68000__
+# define __ASSUME_MMAP2_SYSCALL		1
+# define __ASSUME_TRUNCATE64_SYSCALL	1
+# define __ASSUME_STAT64_SYSCALL	1
+# define __ASSUME_FCNTL64		1
+# define __ASSUME_VFORK_SYSCALL		1
+#endif
+
+/* Beginning with 2.5.63 support for realtime and monotonic clocks and
+   timers based on them is available.  */
+#if __LINUX_KERNEL_VERSION >= 132415
+# define __ASSUME_POSIX_TIMERS		1
+#endif
+
+/* The late 2.5 kernels saw a lot of new CLONE_* flags.  Summarize
+   their availability with one define.  The changes were made first
+   for i386 and the have to be done separately for the other archs.
+   For ia64, s390*, PPC, x86-64 we pick 2.5.64 as the first version
+   with support.  */
+#if __LINUX_KERNEL_VERSION >= 132416 \
+    && (defined __ia64__ || defined __s390__ || defined __powerpc__ \
+	|| defined __x86_64__ || defined __sh__)
+# define __ASSUME_CLONE_THREAD_FLAGS	1
+#endif
+
+/* With kernel 2.4.17 we always have netlink support.  */
+#if __LINUX_KERNEL_VERSION >= (132096+17)
+# define __ASSUME_NETLINK_SUPPORT	1
+#endif
+
+/* The requeue futex functionality was introduced in 2.5.70.  */
+#if __LINUX_KERNEL_VERSION >= 132422
+# define __ASSUME_FUTEX_REQUEUE	1
+#endif
+
+/* The statfs64 syscalls are available in 2.5.74.  */
+#if __LINUX_KERNEL_VERSION >= 132426
+# define __ASSUME_STATFS64	1
+#endif
+
+/* Starting with at least 2.5.74 the kernel passes the setuid-like exec
+   flag unconditionally up to the child.  */
+#if __LINUX_KERNEL_VERSION >= 132426
+# define __ASSUME_AT_SECURE	1
+#endif
+
+/* Starting with the 2.5.75 kernel the kernel fills in the correct value
+   in the si_pid field passed as part of the siginfo_t struct to signal
+   handlers.  */
+#if __LINUX_KERNEL_VERSION >= 132427
+# define __ASSUME_CORRECT_SI_PID	1
+#endif
+
+/* The tgkill syscall was instroduced for i386 in 2.5.75.  For Alpha
+   it was introduced in 2.6.0-test1 which unfortunately cannot be
+   distinguished from 2.6.0.  On x86-64 it was introduced in
+   2.6.0-test3. */
+#if (__LINUX_KERNEL_VERSION >= 132427 && defined __i386__) \
+    || (__LINUX_KERNEL_VERSION >= 132609 && defined __alpha__) \
+    || (__LINUX_KERNEL_VERSION >= 132609 && defined __x86_64__) \
+    || (__LINUX_KERNEL_VERSION >= 132609 && defined __sh__)
+# define __ASSUME_TGKILL	1
+#endif
+
+/* The utimes syscall has been available for some architectures
+   forever.  For x86 it was introduced after 2.5.75, for x86-64 in
+   2.6.0-test3.  */
+#if defined __alpha__ || defined __ia64__ || defined __hppa__ \
+    || defined __sparc__ \
+    || (__LINUX_KERNEL_VERSION > 132427 && defined __i386__) \
+    || (__LINUX_KERNEL_VERSION > 132609 && defined __x86_64__) \
+    || (__LINUX_KERNEL_VERSION >= 132609 && defined __sh__)
+# define __ASSUME_UTIMES	1
+#endif
+
+// XXX Disabled for now since the semantics we want is not achieved.
+#if 0
+/* The CLONE_STOPPED flag was introduced in the 2.6.0-test1 series.  */
+#if __LINUX_KERNEL_VERSION >= 132609
+# define __ASSUME_CLONE_STOPPED	1
+#endif
+#endif
+
+/* The fixed version of the posix_fadvise64 syscall appeared in
+   2.6.0-test3.  At least for x86.  */
+#if __LINUX_KERNEL_VERSION >= 132609 && defined __i386__
+# define __ASSUME_FADVISE64_64_SYSCALL	1
+#endif
+
+/* The PROT_GROWSDOWN/PROT_GROWSUP flags were introduced in the 2.6.0-test
+   series.  */
+#if __LINUX_KERNEL_VERSION >= 132609
+# define __ASSUME_PROT_GROWSUPDOWN	1
+#endif
+
+/* Starting with 2.6.0 PowerPC adds signal/swapcontext support for Vector
+   SIMD (AKA Altivec, VMX) instructions and register state.  This changes
+   the overall size of the sigcontext and adds the swapcontext syscall.  */
+#if __LINUX_KERNEL_VERSION >= 132608 && defined __powerpc__
+# define __ASSUME_SWAPCONTEXT_SYSCALL	1
+#endif
+
+/* The CLONE_DETACHED flag is not necessary in 2.6.2 kernels, it is
+   implied.  */
+#if __LINUX_KERNEL_VERSION >= 132610
+# define __ASSUME_NO_CLONE_DETACHED	1
+#endif
+
+/* Starting with version 2.6.4-rc1 the getdents syscall returns d_type
+   information as well.  */
+#if __LINUX_KERNEL_VERSION >= 132612
+# define __ASSUME_GETDENTS32_D_TYPE	1
+#endif
+
+/* Starting with version 2.5.3, the initial location returned by `brk'
+   after exec is always rounded up to the next page.  */
+#if __LINUX_KERNEL_VERSION >= 132355
+# define __ASSUME_BRK_PAGE_ROUNDED	1
+#endif
+
+/* Starting with version 2.6.9, the waitid system call is available.  */
+#if __LINUX_KERNEL_VERSION >=  0x020609
+# define __ASSUME_WAITID_SYSCALL	1
+#endif
+
+/* Starting with version 2.6.9, SSI_IEEE_RAISE_EXCEPTION exists.  */
+#if __LINUX_KERNEL_VERSION >= 0x020609 && defined __alpha__
+#define __ASSUME_IEEE_RAISE_EXCEPTION	1
+#endif
diff -Nur sysdeps/unix/sysv/linux/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/kernel_stat.h
--- sysdeps/unix/sysv/linux/kernel_stat.h	2000-08-11 19:27:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/kernel_stat.h	2003-01-01 20:56:23.000000000 +0100
@@ -15,31 +15,21 @@
     unsigned long int st_size;
     unsigned long int st_blksize;
     unsigned long int st_blocks;
-    unsigned long int st_atime;
-    unsigned long int __unused1;
-#define _HAVE___UNUSED1
-    unsigned long int st_mtime;
-    unsigned long int __unused2;
-#define _HAVE___UNUSED2
-    unsigned long int st_ctime;
-    unsigned long int __unused3;
-#define _HAVE___UNUSED3
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
     unsigned long int __unused4;
 #define _HAVE___UNUSED4
     unsigned long int __unused5;
 #define _HAVE___UNUSED5
   };
 
-#define _HAVE_STAT___UNUSED1
-#define _HAVE_STAT___UNUSED2
-#define _HAVE_STAT___UNUSED3
 #define _HAVE_STAT___UNUSED4
 #define _HAVE_STAT___UNUSED5
 #define _HAVE_STAT___PAD1
 #define _HAVE_STAT___PAD2
-#define _HAVE_STAT64___UNUSED1
-#define _HAVE_STAT64___UNUSED2
-#define _HAVE_STAT64___UNUSED3
+#define _HAVE_STAT_NSEC
 #define _HAVE_STAT64___PAD1
 #define _HAVE_STAT64___PAD2
 #define _HAVE_STAT64___ST_INO
+#define _HAVE_STAT64_NSEC
diff -Nur sysdeps/unix/sysv/linux/ldsodefs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ldsodefs.h
--- sysdeps/unix/sysv/linux/ldsodefs.h	2002-07-20 19:30:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ldsodefs.h	2003-06-26 21:54:28.000000000 +0200
@@ -1,5 +1,5 @@
 /* Run-time dynamic linker data structures for loaded ELF shared objects.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -41,6 +41,12 @@
 # define HAVE_AUX_XID
 #endif
 
+/* We can assume that the kernel always provides the AT_SECURE value
+   in the auxiliary vector from 2.5.74 or so on.  */
+#if __ASSUME_AT_SECURE
+# define HAVE_AUX_SECURE
+#endif
+
 /* Starting with one of the 2.4.0 pre-releases the Linux kernel passes
    up the page size information.  */
 #if __ASSUME_AT_PAGESIZE
diff -Nur sysdeps/unix/sysv/linux/libc_fatal.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/libc_fatal.c
--- sysdeps/unix/sysv/linux/libc_fatal.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/libc_fatal.c	2004-11-15 22:57:08.000000000 +0100
@@ -0,0 +1,157 @@
+/* Copyright (C) 1993-1995,1997,2000,2002-2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/syslog.h>
+
+/* Abort with an error message.  */
+#include <not-cancel.h>
+
+#ifdef FATAL_PREPARE_INCLUDE
+#include FATAL_PREPARE_INCLUDE
+#endif
+
+struct str_list
+{
+  const char *str;
+  size_t len;
+  struct str_list *next;
+};
+
+
+/* Abort with an error message.  */
+void
+__libc_message (int do_abort, const char *fmt, ...)
+{
+  va_list ap;
+  va_list ap_copy;
+  int fd = -1;
+
+  va_start (ap, fmt);
+  va_copy (ap_copy, ap);
+
+#ifdef FATAL_PREPARE
+  FATAL_PREPARE;
+#endif
+
+  /* Open a descriptor for /dev/tty unless the user explicitly
+     requests errors on standard error.  */
+  const char *on_2 = __secure_getenv ("LIBC_FATAL_STDERR_");
+  if (on_2 == NULL || *on_2 == '\0')
+    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);
+
+  if (fd == -1)
+    fd = STDERR_FILENO;
+
+  struct str_list *list = NULL;
+  int nlist = 0;
+
+  const char *cp = fmt;
+  while (*cp != '\0')
+    {
+      /* Find the next "%s" or the end of the string.  */
+      const char *next = cp;
+      while (next[0] != '%' || next[1] != 's')
+	{
+	  next = __strchrnul (next + 1, '%');
+
+	  if (next[0] == '\0')
+	    break;
+	}
+
+      /* Determine what to print.  */
+      const char *str;
+      size_t len;
+      if (cp[0] == '%' && cp[1] == 's')
+	{
+	  str = va_arg (ap, const char *);
+	  len = strlen (str);
+	  cp += 2;
+	}
+      else
+	{
+	  str = cp;
+	  len = next - cp;
+	  cp = next;
+	}
+
+      struct str_list *newp = alloca (sizeof (struct str_list));
+      newp->str = str;
+      newp->len = len;
+      newp->next = list;
+      list = newp;
+      ++nlist;
+    }
+
+  bool written = false;
+  if (nlist > 0)
+    {
+      struct iovec *iov = alloca (nlist * sizeof (struct iovec));
+      ssize_t total = 0;
+
+      for (int cnt = nlist - 1; cnt >= 0; --cnt)
+	{
+	  iov[cnt].iov_base = (void *) list->str;
+	  iov[cnt].iov_len = list->len;
+	  total += list->len;
+	  list = list->next;
+	}
+
+      INTERNAL_SYSCALL_DECL (err);
+      ssize_t cnt;
+      do
+	cnt = INTERNAL_SYSCALL (writev, err, 3, fd, iov, nlist);
+      while (INTERNAL_SYSCALL_ERROR_P (cnt, err)
+	     && INTERNAL_SYSCALL_ERRNO (cnt, err) == EINTR);
+
+      if (cnt == total)
+	written = true;
+    }
+
+  va_end (ap);
+
+  /* If we  had no success writing the message, use syslog.  */
+  if (! written)
+    vsyslog (LOG_ERR, fmt, ap_copy);
+
+  va_end (ap_copy);
+
+  if (do_abort)
+    /* Terminate the process.  */
+    abort ();
+}
+
+
+void
+__libc_fatal (message)
+     const char *message;
+{
+  /* The loop is added only to keep gcc happy.  */
+  while (1)
+    __libc_message (1, "%s", message);
+}
+libc_hidden_def (__libc_fatal)
diff -Nur sysdeps/unix/sysv/linux/linux_fsinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/linux_fsinfo.h
--- sysdeps/unix/sysv/linux/linux_fsinfo.h	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/linux_fsinfo.h	2003-09-17 02:48:25.000000000 +0200
@@ -1,5 +1,5 @@
 /* Constants from kernel header for various FSes.
-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1998,1999,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,6 +31,9 @@
 /* Constants that identify the `affs' filesystem.  */
 #define AFFS_SUPER_MAGIC	0xadff
 
+/* Constants that identify the `autofs' filesystem.  */
+#define AUTOFS_SUPER_MAGIC	0x187
+
 /* Constants that identify the `bfs' filesystem.  */
 #define BFS_MAGIC		0x1BADFACE
 
@@ -40,6 +43,9 @@
 /* Constants that identify the `coherent' filesystem.  */
 #define COH_SUPER_MAGIC		0x012ff7b7
 
+/* Constant that identifies the `ramfs' filesystem.  */
+#define CRAMFS_MAGIC		0x28cd3d45
+
 /* Constant that identifies the `devfs' filesystem.  */
 #define DEVFS_SUPER_MAGIC	0x1373
 
@@ -48,6 +54,7 @@
 
 /* Constant that identifies the `efs' filesystem.  */
 #define EFS_SUPER_MAGIC		0x414A53
+#define EFS_MAGIC		0x072959
 
 /* Constant that identifies the `ext2' and `ext3' filesystems.  */
 #define EXT2_SUPER_MAGIC	0xef53
@@ -58,6 +65,15 @@
 /* Constant that identifies the `iso9660' filesystem.  */
 #define ISOFS_SUPER_MAGIC	0x9660
 
+/* Constant that identifies the `jffs' filesystem.  */
+#define JFFS_SUPER_MAGIC	0x07c0
+
+/* Constant that identifies the `jffs2' filesystem.  */
+#define JFFS2_SUPER_MAGIC	0x72b6
+
+/* Constant that identifies the `jfs' filesystem.  */
+#define JFS_SUPER_MAGIC		0x3153464a
+
 /* Constants that identify the `minix2' filesystem.  */
 #define MINIX2_SUPER_MAGIC	0x2468
 #define MINIX2_SUPER_MAGIC2	0x2478
@@ -75,15 +91,24 @@
 /* Constants that identify the `nfs' filesystem.  */
 #define NFS_SUPER_MAGIC		0x6969
 
+/* Constants that identify the `ntfs' filesystem.  */
+#define NTFS_SUPER_MAGIC	0x5346544e
+
 /* Constants that identify the `proc' filesystem.  */
 #define PROC_SUPER_MAGIC	0x9fa0
 
+/* Constant that identifies the `usbdevfs' filesystem.  */
+#define USBDEVFS_SUPER_MAGIC	0x9fa2
+
 /* Constants that identify the `qnx4' filesystem.  */
 #define QNX4_SUPER_MAGIC	0x002f
 
 /* Constants that identify the `reiser' filesystem.  */
 #define REISERFS_SUPER_MAGIC	0x52654973
 
+/* Constant that identifies the `romfs' filesystem.  */
+#define ROMFS_SUPER_MAGIC	0x7275
+
 /* Constants that identify the `smb' filesystem.  */
 #define SMB_SUPER_MAGIC		0x517b
 
@@ -91,6 +116,9 @@
 #define SYSV2_SUPER_MAGIC	0x012ff7b6
 #define SYSV4_SUPER_MAGIC	0x012ff7b5
 
+/* Constants that identify the `udf' filesystem.  */
+#define UDF_SUPER_MAGIC		0x15013346
+
 /* Constants that identify the `ufs' filesystem.  */
 #define UFS_MAGIC		0x00011954
 #define UFS_CIGAM		0x54190100 /* byteswapped MAGIC */
@@ -101,6 +129,12 @@
 /* Constant that identifies the `shm' filesystem.  */
 #define SHMFS_SUPER_MAGIC	0x01021994
 
+/* Constants that identify the `xfs' filesystem.  */
+#define XFS_SUPER_MAGIC		0x58465342
+
+/* Constants that identify the `vxfs' filesystem.  */
+#define VXFS_SUPER_MAGIC	0xa501fcf5
+
 /* Maximum link counts.  */
 #define COH_LINK_MAX		10000
 #define EXT2_LINK_MAX		32000
@@ -110,5 +144,10 @@
 #define SYSV_LINK_MAX		126     /* 127? 251? */
 #define UFS_LINK_MAX		EXT2_LINK_MAX
 #define XENIX_LINK_MAX		126     /* ?? */
+#define XFS_LINK_MAX		2147483647
+
+/* The Linux kernel header mentioned this as a kind of generic value.  */
+#define LINUX_LINK_MAX	127
+
 
 #endif	/* linux_fsinfo.h */
diff -Nur sysdeps/unix/sysv/linux/llseek.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/llseek.c
--- sysdeps/unix/sysv/linux/llseek.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/llseek.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* Long-long seek operation.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996-2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,20 +23,17 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall__llseek (int fd, off_t offset_hi, off_t offset_lo,
-			      loff_t *__unbounded result, int whence);
-
 /* Seek to OFFSET on FD, starting from WHENCE.  */
 extern loff_t __llseek (int fd, loff_t offset, int whence);
 
 loff_t
 __llseek (int fd, loff_t offset, int whence)
 {
-  loff_t result;
+  loff_t retval;
 
   return (loff_t) (INLINE_SYSCALL (_llseek, 5, fd, (off_t) (offset >> 32),
 				   (off_t) (offset & 0xffffffff),
-				   __ptrvalue (&result), whence) ?: result);
+				   __ptrvalue (&retval), whence) ?: retval);
 }
 weak_alias (__llseek, llseek)
 strong_alias (__llseek, __libc_lseek64)
diff -Nur sysdeps/unix/sysv/linux/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/lxstat64.c
--- sysdeps/unix/sysv/linux/lxstat64.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/lxstat64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* lxstat64 using old-style Unix lstat system call.
-   Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   Copyright (C) 1997-2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,15 +29,10 @@
 #include "kernel-features.h"
 
 #if __ASSUME_STAT64_SYSCALL == 0
-# include <xstatconv.c>
+# include <xstatconv.h>
 #endif
 
-extern int __syscall_lstat (const char *__unbounded,
-			    struct kernel_stat *__unbounded);
-
 #ifdef __NR_lstat64
-extern int __syscall_lstat64 (const char *__unbounded,
-			      struct stat64 *__unbounded);
 # if  __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.  */
 extern int __have_no_stat64;
@@ -79,23 +74,20 @@
 # endif
   result = INLINE_SYSCALL (lstat, 2, CHECK_STRING (name), __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat64_conv (vers, &kbuf, buf);
+    result = __xstat64_conv (vers, &kbuf, buf);
 
   return result;
 #endif
 }
 
-#ifndef RTLD_STAT64
-# include <shlib-compat.h>
+#include <shlib-compat.h>
 
+#if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
 versioned_symbol (libc, ___lxstat64, __lxstat64, GLIBC_2_2);
-
-# if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
 strong_alias (___lxstat64, __old__lxstat64)
 compat_symbol (libc, __old__lxstat64, __lxstat64, GLIBC_2_1);
-# endif
-
+hidden_ver (___lxstat64, __lxstat64)
 #else
 strong_alias (___lxstat64, __lxstat64);
+hidden_def (__lxstat64)
 #endif
-hidden_ver (___lxstat64, __lxstat64)
diff -Nur sysdeps/unix/sysv/linux/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/lxstat.c
--- sysdeps/unix/sysv/linux/lxstat.c	2002-10-02 10:53:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/lxstat.c	2003-06-28 10:10:46.000000000 +0200
@@ -1,5 +1,5 @@
 /* lxstat using old-style Unix lstat system call.
-   Copyright (C) 1991,1995-1998,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-1998,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,10 +30,7 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-#include <xstatconv.c>
-
-extern int __syscall_lstat (const char *__unbounded,
-			    struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 /* Get information about the file NAME in BUF.  */
 int
@@ -52,7 +49,7 @@
 
   result = INLINE_SYSCALL (lstat, 2, CHECK_STRING (name), __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif
diff -Nur sysdeps/unix/sysv/linux/m68k/bits/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/a.out.h
--- sysdeps/unix/sysv/linux/m68k/bits/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/a.out.h	2003-07-25 11:04:57.000000000 +0200
@@ -0,0 +1,3 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
diff -Nur sysdeps/unix/sysv/linux/m68k/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/fcntl.h
--- sysdeps/unix/sysv/linux/m68k/bits/fcntl.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/fcntl.h	2004-08-23 09:28:45.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 2000 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,6 +45,7 @@
 # define O_DIRECTORY	 040000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0100000	/* Do not follow links.	 */
 # define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_NOATIME	01000000 /* Do not set atime.  */
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
@@ -78,7 +79,7 @@
 #define F_SETLK64	13	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	14	/* Set record locking info (blocking).	*/
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -177,3 +178,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/m68k/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/mman.h
--- sysdeps/unix/sysv/linux/m68k/bits/mman.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/mman.h	2003-09-25 18:39:38.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/m68k version.
-   Copyright (C) 1997 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
@@ -52,11 +56,13 @@
 
 /* These are Linux-specific.  */
 #ifdef __USE_MISC
-# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
-# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
-# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
-# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
 #endif
 
 /* Flags to `msync'.  */
@@ -73,3 +79,21 @@
 #ifdef __USE_GNU
 # define MREMAP_MAYMOVE	1
 #endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -Nur sysdeps/unix/sysv/linux/m68k/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/resource.h
--- sysdeps/unix/sysv/linux/m68k/bits/resource.h	2001-11-09 20:57:55.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* Bit values & structures for resource limits.  Linux/m68k version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((unsigned long int)(~0UL))
-#else
-# define RLIM_INFINITY 0xffffffffffffffffuLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0xffffffffffffffffuLL
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#ifndef __USE_FILE_OFFSET64
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/m68k/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/stat.h
--- sysdeps/unix/sysv/linux/m68k/bits/stat.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1992,95,96,97,98,99,2000,2001,2002
+     Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -60,12 +61,27 @@
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 #endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
 #ifndef __USE_FILE_OFFSET64
     unsigned long int __unused4;
     unsigned long int __unused5;
@@ -91,12 +107,24 @@
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
 
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     __ino64_t st_ino;			/* File serial number.		*/
   };
 #endif
@@ -104,6 +132,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/m68k/brk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/brk.c
--- sysdeps/unix/sysv/linux/m68k/brk.c	2001-07-22 20:27:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/brk.c	2003-01-09 05:06:05.000000000 +0100
@@ -1,5 +1,5 @@
 /* brk system call for Linux/m68k.
-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,16 +33,8 @@
 {
   void *newbrk;
 
-  {
-    register long d0 __asm__ ("%d0");
-
-    asm ("move%.l %2, %%d1\n"
-	 "trap #0"		/* Perform the system call.  */
-	 : "=d" (d0)
-	 : "0" (SYS_ify (brk)), "g" (addr)
-	 : "%d1");
-    newbrk = (void *) d0;
-  }
+  INTERNAL_SYSCALL_DECL (err);
+  newbrk = (void *) INTERNAL_SYSCALL (brk, err, 1, addr);
   __curbrk = newbrk;
 
   if (newbrk < addr)
diff -Nur sysdeps/unix/sysv/linux/m68k/chown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/chown.c
--- sysdeps/unix/sysv/linux/m68k/chown.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/chown.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,13 +26,7 @@
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
-extern int __syscall_chown (const char *__unbounded __file,
-			    __kernel_uid_t __owner, __kernel_gid_t __group);
-
 #ifdef __NR_chown32
-extern int __syscall_chown32 (const char *__unbounded __file,
-			      __kernel_uid32_t owner, __kernel_gid32_t group);
-
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
diff -Nur sysdeps/unix/sysv/linux/m68k/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/clone.S
--- sysdeps/unix/sysv/linux/m68k/clone.S	2002-08-04 04:20:06.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/clone.S	2002-12-15 22:39:21.000000000 +0100
@@ -57,8 +57,9 @@
 thread_start:
 	subl	%fp, %fp	/* terminate the stack frame */
 	jsr	(%a0)
-	movel	%d0, -(%sp)
-	jbsr	HIDDEN_JUMPTARGET (_exit)
+	movel	%d0, %d1
+	movel	#SYS_ify (exit), %d0
+	trap	#0
 
 PSEUDO_END (__clone)
 
diff -Nur sysdeps/unix/sysv/linux/m68k/getpagesize.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getpagesize.c
--- sysdeps/unix/sysv/linux/m68k/getpagesize.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getpagesize.c	2004-03-06 09:06:01.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Schwab <schwab@suse.de>.
 
@@ -33,13 +33,14 @@
   int result;
 #endif
 
-  if (GL(dl_pagesize) != 0)
-    return GL(dl_pagesize);
+  if (GLRO(dl_pagesize) != 0)
+    return GLRO(dl_pagesize);
 
 #ifdef __NR_getpagesize
-  result = INLINE_SYSCALL (getpagesize, 0);
+  INTERNAL_SYSCALL_DECL (err);
+  result = INTERNAL_SYSCALL (getpagesize, err, 0);
   /* The only possible error is ENOSYS.  */
-  if (result != -1)
+  if (!INTERNAL_SYSCALL_ERROR_P (result, err))
     return result;
 #endif
 
diff -Nur sysdeps/unix/sysv/linux/m68k/getpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getpmsg.c
--- sysdeps/unix/sysv/linux/m68k/getpmsg.c	1999-12-21 16:59:14.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/getpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/m68k/getsysstats.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getsysstats.c
--- sysdeps/unix/sysv/linux/m68k/getsysstats.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/getsysstats.c	2003-01-10 16:36:20.000000000 +0100
@@ -0,0 +1,37 @@
+/* Determine various system internal values, Linux/m68k version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Schwab <schwab@suse.de>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* We need to define a special parser for /proc/cpuinfo.  */
+#define GET_NPROCS_PARSER(FP, BUFFER, RESULT)				  \
+  do									  \
+    {									  \
+      (RESULT) = 0;							  \
+      /* Read all lines and count the lines starting with the string	  \
+	 "CPU:".  We don't have to fear extremely long lines since	  \
+	 the kernel will not generate them.  8192 bytes are really	  \
+	 enough.  */							  \
+      while (fgets_unlocked (BUFFER, sizeof (BUFFER), FP) != NULL)	  \
+	if (strncmp (BUFFER, "CPU:", 4) == 0)	      	     		  \
+	  ++(RESULT);							  \
+    }									  \
+  while (0)
+
+#include <sysdeps/unix/sysv/linux/getsysstats.c>
diff -Nur sysdeps/unix/sysv/linux/m68k/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/Makefile
--- sysdeps/unix/sysv/linux/m68k/Makefile	2002-03-29 00:41:51.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/Makefile	2002-10-14 03:02:53.000000000 +0200
@@ -3,7 +3,7 @@
 m68k-syntax-flag = -DMOTOROLA_SYNTAX
 
 ifeq ($(subdir),misc)
-sysdep_routines += mremap setfsgid setfsuid setresgid setresuid
+sysdep_routines += mremap
 sysdep_headers += sys/reg.h
 endif
 
diff -Nur sysdeps/unix/sysv/linux/m68k/putpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/putpmsg.c
--- sysdeps/unix/sysv/linux/m68k/putpmsg.c	1999-12-21 17:01:12.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/putpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/putpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/m68k/register-dump.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/register-dump.h
--- sysdeps/unix/sysv/linux/m68k/register-dump.h	2002-08-28 23:24:19.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/register-dump.h	2004-04-23 22:41:42.000000000 +0200
@@ -1,5 +1,5 @@
 /* Dump registers.
-   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Schwab <schwab@gnu.org>.
 
@@ -48,7 +48,7 @@
 /* static */ void catch_segfault (int, int, struct sigcontext *);
 
 /* Dummy function so that we can use asm with arguments.  */
-static void __attribute__ ((unused))
+static void __attribute_used__
 __dummy__ (void)
 {
   asm ("\n\
@@ -64,7 +64,7 @@
        : : "n" (offsetof (struct sigcontext, sc_fpstate)));
 }
 #define catch_segfault(a,b) \
-  __attribute__ ((unused)) real_catch_segfault(a,b)
+  __attribute_used__ real_catch_segfault(a,b)
 
 static void
 hexvalue (unsigned long int value, char *buf, size_t len)
diff -Nur sysdeps/unix/sysv/linux/m68k/semtimedop.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/semtimedop.S
--- sysdeps/unix/sysv/linux/m68k/semtimedop.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/semtimedop.S	2003-04-27 19:08:00.000000000 +0200
@@ -0,0 +1,60 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Schwab <schwab@suse.de>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#define SYSOP_semtimedop 4
+
+#define SVRSP	8		/* saved register space */
+#define PARMS	4+SVRSP		/* space for 3 saved regs */
+#define SEMID	PARMS
+#define SOPS	SEMID+4
+#define NSOPS	SOPS+4
+#define TIMEOUT	NSOPS+4
+
+	.text
+ENTRY (semtimedop)
+
+	/* Save registers.  */
+	move.l	%d2, %a1
+	move.l	%d3, -(%sp)
+	move.l	%d5, -(%sp)
+
+	move.l	#SYSOP_semtimedop, %d1
+	move.l	SEMID(%sp), %d2
+	move.l	NSOPS(%sp), %d3
+	move.l	SOPS(%sp), %d5
+	move.l	TIMEOUT(%sp), %a0
+	move.l	#SYS_ify (ipc), %d0
+
+	trap	#0
+
+	/* Restore registers.  */
+	move.l	(%sp)+, %d5
+	move.l	(%sp)+, %d3
+	move.l	%a1, %d2
+
+	/* Check for error.  */
+	tst.l	%d0
+	jmi	SYSCALL_ERROR_LABEL
+
+	/* Successful; return the syscall's value.  */
+	ret
+
+PSEUDO_END (semtimedop)
diff -Nur sysdeps/unix/sysv/linux/m68k/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/socket.S
--- sysdeps/unix/sysv/linux/m68k/socket.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/socket.S	2002-12-27 23:15:18.000000000 +0100
@@ -16,7 +16,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 #define P(a, b) P2(a, b)
@@ -41,6 +41,10 @@
 
 .globl __socket
 ENTRY (__socket)
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	jne 1f
+#endif
 
 	/* Save registers.  */
 	move.l %d2, %a0
@@ -64,6 +68,42 @@
 
 	/* Successful; return the syscall's value.  */
 	rts
+
+#if defined NEED_CANCELLATION && defined CENABLE
+1:	/* Enable asynchronous cancellation.  */
+	CENABLE
+
+	/* Save registers.  */
+	move.l %d2, -(%sp)
+	move.l %d0, -(%sp)
+
+	move.l #SYS_ify (socketcall), %d0 /* System call number in %d0.  */
+
+	/* Use ## so `socket' is a separate token that might be #define'd.  */
+	move.l #P (SOCKOP_,socket), %d1	/* Subcode is first arg to syscall.  */
+	lea 4+8(%sp), %a1		/* Address of args is 2nd arg.  */
+	move.l %a1, %d2
+
+	/* Do the system call trap.  */
+	trap #0
+
+	/* Restore cancellation.  */
+	move.l %d0, %d2
+	CDISABLE
+	addq.l #4, %sp
+	move.l %d2, %d0
+
+	/* Restore registers.  */
+	move.l (%sp)+, %d2
+
+	/* %d0 is < 0 if there was an error.  */
+	tst.l %d0
+	jmi SYSCALL_ERROR_LABEL
+
+	/* Successful; return the syscall's value.  */
+	rts
+#endif
+	
 PSEUDO_END (__socket)
 
 #ifndef NO_WEAK_ALIAS
diff -Nur sysdeps/unix/sysv/linux/m68k/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/sysdep.h
--- sysdeps/unix/sysv/linux/m68k/sysdep.h	2001-07-22 20:27:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/sysdep.h	2004-10-04 22:59:37.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Written by Andreas Schwab, <schwab@issan.informatik.uni-dortmund.de>,
    December 1995.
@@ -21,6 +21,9 @@
 #include <sysdeps/unix/sysdep.h>
 #include <sysdeps/m68k/sysdep.h>
 
+/* Defines RTLD_PRIVATE_ERRNO.  */
+#include <dl-sysdep.h>
+
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
    of the kernel.  But these symbols do not follow the SYS_* syntax
@@ -65,10 +68,48 @@
   SYSCALL_ERROR_HANDLER;						      \
   END (name)
 
+#undef PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#define ret_NOERRNO rts
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    negl %d0
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL rts
+
 #ifdef PIC
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER						      \
+SYSCALL_ERROR_LABEL:							      \
+    lea (rtld_errno, %pc), %a0;					      	      \
+    neg.l %d0;								      \
+    move.l %d0, (%a0);							      \
+    move.l &-1, %d0;							      \
+    /* Copy return value to %a0 for syscalls that are declared to return      \
+       a pointer (e.g., mmap).  */					      \
+    move.l %d0, %a0;							      \
+    rts;
+# else /* !RTLD_PRIVATE_ERRNO */
 /* Store (- %d0) into errno through the GOT.  */
-#ifdef _LIBC_REENTRANT
-#define SYSCALL_ERROR_HANDLER						      \
+#  if defined _LIBC_REENTRANT
+#   define SYSCALL_ERROR_HANDLER					      \
 SYSCALL_ERROR_LABEL:							      \
     neg.l %d0;								      \
     move.l %d0, -(%sp);							      \
@@ -79,8 +120,8 @@
        a pointer (e.g., mmap).  */					      \
     move.l %d0, %a0;							      \
     rts;
-#else /* !_LIBC_REENTRANT */
-#define SYSCALL_ERROR_HANDLER						      \
+#  else /* !_LIBC_REENTRANT */
+#   define SYSCALL_ERROR_HANDLER					      \
 SYSCALL_ERROR_LABEL:							      \
     move.l (errno@GOTPC, %pc), %a0;					      \
     neg.l %d0;								      \
@@ -90,9 +131,10 @@
        a pointer (e.g., mmap).  */					      \
     move.l %d0, %a0;							      \
     rts;
-#endif /* _LIBC_REENTRANT */
+#  endif /* _LIBC_REENTRANT */
+# endif /* RTLD_PRIVATE_ERRNO */
 #else
-#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
 #endif /* PIC */
 
 /* Linux takes system call arguments in registers:
@@ -163,10 +205,31 @@
 /* Define a macro which expands into the inline wrapper code for a system
    call.  */
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...)		\
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ unsigned int _sys_result = INTERNAL_SYSCALL (name, , nr, args);	\
+     if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_sys_result, ), 0))\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (_sys_result, ));		\
+	 _sys_result = (unsigned int) -1;				\
+       }								\
+     (int) _sys_result; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+/* Define a macro which expands inline into the wrapper code for a system
+   call.  This use is for internal calls that do not need to handle errors
+   normally.  It will never touch errno.  This returns just what the kernel
+   gave back.  */
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)	\
   ({ unsigned int _sys_result;				\
      {							\
+       /* Load argument values in temporary variables
+	  to perform side effects like function calls
+	  before the call used registers are set.  */	\
        LOAD_ARGS_##nr (args)				\
+       LOAD_REGS_##nr					\
        register int _d0 asm ("%d0") = __NR_##name;	\
        asm volatile ("trap #0"				\
 		     : "=d" (_d0)			\
@@ -174,34 +237,59 @@
 		     : "memory");			\
        _sys_result = _d0;				\
      }							\
-     if (_sys_result >= (unsigned int) -4095)		\
-       {						\
-	 __set_errno (-_sys_result);			\
-	 _sys_result = (unsigned int) -1;		\
-       }						\
      (int) _sys_result; })
 
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
+  ((unsigned int) (val) >= -4095U)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
+
 #define LOAD_ARGS_0()
+#define LOAD_REGS_0
 #define ASM_ARGS_0
 #define LOAD_ARGS_1(a1)				\
-  register int _d1 asm ("d1") = (int) (a1);	\
-  LOAD_ARGS_0 ()
+  LOAD_ARGS_0 ()				\
+  int __arg1 = (int) (a1);
+#define LOAD_REGS_1				\
+  register int _d1 asm ("d1") = __arg1;		\
+  LOAD_REGS_0
 #define ASM_ARGS_1	ASM_ARGS_0, "d" (_d1)
 #define LOAD_ARGS_2(a1, a2)			\
-  register int _d2 asm ("d2") = (int) (a2);	\
-  LOAD_ARGS_1 (a1)
+  LOAD_ARGS_1 (a1)				\
+  int __arg2 = (int) (a2);
+#define LOAD_REGS_2				\
+  register int _d2 asm ("d2") = __arg2;		\
+  LOAD_REGS_1
 #define ASM_ARGS_2	ASM_ARGS_1, "d" (_d2)
 #define LOAD_ARGS_3(a1, a2, a3)			\
-  register int _d3 asm ("d3") = (int) (a3);	\
-  LOAD_ARGS_2 (a1, a2)
+  LOAD_ARGS_2 (a1, a2)				\
+  int __arg3 = (int) (a3);
+#define LOAD_REGS_3				\
+  register int _d3 asm ("d3") = __arg3;		\
+  LOAD_REGS_2
 #define ASM_ARGS_3	ASM_ARGS_2, "d" (_d3)
 #define LOAD_ARGS_4(a1, a2, a3, a4)		\
-  register int _d4 asm ("d4") = (int) (a4);	\
-  LOAD_ARGS_3 (a1, a2, a3)
+  LOAD_ARGS_3 (a1, a2, a3)			\
+  int __arg4 = (int) (a4);
+#define LOAD_REGS_4				\
+  register int _d4 asm ("d4") = __arg4;		\
+  LOAD_REGS_3
 #define ASM_ARGS_4	ASM_ARGS_3, "d" (_d4)
 #define LOAD_ARGS_5(a1, a2, a3, a4, a5)		\
-  register int _d5 asm ("d5") = (int) (a5);	\
-  LOAD_ARGS_4 (a1, a2, a3, a4)
+  LOAD_ARGS_4 (a1, a2, a3, a4)			\
+  int __arg5 = (int) (a5);
+#define LOAD_REGS_5				\
+  register int _d5 asm ("d5") = __arg5;		\
+  LOAD_REGS_4
 #define ASM_ARGS_5	ASM_ARGS_4, "d" (_d5)
+#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)	\
+  LOAD_ARGS_5 (a1, a2, a3, a4, a5)		\
+  int __arg6 = (int) (a6);
+#define LOAD_REGS_6				\
+  register int _a0 asm ("a0") = __arg6;		\
+  LOAD_REGS_5
+#define ASM_ARGS_6	ASM_ARGS_5, "a" (_a0)
 
 #endif /* not __ASSEMBLER__ */
diff -Nur sysdeps/unix/sysv/linux/m68k/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/sysdep.S
--- sysdeps/unix/sysv/linux/m68k/sysdep.S	2002-08-25 01:14:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/sysdep.S	2002-10-11 12:51:12.000000000 +0200
@@ -18,19 +18,6 @@
 
 #include <sysdep.h>
 
-/* The Linux version is in fact m68k/ELF and the start.? file for this
-   system (sysdeps/m68k/elf/start.S) is also used by The Hurd.  This file
-   must not contain the definition of the `errno' variable, we have to
-   define it somewhere else.
-
-   ...and this place is here.  */
-	.bss
-	.globl errno
-	.type errno,@object
-errno:	.space 4
-	.size errno,4
-weak_alias (errno, _errno)
-	.text
 
 /* The following code is only used in the shared library when we
    compile the reentrant version.  Otherwise each system call defines
diff -Nur sysdeps/unix/sysv/linux/m68k/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/vfork.S
--- sysdeps/unix/sysv/linux/m68k/vfork.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/m68k/vfork.S	2003-01-10 15:05:26.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Schwab <schwab@gnu.org>.
 
@@ -20,6 +20,7 @@
 #include <sysdep.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
+#include <kernel-features.h>
 
 /* Clone the calling process, but without copying the whole address space.
    The calling process is suspended until the new process exits or is
@@ -46,13 +47,20 @@
 	/* Push back the return PC.  */
 	movel	%a0,%sp@-
 
+# ifdef __ASSUME_VFORK_SYSCALL
+#  ifndef PIC
+	jbra	SYSCALL_ERROR_LABEL
+#  endif
+# else
 	/* Check if vfork syscall is known at all.  */
 	movel	#-ENOSYS,%d1
 	cmpl	%d0,%d1
 	jne	SYSCALL_ERROR_LABEL
 
+# endif
 #endif
 
+#ifndef __ASSUME_VFORK_SYSCALL
 	/* If we don't have vfork, fork is close enough.  */
 
 	movel	#SYS_ify (fork), %d0
@@ -60,7 +68,9 @@
 	tstl	%d0
 	jmi	SYSCALL_ERROR_LABEL
 	rts
+#endif
 
 PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/makedev.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/makedev.c
--- sysdeps/unix/sysv/linux/makedev.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/makedev.c	2003-09-24 22:26:11.000000000 +0200
@@ -0,0 +1,41 @@
+/* Definitions of functions to access `dev_t' values.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <endian.h>
+#include <sys/sysmacros.h>
+
+unsigned int
+gnu_dev_major (unsigned long long int dev)
+{
+  return ((dev >> 8) & 0xfff) | ((unsigned int) (dev >> 32) & ~0xfff);
+}
+
+unsigned int
+gnu_dev_minor (unsigned long long int dev)
+{
+  return (dev & 0xff) | ((unsigned int) (dev >> 12) & ~0xff);
+}
+
+unsigned long long int
+gnu_dev_makedev (unsigned int major, unsigned int minor)
+{
+  return ((minor & 0xff) | ((major & 0xfff) << 8)
+	  | (((unsigned long long int) (minor & ~0xff)) << 12)
+	  | (((unsigned long long int) (major & ~0xfff)) << 32));
+}
diff -Nur sysdeps/unix/sysv/linux/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Makefile
--- sysdeps/unix/sysv/linux/Makefile	2002-09-15 02:14:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Makefile	2004-10-05 01:29:06.000000000 +0200
@@ -2,17 +2,20 @@
 sysdep_routines += errno-loc
 endif
 
-ifeq ($(subdir),db2)
-CPPFLAGS += -DHAVE_LLSEEK=1
+ifeq ($(subdir),assert)
+CFLAGS-assert.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+CFLAGS-assert-perr.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
 endif
 
 ifeq ($(subdir),malloc)
-CFLAGS-malloc.c = -DMORECORE_CLEARS=2
+CFLAGS-malloc.c += -DMORECORE_CLEARS=2
 endif
 
 ifeq ($(subdir),misc)
-sysdep_routines += sysctl clone llseek getresuid getresgid umount umount2 \
-		   readahead
+sysdep_routines += sysctl clone llseek umount umount2 readahead \
+		   setfsuid setfsgid makedev
+
+CFLAGS-gethostid.c = -fexceptions
 
 sysdep_headers += sys/mount.h sys/acct.h sys/sysctl.h \
 		  sys/klog.h sys/kdaemon.h \
@@ -20,14 +23,16 @@
 		  sys/kd.h sys/soundcard.h sys/vt.h \
 		  sys/quota.h sys/fsuid.h \
 		  scsi/sg.h scsi/scsi.h scsi/scsi_ioctl.h sys/pci.h \
-		  sys/ultrasound.h sys/raw.h sys/personality.h
+		  sys/ultrasound.h sys/raw.h sys/personality.h sys/epoll.h \
+		  bits/a.out.h
 
 install-others += $(inst_includedir)/bits/syscall.h
 
-ifndef no_syscall_list_h
 # Generate the list of SYS_* macros for the system calls (__NR_* macros).
+# For bi-arch platforms, the CPU/Makefile defines {32,64}bit-predefine and
+# we generate a file that uses <bits/wordsize.h>.
 $(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/sys/syscall.h
-	rm -f $(@:.h=.d)-t
+	$(make-target-directory)
 	{ \
 	 echo '/* Generated at libc build time from kernel syscall list.  */';\
 	 echo ''; \
@@ -35,17 +40,38 @@
 	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
 	 echo '#endif'; \
 	 echo ''; \
-	 SUNPRO_DEPENDENCIES='$(@:.h=.d)-t $@' \
-	 $(CC) -E -x c $(sysincludes) $< -D_LIBC -dM | \
-	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p'; \
+	 $(CC) -E -MD -MP -MF $(@:.h=.d)-t1 -MT '$(@:.d=.h) $(@:.h=.d)' \
+	       -x c $(sysincludes) $< $(addprefix -U,$(64bit-predefine)) \
+	       $(addprefix -D,$(32bit-predefine)) -D_LIBC -dM | \
+	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
+	 LC_ALL=C sort > $(@:.d=.h).new32; \
+	 $(CC) -E -MD -MP -MF $(@:.h=.d)-t2 -MT '$(@:.d=.h) $(@:.h=.d)' \
+	       -x c $(sysincludes) $< $(addprefix -U,$(32bit-predefine)) \
+	       $(addprefix -D,$(64bit-predefine)) -D_LIBC -dM | \
+	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
+	 LC_ALL=C sort > $(@:.d=.h).new64; \
+	 if cmp -s $(@:.d=.h).new32 $(@:.d=.h).new64; then \
+	   cat $(@:.d=.h).new32; \
+	 else \
+	   echo '#include <bits/wordsize.h>'; \
+	   echo ''; \
+	   LC_ALL=C comm -12 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#if __WORDSIZE == 64'; \
+	   LC_ALL=C comm -13 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#else'; \
+	   LC_ALL=C comm -23 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#endif'; \
+	 fi; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).new64; \
 	} > $(@:.d=.h).new
 	mv -f $(@:.d=.h).new $(@:.d=.h)
-	sed < $(@:.h=.d)-t > $(@:.h=.d)-t2 \
-	    -e 's,$(subst .,\.,$@),$(patsubst $(objpfx)%,$$(objpfx)%,\
-					      $(@:.d=.h) $(@:.h=.d)),'
-	rm -f $(@:.h=.d)-t
-	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
+ifneq (,$(objpfx))
+	sed $(sed-remove-objpfx) $(@:.h=.d)-t1 $(@:.h=.d)-t2 > $(@:.h=.d)-t3
+else
+	cat $(@:.h=.d)-t1 $(@:.h=.d)-t2 > $(@:.h=.d)-t3
 endif
+	rm -f $(@:.h=.d)-t1 $(@:.h=.d)-t2
+	mv -f $(@:.h=.d)-t3 $(@:.h=.d)
 
 $(inst_includedir)/bits/syscall.h: $(objpfx)syscall-list.h $(+force)
 	$(make-target-directory)
@@ -87,13 +113,13 @@
 endif
 
 ifeq ($(subdir),posix)
-sysdep_headers += bits/pthreadtypes.h bits/initspin.h
+sysdep_headers += bits/initspin.h
 
 sysdep_routines += exit-thread
 endif
 
 ifeq ($(subdir),inet)
-sysdep_headers += netinet/if_fddi.h netinet/if_tr.h netinet/igmp.h \
+sysdep_headers += netinet/if_fddi.h netinet/if_tr.h \
 		  netipx/ipx.h netash/ash.h netax25/ax25.h netatalk/at.h \
 		  netrom/netrom.h netpacket/packet.h netrose/rose.h \
 		  neteconet/ec.h
@@ -110,8 +136,22 @@
 CFLAGS-ypclnt.c = -DUSE_BINDINGDIR=1
 endif
 
+ifeq ($(subdir),io)
+sysdep_routines += xstatconv internal_statvfs internal_statvfs64
+endif
+
 ifeq ($(subdir),elf)
 sysdep-rtld-routines += dl-brk dl-sbrk
 
 CPPFLAGS-lddlibc4 += -DNOT_IN_libc
 endif
+
+ifeq ($(subdir),rt)
+CFLAGS-mq_send.c += -fexceptions
+CFLAGS-mq_receive.c += -fexceptions
+endif
+
+ifeq ($(subdir),nscd)
+CFLAGS-connections.c += -DHAVE_EPOLL
+CFLAGS-gai.c += -DNEED_NETLINK
+endif
diff -Nur sysdeps/unix/sysv/linux/mips/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/fcntl.h
--- sysdeps/unix/sysv/linux/mips/bits/fcntl.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/fcntl.h	2004-11-24 05:37:34.000000000 +0100
@@ -1,5 +1,6 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,9 +22,9 @@
 # error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
 #endif
 
+#include <sgidefs.h>
 #include <sys/types.h>
 
-
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
 #define O_ACCMODE	0x0003
@@ -48,6 +49,7 @@
 # define O_NOFOLLOW	0x20000	/* Do not follow links.	 */
 # define O_DIRECT	0x8000	/* Direct disk access hint.  */
 # define O_DIRECTORY	0x10000	/* Must be a directory.	 */
+# define O_NOATIME	0x40000	/* Do not set atime.  */
 #endif
 
 #define O_NDELAY	O_NONBLOCK
@@ -80,7 +82,7 @@
 #define F_SETLK64	34	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	35	/* Set record locking info (blocking).	*/
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	24	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	23	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -142,14 +144,20 @@
 #ifndef __USE_FILE_OFFSET64
     __off_t l_start;	/* Offset where the lock begins.  */
     __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
-    long int l_sysid;	/* XXX */
+#if _MIPS_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       fcntls in o32 and n32, never has this field.  */
+    long int l_sysid;
+#endif
 #else
     __off64_t l_start;	/* Offset where the lock begins.  */
     __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
 #endif
     __pid_t l_pid;	/* Process holding the lock.  */
-#ifndef __USE_FILE_OFFSET64
-    long int pad[4];	/* XXX */
+#if ! defined __USE_FILE_OFFSET64 && _MIPS_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       flock in o32 and n32, never has this field.  */
+    long int pad[4];
 #endif
 } flock_t;
 
diff -Nur sysdeps/unix/sysv/linux/mips/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/mman.h
--- sysdeps/unix/sysv/linux/mips/bits/mman.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/mman.h	2004-12-15 02:00:48.000000000 +0100
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/MIPS version.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
@@ -59,6 +63,8 @@
 # define MAP_DENYWRITE	0x2000		/* ETXTBSY */
 # define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
 # define MAP_LOCKED	0x8000		/* pages are locked */
+# define MAP_POPULATE   0x10000         /* populate (prefault) pagetables */
+# define MAP_NONBLOCK   0x20000         /* do not block on IO */
 #endif
 
 /* Flags to `msync'.  */
diff -Nur sysdeps/unix/sysv/linux/mips/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/resource.h
--- sysdeps/unix/sysv/linux/mips/bits/resource.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/resource.h	2004-08-16 10:51:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* Bit values & structures for resource limits.  Linux/MIPS version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -55,34 +56,43 @@
      This affects swapping; processes that are exceeding their
      resident set size will be more likely to have physical memory
      taken from them.  */
-  RLIMIT_RSS = 7,
-#define	RLIMIT_RSS RLIMIT_RSS
+  __RLIMIT_RSS = 7,
+#define	RLIMIT_RSS __RLIMIT_RSS
 
   /* Number of open files.  */
   RLIMIT_NOFILE = 5,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
 #define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
 
   /* Address space limit (?) */
   RLIMIT_AS = 6,
 #define RLIMIT_AS RLIMIT_AS
 
   /* Number of processes.  */
-  RLIMIT_NPROC = 8,
-#define RLIMIT_NPROC RLIMIT_NPROC
+  __RLIMIT_NPROC = 8,
+#define RLIMIT_NPROC __RLIMIT_NPROC
 
   /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 9,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+  __RLIMIT_MEMLOCK = 9,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
 
   /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
 
-  RLIM_NLIMITS = 11
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  __RLIMIT_NLIMITS = 13,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
 };
 
 /* Value to indicate that there is no limit.  */
@@ -137,12 +147,8 @@
 #define RUSAGE_SELF RUSAGE_SELF
 
   /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
+  RUSAGE_CHILDREN = -1
 #define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
 };
 
 #define __need_timeval
diff -Nur sysdeps/unix/sysv/linux/mips/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/shm.h
--- sysdeps/unix/sysv/linux/mips/bits/shm.h	2002-08-24 00:19:50.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/shm.h	2003-07-16 09:39:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995,1996,1997,2000,2001,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,8 +36,7 @@
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
 /* Segment low boundary address multiple.  */
-#define SHMLBA		(__getpagesize ())
-extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+#define SHMLBA		0x40000
 
 
 /* Type to count number of attaches.  */
@@ -67,6 +66,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST	01000	/* segment will be destroyed on last detach */
 # define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
 
 struct shminfo
   {
diff -Nur sysdeps/unix/sysv/linux/mips/bits/sigaction.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/sigaction.h
--- sysdeps/unix/sysv/linux/mips/bits/sigaction.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/sigaction.h	2003-03-25 22:51:52.000000000 +0100
@@ -1,5 +1,6 @@
 /* The proper definitions for Linux/MIPS's sigaction.
-   Copyright (C) 1993,94,95,97,98,99,2000 Free Software Foundation, Inc.
+   Copyright (C) 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2003
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -49,7 +50,7 @@
     /* Restore handler.  */
     void (*sa_restorer) (void);
 
-#if _MIPS_ISA == _MIPS_ISA_MIPS1 || _MIPS_ISA == _MIPS_ISA_MIPS2
+#if _MIPS_SZPTR < 64
     int sa_resv[1];
 #endif
   };
diff -Nur sysdeps/unix/sysv/linux/mips/bits/sigcontext.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h
--- sysdeps/unix/sysv/linux/mips/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h	2004-11-24 05:37:34.000000000 +0100
@@ -0,0 +1,105 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#include <sgidefs.h>
+
+#ifndef sigcontext_struct
+/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
+   we need sigcontext.  */
+# define sigcontext_struct sigcontext
+
+/* # include <asm/sigcontext.h> */
+/* Instead of including the kernel header, that will vary depending on
+   whether the 32- or the 64-bit kernel is installed, we paste the
+   contents here.  In case you're wondering about the different
+   licenses, the fact that the file is pasted, instead of included,
+   doesn't really make any difference for the program that includes
+   this header.  */
+#if _MIPS_SIM == _ABIO32
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 1997, 2000 by Ralf Baechle
+ */
+#ifndef _ASM_SIGCONTEXT_H
+#define _ASM_SIGCONTEXT_H
+
+/*
+ * Keep this struct definition in sync with the sigcontext fragment
+ * in arch/mips/tools/offset.c
+ */
+struct sigcontext {
+	unsigned int       sc_regmask;		/* Unused */
+	unsigned int       sc_status;
+	unsigned long long sc_pc;
+	unsigned long long sc_regs[32];
+	unsigned long long sc_fpregs[32];
+	unsigned int       sc_ownedfp;		/* Unused */
+	unsigned int       sc_fpc_csr;
+	unsigned int       sc_fpc_eir;		/* Unused */
+	unsigned int       sc_used_math;
+	unsigned int       sc_ssflags;		/* Unused */
+	unsigned long long sc_mdhi;
+	unsigned long long sc_mdlo;
+
+	unsigned int       sc_cause;		/* Unused */
+	unsigned int       sc_badvaddr;		/* Unused */
+
+	unsigned long      sc_sigset[4];	/* kernel's sigset_t */
+};
+
+#endif /* _ASM_SIGCONTEXT_H */
+#else /* _MIPS_SIM != _ABIO32 */
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 1997, 1999 by Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_SIGCONTEXT_H
+#define _ASM_SIGCONTEXT_H
+
+/*
+ * Keep this struct definition in sync with the sigcontext fragment
+ * in arch/mips/tools/offset.c
+ */
+struct sigcontext {
+	unsigned long long sc_regs[32];
+	unsigned long long sc_fpregs[32];
+	unsigned long long sc_mdhi;
+	unsigned long long sc_mdlo;
+	unsigned long long sc_pc;
+	unsigned int       sc_status;
+	unsigned int       sc_fpc_csr;
+	unsigned int       sc_fpc_eir;
+	unsigned int       sc_used_math;
+	unsigned int       sc_cause;
+	unsigned int       sc_badvaddr;
+};
+
+#endif /* _ASM_SIGCONTEXT_H */
+#endif /* _MIPS_SIM != _ABIO32 */
+#endif
diff -Nur sysdeps/unix/sysv/linux/mips/bits/siginfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/siginfo.h
--- sysdeps/unix/sysv/linux/mips/bits/siginfo.h	2001-07-21 07:21:55.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/siginfo.h	2004-11-22 13:47:50.000000000 +0100
@@ -1,5 +1,6 @@
 /* siginfo_t, sigevent and constants.  Linux/MIPS version.
-   Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,6 +23,8 @@
 # error "Never include this file directly.  Use <signal.h> instead"
 #endif
 
+#include <bits/wordsize.h>
+
 #if (!defined __have_sigval_t \
      && (defined _SIGNAL_H || defined __need_siginfo_t \
 	 || defined __need_sigevent_t))
@@ -39,8 +42,13 @@
      && (defined _SIGNAL_H || defined __need_siginfo_t))
 # define __have_siginfo_t	1
 
-# define __SI_MAX_SIZE     128
-# define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
+# define __SI_MAX_SIZE		128
+# if __WORDSIZE == 64
+#  define __SI_PAD_SIZE		((__SI_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SI_PAD_SIZE		((__SI_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
 
 typedef struct siginfo
   {
@@ -48,6 +56,8 @@
     int si_code;		/* Signal code.  */
     int si_errno;		/* If non-zero, an errno value associated with
 				   this signal, as defined in <errno.h>.  */
+    int __pad0[__SI_MAX_SIZE / sizeof (int) - __SI_PAD_SIZE - 3];
+				/* Explicit padding.  */
 
     union
       {
@@ -119,9 +129,11 @@
    signals.  */
 enum
 {
-  SI_ASYNCNL = -6,		/* Sent by asynch name lookup completion.  */
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
 # define SI_ASYNCNL	SI_ASYNCNL
-  SI_SIGIO,			/* Sent by queued SIGIO. */
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
+  SI_SIGIO,			/* Sent by queued SIGIO.  */
 # define SI_SIGIO	SI_SIGIO
   SI_MESGQ,			/* Sent by real time mesq state change.  */
 # define SI_MESGQ	SI_MESGQ
@@ -147,7 +159,7 @@
 # define ILL_ILLOPN	ILL_ILLOPN
   ILL_ILLADR,			/* Illegal addressing mode.  */
 # define ILL_ILLADR	ILL_ILLADR
-  ILL_ILLTRP,			/* Illegal trap. */
+  ILL_ILLTRP,			/* Illegal trap.  */
 # define ILL_ILLTRP	ILL_ILLTRP
   ILL_PRVOPC,			/* Privileged opcode.  */
 # define ILL_PRVOPC	ILL_PRVOPC
@@ -271,8 +283,8 @@
 
 	struct
 	  {
-	    void (*_function) (sigval_t);	  /* Function to start.  */
-	    struct __pthread_attr_s *_attribute;  /* Really pthread_attr_t.  */
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
 	  } _sigev_thread;
       } _sigev_un;
   } sigevent_t;
diff -Nur sysdeps/unix/sysv/linux/mips/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/socket.h
--- sysdeps/unix/sysv/linux/mips/bits/socket.h	2001-09-26 07:21:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/socket.h	2004-12-15 02:00:55.000000000 +0100
@@ -1,5 +1,6 @@
 /* System-specific socket constants and types.  Linux/MIPS version.
-   Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1991, 92, 1994-1999, 2000, 2001, 2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -261,7 +262,7 @@
 #  define _EXTERN_INLINE extern __inline
 # endif
 _EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
     /* The kernel header does this so there may be a reason.  */
diff -Nur sysdeps/unix/sysv/linux/mips/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/stat.h
--- sysdeps/unix/sysv/linux/mips/bits/stat.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/stat.h	2004-11-24 05:37:34.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,6 +21,8 @@
 # error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
 #endif
 
+#include <sgidefs.h>
+
 /* Versions of the `struct stat' data structure.  */
 #define _STAT_VER_LINUX_OLD	1
 #define _STAT_VER_KERNEL	1
@@ -33,6 +36,7 @@
 #define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
 
 
+#if _MIPS_SIM == _ABIO32
 /* Structure describing file characteristics.  */
 struct stat
   {
@@ -106,6 +110,71 @@
     long int st_pad4[14];
   };
 #endif
+#else
+struct stat
+  {
+    __dev_t st_dev;
+    int	st_pad1[3];		/* Reserved for st_dev expansion  */
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;
+#else
+    __ino64_t st_ino;
+#endif
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+#if !defined __USE_FILE_OFFSET64
+    unsigned int st_pad2[2];	/* Reserved for st_rdev expansion  */
+    __off_t st_size;
+    int st_pad3;
+#else
+    unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
+    __off64_t st_size;
+#endif
+    __time_t st_atime;
+    int __reserved0;
+    __time_t st_mtime;
+    int __reserved1;
+    __time_t st_ctime;
+    int __reserved2;
+    __blksize_t st_blksize;
+    unsigned int st_pad4;
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;
+#else
+    __blkcnt64_t st_blocks;
+#endif
+    int st_pad5[14];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;
+    unsigned int st_pad1[3];	/* Reserved for st_dev expansion  */
+    __ino64_t st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
+    __off64_t st_size;
+    __time_t st_atime;
+    int __reserved0;
+    __time_t st_mtime;
+    int __reserved1;
+    __time_t st_ctime;
+    int __reserved2;
+    __blksize_t st_blksize;
+    unsigned int st_pad3;
+    __blkcnt64_t st_blocks;
+    int st_pad4[14];
+};
+#endif
+#endif
 
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
diff -Nur sysdeps/unix/sysv/linux/mips/bits/termios.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/termios.h
--- sysdeps/unix/sysv/linux/mips/bits/termios.h	2001-10-31 18:35:22.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/termios.h	2004-03-31 10:53:29.000000000 +0200
@@ -73,6 +73,7 @@
 #define IXANY	0004000		/* Any character will restart after stop.  */
 #define IXOFF	0010000		/* Enable start/stop input control.  */
 #define IMAXBEL 0020000		/* Ring bell when input queue is full.  */
+#define IUTF8	0040000		/* Input is UTF8.  */
 
 /* c_oflag bits */
 #define OPOST	0000001		/* Perform output processing.  */
diff -Nur sysdeps/unix/sysv/linux/mips/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/types.h
--- sysdeps/unix/sysv/linux/mips/bits/types.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/bits/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-/* Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <sys/types.h> instead.
- */
-
-#ifndef	_BITS_TYPES_H
-#define	_BITS_TYPES_H	1
-
-#include <features.h>
-
-#define __need_size_t
-#include <stddef.h>
-
-/* Convenience types.  */
-typedef unsigned char __u_char;
-typedef unsigned short __u_short;
-typedef unsigned int __u_int;
-typedef unsigned long __u_long;
-#ifdef __GNUC__
-__extension__ typedef unsigned long long int __u_quad_t;
-__extension__ typedef long long int __quad_t;
-#else
-typedef struct
-  {
-    long int __val[2];
-  } __quad_t;
-typedef struct
-  {
-    __u_long __val[2];
-  } __u_quad_t;
-#endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#ifdef __GNUC__
-__extension__ typedef signed long long int __int64_t;
-__extension__ typedef unsigned long long int __uint64_t;
-#endif
-typedef __quad_t *__qaddr_t;
-
-typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
-typedef __u_int __uid_t;		/* Type of user identifications.  */
-typedef __u_int __gid_t;		/* Type of group identifications.  */
-typedef __u_long __ino_t;		/* Type of file serial numbers.  */
-typedef __u_int __mode_t;		/* Type of file attribute bitmasks.  */
-typedef __u_int __nlink_t; 		/* Type of file link counts.  */
-typedef long int __off_t;		/* Type of file sizes and offsets.  */
-typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
-typedef int __pid_t;			/* Type of process identifications.  */
-typedef int __ssize_t;			/* Type of a byte count, or error.  */
-typedef __u_long __rlim_t;		/* Type of resource counts.  */
-typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
-typedef __u_int __id_t;			/* General type for ID.  */
-
-typedef struct
-  {
-    int __val[2];
-  } __fsid_t;				/* Type of file system IDs.  */
-
-/* Everythin' else.  */
-typedef int __daddr_t;			/* The type of a disk address.  */
-typedef char *__caddr_t;
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef long int __suseconds_t;
-typedef long int __swblk_t;		/* Type of a swap block maybe?  */
-
-typedef long int __clock_t;
-
-/* Clock ID used in clock and timer functions.  */
-typedef int __clockid_t;
-
-/* Timer ID returned by `timer_create'.  */
-typedef int __timer_t;
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define __FD_SETSIZE	1024
-
-
-typedef int __key_t;
-
-/* Used in `struct shmid_ds'.  */
-typedef long int __ipc_pid_t;
-
-
-/* Type to represent block size.  */
-typedef long int __blksize_t;
-
-/* Types from the Large File Support interface.  */
-
-/* Type to count number os disk blocks.  */
-typedef long int __blkcnt_t;
-typedef __quad_t __blkcnt64_t;
-
-/* Type to count file system blocks.  */
-typedef __u_long __fsblkcnt_t;
-typedef __u_quad_t __fsblkcnt64_t;
-
-/* Type to count file system inodes.  */
-typedef __u_long __fsfilcnt_t;
-typedef __u_quad_t __fsfilcnt64_t;
-
-/* Type of file serial numbers.  */
-typedef __u_quad_t __ino64_t;
-
-/* Type of file sizes and offsets.  */
-typedef __loff_t __off64_t;
-
-/* Used in XTI.  */
-typedef long int __t_scalar_t;
-typedef unsigned long int __t_uscalar_t;
-
-/* Duplicates info from stdint.h but this is used in unistd.h.  */
-typedef int __intptr_t;
-
-/* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
-
-
-/* Now add the thread types.  */
-#if defined __USE_POSIX199506 || defined __USE_UNIX98
-# include <bits/pthreadtypes.h>
-#endif
-
-#endif /* bits/types.h */
diff -Nur sysdeps/unix/sysv/linux/mips/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/clone.S
--- sysdeps/unix/sysv/linux/mips/clone.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/clone.S	2003-03-29 09:01:57.000000000 +0100
@@ -1,6 +1,6 @@
-/* Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by Ralf Baechle <ralf@gnu.ai.mit.edu>, 1996.
+   Contributed by Ralf Baechle <ralf@linux-mips.org>, 1996.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -21,7 +21,6 @@
    and invokes a function in the right context after its all over.  */
 
 #include <sys/asm.h>
-#include <asm/unistd.h>
 #include <sysdep.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
@@ -29,15 +28,17 @@
 /* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg) */
 
 	.text
+LOCALSZ= 1
+FRAMESZ= (((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK
+GPOFF= FRAMESZ-(1*SZREG)
 NESTED(__clone,4*SZREG,sp)
 #ifdef __PIC__
-	.set		noreorder
-	.cpload		$25
-	.set		reorder
-	subu		sp,32
-	.cprestore	16
-#else
-	subu		sp,32
+	SETUP_GP
+#endif
+	PTR_SUBU sp, FRAMESZ
+	SETUP_GP64 (GPOFF, __clone)
+#ifdef __PIC__
+	SAVE_GP (GPOFF)
 #endif
 #ifdef PROF
 	.set		noat
@@ -49,12 +50,12 @@
 
 	/* Sanity check arguments.  */
 	li		v0,EINVAL
-	beqz		a0,error	/* No NULL function pointers.  */
-	beqz		a1,error	/* No NULL stack pointers.  */
+	beqz		a0,L(error)	/* No NULL function pointers.  */
+	beqz		a1,L(error)	/* No NULL stack pointers.  */
 
-	subu		a1,32		/* Reserve argument save space.  */
-	sw		a0,0(a1)	/* Save function pointer.  */
-	sw		a3,4(a1)	/* Save argument pointer.  */
+	PTR_SUBU	a1,32		/* Reserve argument save space.  */
+	PTR_S		a0,0(a1)	/* Save function pointer.  */
+	PTR_S		a3,PTRSIZE(a1)	/* Save argument pointer.  */
 
 
 	/* Do the system call */
@@ -62,20 +63,24 @@
 	li		v0,__NR_clone
 	syscall
 
-	bnez		a3,error
-	beqz		v0,__thread_start
+	bnez		a3,L(error)
+	beqz		v0,L(thread_start)
 
 	/* Successful return from the parent */
-	addiu		sp,32
+	RESTORE_GP64
+	PTR_ADDU	sp, FRAMESZ
 	ret
 
 	/* Something bad happened -- no child created */
-error:
-	addiu		sp,32
+L(error):
 #ifdef __PIC__
-	la		t9,__syscall_error
+	PTR_LA		t9,__syscall_error
+	RESTORE_GP64
+	PTR_ADDU	sp, FRAMESZ
 	jr		t9
 #else
+	RESTORE_GP64
+	PTR_ADDU	sp, FRAMESZ
 	j		__syscall_error
 #endif
 	END(__clone)
@@ -85,20 +90,21 @@
    debug info.  */
 
 ENTRY(__thread_start)
+L(thread_start):
 	/* cp is already loaded.  */
-	.cprestore	16
+	SAVE_GP (GPOFF)
 	/* The stackframe has been created on entry of clone().  */
 	/* Restore the arg for user's function.  */
-	lw		t9,0(sp)	/* Function pointer.  */
-	lw		a0,4(sp)	/* Argument pointer.  */
+	PTR_L		t9,0(sp)	/* Function pointer.  */
+	PTR_L		a0,PTRSIZE(sp)	/* Argument pointer.  */
 
 	/* Call the user's function.  */
-	jalr		t9
+	jal		t9
 
 	/* Call _exit rather than doing it inline for breakpoint purposes.  */
 	move		a0,v0
 #ifdef __PIC__
-	la		t9,_exit
+	PTR_LA		t9,_exit
 	jalr		t9
 #else
 	jal		_exit
diff -Nur sysdeps/unix/sysv/linux/mips/configure /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/configure
--- sysdeps/unix/sysv/linux/mips/configure	2002-10-02 07:08:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/configure	2005-04-07 04:12:00.000000000 +0200
@@ -1,58 +1,76 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
  # Local configure fragment for sysdeps/unix/sysv/linux/mips.
 
-for ac_prog in $AS
-do
-# Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:9: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$AS"; then
-  ac_cv_prog_AS="$AS" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_AS="$ac_prog"
-      break
+case $machine in
+mips*64*)
+  rm -f asm-unistd.h
+  asm_unistd_h=$sysheaders/asm/unistd.h
+  if test ! -f $asm_unistd_h; then
+    # Try to find asm/unistd.h in compiler header search path.
+    try_asm_unistd_h=`echo '#include <asm/unistd.h>' | $CPP - |
+			sed -n '/^# 1 "\(\/[^"]*\)".*/{s,,\1,p;q;}'`
+    if test -n "$try_asm_unistd_h" &&
+       test -f "$try_asm_unistd_h"; then
+      asm_unistd_h=$try_asm_unistd_h
     fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-AS="$ac_cv_prog_AS"
-if test -n "$AS"; then
-  echo "$ac_t""$AS" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-test -n "$AS" && break
-done
-
-if test -z "$AS"; then
-  ac_verc_fail=yes
-else
-  # Found it, now check the version.
-  echo $ac_n "checking version of $AS""... $ac_c" 1>&6
-echo "configure:43: checking version of $AS" >&5
-  ac_prog_version=`$AS --version 2>&1 | sed -n 's/^.*GNU assembler.* \([0-9]*\.[0-9.]*\(-ia64-[0-9]*\)*\).*$/\1/p'`
-  case $ac_prog_version in
-    '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
-    2.11.90.0.[5-9]* | 2.11.90.[1-9]* | 2.11.9[1-9]* | 2.11.[1-9]* | 2.1[2-9]*| 2.[2-9]*)
-       ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
-    *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
-
-  esac
-  echo "$ac_t""$ac_prog_version" 1>&6
-fi
-if test $ac_verc_fail = yes; then
-  echo "configure: warning: *** Your binutils versions are too old.  
-*** We strongly advise to update binutils.  For details check 
-*** the FAQ and INSTALL documents." 1>&2
-fi
-
+  fi
+  if test ! -f "$asm_unistd_h"; then
+    { echo "$as_me:$LINENO: WARNING: *** asm/unistd.h not found, it will not be pre-processed" >&5
+echo "$as_me: WARNING: *** asm/unistd.h not found, it will not be pre-processed" >&2;}
+    echo '#include <asm/unistd.h>' > asm-unistd.h
+  else
+    # The point of this preprocessing is to turn __NR_<syscall> into
+    # __NR_N64_<syscall>, as well as to define __NR_<syscall> to
+    # __NR_<abi>_<syscall>, if __NR_<abi>_<syscall> is defined
+    # and <abi> is the compiler-enabled ABI.
+    cat "$asm_unistd_h" |
+    sed -e 's,__NR_,__NR_N64_,g' \
+        -e 's,__NR_N64_##,__NR_##,g' \
+	-e 's,__NR_N64_O32_,__NR_O32_,g' \
+	-e 's,__NR_N64_N32_,__NR_N32_,g' \
+	-e 's,__NR_N64_N64_,__NR_N64_,g' \
+    | awk > asm-unistd.h '
+BEGIN { print "#include <sgidefs.h>"; }
+/^#define __NR.*unused/ { print; next; }
+/^#define __NR_N64__exit __NR_N64_exit/ {
+	print "#define __NR__exit __NR_exit";
+	print "#define __NR_O32__exit __NR_O32_exit";
+	print "#define __NR_N32__exit __NR_N32_exit";
+	print; next;
+}
+/^#define __NR_O32_/ {
+	name = $2;
+	sub (/_O32_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABIO32";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+/^#define __NR_N32_/ {
+	name = $2;
+	sub (/_N32_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABIN32";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+/^#define __NR_N64_/ {
+	name = $2;
+	sub (/_N64_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABI64";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+{
+	print;
+}'
+  fi ;;
+mips*)
+  rm -f asm-unistd.h
+  echo '#include <asm/unistd.h>' > asm-unistd.h
+  ;;
+esac
diff -Nur sysdeps/unix/sysv/linux/mips/configure.in /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/configure.in
--- sysdeps/unix/sysv/linux/mips/configure.in	2001-08-26 10:01:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/configure.in	2004-11-24 05:38:31.000000000 +0100
@@ -2,10 +2,75 @@
 GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
 # Local configure fragment for sysdeps/unix/sysv/linux/mips.
 
-define([AC_SUBST])dnl Prevent junk from being appended due to no AC_OUTPUT
-AC_CHECK_PROG_VER(AS, $AS, --version,
-  [GNU assembler.* \([0-9]*\.[0-9.]*\(-ia64-[0-9]*\)*\)],
-  [2.11.90.0.[5-9]* | 2.11.90.[1-9]* | 2.11.9[1-9]* | 2.11.[1-9]* | 2.1[2-9]*| 2.[2-9]*], 
-AC_MSG_WARN([*** Your binutils versions are too old.  
-*** We strongly advise to update binutils.  For details check 
-*** the FAQ and INSTALL documents.]))
+case $machine in
+mips*64*)
+  rm -f asm-unistd.h
+  asm_unistd_h=$sysheaders/asm/unistd.h
+  if test ! -f $asm_unistd_h; then
+    # Try to find asm/unistd.h in compiler header search path.
+    try_asm_unistd_h=`echo '#include <asm/unistd.h>' | $CPP - |
+			sed -n '/^# 1 "\(\/[^"]*\)".*/{s,,\1,p;q;}'`
+    if test -n "$try_asm_unistd_h" &&
+       test -f "$try_asm_unistd_h"; then
+      asm_unistd_h=$try_asm_unistd_h
+    fi
+  fi
+  if test ! -f "$asm_unistd_h"; then
+    AC_MSG_WARN([*** asm/unistd.h not found, it will not be pre-processed])
+    echo '#include <asm/unistd.h>' > asm-unistd.h
+  else
+    # The point of this preprocessing is to turn __NR_<syscall> into
+    # __NR_N64_<syscall>, as well as to define __NR_<syscall> to
+    # __NR_<abi>_<syscall>, if __NR_<abi>_<syscall> is defined
+    # and <abi> is the compiler-enabled ABI.
+    cat "$asm_unistd_h" |
+    sed -e 's,__NR_,__NR_N64_,g' \
+        -e 's,__NR_N64_##,__NR_##,g' \
+	-e 's,__NR_N64_O32_,__NR_O32_,g' \
+	-e 's,__NR_N64_N32_,__NR_N32_,g' \
+	-e 's,__NR_N64_N64_,__NR_N64_,g' \
+    | awk > asm-unistd.h '
+BEGIN { print "#include <sgidefs.h>"; }
+/^#define __NR.*unused/ { print; next; }
+/^#define __NR_N64__exit __NR_N64_exit/ {
+	print "#define __NR__exit __NR_exit";
+	print "#define __NR_O32__exit __NR_O32_exit";
+	print "#define __NR_N32__exit __NR_N32_exit";
+	print; next;
+}
+/^#define __NR_O32_/ {
+	name = $2;
+	sub (/_O32_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABIO32";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+/^#define __NR_N32_/ {
+	name = $2;
+	sub (/_N32_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABIN32";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+/^#define __NR_N64_/ {
+	name = $2;
+	sub (/_N64_/, "_", name);
+	print;
+	print "#if _MIPS_SIM == _ABI64";
+	print "# define " name " " $2;
+	print "#endif";
+	next;
+}
+{
+	print;
+}'
+  fi ;;
+mips*)
+  rm -f asm-unistd.h
+  echo '#include <asm/unistd.h>' > asm-unistd.h
+  ;;
+esac
diff -Nur sysdeps/unix/sysv/linux/mips/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/dl-cache.h
--- sysdeps/unix/sysv/linux/mips/dl-cache.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/dl-cache.h	2003-06-25 10:03:24.000000000 +0200
@@ -0,0 +1,43 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6						\
+	  && (! memcmp (path + len - 6, "/lib64", 6)		\
+	      || ! memcmp (path + len - 6, "/lib32", 6)))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "32", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include_next <dl-cache.h>
diff -Nur sysdeps/unix/sysv/linux/mips/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ftruncate64.c
--- sysdeps/unix/sysv/linux/mips/ftruncate64.c	2002-09-28 22:12:57.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ftruncate64.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -32,11 +33,6 @@
 extern int __have_no_truncate64;
 #endif
 
-/* The order of hight, low depends on endianness.  */
-extern int __syscall_ftruncate64 (int fd, int dummy, int high_length,
-				  int low_length);
-
-
 /* Truncate the file FD refers to to LENGTH bytes.  */
 int
 __ftruncate64 (int fd, off64_t length)
diff -Nur sysdeps/unix/sysv/linux/mips/getpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/getpmsg.c
--- sysdeps/unix/sysv/linux/mips/getpmsg.c	1999-12-21 16:59:14.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/getpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/getpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/mips/kernel_sigaction.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/kernel_sigaction.h
--- sysdeps/unix/sysv/linux/mips/kernel_sigaction.h	2000-12-15 07:05:44.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/kernel_sigaction.h	2003-03-25 22:51:53.000000000 +0100
@@ -12,7 +12,7 @@
 
 	/* Abi says here follows reserved int[2] */
 	void		(*sa_restorer)(void);
-#if (_MIPS_ISA == _MIPS_ISA_MIPS1) || (_MIPS_ISA == _MIPS_ISA_MIPS2)
+#if (_MIPS_SZPTR < 64)
 	/*
 	 * For 32 bit code we have to pad struct sigaction to get
 	 * constant size for the ABI
@@ -23,7 +23,7 @@
 
 
 #define _KERNEL_NSIG	       128
-#define _KERNEL_NSIG_BPW       32
+#define _KERNEL_NSIG_BPW       _MIPS_SZLONG
 #define _KERNEL_NSIG_WORDS     (_KERNEL_NSIG / _KERNEL_NSIG_BPW)
 
 typedef struct {
diff -Nur sysdeps/unix/sysv/linux/mips/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/kernel_stat.h
--- sysdeps/unix/sysv/linux/mips/kernel_stat.h	2000-11-20 09:45:43.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/kernel_stat.h	2004-11-24 05:37:35.000000000 +0100
@@ -1,4 +1,32 @@
-/* Definition of `struct stat' used in the kernel..  */
+#include <sgidefs.h>
+/* As tempting as it is to define XSTAT_IS_XSTAT64 for n64, the
+   userland data structures are not identical, because of different
+   padding.  */
+/* Definition of `struct stat' used in the kernel.  */
+#if _MIPS_SIM != _ABIO32
+struct kernel_stat
+  {
+    unsigned int st_dev;
+    unsigned int __pad1[3];
+    unsigned long long st_ino;
+    unsigned int st_mode;
+    unsigned int st_nlink;
+    int st_uid;
+    int st_gid;
+    unsigned int st_rdev;
+    unsigned int __pad2[3];
+    long long st_size;
+    unsigned int st_atime;
+    unsigned int __unused1;
+    unsigned int st_mtime;
+    unsigned int __unused2;
+    unsigned int st_ctime;
+    unsigned int __unused3;
+    unsigned int st_blksize;
+    unsigned int __pad3;
+    unsigned long long st_blocks;
+  };
+#else
 struct kernel_stat
   {
     unsigned long int st_dev;
@@ -26,3 +54,4 @@
     unsigned int st_flags;
     unsigned int st_gen;
   };
+#endif
diff -Nur sysdeps/unix/sysv/linux/mips/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/Makefile
--- sysdeps/unix/sysv/linux/mips/Makefile	2002-03-29 00:41:51.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/Makefile	2004-11-24 05:38:15.000000000 +0100
@@ -1,6 +1,4 @@
 ifeq ($(subdir),signal)
-sysdep_routines += rt_sigsuspend rt_sigprocmask rt_sigtimedwait	\
-		   rt_sigqueueinfo rt_sigaction rt_sigpending
 #sysdep_routines += sigsuspend
 endif
 
@@ -8,4 +6,51 @@
 sysdep_routines += cachectl cacheflush sysmips _test_and_set
 
 sysdep_headers += sys/cachectl.h sys/sysmips.h sys/tas.h
+
+no_syscall_list_h = 1
+
+# Generate the list of SYS_* macros for the system calls (__NR_* macros).
+# We generate not only SYS_<syscall>, pointing at SYS_<abi>_<syscall> if
+# it exists, but also define SYS_<abi>_<syscall> for all ABIs.
+$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/mips/sys/syscall.h
+	$(make-target-directory)
+	{ \
+	 echo '/* Generated at libc build time from kernel syscall list.  */';\
+	 echo ''; \
+	 echo '#ifndef _SYSCALL_H'; \
+	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
+	 echo '#endif'; \
+	 echo ''; \
+	 echo '#include <sgidefs.h>'; \
+	 rm -f $(@:.d=.h).newt; \
+	 $(CC) -E -MD -MP -MF $(@:.h=.d)-t -MT '$(@:.d=.h) $(@:.h=.d)' \
+	       -x c $(+includes) $(sysincludes) $< -D_LIBC -dM | \
+	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' \
+	     > $(@:.d=.h).newt; \
+	 if grep SYS_O32_ $(@:.d=.h).newt > /dev/null; then \
+	   echo '#if _MIPS_SIM == _ABIN32'; \
+	   sed -n 's/^\(#define SYS_\)N32_/\1/p' < $(@:.d=.h).newt | \
+		LC_ALL=C sort; \
+	   echo '#elif _MIPS_SIM == _ABI64'; \
+	   sed -n 's/^\(#define SYS_\)N64_/\1/p' < $(@:.d=.h).newt | \
+		LC_ALL=C sort; \
+	   echo '#else'; \
+	   sed -n 's/^\(#define SYS_\)O32_/\1/p' < $(@:.d=.h).newt | \
+		LC_ALL=C sort; \
+	   echo '#endif'; \
+	   sed -n '/^#define SYS_\([ON]32\|N64\)_/p' < $(@:.d=.h).newt | \
+		LC_ALL=C sort +1.8; \
+	 else \
+	   cat $(@:.d=.h).newt; \
+	 fi; \
+	 rm $(@:.d=.h).newt; \
+	} > $(@:.d=.h).new
+	mv -f $(@:.d=.h).new $(@:.d=.h)
+ifneq (,$(objpfx))
+	sed $(sed-remove-objpfx) $(@:.h=.d)-t > $(@:.h=.d)-t2
+	rm -f $(@:.h=.d)-t
+	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
+else
+	mv -f $(@:.h=.d)-t $(@:.h=.d)
+endif
 endif
diff -Nur sysdeps/unix/sysv/linux/mips/mips32/kern64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips32/kern64/sysdep.h
--- sysdeps/unix/sysv/linux/mips/mips32/kern64/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips32/kern64/sysdep.h	2003-03-29 09:15:29.000000000 +0100
@@ -0,0 +1,36 @@
+/* Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_MIPS32_KERN64_SYSDEP_H
+#define _LINUX_MIPS_MIPS32_KERN64_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/sysv/linux/mips/mips32/sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_O32_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_O32_/**/syscall_name
+#endif
+
+#endif /* linux/mips/mips32/kern64/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/mips/mips32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
--- sysdeps/unix/sysv/linux/mips/mips32/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h	2004-10-18 07:16:06.000000000 +0200
@@ -0,0 +1,283 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_MIPS32_SYSDEP_H
+#define _LINUX_MIPS_MIPS32_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/mips/mips32/sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+
+#else   /* ! __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)                               \
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);      	\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )  		\
+       {                                                                \
+         __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));      	\
+         result_var = -1L;                               		\
+       }                                                                \
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) long err
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (err))
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) internal_syscall##nr(name, err, args)
+
+#define internal_syscall0(name, err, dummy...) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %2\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "i" (SYS_ify(name))						\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(name, err, arg1) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %3\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(name, err, arg1, arg2) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %4\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(name, err, arg1, arg2, arg3) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(name, err, arg1, arg2, arg3, arg4) 		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(name, err, arg1, arg2, arg3, arg4, arg5) 	\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"lw\t$2, %6\n\t" 						\
+	"subu\t$29, 32\n\t" 						\
+	"sw\t$2, 16($29)\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu\t$29, 32\n\t" 						\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" ((long)arg5) 						\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(name, err, arg1, arg2, arg3, arg4, arg5, arg6)\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"lw\t$2, %6\n\t" 						\
+	"lw\t$8, %7\n\t" 						\
+	"subu\t$29, 32\n\t" 						\
+	"sw\t$2, 16($29)\n\t" 						\
+	"sw\t$8, 20($29)\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu\t$29, 32\n\t" 						\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" ((long)arg5), "m" ((long)arg6)				\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall7(name, err, arg1, arg2, arg3, arg4, arg5, arg6, arg7)\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"lw\t$2, %6\n\t" 						\
+	"lw\t$8, %7\n\t" 						\
+	"lw\t$9, %8\n\t" 						\
+	"subu\t$29, 32\n\t" 						\
+	"sw\t$2, 16($29)\n\t" 						\
+	"sw\t$8, 20($29)\n\t" 						\
+	"sw\t$9, 24($29)\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu\t$29, 32\n\t" 						\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" ((long)arg5), "m" ((long)arg6), "m" ((long)arg7)		\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13", \
+	"$14", "$15", "$24", "$25", "memory"
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* linux/mips/mips32/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/Dist
--- sysdeps/unix/sysv/linux/mips/mips64/Dist	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/Dist	2003-03-17 16:57:19.000000000 +0100
@@ -0,0 +1 @@
+ldd-rewrite.sed
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h
--- sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1,26 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
+  { "/lib64/ld.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed
--- sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/ldd-rewrite.sed	2003-03-17 16:57:19.000000000 +0100
@@ -0,0 +1 @@
+s_^\(RTLDLIST=\)\(.*lib\)\(\|32\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\232\4 \264\4 \2\4"_
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/llseek.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/llseek.c
--- sysdeps/unix/sysv/linux/mips/mips64/llseek.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/llseek.c	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1 @@
+/* lseek() is 64-bit capable already.  */
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n32/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/ftruncate64.c
--- sysdeps/unix/sysv/linux/mips/mips64/n32/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/ftruncate64.c	2003-04-05 21:57:35.000000000 +0200
@@ -0,0 +1,28 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+
+#include <sysdep.h>
+
+extern int ftruncate (int fd, off64_t length);
+
+int __ftruncate64 (int fd, off64_t length) {
+  return ftruncate (fd, length);
+}
+weak_alias (__ftruncate64, ftruncate64)
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
--- sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h	2004-10-18 07:16:07.000000000 +0200
@@ -0,0 +1,242 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_SYSDEP_H
+#define _LINUX_MIPS_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/mips/mips64/n32/sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_N32_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_N32_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+
+#else   /* ! __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)                               \
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);      	\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )  		\
+       {                                                                \
+         __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));      	\
+         result_var = -1L;                               		\
+       }                                                                \
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) long err
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (err))
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) internal_syscall##nr(name, err, args)
+
+#define internal_syscall0(name, err, dummy...) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %2\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "i" (SYS_ify(name))						\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(name, err, arg1) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %3\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(name, err, arg1, arg2) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a1 asm("$5") = (long long) arg2; 		\
+	register long long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %4\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(name, err, arg1, arg2, arg3) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a1 asm("$5") = (long long) arg2; 		\
+	register long long __a2 asm("$6") = (long long) arg3; 		\
+	register long long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(name, err, arg1, arg2, arg3, arg4) 		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a1 asm("$5") = (long long) arg2; 		\
+	register long long __a2 asm("$6") = (long long) arg3; 		\
+	register long long __a3 asm("$7") = (long long) arg4; 		\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(name, err, arg1, arg2, arg3, arg4, arg5) 	\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a1 asm("$5") = (long long) arg2; 		\
+	register long long __a2 asm("$6") = (long long) arg3; 		\
+	register long long __a3 asm("$7") = (long long) arg4; 		\
+	register long long __a4 asm("$8") = (long long) arg5; 		\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "r" (__a4) 							\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(name, err, arg1, arg2, arg3, arg4, arg5, arg6)\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long long __v0 asm("$2"); 				\
+	register long long __a0 asm("$4") = (long long) arg1; 		\
+	register long long __a1 asm("$5") = (long long) arg2; 		\
+	register long long __a2 asm("$6") = (long long) arg3; 		\
+	register long long __a3 asm("$7") = (long long) arg4; 		\
+	register long long __a4 asm("$8") = (long long) arg5; 		\
+	register long long __a5 asm("$9") = (long long) arg6; 		\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "r" (__a4), "r" (__a5)					\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "$1", "$3", "$10", "$11", "$12", "$13", \
+	"$14", "$15", "$24", "$25", "memory"
+#endif /* __ASSEMBLER__ */
+
+#endif /* linux/mips/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n32/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/truncate64.c
--- sysdeps/unix/sysv/linux/mips/mips64/n32/truncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n32/truncate64.c	2003-04-05 21:57:35.000000000 +0200
@@ -0,0 +1,30 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+
+#include <sysdep.h>
+#include <bp-checks.h>
+
+extern int truncate (const char *__unbounded path, int dummy,
+		     off64_t length);
+
+int truncate64 (const char *__unbounded path, int dummy,
+		off64_t length) {
+  return truncate (path, dummy, length);
+}
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/glob64.c
--- sysdeps/unix/sysv/linux/mips/mips64/n64/glob64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/glob64.c	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1 @@
+/* glob64 is in glob.c */
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n64/ioctl.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/ioctl.S
--- sysdeps/unix/sysv/linux/mips/mips64/n64/ioctl.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/ioctl.S	2003-03-20 08:54:56.000000000 +0100
@@ -0,0 +1,42 @@
+/* Copyright 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include <sys/asm.h>
+
+/* Sign-extend the ioctl number, since the kernel wants it as a
+   sign-extended 32-bit value, but our prototype is that of a long.  */
+
+	.text
+ENTRY (__ioctl)
+	li v0, __NR_ioctl
+	sll a1,a1,0
+	syscall			/* Do the system call.  */
+	bne a3, zero, L(error)
+	ret
+
+L(error):
+	.cpsetup t9, a0, __ioctl
+	PTR_LA t9,__syscall_error
+	.cprestore
+	jr t9
+
+PSEUDO_END (__ioctl)
+
+weak_alias (__ioctl, ioctl)
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
--- sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h	2004-10-18 07:16:08.000000000 +0200
@@ -0,0 +1,242 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_SYSDEP_H
+#define _LINUX_MIPS_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/mips/mips64/n64/sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_N64_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_N64_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+
+#else   /* ! __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)                               \
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);      	\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )  		\
+       {                                                                \
+         __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));      	\
+         result_var = -1L;                               		\
+       }                                                                \
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) long err
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (err))
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) internal_syscall##nr(name, err, args)
+
+#define internal_syscall0(name, err, dummy...) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %2\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "i" (SYS_ify(name))						\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(name, err, arg1) 				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %3\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(name, err, arg1, arg2) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %4\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(name, err, arg1, arg2, arg3) 			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7"); 					\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(name, err, arg1, arg2, arg3, arg4) 		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(name, err, arg1, arg2, arg3, arg4, arg5) 	\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	register long __a4 asm("$8") = (long) arg5; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "r" (__a4) 							\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(name, err, arg1, arg2, arg3, arg4, arg5, arg6)\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("$2"); 					\
+	register long __a0 asm("$4") = (long) arg1; 			\
+	register long __a1 asm("$5") = (long) arg2; 			\
+	register long __a2 asm("$6") = (long) arg3; 			\
+	register long __a3 asm("$7") = (long) arg4; 			\
+	register long __a4 asm("$8") = (long) arg5; 			\
+	register long __a5 asm("$9") = (long) arg6; 			\
+	__asm__ volatile ( 						\
+	".set\tnoreorder\n\t" 						\
+	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set\treorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "r" (__a4), "r" (__a5)					\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "$1", "$3", "$10", "$11", "$12", "$13", \
+	"$14", "$15", "$24", "$25", "memory"
+#endif /* __ASSEMBLER__ */
+
+#endif /* linux/mips/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/recv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/recv.c
--- sysdeps/unix/sysv/linux/mips/mips64/recv.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/recv.c	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/recv.c>
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/send.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/send.c
--- sysdeps/unix/sysv/linux/mips/mips64/send.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/send.c	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/send.c>
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/syscall.S
--- sysdeps/unix/sysv/linux/mips/mips64/syscall.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/syscall.S	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1,53 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include <sys/asm.h>
+
+/* Please consult the file sysdeps/unix/sysv/linux/x86-64/sysdep.h for
+   more information about the value -4095 used below.  */
+
+/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5)
+   We need to do some arg shifting, the syscall_number will be in
+   rax.  */
+
+
+	.text
+ENTRY (syscall)
+	move v0, a0		/* Syscall number -> v0 */
+	move a0, a1		/* shift arg1 - arg7.  */
+	move a1, a2
+	move a2, a3
+	move a3, a4
+	move a4, a5
+	move a5, a6
+	move a6, a7
+
+	syscall			/* Do the system call.  */
+	bne a3, zero, L(error)
+
+	ret
+
+L(error):
+	.cpsetup t9, a0, syscall
+	PTR_LA t9,__syscall_error
+	.cprestore
+	jr t9
+
+PSEUDO_END (syscall)
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list
--- sysdeps/unix/sysv/linux/mips/mips64/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list	2004-07-21 08:13:15.000000000 +0200
@@ -0,0 +1,21 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+lseek		-	lseek		i:iii	__libc_lseek	__lseek lseek __llseek llseek __libc_lseek64 __lseek64 lseek64
+
+# proper socket implementations:
+recvfrom	-	recvfrom	i:ibniBN __libc_recvfrom __recvfrom recvfrom
+sendto		-	sendto		i:ibnibn __libc_sendto	__sendto sendto
+
+# semaphore and shm system calls
+msgctl		-	msgctl		i:iip	__msgctl	msgctl
+msgget		-	msgget		i:ii	__msgget	msgget
+msgrcv		-	msgrcv		i:ibnii	__msgrcv	msgrcv
+msgsnd		-	msgsnd		i:ibni	__msgsnd	msgsnd
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmctl		-	shmctl		i:iip	__shmctl	shmctl
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
+semget		-	semget		i:iii	__semget	semget
+semctl		-	semctl		i:iiii	__semctl	semctl
diff -Nur sysdeps/unix/sysv/linux/mips/mips64/umount.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/umount.c
--- sysdeps/unix/sysv/linux/mips/mips64/umount.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/mips64/umount.c	2003-03-17 17:20:44.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/hppa/umount.c>
diff -Nur sysdeps/unix/sysv/linux/mips/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pread64.c
--- sysdeps/unix/sysv/linux/mips/pread64.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pread64.c	2004-11-27 21:01:02.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -18,15 +19,25 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
 #include <unistd.h>
 #include <endian.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #include <kernel-features.h>
 
+#ifdef __NR_pread64             /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
 #if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
 
 # if __ASSUME_PREAD_SYSCALL == 0
@@ -34,11 +45,6 @@
 				  off64_t offset) internal_function;
 # endif
 
-extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
-				int dummy, off_t offset_hi, off_t offset_lo);
-
-
-
 ssize_t
 __libc_pread64 (fd, buf, count, offset)
      int fd;
@@ -48,15 +54,44 @@
 {
   ssize_t result;
 
+
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			      (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
   /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
   result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
 			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
 					     (off_t) (offset & 0xffffffff)));
+#endif
 # if __ASSUME_PREAD_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use the emulation.  */
     result = __emulate_pread64 (fd, buf, count, offset);
 # endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
   return result;
 }
 
diff -Nur sysdeps/unix/sysv/linux/mips/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pread.c
--- sysdeps/unix/sysv/linux/mips/pread.c	2002-07-17 22:35:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pread.c	2004-11-27 21:01:02.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,25 +20,31 @@
 
 #include <assert.h>
 #include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
 #include <unistd.h>
 #include <endian.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #include <kernel-features.h>
 
+#ifdef __NR_pread64             /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
 #if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
 
 # if __ASSUME_PREAD_SYSCALL == 0
 static ssize_t __emulate_pread (int fd, void *buf, size_t count,
 				off_t offset) internal_function;
 # endif
-extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
-				int dummy, off_t offset_hi, off_t offset_lo);
-
-
 
 ssize_t
 __libc_pread (fd, buf, count, offset)
@@ -48,15 +55,45 @@
 {
   ssize_t result;
 
-  /* First try the syscall.  */
+#if _MIPS_SIM != _ABI64
   assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+        /* No system call available.  Use the emulation.  */
+        result = __emulate_pread (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
   result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
 			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
 # if __ASSUME_PREAD_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use the emulation.  */
     result = __emulate_pread (fd, buf, count, offset);
 # endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
   return result;
 }
 
diff -Nur sysdeps/unix/sysv/linux/mips/profil-counter.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/profil-counter.h
--- sysdeps/unix/sysv/linux/mips/profil-counter.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/profil-counter.h	2003-04-13 13:36:32.000000000 +0200
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff -Nur sysdeps/unix/sysv/linux/mips/ptrace.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ptrace.c
--- sysdeps/unix/sysv/linux/mips/ptrace.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ptrace.c	2004-11-24 05:36:11.000000000 +0100
@@ -0,0 +1,111 @@
+/* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sgidefs.h>
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <sys/user.h>
+#include <stdarg.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+#include <sgidefs.h>
+
+#if _MIPS_SIM == _ABIN32
+__extension__ typedef long long int reg_type;
+#else
+typedef long int reg_type;
+#endif
+
+reg_type
+ptrace (enum __ptrace_request request, ...)
+{
+  reg_type res, ret;
+  va_list ap;
+  pid_t pid;
+  void *addr;
+  reg_type data;
+
+  va_start (ap, request);
+  pid = va_arg (ap, pid_t);
+  addr = va_arg (ap, void *);
+  data = va_arg (ap, reg_type);
+  va_end (ap);
+
+  if (request > 0 && request < 4)
+    data = &ret;
+
+#if __BOUNDED_POINTERS__
+  switch (request)
+    {
+    case PTRACE_PEEKTEXT:
+    case PTRACE_PEEKDATA:
+    case PTRACE_PEEKUSER:
+    case PTRACE_POKETEXT:
+    case PTRACE_POKEDATA:
+    case PTRACE_POKEUSER:
+      (void) CHECK_1 ((int *) addr);
+      (void) CHECK_1 ((int *) data);
+      break;
+
+    case PTRACE_GETREGS:
+    case PTRACE_SETREGS:
+      /* We don't know the size of data, so the best we can do is ensure
+	 that `data' is valid for at least one word.  */
+      (void) CHECK_1 ((int *) data);
+      break;
+
+    case PTRACE_GETFPREGS:
+    case PTRACE_SETFPREGS:
+      /* We don't know the size of data, so the best we can do is ensure
+	 that `data' is valid for at least one word.  */
+      (void) CHECK_1 ((int *) data);
+      break;
+
+    case PTRACE_GETFPXREGS:
+    case PTRACE_SETFPXREGS:
+      /* We don't know the size of data, so the best we can do is ensure
+	 that `data' is valid for at least one word.  */
+      (void) CHECK_1 ((int *) data);
+      break;
+
+    case PTRACE_TRACEME:
+    case PTRACE_CONT:
+    case PTRACE_KILL:
+    case PTRACE_SINGLESTEP:
+    case PTRACE_ATTACH:
+    case PTRACE_DETACH:
+    case PTRACE_SYSCALL:
+      /* Neither `data' nor `addr' needs any checks.  */
+      break;
+    };
+#endif
+
+  res = INLINE_SYSCALL (ptrace, 4, request, pid,
+			__ptrvalue (addr), __ptrvalue (data));
+  if (res >= 0 && request > 0 && request < 4)
+    {
+      __set_errno (0);
+      return ret;
+    }
+
+  return res;
+}
diff -Nur sysdeps/unix/sysv/linux/mips/putpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/putpmsg.c
--- sysdeps/unix/sysv/linux/mips/putpmsg.c	1999-12-21 17:01:20.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/putpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/putpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/mips/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pwrite64.c
--- sysdeps/unix/sysv/linux/mips/pwrite64.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pwrite64.c	2004-11-27 21:01:03.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ralf Baechle <ralf@gnu.org>, 1998.
 
@@ -18,19 +19,26 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
 #include <unistd.h>
 #include <endian.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #include <kernel-features.h>
 
-#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+#ifdef __NR_pwrite64            /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
 
-extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf, size_t count,
-				 int dummy, off_t offset_hi, off_t offset_lo);
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
 
 # if __ASSUME_PWRITE_SYSCALL == 0
 static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
@@ -46,16 +54,44 @@
 {
   ssize_t result;
 
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
   /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
   result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
 			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
 					     (off_t) (offset & 0xffffffff)));
+#endif
 # if __ASSUME_PWRITE_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use the emulation.  */
     result = __emulate_pwrite64 (fd, buf, count, offset);
 # endif
 
+  LIBC_CANCEL_RESET (oldtype);
+
   return result;
 }
 
diff -Nur sysdeps/unix/sysv/linux/mips/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pwrite.c
--- sysdeps/unix/sysv/linux/mips/pwrite.c	2002-07-17 22:35:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/pwrite.c	2004-11-27 21:01:02.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -19,19 +20,26 @@
 
 #include <assert.h>
 #include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
 #include <unistd.h>
 #include <endian.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #include <kernel-features.h>
 
-#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+#ifdef __NR_pwrite64            /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
 
-extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf, size_t count,
-				 int dummy, off_t offset_hi, off_t offset_lo);
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
 
 # if __ASSUME_PWRITE_SYSCALL == 0
 static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
@@ -47,16 +55,45 @@
 {
   ssize_t result;
 
-  /* First try the syscall.  */
+#if _MIPS_SIM != _ABI64
   assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+        /* No system call available.  Use the emulation.  */
+        result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
   result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
 			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
 # if __ASSUME_PWRITE_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use the emulation.  */
     result = __emulate_pwrite (fd, buf, count, offset);
 # endif
 
+  LIBC_CANCEL_RESET (oldtype);
+
   return result;
 }
 
diff -Nur sysdeps/unix/sysv/linux/mips/readelflib.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/readelflib.c
--- sysdeps/unix/sysv/linux/mips/readelflib.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/readelflib.c	2003-03-14 08:52:05.000000000 +0100
@@ -0,0 +1,71 @@
+/* Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Alexandre Oliva <aoliva@redhat.com>
+   Based on work ../x86_64/readelflib.c,
+   contributed by Andreas Jaeger <aj@suse.de>, 1999 and
+		  Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+int process_elf32_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+int process_elf64_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+
+/* Returns 0 if everything is ok, != 0 in case of error.  */
+int
+process_elf_file (const char *file_name, const char *lib, int *flag,
+		  unsigned int *osversion, char **soname, void *file_contents,
+		  size_t file_length)
+{
+  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
+  int ret;
+
+  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
+    {
+      ret = process_elf32_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+
+      /* n32 libraries are always libc.so.6+.  */
+      if (ret && (elf_header->e_flags & EF_MIPS_ABI2) != 0)
+	*flag = FLAG_MIPS64_LIBN32|FLAG_ELF_LIBC6;
+    }
+  else
+    {
+      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* n64 libraries are always libc.so.6+.  */
+      if (!ret)
+	*flag = FLAG_MIPS64_LIBN64|FLAG_ELF_LIBC6;
+    }
+
+  return ret;
+}
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf32_file
+#define __ELF_NATIVE_CLASS 32
+#include "sysdeps/generic/readelflib.c"
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf64_file
+#define __ELF_NATIVE_CLASS 64
+#include "sysdeps/generic/readelflib.c"
diff -Nur sysdeps/unix/sysv/linux/mips/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sigaction.c
--- sysdeps/unix/sysv/linux/mips/sigaction.c	2002-09-18 19:59:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sigaction.c	2004-11-24 05:36:11.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2002,2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,12 +18,15 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#include <sgidefs.h>
 #include <signal.h>
 #include <string.h>
 
 #include <sysdep.h>
 #include <sys/syscall.h>
 
+#include <sgidefs.h>
+
 #include "kernel-features.h"
 
 /* The difference here is that the sigaction structure used in the
@@ -35,12 +39,17 @@
    functions which have RT equivalents.	 This is the definition.  */
 int __libc_missing_rt_sigs;
 
-extern int __syscall_sigaction (int, const struct old_kernel_sigaction *__unbounded,
-				struct old_kernel_sigaction *__unbounded);
 #endif
-extern int __syscall_rt_sigaction (int, const struct kernel_sigaction *__unbounded,
-				   struct kernel_sigaction *__unbounded, size_t);
 
+#if _MIPS_SIM != _ABIO32
+
+# ifdef __NR_rt_sigreturn
+static void restore_rt (void) asm ("__restore_rt");
+# endif
+# ifdef __NR_sigreturn
+static void restore (void) asm ("__restore");
+# endif
+#endif
 
 /* If ACT is not NULL, change the action for SIG to *ACT.
    If OACT is not NULL, put the old action for SIG in *OACT.  */
@@ -74,7 +83,11 @@
 	  memcpy (&kact.sa_mask, &act->sa_mask, sizeof (kernel_sigset_t));
 	  kact.sa_flags = act->sa_flags;
 # ifdef HAVE_SA_RESTORER
+#  if _MIPS_SIM == _ABIO32
 	  kact.sa_restorer = act->sa_restorer;
+#  else
+	  kact.sa_restorer = &restore_rt;
+#  endif
 # endif
 	}
 
@@ -128,13 +141,48 @@
       oact->sa_mask.__val[0] = k_osigact.sa_mask;
       oact->sa_flags = k_osigact.sa_flags;
 # ifdef HAVE_SA_RESTORER
+#  if _MIPS_SIM == _ABIO32
       oact->sa_restorer = k_osigact.sa_restorer;
+#  else
+      oact->sa_restorer = &restore;
+#  endif
 # endif
     }
   return result;
 #endif
 }
 libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction)
+#endif
+
+/* NOTE: Please think twice before making any changes to the bits of
+   code below.  GDB needs some intimate knowledge about it to
+   recognize them as signal trampolines, and make backtraces through
+   signal handlers work right.  Important are both the names
+   (__restore_rt) and the exact instruction sequence.
+   If you ever feel the need to make any changes, please notify the
+   appropriate GDB maintainer.  */
+
+#define RESTORE(name, syscall) RESTORE2 (name, syscall)
+#define RESTORE2(name, syscall) \
+asm						\
+  (						\
+   ".align 4\n"					\
+   "__" #name ":\n"				\
+   "	li $2, " #syscall "\n"			\
+   "	syscall\n"				\
+   );
+
+/* The return code for realtime-signals.  */
+#if _MIPS_SIM != _ABIO32
+# ifdef __NR_rt_sigreturn
+RESTORE (restore_rt, __NR_rt_sigreturn)
+# endif
+# ifdef __NR_sigreturn
+RESTORE (restore, __NR_sigreturn)
+# endif
+#endif
diff -Nur sysdeps/unix/sysv/linux/mips/sigcontextinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sigcontextinfo.h
--- sysdeps/unix/sysv/linux/mips/sigcontextinfo.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sigcontextinfo.h	2004-11-24 05:37:35.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 2000.
 
@@ -18,6 +18,10 @@
    02111-1307 USA.  */
 
 
+#include <sgidefs.h>
+
+#if _MIPS_SIM == _ABIO32
+
 #define SIGCONTEXT unsigned long _code, struct sigcontext *
 #define SIGCONTEXT_EXTRA_ARGS _code,
 #define GET_PC(ctx)	((void *) ctx->sc_pc)
@@ -25,3 +29,15 @@
 #define GET_STACK(ctx)	((void *) ctx->sc_regs[29])
 #define CALL_SIGHANDLER(handler, signo, ctx) \
   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+
+#else
+
+#define SIGCONTEXT unsigned long _code, ucontext_t *
+#define SIGCONTEXT_EXTRA_ARGS _code,
+#define GET_PC(ctx)	((void *) ctx->uc_mcontext.pc)
+#define GET_FRAME(ctx)	((void *) ctx->uc_mcontext.gregs[30])
+#define GET_STACK(ctx)	((void *) ctx->uc_mcontext.gregs[29])
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/mips/sys/procfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/procfs.h
--- sysdeps/unix/sysv/linux/mips/sys/procfs.h	2002-02-09 02:19:07.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/procfs.h	2004-11-24 05:36:11.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,15 +25,21 @@
    used on Linux.  */
 
 #include <features.h>
+#include <sgidefs.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/user.h>
+#include <sgidefs.h>
 
 /* ELF register definitions */
 #define ELF_NGREG	45
 #define ELF_NFPREG	33
 
+#if _MIPS_SIM == _ABIN32
+__extension__ typedef unsigned long long elf_greg_t;
+#else
 typedef unsigned long elf_greg_t;
+#endif
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
 typedef double elf_fpreg_t;
@@ -59,8 +66,13 @@
   {
     struct elf_siginfo pr_info;		/* Info associated with signal.  */
     short int pr_cursig;		/* Current signal.  */
+#if _MIPS_SIM == _ABIN32
+    __extension__ unsigned long long int pr_sigpend;
+    __extension__ unsigned long long int pr_sighold;
+#else
     unsigned long int pr_sigpend;	/* Set of pending signals.  */
     unsigned long int pr_sighold;	/* Set of held signals.  */
+#endif
     __pid_t pr_pid;
     __pid_t pr_ppid;
     __pid_t pr_pgrp;
@@ -82,7 +94,11 @@
     char pr_sname;			/* Char for pr_state.  */
     char pr_zomb;			/* Zombie.  */
     char pr_nice;			/* Nice val.  */
+#if _MIPS_SIM == _ABIN32
+    __extension__ unsigned long long int pr_flag;
+#else
     unsigned long int pr_flag;		/* Flags.  */
+#endif
     long pr_uid;
     long pr_gid;
     int pr_pid, pr_ppid, pr_pgrp, pr_sid;
diff -Nur sysdeps/unix/sysv/linux/mips/sys/ptrace.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/ptrace.h
--- sysdeps/unix/sysv/linux/mips/sys/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/ptrace.h	2004-11-24 05:37:35.000000000 +0100
@@ -0,0 +1,136 @@
+/* `ptrace' debugger support interface.  Linux version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+#include <sgidefs.h>
+
+__BEGIN_DECLS
+
+/* Type of the REQUEST argument to `ptrace.'  */
+enum __ptrace_request
+{
+  /* Indicate that the process making this request should be traced.
+     All signals received by this process can be intercepted by its
+     parent, and its parent can use the other `ptrace' requests.  */
+  PTRACE_TRACEME = 0,
+#define PT_TRACE_ME PTRACE_TRACEME
+
+  /* Return the word in the process's text space at address ADDR.  */
+  PTRACE_PEEKTEXT = 1,
+#define PT_READ_I PTRACE_PEEKTEXT
+
+  /* Return the word in the process's data space at address ADDR.  */
+  PTRACE_PEEKDATA = 2,
+#define PT_READ_D PTRACE_PEEKDATA
+
+  /* Return the word in the process's user area at offset ADDR.  */
+  PTRACE_PEEKUSER = 3,
+#define PT_READ_U PTRACE_PEEKUSER
+
+  /* Write the word DATA into the process's text space at address ADDR.  */
+  PTRACE_POKETEXT = 4,
+#define PT_WRITE_I PTRACE_POKETEXT
+
+  /* Write the word DATA into the process's data space at address ADDR.  */
+  PTRACE_POKEDATA = 5,
+#define PT_WRITE_D PTRACE_POKEDATA
+
+  /* Write the word DATA into the process's user area at offset ADDR.  */
+  PTRACE_POKEUSER = 6,
+#define PT_WRITE_U PTRACE_POKEUSER
+
+  /* Continue the process.  */
+  PTRACE_CONT = 7,
+#define PT_CONTINUE PTRACE_CONT
+
+  /* Kill the process.  */
+  PTRACE_KILL = 8,
+#define PT_KILL PTRACE_KILL
+
+  /* Single step the process.
+     This is not supported on all machines.  */
+  PTRACE_SINGLESTEP = 9,
+#define PT_STEP PTRACE_SINGLESTEP
+
+  /* Get all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETREGS = 12,
+#define PT_GETREGS PTRACE_GETREGS
+
+  /* Set all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETREGS = 13,
+#define PT_SETREGS PTRACE_SETREGS
+
+  /* Get all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETFPREGS = 14,
+#define PT_GETFPREGS PTRACE_GETFPREGS
+
+  /* Set all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETFPREGS = 15,
+#define PT_SETFPREGS PTRACE_SETFPREGS
+
+  /* Attach to a process that is already running. */
+  PTRACE_ATTACH = 16,
+#define PT_ATTACH PTRACE_ATTACH
+
+  /* Detach from a process attached to with PTRACE_ATTACH.  */
+  PTRACE_DETACH = 17,
+#define PT_DETACH PTRACE_DETACH
+
+  /* Get all extended floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETFPXREGS = 18,
+#define PT_GETFPXREGS PTRACE_GETFPXREGS
+
+  /* Set all extended floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETFPXREGS = 19,
+#define PT_SETFPXREGS PTRACE_SETFPXREGS
+
+  /* Continue and stop at the next (return from) syscall.  */
+  PTRACE_SYSCALL = 24
+#define PT_SYSCALL PTRACE_SYSCALL
+};
+
+/* Perform process tracing functions.  REQUEST is one of the values
+   above, and determines the action to be taken.
+   For all requests except PTRACE_TRACEME, PID specifies the process to be
+   traced.
+
+   PID and the other arguments described above for the various requests should
+   appear (those that are used for the particular request) as:
+     pid_t PID, void *ADDR, int DATA, void *ADDR2
+   after REQUEST.  */
+#if _MIPS_SIM == _ABIN32
+__extension__ extern long long int ptrace
+  (enum __ptrace_request __request, ...) __THROW;
+#else
+extern long int ptrace (enum __ptrace_request __request, ...) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
diff -Nur sysdeps/unix/sysv/linux/mips/sys/syscall.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/syscall.h
--- sysdeps/unix/sysv/linux/mips/sys/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/syscall.h	2003-03-17 16:50:05.000000000 +0100
@@ -0,0 +1,42 @@
+/* Copyright (C) 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/* This file should list the numbers of the system the system knows.
+   But instead of duplicating this we use the information available
+   from the kernel sources.  */
+#ifdef _LIBC
+/* Since the kernel doesn't define macro names in a way usable for
+   glibc, we preprocess this header, and use it during the glibc build
+   process.  */
+# include <asm-unistd.h>
+#else
+# include <asm/unistd.h>
+#endif
+
+#ifndef _LIBC
+/* The Linux kernel header file defines macros `__NR_<name>', but some
+   programs expect the traditional form `SYS_<name>'.  So in building libc
+   we scan the kernel's list and produce <bits/syscall.h> with macros for
+   all the `SYS_' names.  */
+# include <bits/syscall.h>
+#endif
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/mips/sys/tas.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/tas.h
--- sysdeps/unix/sysv/linux/mips/sys/tas.h	2002-07-16 02:52:17.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/tas.h	2004-12-15 02:00:56.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.
 
@@ -21,6 +21,7 @@
 #define _SYS_TAS_H 1
 
 #include <features.h>
+#include <sgidefs.h>
 
 __BEGIN_DECLS
 
@@ -33,7 +34,7 @@
 # endif
 
 _EXTERN_INLINE int
-_test_and_set (int *p, int v) __THROW
+__NTH (_test_and_set (int *p, int v))
 {
   int r, t;
 
@@ -41,7 +42,9 @@
     ("/* Inline test and set */\n"
      "1:\n\t"
      ".set	push\n\t"
+#if _MIPS_SIM == _ABIO32
      ".set	mips2\n\t"
+#endif
      "ll	%0,%3\n\t"
      "move	%1,%4\n\t"
      "beq	%0,%4,2f\n\t"
diff -Nur sysdeps/unix/sysv/linux/mips/sys/ucontext.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/ucontext.h
--- sysdeps/unix/sysv/linux/mips/sys/ucontext.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/ucontext.h	2004-11-24 05:36:11.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,50 +22,79 @@
 #define _SYS_UCONTEXT_H	1
 
 #include <features.h>
+#include <sgidefs.h>
 #include <signal.h>
 
 /* We need the signal context definitions even if they are not used
    included in <signal.h>.  */
 #include <bits/sigcontext.h>
 
-
-/* Type for general register.  */
-typedef unsigned long int greg_t;
+/* Type for general register.  Even in o32 we assume 64-bit registers,
+   like the kernel.  */
+__extension__ typedef unsigned long long int greg_t;
 
 /* Number of general registers.  */
-#define NGREG	37
-#define NFPREG	33
+#define NGREG	32
+#define NFPREG	32
 
 /* Container for all general registers.  */
-/* gregset_t must be an array.  The below declared array corresponds to:
-typedef struct gregset {
-	greg_t	g_regs[32];
-	greg_t	g_hi;
-	greg_t	g_lo;
-	greg_t	g_pad[3];
-} gregset_t;  */
 typedef greg_t gregset_t[NGREG];
 
 /* Container for all FPU registers.  */
 typedef struct fpregset {
 	union {
-		double	fp_dregs[32];
+		double	fp_dregs[NFPREG];
 		struct {
 			float		_fp_fregs;
 			unsigned int	_fp_pad;
-		} fp_fregs[32];
+		} fp_fregs[NFPREG];
 	} fp_r;
-	unsigned int	fp_csr;
-	unsigned int	fp_pad;
 } fpregset_t;
 
 
 /* Context to describe whole processor state.  */
+#if _MIPS_SIM == _ABIO32
+/* Earlier versions of glibc for mips had an entirely different
+   definition of mcontext_t, that didn't even resemble the
+   corresponding kernel data structure.  Since all legitimate uses of
+   ucontext_t in glibc mustn't have accessed anything beyond
+   uc_mcontext and, even then, taking a pointer to it, casting it to
+   sigcontext_t, and accessing it as such, which is what it has always
+   been, this can still be rectified.  Fortunately, makecontext,
+   [gs]etcontext et all have never been implemented.  */
+typedef struct
+  {
+    unsigned int regmask;
+    unsigned int status;
+    greg_t pc;
+    gregset_t gregs;
+    fpregset_t fpregs;
+    unsigned int fp_owned;
+    unsigned int fpc_csr;
+    unsigned int fpc_eir;
+    unsigned int used_math;
+    unsigned int ssflags;
+    greg_t mdhi;
+    greg_t mdlo;
+    unsigned int cause;
+    unsigned int badvaddr;
+  } mcontext_t;
+#else
 typedef struct
   {
     gregset_t gregs;
     fpregset_t fpregs;
+    greg_t mdhi;
+    greg_t mdlo;
+    greg_t pc;
+    unsigned int status;
+    unsigned int fpc_csr;
+    unsigned int fpc_eir;
+    unsigned int used_math;
+    unsigned int cause;
+    unsigned int badvaddr;
   } mcontext_t;
+#endif
 
 /* Userlevel context.  */
 typedef struct ucontext
diff -Nur sysdeps/unix/sysv/linux/mips/sys/user.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/user.h
--- sysdeps/unix/sysv/linux/mips/sys/user.h	2002-02-08 17:21:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sys/user.h	2004-11-24 05:37:35.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,11 +19,160 @@
 #ifndef _SYS_USER_H
 #define _SYS_USER_H	1
 
+#include <sgidefs.h>
+
 /* The whole purpose of this file is for GDB and GDB only.  Don't read
    too much into it.  Don't use it for anything other than GDB unless
    you know what you are doing.  */
 
-#include <asm/reg.h>
+/* #include <asm/reg.h> */
+/* Instead of including the kernel header, that will vary depending on
+   whether the 32- or the 64-bit kernel is installed, we paste its
+   contents here.  Note that the fact that the file is inline here,
+   instead of included separately, doesn't change in any way the
+   licensing status of a program that includes user.h.  Since this is
+   for gdb alone, and gdb is GPLed, no surprises here.  */
+#if _MIPS_SIM == _ABIO32
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 by Ralf Baechle
+ */
+#ifndef __ASM_MIPS_REG_H
+#define __ASM_MIPS_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			6
+#define EF_REG1			7
+#define EF_REG2			8
+#define EF_REG3			9
+#define EF_REG4			10
+#define EF_REG5			11
+#define EF_REG6			12
+#define EF_REG7			13
+#define EF_REG8			14
+#define EF_REG9			15
+#define EF_REG10		16
+#define EF_REG11		17
+#define EF_REG12		18
+#define EF_REG13		19
+#define EF_REG14		20
+#define EF_REG15		21
+#define EF_REG16		22
+#define EF_REG17		23
+#define EF_REG18		24
+#define EF_REG19		25
+#define EF_REG20		26
+#define EF_REG21		27
+#define EF_REG22		28
+#define EF_REG23		29
+#define EF_REG24		30
+#define EF_REG25		31
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		34
+#define EF_REG29		35
+#define EF_REG30		36
+#define EF_REG31		37
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			38
+#define EF_HI			39
+
+#define EF_CP0_EPC		40
+#define EF_CP0_BADVADDR		41
+#define EF_CP0_STATUS		42
+#define EF_CP0_CAUSE		43
+
+#define EF_SIZE			180	/* size in bytes */
+
+#endif /* __ASM_MIPS_REG_H */
+
+#else /* _MIPS_SIM != _ABIO32 */
+
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 Ralf Baechle
+ * Copyright (C) 1995, 1999 Silicon Graphics
+ */
+#ifndef _ASM_REG_H
+#define _ASM_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			 0
+#define EF_REG1			 1
+#define EF_REG2			 2
+#define EF_REG3			 3
+#define EF_REG4			 4
+#define EF_REG5			 5
+#define EF_REG6			 6
+#define EF_REG7			 7
+#define EF_REG8			 8
+#define EF_REG9			 9
+#define EF_REG10		10
+#define EF_REG11		11
+#define EF_REG12		12
+#define EF_REG13		13
+#define EF_REG14		14
+#define EF_REG15		15
+#define EF_REG16		16
+#define EF_REG17		17
+#define EF_REG18		18
+#define EF_REG19		19
+#define EF_REG20		20
+#define EF_REG21		21
+#define EF_REG22		22
+#define EF_REG23		23
+#define EF_REG24		24
+#define EF_REG25		25
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		28
+#define EF_REG29		29
+#define EF_REG30		30
+#define EF_REG31		31
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			32
+#define EF_HI			33
+
+#define EF_CP0_EPC		34
+#define EF_CP0_BADVADDR		35
+#define EF_CP0_STATUS		36
+#define EF_CP0_CAUSE		37
+
+#define EF_SIZE			304	/* size in bytes */
+
+#endif /* _ASM_REG_H */
+
+#endif /* _MIPS_SIM != _ABIO32 */
+
+#if _MIPS_SIM == _ABIO32
 
 struct user
 {
@@ -40,6 +189,24 @@
   char		u_comm[32];		/* user command name */
 };
 
+#else
+
+struct user {
+  __extension__ unsigned long	regs[EF_SIZE/8+64]; /* integer and fp regs */
+  __extension__ unsigned long	u_tsize;	/* text size (pages) */
+  __extension__ unsigned long	u_dsize;	/* data size (pages) */
+  __extension__ unsigned long	u_ssize;	/* stack size (pages) */
+  __extension__ unsigned long long start_code;	/* text starting address */
+  __extension__ unsigned long long start_data;	/* data starting address */
+  __extension__ unsigned long long start_stack;	/* stack starting address */
+  __extension__ long long	signal;		/* signal causing core dump */
+  __extension__ unsigned long long u_ar0;	/* help gdb find registers */
+  __extension__ unsigned long long magic;	/* identifies a core file */
+  char		u_comm[32];		/* user command name */
+};
+
+#endif
+
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(1UL << PAGE_SHIFT)
 #define PAGE_MASK		(~(PAGE_SIZE-1))
diff -Nur sysdeps/unix/sysv/linux/mips/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/syscalls.list
--- sysdeps/unix/sysv/linux/mips/syscalls.list	2002-09-28 05:35:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/syscalls.list	2003-09-03 05:16:40.000000000 +0200
@@ -8,78 +8,24 @@
 cacheflush	-	cacheflush	i:pii	_flush_cache	cacheflush
 sysmips		-	sysmips		i:iiii	__sysmips	sysmips
 
-s_sigsuspend	sigsuspend sigsuspend	i:p	__syscall_sigsuspend
-
 #
 # Socket functions; Linux/MIPS doesn't use the socketcall(2) wrapper;
 # it's provided for compatibility, though.
 #
-accept		-	accept		i:iBN	__libc_accept	__accept accept
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
 bind		-	bind		i:ipi	__bind		bind
-connect		-	connect		i:ipi	__libc_connect	__connect_internal __connect connect
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
 getsockname	-	getsockname	i:ipp	__getsockname	getsockname
 getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
 listen		-	listen		i:ii	__listen	listen
-recv		-	recv		i:ibni	__libc_recv	__recv recv
-recvfrom	-	recvfrom	i:ibniBN __libc_recvfrom __recvfrom recvfrom
-recvmsg		-	recvmsg		i:ipi	__libc_recvmsg	__recvmsg recvmsg
-send		-	send		i:ibni	__libc_send	__send send
-sendmsg		-	sendmsg		i:ipi	__libc_sendmsg	__sendmsg sendmsg
-sendto		-	sendto		i:ibnibn __libc_sendto	__sendto sendto
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN __libc_recvfrom __recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn __libc_sendto	__sendto sendto
 setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
 socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
-
-#
-# These are defined locally because the caller is also defined in this dir.
-#
-s_llseek	llseek	_llseek		i:iiipi	__syscall__llseek
-s_sigaction	sigaction sigaction	i:ipp	__syscall_sigaction
-s_ustat		ustat	ustat		i:ip	__syscall_ustat
-sys_mknod	xmknod	mknod		i:sii	__syscall_mknod
-
-# System calls with wrappers.
-rt_sigaction	-	rt_sigaction	i:ippi	__syscall_rt_sigaction
-rt_sigpending	-	rt_sigpending	i:pi	__syscall_rt_sigpending
-rt_sigprocmask	-	rt_sigprocmask	i:ippi	__syscall_rt_sigprocmask
-rt_sigqueueinfo	-	rt_sigqueueinfo	i:iip	__syscall_rt_sigqueueinfo
-rt_sigsuspend	-	rt_sigsuspend	i:pi	__syscall_rt_sigsuspend
-rt_sigtimedwait	-	rt_sigtimedwait	i:pppi	__syscall_rt_sigtimedwait
-s_execve	execve	execve		i:spp	__syscall_execve
-s_exit		_exit	exit		i:i	__syscall_exit
-s_fcntl		fcntl	fcntl		i:iiF	__syscall_fcntl
-s_fcntl64	fcntl64	fcntl64		i:iiF	__syscall_fcntl64
-s_fstat64	fxstat64 fstat64	i:ip	__syscall_fstat64
-s_ftruncate64	ftruncate64 ftruncate64	i:iiii	__syscall_ftruncate64
-s_getcwd	getcwd	getcwd		i:pi	__syscall_getcwd
-s_getdents	getdents getdents	i:ipi	__syscall_getdents
-s_getdents64	getdents getdents64	i:ipi	__syscall_getdents64
-s_getpmsg	getpmsg	getpmsg		i:ipppp	__syscall_getpmsg
-s_getpriority	getpriority getpriority	i:ii	__syscall_getpriority
-getresgid	-	getresgid	i:ppp	getresgid
-getresuid	-	getresuid	i:ppp	getresuid
-s_ipc		msgget	ipc		i:iiiip	__syscall_ipc
-s_lstat64	lxstat64 lstat64	i:sp	__syscall_lstat64
-s_mmap2		mmap64	mmap2		b:aniiii __syscall_mmap2
-s_poll		poll	poll		i:pii	__syscall_poll
-s_pread64	pread64	pread		i:ibniii __syscall_pread
-s_putpmsg	putpmsg	putpmsg		i:ippii	__syscall_putpmsg
-s_ptrace	ptrace	ptrace		i:iipp	__syscall_ptrace
-s_pwrite64	pwrite64 pwrite		i:ibniii __syscall_pwrite
-s_readahead	EXTRA	readahead	i:iipi	__syscall_readahead
-s_reboot	reboot	reboot		i:iii	__syscall_reboot
-s_setrlimit	setrlimit setrlimit	i:ip	__syscall_setrlimit
-s_sigpending	sigpending sigpending	i:p	__syscall_sigpending
-s_sigprocmask	sigprocmask sigprocmask	i:ipp	__syscall_sigprocmask
-s_stat64	xstat64  stat64		i:sp	__syscall_stat64
-s_truncate64	truncate64 truncate64	i:siii	__syscall_truncate64
-
-# Todo: we can pass 6 args in registers, no need for the wrapper
-sys_sysctl	sysctl	_sysctl		i:p	__syscall__sysctl
-sys_fstat	fxstat	fstat		i:ip	__syscall_fstat
-sys_lstat	lxstat	lstat		i:sp	__syscall_lstat
-sys_readv	readv	readv		i:ipi	__syscall_readv
-sys_stat	xstat	stat		i:sp	__syscall_stat
-sys_writev	writev	writev		i:ipi	__syscall_writev
diff -Nur sysdeps/unix/sysv/linux/mips/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sysdep.h
--- sysdeps/unix/sysv/linux/mips/sysdep.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sysdep.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _LINUX_MIPS_SYSDEP_H
-#define _LINUX_MIPS_SYSDEP_H 1
-
-/* There is some commonality.  */
-#include <sysdeps/unix/mips/sysdep.h>
-
-/* For Linux we can use the system call table in the header file
-	/usr/include/asm/unistd.h
-   of the kernel.  But these symbols do not follow the SYS_* syntax
-   so we have to redefine the `SYS_ify' macro here.  */
-#undef SYS_ify
-#ifdef __STDC__
-# define SYS_ify(syscall_name)	__NR_##syscall_name
-#else
-# define SYS_ify(syscall_name)	__NR_/**/syscall_name
-#endif
-
-#endif /* linux/mips/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/mips/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sysdep.S
--- sysdeps/unix/sysv/linux/mips/sysdep.S	2002-08-25 01:15:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/sysdep.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-/* The Linux version is in fact MIPS/ELF and the start.? file for this
-   system (sysdeps/mips/elf/start.S) is also used by The Hurd.  This file
-   must not contain the definition of the `errno' variable, we have to
-   define it somewhere else.
-
-   ...and this place is here.  */
-	.bss
-	.globl  errno
-	.type   errno,@object
-	.size   errno,4
-errno:	.word   4
-	.text
-weak_alias(errno, _errno)
-
-#include <sysdeps/unix/mips/sysdep.S>
diff -Nur sysdeps/unix/sysv/linux/mips/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/truncate64.c
--- sysdeps/unix/sysv/linux/mips/truncate64.c	2002-09-28 22:12:57.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/truncate64.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,11 +34,6 @@
 int __have_no_truncate64;
 #endif
 
-/* The order of hight, low depends on endianness.  */
-extern int __syscall_truncate64 (const char *__unbounded path, int dummy,
-				 int high_length, int low_length);
-
-
 /* Truncate the file FD refers to to LENGTH bytes.  */
 int
 truncate64 (const char *path, off64_t length)
diff -Nur sysdeps/unix/sysv/linux/mips/ustat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ustat.c
--- sysdeps/unix/sysv/linux/mips/ustat.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/ustat.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -25,8 +25,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_ustat (unsigned long dev, struct ustat *__unbounded ubuf);
-
 int
 ustat (dev_t dev, struct ustat *ubuf)
 {
diff -Nur sysdeps/unix/sysv/linux/mips/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/Versions
--- sysdeps/unix/sysv/linux/mips/Versions	2002-08-29 01:39:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/Versions	2002-11-06 03:53:24.000000000 +0100
@@ -5,7 +5,7 @@
   # for all GNU/Linux configurations.
 
   GLIBC_2.0 {
-    #errlist-compat	1134
+    #errlist-compat	123
     _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
 
     # Exception handling support functions from libgcc
@@ -21,16 +21,11 @@
     # s*
     sysmips;
   }
-  GLIBC_2.1 {
+  GLIBC_2.2 {
     #errlist-compat	1134
     _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
-  }
-  GLIBC_2.2 {
+
     # _*
     _test_and_set;
   }
-  GLIBC_2.3 {
-    #errlist-compat	1134
-    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
-  }
 }
diff -Nur sysdeps/unix/sysv/linux/mips/xmknod.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/xmknod.c
--- sysdeps/unix/sysv/linux/mips/xmknod.c	2002-08-04 10:22:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/xmknod.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,5 +1,6 @@
 /* xmknod call using old-style Unix mknod system call.
-   Copyright (C) 1991,93,95,96,97,98,00,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,8 +27,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_mknod (const char *__unbounded, unsigned long, unsigned int);
-
 /* Create a device file named PATH, with permission and special bits MODE
    and device number DEV (which can be constructed from major and minor
    device numbers with the `makedev' macro above).  */
diff -Nur sysdeps/unix/sysv/linux/mips/xstatconv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/xstatconv.c
--- sysdeps/unix/sysv/linux/mips/xstatconv.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mips/xstatconv.c	2003-06-30 11:33:13.000000000 +0200
@@ -1,5 +1,5 @@
 /* Convert between the kernel's `struct stat' format, and libc's.
-   Copyright (C) 1991,1995,1996,1997,1998,2000 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995,1996,1997,1998,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,11 +17,22 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#ifdef STAT_IS_KERNEL_STAT
+
+/* Dummy.  */
+struct kernel_stat;
+
+#else
+
 #include <string.h>
 
 
-static inline int
-xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+int
+__xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
 {
   switch (vers)
     {
@@ -70,8 +81,8 @@
   return 0;
 }
 
-static inline int
-xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+int
+__xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
 {
 #ifdef XSTAT_IS_XSTAT64
   return xstat_conv (vers, kbuf, ubuf);
@@ -118,3 +129,5 @@
   return 0;
 #endif
 }
+
+#endif /* ! STAT_IS_KERNEL_STAT */
diff -Nur sysdeps/unix/sysv/linux/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mmap64.c
--- sysdeps/unix/sysv/linux/mmap64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mmap64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,6 +1,6 @@
-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1999,2000,01,02 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by Daniel Jacobowitz <dan@debian.org>, 1999.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 1999.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -19,21 +19,64 @@
 
 #include <errno.h>
 #include <unistd.h>
+#include <sys/mman.h>
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <bp-checks.h>
 
-#include <sys/mman.h>
+#include "kernel-features.h"
+
+#ifdef __NR_mmap2
+
+/* This is always 12, even on architectures where PAGE_SHIFT != 12.  */
+# ifndef MMAP2_PAGE_SHIFT
+#  define MMAP2_PAGE_SHIFT 12
+# endif
 
-__ptr_t
-__mmap64 (addr, len, prot, flags, fd, offset)
-     __ptr_t addr;
-     size_t len;
-     int prot;
-     int flags;
-     int fd;
-     off64_t offset;
+# ifndef __ASSUME_MMAP2_SYSCALL
+static int have_no_mmap2;
+# endif
+#endif
+
+
+void *
+__mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
 {
+#ifdef __NR_mmap2
+  if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
+    {
+      __set_errno (EINVAL);
+      return MAP_FAILED;
+    }
+# ifndef __ASSUME_MMAP2_SYSCALL
+  if (! have_no_mmap2)
+# endif
+    {
+# ifndef __ASSUME_MMAP2_SYSCALL
+      int saved_errno = errno;
+# endif
+      void *result;
+      __ptrvalue (result) = (void *__unbounded)
+	INLINE_SYSCALL (mmap2, 6, __ptrvalue (addr),
+			len, prot, flags, fd,
+			(off_t) (offset >> MMAP2_PAGE_SHIFT));
+# if __BOUNDED_POINTERS__
+      __ptrlow (result) = __ptrvalue (result);
+      __ptrhigh (result) = __ptrvalue (result) + len;
+# endif
+# ifndef __ASSUME_MMAP2_SYSCALL
+      if (result != MAP_FAILED || errno != ENOSYS)
+# endif
+	return result;
+
+# ifndef __ASSUME_MMAP2_SYSCALL
+      __set_errno (saved_errno);
+      have_no_mmap2 = 1;
+# endif
+    }
+#endif
+#ifndef __ASSUME_MMAP2_SYSCALL
   if (offset != (off_t) offset || (offset + len) != (off_t) (offset + len))
     {
       __set_errno (EINVAL);
@@ -41,6 +84,6 @@
     }
 
   return __mmap (addr, len, prot, flags, fd, (off_t) offset);
+#endif
 }
-
 weak_alias (__mmap64, mmap64)
diff -Nur sysdeps/unix/sysv/linux/mq_close.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_close.c
--- sysdeps/unix/sysv/linux/mq_close.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_close.c	2004-04-13 04:12:41.000000000 +0200
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_open
+
+/* Removes the association between message queue descriptor MQDES and its
+   message queue.  */
+int
+mq_close (mqd_t mqdes)
+{
+  return INLINE_SYSCALL (close, 1, mqdes);
+}
+
+#else
+# include <sysdeps/generic/mq_close.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_getattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_getattr.c
--- sysdeps/unix/sysv/linux/mq_getattr.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_getattr.c	2004-04-29 23:55:24.000000000 +0200
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_getsetattr
+
+/* Query status and attributes of message queue MQDES.  */
+int
+mq_getattr (mqd_t mqdes, struct mq_attr *mqstat)
+{
+  return mq_setattr (mqdes, NULL, mqstat);
+}
+
+#else
+# include <sysdeps/generic/mq_getattr.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_notify.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_notify.c
--- sysdeps/unix/sysv/linux/mq_notify.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_notify.c	2004-04-29 23:55:24.000000000 +0200
@@ -0,0 +1,44 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_notify
+
+/* Register notification upon message arrival to an empty message queue
+   MQDES.  */
+int
+mq_notify (mqd_t mqdes, const struct sigevent *notification)
+{
+  /* mq_notify which handles SIGEV_THREAD is included in the thread
+     add-on.  */
+  if (notification != NULL
+      && notification->sigev_notify == SIGEV_THREAD)
+    {
+      __set_errno (ENOSYS);
+      return -1;
+    }
+  return INLINE_SYSCALL (mq_notify, 2, mqdes, notification);
+}
+
+#else
+# include <sysdeps/generic/mq_notify.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_open.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_open.c
--- sysdeps/unix/sysv/linux/mq_open.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_open.c	2004-04-29 23:55:24.000000000 +0200
@@ -0,0 +1,60 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_open
+
+/* Establish connection between a process and a message queue NAME and
+   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines
+   the type of access used.  If O_CREAT is on OFLAG, the third argument is
+   taken as a `mode_t', the mode of the created message queue, and the fourth
+   argument is taken as `struct mq_attr *', pointer to message queue
+   attributes.  If the fourth argument is NULL, default attributes are
+   used.  */
+mqd_t
+mq_open (const char *name, int oflag, ...)
+{
+  if (name[0] != '/')
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  mode_t mode = 0;
+  struct mq_attr *attr = NULL;
+  if (oflag & O_CREAT)
+    {
+      va_list ap;
+
+      va_start (ap, oflag);
+      mode = va_arg (ap, mode_t);
+      attr = va_arg (ap, struct mq_attr *);
+      va_end (ap);
+    }
+
+  return INLINE_SYSCALL (mq_open, 4, name + 1, oflag, mode, attr);
+}
+
+#else
+# include <sysdeps/generic/mq_open.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_receive.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_receive.c
--- sysdeps/unix/sysv/linux/mq_receive.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_receive.c	2004-04-29 23:55:24.000000000 +0200
@@ -0,0 +1,37 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_timedreceive
+
+/* Receive the oldest from highest priority messages in message queue
+   MQDES.  */
+ssize_t
+mq_receive (mqd_t mqdes, char *msg_ptr, size_t msg_len,
+	    unsigned int *msg_prio)
+{
+  return mq_timedreceive (mqdes, msg_ptr, msg_len, msg_prio, NULL);
+}
+
+#else
+# include <sysdeps/generic/mq_receive.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_send.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_send.c
--- sysdeps/unix/sysv/linux/mq_send.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_send.c	2004-04-29 23:55:24.000000000 +0200
@@ -0,0 +1,36 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_timedsend
+
+/* Add message pointed by MSG_PTR to message queue MQDES.  */
+int
+mq_send (mqd_t mqdes, const char *msg_ptr, size_t msg_len,
+	 unsigned int msg_prio)
+{
+  return mq_timedsend (mqdes, msg_ptr, msg_len, msg_prio, NULL);
+}
+
+#else
+# include <sysdeps/generic/mq_send.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/mq_unlink.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_unlink.c
--- sysdeps/unix/sysv/linux/mq_unlink.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/mq_unlink.c	2004-04-20 06:30:13.000000000 +0200
@@ -0,0 +1,54 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <sysdep.h>
+
+#ifdef __NR_mq_unlink
+
+/* Remove message queue named NAME.  */
+int
+mq_unlink (const char *name)
+{
+  if (name[0] != '/')
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (mq_unlink, err, 1, name + 1);
+
+  /* While unlink can return either EPERM or EACCES, mq_unlink should
+     return just EACCES.  */
+  if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (ret, err), 0))
+    {
+      ret = INTERNAL_SYSCALL_ERRNO (ret, err);
+      if (ret == EPERM)
+	ret = EACCES;
+      __set_errno (ret);
+      ret = -1;
+    }
+
+  return ret;
+}
+
+#else
+# include <sysdeps/generic/mq_unlink.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/msgctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgctl.c
--- sysdeps/unix/sysv/linux/msgctl.c	2002-07-18 10:12:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgctl.c	2004-03-10 20:22:54.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -55,6 +56,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_msgctl (int msqid, int cmd, struct __old_msqid_ds *buf)
 {
   return INLINE_SYSCALL (ipc, 5, IPCOP_msgctl, msqid, cmd, 0, CHECK_1 (buf));
diff -Nur sysdeps/unix/sysv/linux/msgrcv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgrcv.c
--- sysdeps/unix/sysv/linux/msgrcv.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgrcv.c	2002-12-15 11:25:23.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -21,7 +21,7 @@
 #include <sys/msg.h>
 #include <ipc_priv.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 
 #include <bp-checks.h>
@@ -36,7 +36,7 @@
 
 
 int
-msgrcv (msqid, msgp, msgsz, msgtyp, msgflg)
+__libc_msgrcv (msqid, msgp, msgsz, msgtyp, msgflg)
      int msqid;
      void *msgp;
      size_t msgsz;
@@ -50,5 +50,17 @@
   tmp.msgp = CHECK_N (msgp, msgsz);
   tmp.msgtyp = msgtyp;
 
-  return INLINE_SYSCALL (ipc, 5, IPCOP_msgrcv, msqid, msgsz, msgflg, __ptrvalue (&tmp));
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (ipc, 5, IPCOP_msgrcv, msqid, msgsz, msgflg,
+			   __ptrvalue (&tmp));
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (ipc, 5, IPCOP_msgrcv, msqid, msgsz, msgflg,
+			       __ptrvalue (&tmp));
+
+   LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
+weak_alias (__libc_msgrcv, msgrcv)
diff -Nur sysdeps/unix/sysv/linux/msgsnd.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgsnd.c
--- sysdeps/unix/sysv/linux/msgsnd.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/msgsnd.c	2002-12-15 11:25:23.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, August 1995.
 
@@ -21,18 +21,29 @@
 #include <sys/msg.h>
 #include <ipc_priv.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 
 #include <bp-checks.h>
 
 int
-msgsnd (msqid, msgp, msgsz, msgflg)
+__libc_msgsnd (msqid, msgp, msgsz, msgflg)
      int msqid;
      const void *msgp;
      size_t msgsz;
      int msgflg;
 {
-  return INLINE_SYSCALL (ipc, 5, IPCOP_msgsnd, msqid, msgsz,
-			 msgflg, (void *) CHECK_N (msgp, msgsz));
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (ipc, 5, IPCOP_msgsnd, msqid, msgsz,
+			   msgflg, (void *) CHECK_N (msgp, msgsz));
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (ipc, 5, IPCOP_msgsnd, msqid, msgsz,
+			       msgflg, (void *) CHECK_N (msgp, msgsz));
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
+weak_alias (__libc_msgsnd, msgsnd)
diff -Nur sysdeps/unix/sysv/linux/net/if_arp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/net/if_arp.h
--- sysdeps/unix/sysv/linux/net/if_arp.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/net/if_arp.h	2003-06-28 10:19:47.000000000 +0200
@@ -83,6 +83,9 @@
 #define	ARPHRD_DLCI	15		/* Frame Relay DLCI.  */
 #define	ARPHRD_ATM	19		/* ATM.  */
 #define	ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id).  */
+#define ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734.  */
+#define ARPHRD_EUI64		27		/* EUI-64.  */
+#define ARPHRD_INFINIBAND	32		/* InfiniBand.  */
 
 /* Dummy types for non ARP hardware */
 #define ARPHRD_SLIP	256
@@ -120,7 +123,7 @@
 #define ARPHRD_FCPP	784		/* Point to point fibrechanel.  */
 #define ARPHRD_FCAL	785		/* Fibrechanel arbitrated loop.  */
 #define ARPHRD_FCPL	786		/* Fibrechanel public loop.  */
-#define ARPHRD_FCPFABRIC 787		/* Fibrechanel fabric.  */
+#define ARPHRD_FCFABRIC 787		/* Fibrechanel fabric.  */
 #define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR.  */
 #define ARPHRD_IEEE80211 801		/* IEEE 802.11.  */
 
diff -Nur sysdeps/unix/sysv/linux/netatalk/at.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netatalk/at.h
--- sysdeps/unix/sysv/linux/netatalk/at.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netatalk/at.h	2004-08-06 19:52:29.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991, 92, 93, 95, 96, 97 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,6 +21,7 @@
 #define _NETATALK_AT_H 1
 
 #include <asm/types.h>
+#include <bits/sockaddr.h>
 #include <linux/atalk.h>
 #include <sys/socket.h>
 
diff -Nur sysdeps/unix/sysv/linux/netinet/igmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netinet/igmp.h
--- sysdeps/unix/sysv/linux/netinet/igmp.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netinet/igmp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/* Copyright (C) 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _NETINET_IGMP_H
-#define	_NETINET_IGMP_H 1
-
-#include <sys/cdefs.h>
-#include <sys/types.h>
-
-#include <asm/types.h>
-#include <linux/igmp.h>
-
-#ifdef __USE_BSD
-
-#include <netinet/in.h>
-
-__BEGIN_DECLS
-
-/*
- * Copyright (c) 1988 Stephen Deering.
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Stephen Deering of Stanford University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)igmp.h	8.1 (Berkeley) 6/10/93
- *	$FreeBSD$
- */
-
-struct igmp {
-  u_int8_t igmp_type;             /* IGMP type */
-  u_int8_t igmp_code;             /* routing code */
-  u_int16_t igmp_cksum;           /* checksum */
-  struct in_addr igmp_group;      /* group address */
-};
-
-/*
- * Message types, including version number.
- */
-#define IGMP_MEMBERSHIP_QUERY   	0x11	/* membership query         */
-#define IGMP_V1_MEMBERSHIP_REPORT	0x12	/* Ver. 1 membership report */
-#define IGMP_V2_MEMBERSHIP_REPORT	0x16	/* Ver. 2 membership report */
-#define IGMP_V2_LEAVE_GROUP		0x17	/* Leave-group message	    */
-
-__END_DECLS
-
-#endif
-
-#endif	/* netinet/igmp.h */
diff -Nur sysdeps/unix/sysv/linux/netlinkaccess.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netlinkaccess.h
--- sysdeps/unix/sysv/linux/netlinkaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/netlinkaccess.h	2004-06-30 09:40:24.000000000 +0200
@@ -0,0 +1,62 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NETLINKACCESS_H
+#define _NETLINKACCESS_H 1
+
+#include <asm/types.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include "kernel-features.h"
+
+
+struct netlink_res
+{
+  struct netlink_res *next;
+  struct nlmsghdr *nlh;
+  size_t size;			/* Size of response.  */
+  uint32_t seq;			/* sequential number we used.  */
+};
+
+
+struct netlink_handle
+{
+  int fd;			/* Netlink file descriptor.  */
+  pid_t pid;			/* Process ID.  */
+  uint32_t seq;			/* The sequence number we use currently.  */
+  struct netlink_res *nlm_list;	/* Pointer to list of responses.  */
+  struct netlink_res *end_ptr;	/* For faster append of new entries.  */
+};
+
+
+#if __ASSUME_NETLINK_SUPPORT == 0
+extern int __no_netlink_support attribute_hidden;
+#else
+# define __no_netlink_support 0
+#endif
+
+
+extern int __netlink_open (struct netlink_handle *h);
+extern void __netlink_close (struct netlink_handle *h);
+extern void __netlink_free_handle (struct netlink_handle *h);
+extern int __netlink_sendreq (struct netlink_handle *h, int type);
+extern int __netlink_receive (struct netlink_handle *h);
+
+
+#endif /* netlinkaccess.h */
diff -Nur sysdeps/unix/sysv/linux/not-cancel.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/not-cancel.h
--- sysdeps/unix/sysv/linux/not-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/not-cancel.h	2003-09-04 16:05:12.000000000 +0200
@@ -0,0 +1,60 @@
+/* Uncancelable versions of cancelable interfaces.  Linux version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Uncancelable open.  */
+#define open_not_cancel(name, flags, mode) \
+   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
+#define open_not_cancel_2(name, flags) \
+   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+
+/* Uncancelable close.  */
+#define close_not_cancel(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+#define close_not_cancel_no_status(fd) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
+	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+
+/* Uncancelable read.  */
+#define read_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+
+/* Uncancelable write.  */
+#define write_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+
+/* Uncancelable writev.  */
+#define writev_not_cancel_no_status(fd, iov, n) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
+	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+
+/* Uncancelable fcntl.  */
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl_nocancel (fd, cmd, val)
+
+/* Uncancelable waitpid.  */
+#ifdef __NR_waitpid
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options)
+#else
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
+#endif
diff -Nur sysdeps/unix/sysv/linux/nscd_setup_thread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/nscd_setup_thread.c
--- sysdeps/unix/sysv/linux/nscd_setup_thread.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/nscd_setup_thread.c	2004-09-18 01:46:58.000000000 +0200
@@ -0,0 +1,49 @@
+/* Setup of nscd worker threads.  Linux verison.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <unistd.h>
+#include <nscd.h>
+#include <sysdep.h>
+
+
+void
+setup_thread (struct database_dyn *db)
+{
+#ifdef __NR_set_tid_address
+  /* Only supported when NPTL is used.  */
+  char buf[100];
+  if (confstr (_CS_GNU_LIBPTHREAD_VERSION, buf, sizeof (buf)) >= sizeof (buf)
+      || strncmp (buf, "NPTL", 4) != 0)
+    return;
+
+  /* Do not try this at home, kids.  We play with the SETTID address
+     even thought the process is multi-threaded.  This can only work
+     since none of the threads ever terminates.  */
+  INTERNAL_SYSCALL_DECL (err);
+  int r = INTERNAL_SYSCALL (set_tid_address, err, 1,
+			    &db->head->nscd_certainly_running);
+  if (!INTERNAL_SYSCALL_ERROR_P (r, err))
+    /* We know the kernel can reset this field when nscd terminates.
+       So, set the field to a nonzero value which indicates that nscd
+       is certainly running and clients can skip the test.  */
+    db->head->nscd_certainly_running = 1;
+#endif
+}
diff -Nur sysdeps/unix/sysv/linux/open64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/open64.c
--- sysdeps/unix/sysv/linux/open64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/open64.c	2002-12-15 11:22:52.000000000 +0100
@@ -0,0 +1,53 @@
+/* Copyright (C) 1991,1995-1997,1999,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <bp-sym.h>
+#include <sysdep-cancel.h>
+
+/* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
+   a third argument is the file protection.  */
+int
+__libc_open64 (const char *file, int oflag, ...)
+{
+  int mode = 0;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_open64, BP_SYM (__open64))
+libc_hidden_weak (BP_SYM (__open64))
+weak_alias (__libc_open64, BP_SYM (open64))
diff -Nur sysdeps/unix/sysv/linux/pathconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pathconf.c
--- sysdeps/unix/sysv/linux/pathconf.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pathconf.c	2003-09-04 16:40:21.000000000 +0200
@@ -1,5 +1,5 @@
-/* Linux specific extensions to pathconf.
-   Copyright (C) 1991,95,96,98,99,2000,2001 Free Software Foundation, Inc.
+/* Get file-specific information about a file.  Linux version.
+   Copyright (C) 1991,1995,1996,1998-2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,78 +17,165 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <errno.h>
 #include <unistd.h>
-#include <limits.h>
-#include <sys/statfs.h>
-
+#include <errno.h>
+#include "pathconf.h"
 #include "linux_fsinfo.h"
 
+static long int posix_pathconf (const char *file, int name);
+
+/* Define this first, so it can be inlined.  */
+#define __pathconf static posix_pathconf
+#include <sysdeps/posix/pathconf.c>
 
-/* The Linux kernel header mentioned this as a kind of generic value.  */
-#define LINUX_LINK_MAX	127
 
-static long int posix_pathconf (const char *path, int name);
+/* Get file-specific information about FILE.  */
+long int
+__pathconf (const char *file, int name)
+{
+  struct statfs fsbuf;
+
+  switch (name)
+    {
+    case _PC_LINK_MAX:
+      return __statfs_link_max (__statfs (file, &fsbuf), &fsbuf);
+
+    case _PC_FILESIZEBITS:
+      return __statfs_filesize_max (__statfs (file, &fsbuf), &fsbuf);
 
+    case _PC_2_SYMLINKS:
+      return __statfs_symlinks (__statfs (file, &fsbuf), &fsbuf);
 
-/* Get file-specific information about descriptor FD.  */
+    default:
+      return posix_pathconf (file, name);
+    }
+}
+
+
+/* Used like: return statfs_link_max (__statfs (name, &buf), &buf); */
 long int
-__pathconf (path, name)
-     const char *path;
-     int name;
+__statfs_link_max (int result, const struct statfs *fsbuf)
 {
-  if (name == _PC_LINK_MAX)
+  if (result < 0)
     {
-      struct statfs fsbuf;
+      if (errno == ENOSYS)
+	/* Not possible, return the default value.  */
+	return LINUX_LINK_MAX;
 
-      /* Determine the filesystem type.  */
-      if (__statfs (path, &fsbuf) < 0)
-	{
-	  if (errno == ENOSYS)
-	    /* not possible, return the default value.  */
-	    return LINUX_LINK_MAX;
+      /* Some error occured.  */
+      return -1;
+    }
 
-	  /* Some error occured.  */
-          return -1;
-	}
+  switch (fsbuf->f_type)
+    {
+    case EXT2_SUPER_MAGIC:
+      return EXT2_LINK_MAX;
 
-      switch (fsbuf.f_type)
-	{
-	case EXT2_SUPER_MAGIC:
-	  return EXT2_LINK_MAX;
+    case MINIX_SUPER_MAGIC:
+    case MINIX_SUPER_MAGIC2:
+      return MINIX_LINK_MAX;
 
-	case MINIX_SUPER_MAGIC:
-	case MINIX_SUPER_MAGIC2:
-	  return MINIX_LINK_MAX;
+    case MINIX2_SUPER_MAGIC:
+    case MINIX2_SUPER_MAGIC2:
+      return MINIX2_LINK_MAX;
 
-	case MINIX2_SUPER_MAGIC:
-	case MINIX2_SUPER_MAGIC2:
-	  return MINIX2_LINK_MAX;
+    case XENIX_SUPER_MAGIC:
+      return XENIX_LINK_MAX;
 
-	case XENIX_SUPER_MAGIC:
-	  return XENIX_LINK_MAX;
+    case SYSV4_SUPER_MAGIC:
+    case SYSV2_SUPER_MAGIC:
+      return SYSV_LINK_MAX;
 
-	case SYSV4_SUPER_MAGIC:
-	case SYSV2_SUPER_MAGIC:
-	  return SYSV_LINK_MAX;
+    case COH_SUPER_MAGIC:
+      return COH_LINK_MAX;
 
-	case COH_SUPER_MAGIC:
-	  return COH_LINK_MAX;
+    case UFS_MAGIC:
+    case UFS_CIGAM:
+      return UFS_LINK_MAX;
 
-	case UFS_MAGIC:
-	case UFS_CIGAM:
-	  return UFS_LINK_MAX;
+    case REISERFS_SUPER_MAGIC:
+      return REISERFS_LINK_MAX;
 
-	case REISERFS_SUPER_MAGIC:
-	  return REISERFS_LINK_MAX;
+    case XFS_SUPER_MAGIC:
+      return XFS_LINK_MAX;
 
-	default:
-	  return LINUX_LINK_MAX;
-	}
+    default:
+      return LINUX_LINK_MAX;
     }
+}
+
 
-  return posix_pathconf (path, name);
+/* Used like: return statfs_filesize_max (__statfs (name, &buf), &buf); */
+long int
+__statfs_filesize_max (int result, const struct statfs *fsbuf)
+{
+  if (result < 0)
+    {
+      if (errno == ENOSYS)
+	/* Not possible, return the default value.  */
+	return 32;
+
+      /* Some error occured.  */
+      return -1;
+    }
+
+  switch (fsbuf->f_type)
+    {
+    case EXT2_SUPER_MAGIC:
+    case UFS_MAGIC:
+    case UFS_CIGAM:
+    case REISERFS_SUPER_MAGIC:
+    case XFS_SUPER_MAGIC:
+    case SMB_SUPER_MAGIC:
+    case NTFS_SUPER_MAGIC:
+    case UDF_SUPER_MAGIC:
+    case JFS_SUPER_MAGIC:
+    case VXFS_SUPER_MAGIC:
+      return 64;
+
+    case MSDOS_SUPER_MAGIC:
+    case JFFS_SUPER_MAGIC:
+    case JFFS2_SUPER_MAGIC:
+    case NCP_SUPER_MAGIC:
+    case ROMFS_SUPER_MAGIC:
+      return 32;
+
+    default:
+      return 32;
+    }
 }
 
-#define __pathconf static posix_pathconf
-#include <sysdeps/posix/pathconf.c>
+
+/* Used like: return statfs_link_max (__statfs (name, &buf), &buf); */
+long int
+__statfs_symlinks (int result, const struct statfs *fsbuf)
+{
+  if (result < 0)
+    {
+      if (errno == ENOSYS)
+	/* Not possible, return the default value.  */
+	return 1;
+
+      /* Some error occured.  */
+      return -1;
+    }
+
+  switch (fsbuf->f_type)
+    {
+    case ADFS_SUPER_MAGIC:
+    case BFS_MAGIC:
+    case CRAMFS_MAGIC:
+    case DEVPTS_SUPER_MAGIC:
+    case EFS_SUPER_MAGIC:
+    case EFS_MAGIC:
+    case MSDOS_SUPER_MAGIC:
+    case NTFS_SUPER_MAGIC:
+    case QNX4_SUPER_MAGIC:
+    case ROMFS_SUPER_MAGIC:
+      /* No symlink support.  */
+      return 0;
+
+    default:
+      return 1;
+    }
+}
diff -Nur sysdeps/unix/sysv/linux/pathconf.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pathconf.h
--- sysdeps/unix/sysv/linux/pathconf.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pathconf.h	2003-06-12 00:39:38.000000000 +0200
@@ -0,0 +1,34 @@
+/* Common parts of Linux implementation of pathconf and fpathconf.
+   Copyright (C) 1991,1995,1996,1998-2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/statfs.h>
+
+
+/* Used like: return statfs_link_max (__statfs (name, &buf), &buf); */
+extern long int __statfs_link_max (int result, const struct statfs *fsbuf);
+
+
+/* Used like: return statfs_filesize_max (__statfs (name, &buf), &buf); */
+extern long int __statfs_filesize_max (int result, const struct statfs *fsbuf);
+
+
+/* Used like: return statfs_link_max (__statfs (name, &buf), &buf); */
+extern long int __statfs_symlinks (int result, const struct statfs *fsbuf);
diff -Nur sysdeps/unix/sysv/linux/poll.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/poll.c
--- sysdeps/unix/sysv/linux/poll.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/poll.c	2003-09-03 05:21:26.000000000 +0200
@@ -20,7 +20,7 @@
 #include <errno.h>
 #include <sys/poll.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
@@ -28,28 +28,24 @@
 
 #if defined __NR_poll || __ASSUME_POLL_SYSCALL > 0
 
-extern int __syscall_poll (struct pollfd *__unbounded fds,
-			   unsigned int nfds, int timeout);
-
 # if __ASSUME_POLL_SYSCALL == 0
 static int __emulate_poll (struct pollfd *fds, nfds_t nfds,
 			   int timeout) internal_function;
 # endif
 
-/* The real implementation.  */
-int
-__poll (fds, nfds, timeout)
-     struct pollfd *fds;
-     nfds_t nfds;
-     int timeout;
-{
+
 # if __ASSUME_POLL_SYSCALL == 0
+/* For loser kernels.  */
+static int
+loser_poll (struct pollfd *fds, nfds_t nfds, int timeout)
+{
   static int must_emulate;
 
   if (!must_emulate)
     {
       int errno_saved = errno;
-      int retval = INLINE_SYSCALL (poll, 3, CHECK_N (fds, nfds), nfds, timeout);
+      int retval = INLINE_SYSCALL (poll, 3, CHECK_N (fds, nfds), nfds,
+				   timeout);
 
       if (retval >= 0 || errno != ENOSYS)
 	return retval;
@@ -59,12 +55,44 @@
     }
 
   return __emulate_poll (fds, nfds, timeout);
+}
+# endif
+
+
+/* The real implementation.  */
+int
+__poll (fds, nfds, timeout)
+     struct pollfd *fds;
+     nfds_t nfds;
+     int timeout;
+{
+# if __ASSUME_POLL_SYSCALL == 0
+  if (SINGLE_THREAD_P)
+    return loser_poll (CHECK_N (fds, nfds), nfds, timeout);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = loser_poll (CHECK_N (fds, nfds), nfds, timeout);
+
+   LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 # else
-  return INLINE_SYSCALL (poll, 3, CHECK_N (fds, nfds), nfds, timeout);
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (poll, 3, CHECK_N (fds, nfds), nfds, timeout);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (poll, 3, CHECK_N (fds, nfds), nfds, timeout);
+
+   LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 # endif
 }
 libc_hidden_def (__poll)
 weak_alias (__poll, poll)
+strong_alias (__poll, __libc_poll)
 
 /* Get the emulation code.  */
 # define __poll(fds, nfds, timeout) \
diff -Nur sysdeps/unix/sysv/linux/posix_fadvise64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/posix_fadvise64.c
--- sysdeps/unix/sysv/linux/posix_fadvise64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/posix_fadvise64.c	2004-03-10 20:27:05.000000000 +0100
@@ -0,0 +1,82 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+int __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise);
+int __posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise);
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+#ifdef __NR_fadvise64_64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64_64, err, 6, fd,
+			      __LONG_LONG_PAIR ((long) (offset >> 32),
+						(long) offset),
+			      __LONG_LONG_PAIR ((long) (len >> 32),
+						(long) len),
+			      advise);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return 0;
+# ifndef __ASSUME_FADVISE64_64_SYSCALL
+  if (INTERNAL_SYSCALL_ERRNO (ret, err) != ENOSYS)
+# endif
+   return INTERNAL_SYSCALL_ERRNO (ret, err);
+#endif
+#ifndef __ASSUME_FADVISE64_64_SYSCALL
+# ifdef __NR_fadvise64
+  if (len != (off_t) len)
+    return EOVERFLOW;
+
+  INTERNAL_SYSCALL_DECL (err2);
+  int ret2 = INTERNAL_SYSCALL (fadvise64, err2, 5, fd,
+			       __LONG_LONG_PAIR ((long) (offset >> 32),
+						 (long) offset),
+			       (off_t) len, advise);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret2, err2))
+    return 0;
+  return INTERNAL_SYSCALL_ERRNO (ret2, err2);
+# else
+  return ENOSYS;
+# endif
+#endif
+}
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise)
+{
+  return __posix_fadvise64_l64 (fd, offset, len, advise);
+}
+
+versioned_symbol (libc, __posix_fadvise64_l64, posix_fadvise64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fadvise64_l32, posix_fadvise64, GLIBC_2_2);
+#else
+strong_alias (__posix_fadvise64_l64, posix_fadvise64);
+#endif
diff -Nur sysdeps/unix/sysv/linux/posix_fadvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/posix_fadvise.c
--- sysdeps/unix/sysv/linux/posix_fadvise.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/posix_fadvise.c	2003-08-17 02:36:22.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 5, fd,
+			      __LONG_LONG_PAIR (offset >> 31, offset), len,
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/environments.h
--- sysdeps/unix/sysv/linux/powerpc/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/environments.h	2004-11-26 09:11:05.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* Environments with 32-bit wide pointers are optionally provided.
+   Therefore following macros aren't defined:
+   # undef _POSIX_V6_ILP32_OFF32
+   # undef _POSIX_V6_ILP32_OFFBIG
+   # undef _XBS5_ILP32_OFF32
+   # undef _XBS5_ILP32_OFFBIG
+   and users need to check at runtime.  */
+
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* Environments with 64-bit wide pointers can be provided,
+   so these macros aren't defined:
+   # undef _POSIX_V6_LP64_OFF64
+   # undef _POSIX_V6_LPBIG_OFFBIG
+   # undef _XBS5_LP64_OFF64
+   # undef _XBS5_LPBIG_OFFBIG
+   and sysconf tests for it at runtime.  */
+
+#endif /* __WORDSIZE == 32 */
+
+#define __ILP32_OFF32_CFLAGS	"-m32"
+#define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+#define __ILP32_OFF32_LDFLAGS	"-m32"
+#define __ILP32_OFFBIG_LDFLAGS	"-m32"
+#define __LP64_OFF64_CFLAGS	"-m64"
+#define __LP64_OFF64_LDFLAGS	"-m64"
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/fcntl.h
--- sysdeps/unix/sysv/linux/powerpc/bits/fcntl.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/fcntl.h	2004-08-23 09:28:45.000000000 +0200
@@ -1,5 +1,6 @@
-/* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995-1998, 2000 Free Software Foundation, Inc.
+/* O_*, F_*, FD_* bit values for Linux/PowerPC.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -42,8 +43,10 @@
 #define O_ASYNC		020000
 
 #ifdef __USE_GNU
-# define O_DIRECTORY	040000	/* Must be a directory.	 */
+# define O_DIRECT	0400000	/* Direct disk access.	*/
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_NOATIME	01000000 /* Do not set atime.  */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -64,7 +67,6 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-
 #ifndef __USE_FILE_OFFSET64
 # define F_GETLK	5	/* Get record locking info.  */
 # define F_SETLK	6	/* Set record locking info (non-blocking).  */
@@ -74,12 +76,11 @@
 # define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
 # define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
 #endif
-
 #define F_GETLK64	12	/* Get record locking info.  */
 #define F_SETLK64	13	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	14	/* Set record locking info (blocking).	*/
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -103,12 +104,12 @@
 #define F_WRLCK		1	/* Write lock.	*/
 #define F_UNLCK		2	/* Remove lock.	 */
 
-/* for old implementation of bsd flock () */
+/* For old implementation of bsd flock().  */
 #define F_EXLCK		4	/* or 3 */
 #define F_SHLCK		8	/* or 4 */
 
 #ifdef __USE_BSD
-/* Operations for bsd flock(), also used by the kernel implementation */
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
 # define LOCK_SH	1	/* shared lock */
 # define LOCK_EX	2	/* exclusive lock */
 # define LOCK_NB	4	/* or'd with one of the above to prevent
@@ -178,3 +179,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/mman.h
--- sysdeps/unix/sysv/linux/powerpc/bits/mman.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/mman.h	2003-09-25 18:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/PowerPC version.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x001		/* Share changes.  */
@@ -52,11 +56,13 @@
 
 /* These are Linux-specific.  */
 #ifdef __USE_MISC
-# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
-# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
-# define MAP_LOCKED	0x0080		/* Lock the mapping.  */
-# define MAP_NORESERVE	0x0040		/* Don't check for reservations.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x00080		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x00040		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
 #endif
 
 /* Flags to `msync'.  */
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/msq.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/msq.h
--- sysdeps/unix/sysv/linux/powerpc/bits/msq.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/msq.h	2002-11-22 06:23:44.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -38,11 +38,17 @@
 struct msqid_ds
 {
   struct ipc_perm msg_perm;    /* structure describing operation permission */
+#if __WORDSIZE == 32
   unsigned int __unused1;
+#endif
   __time_t msg_stime;          /* time of last msgsnd command */
+#if __WORDSIZE == 32
   unsigned int __unused2;
+#endif
   __time_t msg_rtime;          /* time of last msgrcv command */
+#if __WORDSIZE == 32
   unsigned int __unused3;
+#endif
   __time_t msg_ctime;          /* time of last change */
   unsigned long __msg_cbytes; /* current number of bytes on queue */
   msgqnum_t msg_qnum;          /* number of messages currently on queue */
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/resource.h
--- sysdeps/unix/sysv/linux/powerpc/bits/resource.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* Bit values & structures for resource limits.  Linux/PPC version.
-   Copyright (C) 1994-99, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((unsigned long int)(~0UL))
-#else
-# define RLIM_INFINITY 0xffffffffffffffffuLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0xffffffffffffffffuLL
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#ifndef __USE_FILE_OFFSET64
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/sem.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/sem.h
--- sysdeps/unix/sysv/linux/powerpc/bits/sem.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/sem.h	2002-11-22 06:23:44.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002 
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -39,9 +40,13 @@
 struct semid_ds
 {
   struct ipc_perm sem_perm;            /* operation permission struct */
+#if __WORDSIZE == 32
   unsigned int __unused1;
+#endif
   __time_t sem_otime;                  /* last semop() time */
+#if __WORDSIZE == 32
   unsigned int __unused2;
+#endif
   __time_t sem_ctime;                  /* last time changed by semctl() */
   unsigned long int sem_nsems;         /* number of semaphores in set */
   unsigned long __unused3;
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/shm.h
--- sysdeps/unix/sysv/linux/powerpc/bits/shm.h	2002-08-24 00:20:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/shm.h	2004-08-12 19:27:20.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -35,6 +36,8 @@
 #define SHM_LOCK       11              /* lock segment (root only) */
 #define SHM_UNLOCK     12              /* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -47,13 +50,21 @@
 struct shmid_ds
   {
     struct ipc_perm shm_perm;          /* operation permission struct */
+#if __WORDSIZE == 32
     unsigned int __unused1;
+#endif
     __time_t shm_atime;                        /* time of last shmat() */
+#if __WORDSIZE == 32
     unsigned int __unused2;
+#endif
     __time_t shm_dtime;                        /* time of last shmdt() */
+#if __WORDSIZE == 32
     unsigned int __unused3;
-    __time_t shm_ctime;                        /* time of last change by shmctl() */
+#endif
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+#if __WORDSIZE == 32
     unsigned int __unused4;
+#endif
     size_t shm_segsz;                  /* size of segment in bytes */
     __pid_t shm_cpid;                  /* pid of creator */
     __pid_t shm_lpid;                  /* pid of last shmop */
@@ -71,6 +82,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST      01000   /* segment will be destroyed on last detach */
 # define SHM_LOCKED    02000   /* segment will not be swapped */
+# define SHM_HUGETLB   04000	/* segment is mapped via hugetlb */
 
 struct shminfo
   {
@@ -96,3 +108,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/stat.h
--- sysdeps/unix/sysv/linux/powerpc/bits/stat.h	2002-10-02 10:53:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -27,11 +27,11 @@
 #define _STAT_VER_LINUX_OLD	1
 #define _STAT_VER_KERNEL	1
 #define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX	  3
 #if __WORDSIZE == 32
-# define _STAT_VER_LINUX	3
-# define _STAT_VER		_STAT_VER_LINUX	/* The one defined below.  */
+# define _STAT_VER		_STAT_VER_LINUX
 #else
-# define _STAT_VER		_STAT_VER_KERNEL /* The one defined below.  */
+# define _STAT_VER		_STAT_VER_KERNEL
 #endif
 
 /* Versions of the `xmknod' interface.  */
@@ -69,12 +69,27 @@
 # else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 # endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;	/* Reserved for atime.nanoseconds.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;	/* Reserved for mtime.nanoseconds.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;	/* Reserved for ctime.nanoseconds.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
   };
@@ -94,12 +109,27 @@
     __off64_t st_size;			/* Size of file, in bytes.  */
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;	/* Reserved for atime.nanoseconds.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;	/* Reserved for mtime.nanoseconds.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;	/* Reserved for ctime.nanoseconds.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
   };
@@ -133,12 +163,27 @@
 # else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 # endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;	/* Reserved for atime.nanoseconds.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;	/* Reserved for mtime.nanoseconds.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;	/* Reserved for ctime.nanoseconds.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
     unsigned long int __unused6;
@@ -158,12 +203,27 @@
     __off64_t st_size;			/* Size of file, in bytes.  */
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;	/* Reserved for atime.nanoseconds.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;	/* Reserved for mtime.nanoseconds.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;	/* Reserved for ctime.nanoseconds.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
     unsigned long int __unused6;
@@ -175,6 +235,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/termios.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/termios.h
--- sysdeps/unix/sysv/linux/powerpc/bits/termios.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/termios.h	2004-05-13 04:17:03.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1999,2001,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -40,6 +40,8 @@
 	cc_t c_cc[NCCS];		/* control characters */
 	speed_t c_ispeed;		/* input speed */
 	speed_t c_ospeed;		/* output speed */
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
 };
 
 /* c_cc characters */
@@ -77,6 +79,7 @@
 #define IXANY	0004000
 #define IUCLC	0010000
 #define IMAXBEL	0020000
+#define IUTF8	0040000
 
 /* c_oflag bits */
 #define OPOST	0000001
@@ -99,6 +102,7 @@
 #define   TAB1	00002000
 #define   TAB2	00004000
 #define   TAB3	00006000
+#define XTABS	00006000	/* Required by POSIX to be == TAB3.  */
 #define CRDLY	00030000
 #define   CR0	00000000
 #define   CR1	00010000
@@ -113,7 +117,6 @@
 #define VTDLY	00200000
 #define   VT0	00000000
 #define   VT1	00200000
-#define XTABS	01000000 /* Hmm.. Linux/i386 considers this part of TABDLY.. */
 
 /* c_cflag bit meaning */
 #define CBAUD	0000377
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/utmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/utmp.h
--- sysdeps/unix/sysv/linux/powerpc/bits/utmp.h	2002-10-02 23:15:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/utmp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
-   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002 
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMP_H
-# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
-#endif
-
-#include <paths.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <bits/wordsize.h>
-
-
-#define UT_LINESIZE	32
-#define UT_NAMESIZE	32
-#define UT_HOSTSIZE	256
-
-
-/* The structure describing an entry in the database of
-   previous logins.  */
-struct lastlog
-  {
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-    int32_t ll_time;
-#else
-    __time_t ll_time;
-#endif
-    char ll_line[UT_LINESIZE];
-    char ll_host[UT_HOSTSIZE];
-  };
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmp' below.  */
-struct exit_status
-  {
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmp
-{
-  short int ut_type;		/* Type of login.  */
-  pid_t ut_pid;			/* Process ID of login process.  */
-  char ut_line[UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
-  char ut_user[UT_NAMESIZE];	/* Username.  */
-  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled 
-   32- and 64-bit.  This allows files and shared memory to be shared 
-   between 32/64bit applications.  For example /var/run/utmp.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    int32_t tv_sec;		/* Seconds.  */
-    int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-
-  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-/* Backwards compatibility hacks.  */
-#define ut_name		ut_user
-#ifndef _NO_UT_TIME
-/* We have a problem here: `ut_time' is also used otherwise.  Define
-   _NO_UT_TIME if the compiler complains.  */
-# define ut_time	ut_tv.tv_sec
-#endif
-#define ut_xtime	ut_tv.tv_sec
-#define ut_addr		ut_addr_v6[0]
-
-
-/* Values for the `ut_type' field of a `struct utmp'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#define RUN_LVL		1	/* The system's runlevel.  */
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#define ACCOUNTING	9
-
-/* Old Linux name for the EMPTY type.  */
-#define UT_UNKNOWN	EMPTY
-
-
-/* Tell the user that we have a modern system with UT_HOST, UT_PID,
-   UT_TYPE, UT_ID and UT_TV fields.  */
-#define _HAVE_UT_TYPE	1
-#define _HAVE_UT_PID	1
-#define _HAVE_UT_ID	1
-#define _HAVE_UT_TV	1
-#define _HAVE_UT_HOST	1
diff -Nur sysdeps/unix/sysv/linux/powerpc/bits/utmpx.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/utmpx.h
--- sysdeps/unix/sysv/linux/powerpc/bits/utmpx.h	2002-10-02 22:39:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/bits/utmpx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,102 +0,0 @@
-/* Structures and definitions for the user accounting database.  GNU version.
-   Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMPX_H
-# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
-#endif
-
-#include <bits/types.h>
-#include <sys/time.h>
-
-
-#ifdef __USE_GNU
-# include <paths.h>
-# define _PATH_UTMPX	_PATH_UTMP
-# define _PATH_WTMPX	_PATH_WTMP
-#endif
-
-
-#define __UT_LINESIZE	32
-#define __UT_NAMESIZE	32
-#define __UT_HOSTSIZE	256
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmpx' below.  */
-struct __exit_status
-  {
-#ifdef __USE_GNU
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-#else
-    short int __e_termination;	/* Process termination status.  */
-    short int __e_exit;		/* Process exit status.  */
-#endif
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmpx
-{
-  short int ut_type;		/* Type of login.  */
-  __pid_t ut_pid;		/* Process ID of login process.  */
-  char ut_line[__UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID. */
-  char ut_user[__UT_NAMESIZE];	/* Username.  */
-  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct __exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled
-   32- and 64-bit.  This allows files and shared memory to be shared
-   between 32/64bit applications.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  __int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    __int32_t tv_sec;		/* Seconds.  */
-    __int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-
-/* Values for the `ut_type' field of a `struct utmpx'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#ifdef __USE_GNU
-# define RUN_LVL	1	/* The system's runlevel.  */
-#endif
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#ifdef __USE_GNU
-# define ACCOUNTING	9	/* System accounting.  */
-#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/chown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/chown.c
--- sysdeps/unix/sysv/linux/powerpc/chown.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/chown.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,5 +1,5 @@
 /* chown() compatibility.
-   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,7 +21,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <limits.h>
-#include <sys/syscall.h>
+#include <sysdep.h>
 #include <stdlib.h>
 
 /*
@@ -31,9 +31,6 @@
   This file emulates chown() under the old kernels.
 */
 
-extern int __syscall_chown (const char *__file,
-			    uid_t __owner, gid_t __group);
-
 int
 __chown (const char *file, uid_t owner, gid_t group)
 {
@@ -42,18 +39,18 @@
    char link[PATH_MAX+2];
    char path[2*PATH_MAX+4];
    int loopct;
-   int filelen;
+   size_t filelen;
    static int libc_old_chown = 0 /* -1=old linux, 1=new linux, 0=unknown */;
 
    if (libc_old_chown == 1)
-     return __syscall_chown (file, owner, group);
+     return INLINE_SYSCALL (chown, 3, __ptrvalue (file), owner, group);
 
    old_errno = errno;
 
 #ifdef __NR_lchown
    if (libc_old_chown == 0)
      {
-       err = __syscall_chown (file, owner, group);
+       err = INLINE_SYSCALL (chown, 3, __ptrvalue (file), owner, group);
        if (err != -1 || errno != ENOSYS)
 	 {
 	   libc_old_chown = 1;
@@ -82,7 +79,7 @@
       ENAMETOOLONG before this, usually.  */
    for (loopct = 0; loopct < 128; loopct++)
    {
-     int linklen;
+     size_t linklen;
 
      if (err >= PATH_MAX+1)
        {
diff -Nur sysdeps/unix/sysv/linux/powerpc/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/Dist
--- sysdeps/unix/sysv/linux/powerpc/Dist	2002-10-03 02:54:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/Dist	2003-02-20 23:19:51.000000000 +0100
@@ -1,6 +1,4 @@
-bits/utmpx.h
 dl-brk.S
-fe_nomask.c
 ipc_priv.h
 kernel_termios.h
 ldd-rewrite.sed
diff -Nur sysdeps/unix/sysv/linux/powerpc/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/dl-cache.h
--- sysdeps/unix/sysv/linux/powerpc/dl-cache.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/dl-cache.h	2003-06-25 10:03:30.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>
diff -Nur sysdeps/unix/sysv/linux/powerpc/dl-sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/dl-sysdep.c
--- sysdeps/unix/sysv/linux/powerpc/dl-sysdep.c	2002-08-23 21:47:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/dl-sysdep.c	2003-03-16 01:40:44.000000000 +0100
@@ -1,5 +1,5 @@
 /* Operating system support for run-time dynamic linker.  Linux/PPC version.
-   Copyright (C) 1997, 1998, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,27 +25,18 @@
 extern int __cache_line_size;
 weak_extern (__cache_line_size)
 
-#define DL_PLATFORM_INIT __aux_init_cache(_dl_auxv)
-
 /* Scan the Aux Vector for the "Data Cache Block Size" entry.  If found
    verify that the static extern __cache_line_size is defined by checking
-   for not NULL.  If it is defined then assign the cache block size 
+   for not NULL.  If it is defined then assign the cache block size
    value to __cache_line_size.  */
-static inline void
-__aux_init_cache (ElfW(auxv_t) *av)
-{
-  for (; av->a_type != AT_NULL; ++av)
-    switch (av->a_type)
-      {
-        case AT_DCACHEBSIZE:
-          {
-            int *cls = & __cache_line_size;
-            if (cls != NULL)
-              *cls = av->a_un.a_val;
-          }
-        break;
-      }
-}
+#define DL_PLATFORM_AUXV						      \
+      case AT_DCACHEBSIZE:						      \
+	{								      \
+	  int *cls = & __cache_line_size;				      \
+	  if (cls != NULL)						      \
+	    *cls = av->a_un.a_val;					      \
+	}								      \
+      break;
 
 #ifndef __ASSUME_STD_AUXV
 
diff -Nur sysdeps/unix/sysv/linux/powerpc/fcntl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/fcntl.c
--- sysdeps/unix/sysv/linux/powerpc/fcntl.c	2000-09-29 09:28:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/fcntl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/fe_nomask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/fe_nomask.c
--- sysdeps/unix/sysv/linux/powerpc/fe_nomask.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/fe_nomask.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/* Procedure definition for FE_NOMASK_ENV for Linux/ppc.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv.h>
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-
-/* This is rather fiddly under Linux.  We don't have direct access,
-   and there is no system call, but we can change the bits 
-   in a signal handler's context...  */
-
-static struct sigaction oact;
-
-static void
-fe_nomask_handler (int signum, struct sigcontext *sc)
-{
-  sc->regs->msr |= 0x900ul;  /* FE0 | FE1 */
-  sigaction (SIGUSR1, &oact, NULL);
-}
-
-const fenv_t *
-__fe_nomask_env(void)
-{
-  struct sigaction act;
-
-  act.sa_handler = (sighandler_t) fe_nomask_handler;
-  sigemptyset (&act.sa_mask);
-  act.sa_flags = 0;
-
-  sigaction (SIGUSR1, &act, &oact);
-  raise (SIGUSR1);
-
-  return FE_ENABLED_ENV;
-}
diff -Nur sysdeps/unix/sysv/linux/powerpc/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/ftruncate64.c
--- sysdeps/unix/sysv/linux/powerpc/ftruncate64.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sys/types.h>
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#include "kernel-features.h"
-
-#ifdef __NR_ftruncate64
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-/* The variable is shared between all wrappers around *truncate64 calls.  */
-extern int have_no_truncate64;
-#endif
-
-extern int __syscall_ftruncate64 (int fd, off64_t length);
-
-
-/* Truncate the file FD refers to to LENGTH bytes.  */
-int
-__ftruncate64 (fd, length)
-     int fd;
-     off64_t length;
-{
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-  if (! have_no_truncate64)
-#endif
-    {
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      int saved_errno = errno;
-#endif
-      int result = __syscall_ftruncate64 (fd, length);
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      if (result != -1 || errno != ENOSYS)
-#endif
-	return result;
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      __set_errno (saved_errno);
-      have_no_truncate64 = 1;
-#endif
-    }
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-  if ((off_t) length != length)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-  return __ftruncate (fd, (off_t) length);
-#endif
-}
-weak_alias (__ftruncate64, ftruncate64)
-
-#else
-/* Use the generic implementation.  */
-# include <sysdeps/generic/ftruncate64.c>
-#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/getpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/getpmsg.c
--- sysdeps/unix/sysv/linux/powerpc/getpmsg.c	1999-12-21 16:59:14.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/getpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/getpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/glob64.c
--- sysdeps/unix/sysv/linux/powerpc/glob64.c	2000-08-19 18:11:30.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/glob64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/glob64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/ioctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/ioctl.c
--- sysdeps/unix/sysv/linux/powerpc/ioctl.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/ioctl.c	2004-04-01 23:24:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,26 +20,25 @@
 #include <termios.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
+#include <sysdep.h>
 
 /* The user-visible size of struct termios has changed.  Catch ioctl calls
    using the new-style struct termios, and translate them to old-style.  */
 
-extern int __syscall_ioctl (int fd, unsigned long int request, ...);
-
 int
 __ioctl (int fd, unsigned long int request, ...)
 {
   void *arg;
   va_list ap;
   int result;
-	
+
   va_start (ap, request);
   arg = va_arg (ap, void *);
-	
+
   switch (request)
     {
     case TCGETS:
-      result = tcgetattr (fd, (struct termios *) arg);
+      result = __tcgetattr (fd, (struct termios *) arg);
       break;
 
     case TCSETS:
@@ -55,7 +54,7 @@
       break;
 
     default:
-      result = __syscall_ioctl (fd, request, arg);
+      result = INLINE_SYSCALL (ioctl, 3, fd, request, arg);
       break;
     }
 
diff -Nur sysdeps/unix/sysv/linux/powerpc/lockf64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/lockf64.c
--- sysdeps/unix/sysv/linux/powerpc/lockf64.c	2000-09-29 09:28:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/lockf64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/Makefile
--- sysdeps/unix/sysv/linux/powerpc/Makefile	2002-09-05 12:08:49.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/Makefile	2004-04-19 08:18:35.000000000 +0200
@@ -1,4 +1,4 @@
-ifeq ($(subdir),signal)
-sysdep_routines += rt_sigsuspend rt_sigprocmask rt_sigtimedwait	\
-		   rt_sigqueueinfo rt_sigaction rt_sigpending
+64bit-predefine = __powerpc64__
+ifeq ($(subdir),rt)
+librt-routines += rt-sysdep
 endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/mmap64.c
--- sysdeps/unix/sysv/linux/powerpc/mmap64.c	2002-09-17 18:46:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/mmap64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/* Copyright (C) 1999,2000,01,02 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-#include <bp-checks.h>
-
-#include "kernel-features.h"
-
-/* This is always the constant 12 for this routine, even if the actual
-   page size is larger.  */
-#define PAGE_SHIFT 12
-
-#ifdef __NR_mmap2
-extern void *__unbounded __syscall_mmap2(void *__unbounded, size_t,
-					 int, int, int, off_t);
-#ifndef __ASSUME_MMAP2_SYSCALL
-static int have_no_mmap2;
-#endif
-#endif
-
-void *
-__mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
-{
-  if (offset & ((1 << PAGE_SHIFT)-1))
-    {
-      __set_errno (EINVAL);
-      return MAP_FAILED;
-    }
-#ifdef __NR_mmap2
-# ifndef __ASSUME_MMAP2_SYSCALL
-  if (! have_no_mmap2)
-# endif
-    {
-# ifndef __ASSUME_MMAP2_SYSCALL
-      int saved_errno = errno;
-# endif
-      void *result;
-      __ptrvalue (result)
-	= (void *) INLINE_SYSCALL (mmap2, 6, __ptrvalue (addr), len,
-				   prot, flags, fd,
-				   (off_t) (offset >> PAGE_SHIFT));
-# if __BOUNDED_POINTERS__
-      __ptrlow (result) = __ptrvalue (result);
-      __ptrhigh (result) = __ptrvalue (result) + len;
-# endif
-# ifndef __ASSUME_MMAP2_SYSCALL
-      if (result != MAP_FAILED || errno != ENOSYS)
-# endif
-	return result;
-
-# ifndef __ASSUME_MMAP2_SYSCALL
-      __set_errno (saved_errno);
-      have_no_mmap2 = 1;
-# endif
-    }
-#endif
-#ifndef __ASSUME_MMAP2_SYSCALL
-  if (offset != (off_t) offset || (offset + len) != (off_t) (offset + len))
-    {
-      __set_errno (EINVAL);
-      return MAP_FAILED;
-    }
-
-  return __mmap (addr, len, prot, flags, fd, (off_t) offset);
-#endif
-}
-
-weak_alias (__mmap64, mmap64)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/clone.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/clone.S	2002-08-04 04:20:06.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/clone.S	2004-12-15 21:50:04.000000000 +0100
@@ -1,5 +1,5 @@
 /* Wrapper around clone system call.
-   Copyright (C) 1997,98,99,2000,02 Free Software Foundation, Inc.
+   Copyright (C) 1997,98,99,2000,02,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,15 +20,21 @@
 #include <sysdep.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
+#include <kernel-features.h>
 #include <bp-sym.h>
 #include <bp-asm.h>
 
+#define CLONE_VM	0x00000100
+#define CLONE_THREAD	0x00010000
+
+
 /* This is the only really unusual system call in PPC linux, but not
    because of any weirdness in the system call itself; because of
    all the freaky stuff we have to do to make the call useful.  */
 
 /* int [r3] clone(int (*fn)(void *arg) [r3], void *child_stack [r4],
-   		  int flags [r5], void *arg [r6]); */
+   		  int flags [r5], void *arg [r6], void *parent_tid [r7],
+		  void *tls [r8], void *child_tid [r9]); */
 
 ENTRY (BP_SYM (__clone))
 	/* GKM FIXME: add bounds checks, where sensible.  */
@@ -43,7 +49,15 @@
 
 	/* Set up stack frame for parent.  */
 	stwu	r1,-32(r1)
+#ifdef RESET_PID
+	stmw	r28,16(r1)
+#else
+# ifndef __ASSUME_FIXED_CLONE_SYSCALL
 	stmw	r29,16(r1)
+# else
+	stmw	r30,16(r1)
+# endif
+#endif
 
 	/* Set up stack frame for child.  */
 	clrrwi	r4,r4,4
@@ -51,14 +65,24 @@
 	stwu	r0,-16(r4)
 
 	/* Save fn, args, stack across syscall.  */
-	mr	r29,r3			/* Function in r29.  */
-	mr	r30,r4			/* Stack pointer in r30.  */
+	mr	r30,r3			/* Function in r30.  */
+#ifndef __ASSUME_FIXED_CLONE_SYSCALL
+	mr	r29,r4			/* Stack pointer in r29.  */
+#endif
+#ifdef RESET_PID
+	mr	r28,r5
+#endif
 	mr	r31,r6			/* Argument in r31.  */
 
 	/* 'flags' argument is first parameter to clone syscall. (The other
 	   argument is the stack pointer, already in r4.)  */
 	mr	r3,r5
 
+	/* Move the parent_tid, child_tid and tls arguments. */
+	mr	r5,r7
+	mr	r6,r8
+	mr	r7,r9
+
 	/* Do the call.  */
 	DO_CALL(SYS_ify(clone))
 
@@ -67,13 +91,29 @@
 	crandc	cr1*4+eq,cr1*4+eq,cr0*4+so
 	bne-	cr1,L(parent)		/* The '-' is to minimise the race.  */
 
+#ifndef __ASSUME_FIXED_CLONE_SYSCALL
 	/* On at least mklinux DR3a5, clone() doesn't actually change
 	   the stack pointer.  I'm pretty sure this is a bug, because
 	   it adds a race condition if a signal is sent to a thread
 	   just after it is created (in the previous three instructions).  */
-	mr	r1,r30
+	mr	r1,r29
+#endif
+
+#ifdef RESET_PID
+	andis.	r0,r28,CLONE_THREAD>>16
+	bne+	r0,L(oldpid)
+	andi.	r0,r28,CLONE_VM
+	li	r3,-1
+	bne-	r0,L(nomoregetpid)
+	DO_CALL(SYS_ify(getpid))
+L(nomoregetpid):
+	stw	r3,TID(r2)
+	stw	r3,PID(r2)
+L(oldpid):
+#endif
+
 	/* Call procedure.  */
-	mtctr	r29
+	mtctr	r30
 	mr	r3,r31
 	bctrl
 	/* Call _exit with result from procedure.  */
@@ -81,7 +121,15 @@
 
 L(parent):
 	/* Parent.  Restore registers & return.  */
+#ifdef RESET_PID
+	lmw	r28,16(r1)
+#else
+# ifndef __ASSUME_FIXED_CLONE_SYSCALL
 	lmw	r29,16(r1)
+# else
+	lmw	r30,16(r1)
+# endif
+#endif
 	addi	r1,r1,32
 	bnslr+
 	b	JUMPTARGET(__syscall_error)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/Dist
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/Dist	2002-09-19 07:48:02.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/Dist	2003-02-20 23:20:07.000000000 +0100
@@ -1,2 +1,3 @@
 clone.S
 kernel_stat.h
+fe_nomask.c
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/fcntl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fcntl.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fcntl.c	2004-06-27 22:45:18.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/fe_nomask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fe_nomask.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/fe_nomask.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fe_nomask.c	2003-02-20 23:17:50.000000000 +0100
@@ -0,0 +1,68 @@
+/* Procedure definition for FE_NOMASK_ENV for Linux/ppc.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+#include "kernel-features.h"
+
+#if __ASSUME_NEW_PRCTL_SYSCALL == 0
+/* This is rather fiddly under Linux.  We don't have direct access,
+   and there is no system call, but we can change the bits 
+   in a signal handler's context...  */
+
+static struct sigaction oact;
+
+static void
+fe_nomask_handler (int signum, struct sigcontext *sc)
+{
+  sc->regs->msr |= 0x900ul;  /* FE0 | FE1 */
+  sigaction (SIGUSR1, &oact, NULL);
+}
+#endif
+
+const fenv_t *
+__fe_nomask_env (void)
+{
+#if __ASSUME_NEW_PRCTL_SYSCALL == 0
+# if defined PR_SET_FPEXC && defined PR_FP_EXC_PRECISE
+  int result = INLINE_SYSCALL (prctl, 2, PR_SET_FPEXC, PR_FP_EXC_PRECISE);
+
+  if (result == -1 && errno == EINVAL)
+# endif
+    {
+      struct sigaction act;
+
+      act.sa_handler = (sighandler_t) fe_nomask_handler;
+      sigemptyset (&act.sa_mask);
+      act.sa_flags = 0;
+
+      sigaction (SIGUSR1, &act, &oact);
+      raise (SIGUSR1);
+    }
+#else
+  INTERNAL_SYSCALL_DECL (err);
+  INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, PR_FP_EXC_PRECISE);
+#endif
+
+  return FE_ENABLED_ENV;
+}
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/ftruncate64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/ftruncate64.c	2003-01-07 01:32:18.000000000 +0100
@@ -0,0 +1,78 @@
+/* Copyright (C) 1997,1998,1999,2000,2001,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_ftruncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+extern int have_no_truncate64;
+#endif
+
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+__ftruncate64 (fd, length)
+     int fd;
+     off64_t length;
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! have_no_truncate64)
+#endif
+    {
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      int result = INLINE_SYSCALL (ftruncate64, 4, fd, 0,
+				   (long) (length >> 32),
+				   (long) length);
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return __ftruncate (fd, (off_t) length);
+#endif
+}
+weak_alias (__ftruncate64, ftruncate64)
+
+#else
+/* Use the generic implementation.  */
+# include <sysdeps/generic/ftruncate64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fxstat.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/fxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/fxstat.c	2004-03-02 19:50:00.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstat.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/getcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/getcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/getcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/getcontext.S	2004-09-02 20:59:01.000000000 +0200
@@ -0,0 +1,393 @@
+/* Save current context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+
+	.machine	"altivec"
+ENTRY(__getcontext)
+	stwu	r1,-16(r1)
+/* Insure that the _UC_REGS start on a quadword boundary.  */
+	stw	r3,_FRAME_PARM_SAVE1(r1)
+	addi	r3,r3,_UC_REG_SPACE+12
+	clrrwi  r3,r3,4
+
+/* Save the general purpose registers */
+	stw	r0,_UC_GREGS+(PT_R0*4)(r3)
+	mflr	r0
+	stw	r2,_UC_GREGS+(PT_R2*4)(r3)
+	stw	r4,_UC_GREGS+(PT_R4*4)(r3)
+/* Set the callers LR_SAVE, and the ucontext LR and NIP to the callers
+   return address.  */
+	stw	r0,_UC_GREGS+(PT_LNK*4)(r3)
+	stw	r0,_UC_GREGS+(PT_NIP*4)(r3)
+	stw	r0,_FRAME_LR_SAVE+16(r1)
+	stw	r5,_UC_GREGS+(PT_R5*4)(r3)
+	stw	r6,_UC_GREGS+(PT_R6*4)(r3)
+	stw	r7,_UC_GREGS+(PT_R7*4)(r3)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r3)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r3)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r3)
+	stw	r11,_UC_GREGS+(PT_R11*4)(r3)
+	stw	r12,_UC_GREGS+(PT_R12*4)(r3)
+	stw	r13,_UC_GREGS+(PT_R13*4)(r3)
+	stw	r14,_UC_GREGS+(PT_R14*4)(r3)
+	stw	r15,_UC_GREGS+(PT_R15*4)(r3)
+	stw	r16,_UC_GREGS+(PT_R16*4)(r3)
+	stw	r17,_UC_GREGS+(PT_R17*4)(r3)
+	stw	r18,_UC_GREGS+(PT_R18*4)(r3)
+	stw	r19,_UC_GREGS+(PT_R19*4)(r3)
+	stw	r20,_UC_GREGS+(PT_R20*4)(r3)
+	stw	r21,_UC_GREGS+(PT_R21*4)(r3)
+	stw	r22,_UC_GREGS+(PT_R22*4)(r3)
+	stw	r23,_UC_GREGS+(PT_R23*4)(r3)
+	stw	r24,_UC_GREGS+(PT_R24*4)(r3)
+	stw	r25,_UC_GREGS+(PT_R25*4)(r3)
+	stw	r26,_UC_GREGS+(PT_R26*4)(r3)
+	stw	r27,_UC_GREGS+(PT_R27*4)(r3)
+	stw	r28,_UC_GREGS+(PT_R28*4)(r3)
+	stw	r29,_UC_GREGS+(PT_R29*4)(r3)
+	stw	r30,_UC_GREGS+(PT_R30*4)(r3)
+	stw	r31,_UC_GREGS+(PT_R31*4)(r3)
+/* Save the value of R1.  We had to push the stack before we
+   had the address of uc_reg_space.  So compute the address of
+   the callers stack pointer and save it as R1.  */
+	addi	r8,r1,16
+	li	r0,0
+/* Save the count, exception and condition registers.  */
+	mfctr	r11
+	mfxer	r10
+	mfcr	r9
+	stw	r8,_UC_GREGS+(PT_R1*4)(r3)
+	stw	r11,_UC_GREGS+(PT_CTR*4)(r3)
+	stw	r10,_UC_GREGS+(PT_XER*4)(r3)
+	stw	r9,_UC_GREGS+(PT_CCR*4)(r3)
+/* Set the return value of getcontext to "success".  R3 is the only
+   register whose value is not preserved in the saved context.  */
+	stw	r0,_UC_GREGS+(PT_R3*4)(r3)
+
+/* Zero fill fields that can't be set in user state. */
+	stw	r0,_UC_GREGS+(PT_MSR*4)(r3)
+	stw	r0,_UC_GREGS+(PT_MQ*4)(r3)
+
+/* Save the floating-point registers */
+	stfd	fp0,_UC_FREGS+(0*8)(r3)
+	stfd	fp1,_UC_FREGS+(1*8)(r3)
+	stfd	fp2,_UC_FREGS+(2*8)(r3)
+	stfd	fp3,_UC_FREGS+(3*8)(r3)
+	stfd	fp4,_UC_FREGS+(4*8)(r3)
+	stfd	fp5,_UC_FREGS+(5*8)(r3)
+	stfd	fp6,_UC_FREGS+(6*8)(r3)
+	stfd	fp7,_UC_FREGS+(7*8)(r3)
+	stfd	fp8,_UC_FREGS+(8*8)(r3)
+	stfd	fp9,_UC_FREGS+(9*8)(r3)
+	stfd	fp10,_UC_FREGS+(10*8)(r3)
+	stfd	fp11,_UC_FREGS+(11*8)(r3)
+	stfd	fp12,_UC_FREGS+(12*8)(r3)
+	stfd	fp13,_UC_FREGS+(13*8)(r3)
+	stfd	fp14,_UC_FREGS+(14*8)(r3)
+	stfd	fp15,_UC_FREGS+(15*8)(r3)
+	stfd	fp16,_UC_FREGS+(16*8)(r3)
+	stfd	fp17,_UC_FREGS+(17*8)(r3)
+	stfd	fp18,_UC_FREGS+(18*8)(r3)
+	stfd	fp19,_UC_FREGS+(19*8)(r3)
+	stfd	fp20,_UC_FREGS+(20*8)(r3)
+	stfd	fp21,_UC_FREGS+(21*8)(r3)
+	stfd	fp22,_UC_FREGS+(22*8)(r3)
+	stfd	fp23,_UC_FREGS+(23*8)(r3)
+	stfd	fp24,_UC_FREGS+(24*8)(r3)
+	stfd	fp25,_UC_FREGS+(25*8)(r3)
+	stfd	fp26,_UC_FREGS+(26*8)(r3)
+	stfd	fp27,_UC_FREGS+(27*8)(r3)
+	stfd	fp28,_UC_FREGS+(28*8)(r3)
+	stfd	fp29,_UC_FREGS+(29*8)(r3)
+	mffs	fp0
+	stfd	fp30,_UC_FREGS+(30*8)(r3)
+	stfd	fp31,_UC_FREGS+(31*8)(r3)
+	stfd	fp0,_UC_FREGS+(32*8)(r3)
+
+#ifdef PIC
+	mflr    r8
+	bl      _GLOBAL_OFFSET_TABLE_@local-4
+	mflr    r7
+# ifdef SHARED
+	lwz     r7,_rtld_global_ro@got(r7)
+	mtlr    r8
+	lwz     r7,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r7)
+# else
+	lwz     r7,_dl_hwcap@got(r7)
+	mtlr    r8
+	lwz     r7,0(r7)
+# endif
+#else
+	lis	r7,_dl_hwcap@ha
+	lwz     r7,_dl_hwcap@l(r7)
+#endif
+	andis.	r7,r7,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+
+	la	r10,(_UC_VREGS)(r3)
+	la	r9,(_UC_VREGS+16)(r3)
+	
+	beq	L(no_vec)
+/* address of the combined VSCR/VSAVE quadword.  */	
+	la	r8,(_UC_VREGS+512)(r3)
+
+/* Save the vector registers */
+	stvx  v0,0,r10
+	stvx  v1,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+/* We need to get the Vector Status and Control Register early to avoid
+   store order problems later with the VSAVE register that shares the
+   same quadword.  */
+	mfvscr	v0
+
+	stvx  v2,0,r10
+	stvx  v3,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx	v0,0,r8
+	
+	stvx  v4,0,r10
+	stvx  v5,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v6,0,r10
+	stvx  v7,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v8,0,r10
+	stvx  v9,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v10,0,r10
+	stvx  v11,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v12,0,r10
+	stvx  v13,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v14,0,r10
+	stvx  v15,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v16,0,r10
+	stvx  v17,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v18,0,r10
+	stvx  v19,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v20,0,r10
+	stvx  v21,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v22,0,r10
+	stvx  v23,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v24,0,r10
+	stvx  v25,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v26,0,r10
+	stvx  v27,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v28,0,r10
+	stvx  v29,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	mfspr	r0,VRSAVE
+	stvx  v30,0,r10
+	stvx  v31,0,r9
+
+ 	stw	r0,0(r8)
+
+L(no_vec):
+/* We need to set up parms and call sigprocmask which will clobber
+   volatile registers. So before the call we need to retrieve the
+   original ucontext ptr (parm1) from stack and store the UC_REGS_PTR
+   (current R3).  */
+	lwz	r12,_FRAME_PARM_SAVE1(r1)
+	li	r4,0
+	stw	r3,_UC_REGS_PTR(r12)
+	addi	r5,r12,_UC_SIGMASK
+	li	r3,SIG_BLOCK
+	bl	JUMPTARGET(__sigprocmask)
+
+	lwz	r0,_FRAME_LR_SAVE+16(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+END(__getcontext)
+
+versioned_symbol (libc, __getcontext, getcontext, GLIBC_2_3_4)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+
+	compat_text_section
+ENTRY(__novec_getcontext)
+	/*
+	 * Since we are not attempting to save the altivec registers,
+	 * there is no need to get the register storage space
+	 * aligned on a 16-byte boundary.
+	 */
+	addi	r3,r3,_UC_REG_SPACE
+	stw	r3,_UC_REGS_PTR - _UC_REG_SPACE(r3)
+	stw	r0,_UC_GREGS+(PT_R0*4)(r3)
+	stw	r1,_UC_GREGS+(PT_R1*4)(r3)
+	mflr	r0
+	stwu	r1,-16(r1)
+	stw	r0,20(r1)
+	stw	r0,_UC_GREGS+(PT_LNK*4)(r3)
+	stw	r0,_UC_GREGS+(PT_NIP*4)(r3)
+	stw	r2,_UC_GREGS+(PT_R2*4)(r3)
+	stw	r4,_UC_GREGS+(PT_R4*4)(r3)
+	stw	r5,_UC_GREGS+(PT_R5*4)(r3)
+	stw	r6,_UC_GREGS+(PT_R6*4)(r3)
+	stw	r7,_UC_GREGS+(PT_R7*4)(r3)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r3)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r3)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r3)
+	stw	r11,_UC_GREGS+(PT_R11*4)(r3)
+	stw	r12,_UC_GREGS+(PT_R12*4)(r3)
+	stw	r13,_UC_GREGS+(PT_R13*4)(r3)
+	stw	r14,_UC_GREGS+(PT_R14*4)(r3)
+	stw	r15,_UC_GREGS+(PT_R15*4)(r3)
+	stw	r16,_UC_GREGS+(PT_R16*4)(r3)
+	stw	r17,_UC_GREGS+(PT_R17*4)(r3)
+	stw	r18,_UC_GREGS+(PT_R18*4)(r3)
+	stw	r19,_UC_GREGS+(PT_R19*4)(r3)
+	stw	r20,_UC_GREGS+(PT_R20*4)(r3)
+	stw	r21,_UC_GREGS+(PT_R21*4)(r3)
+	stw	r22,_UC_GREGS+(PT_R22*4)(r3)
+	stw	r23,_UC_GREGS+(PT_R23*4)(r3)
+	stw	r24,_UC_GREGS+(PT_R24*4)(r3)
+	stw	r25,_UC_GREGS+(PT_R25*4)(r3)
+	stw	r26,_UC_GREGS+(PT_R26*4)(r3)
+	stw	r27,_UC_GREGS+(PT_R27*4)(r3)
+	stw	r28,_UC_GREGS+(PT_R28*4)(r3)
+	stw	r29,_UC_GREGS+(PT_R29*4)(r3)
+	stw	r30,_UC_GREGS+(PT_R30*4)(r3)
+	stw	r31,_UC_GREGS+(PT_R31*4)(r3)
+	mfctr	r0
+	stw	r0,_UC_GREGS+(PT_CTR*4)(r3)
+	mfxer	r0
+	stw	r0,_UC_GREGS+(PT_XER*4)(r3)
+	mfcr	r0
+	stw	r0,_UC_GREGS+(PT_CCR*4)(r3)
+
+	/* Set the return value of getcontext to "success".  R3 is the only
+	   register whose value is not preserved in the saved context.  */
+	li	r0,0
+	stw	r0,_UC_GREGS+(PT_R3*4)(r3)
+
+	/* Zero fill fields that can't be set in user state. */
+	stw	r0,_UC_GREGS+(PT_MSR*4)(r3)
+	stw	r0,_UC_GREGS+(PT_MQ*4)(r3)
+
+	/* Save the floating-point registers */
+	stfd	fp0,_UC_FREGS+(0*8)(r3)
+	stfd	fp1,_UC_FREGS+(1*8)(r3)
+	stfd	fp2,_UC_FREGS+(2*8)(r3)
+	stfd	fp3,_UC_FREGS+(3*8)(r3)
+	stfd	fp4,_UC_FREGS+(4*8)(r3)
+	stfd	fp5,_UC_FREGS+(5*8)(r3)
+	stfd	fp6,_UC_FREGS+(6*8)(r3)
+	stfd	fp7,_UC_FREGS+(7*8)(r3)
+	stfd	fp8,_UC_FREGS+(8*8)(r3)
+	stfd	fp9,_UC_FREGS+(9*8)(r3)
+	stfd	fp10,_UC_FREGS+(10*8)(r3)
+	stfd	fp11,_UC_FREGS+(11*8)(r3)
+	stfd	fp12,_UC_FREGS+(12*8)(r3)
+	stfd	fp13,_UC_FREGS+(13*8)(r3)
+	stfd	fp14,_UC_FREGS+(14*8)(r3)
+	stfd	fp15,_UC_FREGS+(15*8)(r3)
+	stfd	fp16,_UC_FREGS+(16*8)(r3)
+	stfd	fp17,_UC_FREGS+(17*8)(r3)
+	stfd	fp18,_UC_FREGS+(18*8)(r3)
+	stfd	fp19,_UC_FREGS+(19*8)(r3)
+	stfd	fp20,_UC_FREGS+(20*8)(r3)
+	stfd	fp21,_UC_FREGS+(21*8)(r3)
+	stfd	fp22,_UC_FREGS+(22*8)(r3)
+	stfd	fp23,_UC_FREGS+(23*8)(r3)
+	stfd	fp24,_UC_FREGS+(24*8)(r3)
+	stfd	fp25,_UC_FREGS+(25*8)(r3)
+	stfd	fp26,_UC_FREGS+(26*8)(r3)
+	stfd	fp27,_UC_FREGS+(27*8)(r3)
+	stfd	fp28,_UC_FREGS+(28*8)(r3)
+	stfd	fp29,_UC_FREGS+(29*8)(r3)
+	mffs	fp0
+	stfd	fp30,_UC_FREGS+(30*8)(r3)
+	stfd	fp31,_UC_FREGS+(31*8)(r3)
+	stfd	fp0,_UC_FREGS+(32*8)(r3)
+
+	addi	r5,r3,_UC_SIGMASK - _UC_REG_SPACE
+	li	r4,0
+	li	r3,SIG_BLOCK
+	bl	JUMPTARGET(__sigprocmask)
+
+	lwz	r0,20(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+END(__novec_getcontext)
+	.previous
+
+compat_symbol (libc, __novec_getcontext, getcontext, GLIBC_2_3_3)
+
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_3_3)
+
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+	compat_text_section
+ENTRY (__getcontext_stub)
+	li	r3,ENOSYS
+	b	JUMPTARGET(__syscall_error)
+END (__getcontext_stub)
+	.previous
+
+compat_symbol (libc, __getcontext_stub, getcontext, GLIBC_2_1)
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/glob64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/glob64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/glob64.c	2003-02-17 20:08:57.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/glob64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/kernel_stat.h
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/kernel_stat.h	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/kernel_stat.h	2004-02-05 21:56:09.000000000 +0100
@@ -1,5 +1,5 @@
 /* Definition of `struct stat' used in the kernel.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,31 +29,21 @@
     unsigned long int st_size;
     unsigned long int st_blksize;
     unsigned long int st_blocks;
-    unsigned long int st_atime;
-    unsigned long int __unused1;
-#define _HAVE___UNUSED1
-    unsigned long int st_mtime;
-    unsigned long int __unused2;
-#define _HAVE___UNUSED2
-    unsigned long int st_ctime;
-    unsigned long int __unused3;
-#define _HAVE___UNUSED3
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
     unsigned long int __unused4;
 #define _HAVE___UNUSED4
     unsigned long int __unused5;
 #define _HAVE___UNUSED5
   };
 
-#define _HAVE_STAT___UNUSED1
-#define _HAVE_STAT___UNUSED2
-#define _HAVE_STAT___UNUSED3
 #define _HAVE_STAT___UNUSED4
 #define _HAVE_STAT___UNUSED5
 #define _HAVE_STAT___PAD1
 #define _HAVE_STAT___PAD2
-#define _HAVE_STAT64___UNUSED1
-#define _HAVE_STAT64___UNUSED2
-#define _HAVE_STAT64___UNUSED3
+#define _HAVE_STAT_NSEC
 #define _HAVE_STAT64___UNUSED4
 #define _HAVE_STAT64___UNUSED5
 #define _HAVE_STAT64___PAD2
+#define _HAVE_STAT64_NSEC
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/lockf64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/lockf64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/lockf64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/lockf64.c	2004-06-27 22:46:04.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/lxstat.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/lxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/lxstat.c	2004-03-02 19:50:14.000000000 +0100
@@ -0,0 +1,2 @@
+#include <sysdeps/unix/sysv/linux/i386/lxstat.c>
+
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/makecontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/makecontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/makecontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/makecontext.S	2004-03-10 20:24:11.000000000 +0100
@@ -0,0 +1,215 @@
+/* Set up a context to call a function.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+
+ENTRY(__makecontext)
+	/* Set up the first 7 args to the function in its registers */
+	addi	r11,r3,_UC_REG_SPACE+12
+	clrrwi  r11,r11,4
+	stw	r11,_UC_REGS_PTR(r3)
+	stw	r6,_UC_GREGS+(PT_R3*4)(r11)
+	stw	r7,_UC_GREGS+(PT_R4*4)(r11)
+	stw	r8,_UC_GREGS+(PT_R5*4)(r11)
+	stw	r9,_UC_GREGS+(PT_R6*4)(r11)
+	stw	r10,_UC_GREGS+(PT_R7*4)(r11)
+	lwz	r8,8(r1)
+	lwz	r9,12(r1)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r11)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r11)
+
+	/* Set the NIP to the start of the function */
+	stw	r4,_UC_GREGS+(PT_NIP*4)(r11)
+
+	/* Set the function's r31 to ucp->uc_link for the exitcode below. */
+	lwz	r7,_UC_LINK(r3)
+	stw	r7,_UC_GREGS+(PT_R31*4)(r11)
+
+	/* Set the function's LR to point to the exitcode below. */
+#ifdef PIC
+	mflr	r0
+	bl	1f
+1:	mflr	r6
+	addi	r6,r6,L(exitcode)-1b
+	mtlr	r0
+#else
+	lis	r6,L(exitcode)@ha
+	addi	r6,r6,L(exitcode)@l
+#endif
+	stw	r6,_UC_GREGS+(PT_LNK*4)(r11)
+
+	/*
+	 * Set up the stack frame for the function.
+	 * If we have more than 5 args to the function (8 args to makecontext),
+	 * there will be some arguments on the stack which have to end up
+	 * in registers.  If there are more than 8 args to the function,
+	 * we have to copy (argc - 8) args from our stack to the functions'
+	 * stack (and allow space for them in the frame).
+	 */
+	lwz	r4,_UC_STACK_SP(r3)
+	lwz	r8,_UC_STACK_SIZE(r3)
+	add	r4,r4,r8
+	rlwinm	r4,r4,0,0,27	/* round down to 16-byte boundary */
+	addi	r7,r4,-16	/* stack frame for fn's caller */
+	cmpwi	r5,8
+	blt	2f		/* less than 8 args is easy */
+	lwz	r10,16(r1)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r11)
+	beq	2f		/* if exactly 8 args */
+	subi	r9,r5,3
+	subi	r5,r5,8
+	rlwinm	r9,r9,2,0,27
+	subf	r7,r9,r4
+	mtctr	r5		/* copy the 9th and following args */
+	addi	r6,r1,16
+	addi	r8,r7,4
+3:	lwzu	r10,4(r6)
+	stwu	r10,4(r8)
+	bdnz	3b
+2:	stw	r7,_UC_GREGS+(PT_R1*4)(r11)
+	li	r6,0
+	stw	r6,0(r7)
+
+	blr
+
+/*
+ * If the function returns, it comes here.  We put ucp->uc_link in
+ * r31, which is a callee-saved register.  We have to continue with
+ * the context that r31 points to, or exit if it is 0.
+ */
+L(exitcode):
+	mr.	r3,r31
+	beq	4f
+	bl	JUMPTARGET(__setcontext)
+4:	bl	HIDDEN_JUMPTARGET(exit)
+	b	4b
+
+END(__makecontext)
+
+versioned_symbol (libc, __makecontext, makecontext, GLIBC_2_3_4)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+
+	compat_text_section
+ENTRY(__novec_makecontext)
+	/* Set up the first 7 args to the function in its registers */
+	addi	r11,r3,_UC_REG_SPACE
+	stw	r11,_UC_REGS_PTR(r3)
+	stw	r6,_UC_GREGS+(PT_R3*4)(r11)
+	stw	r7,_UC_GREGS+(PT_R4*4)(r11)
+	stw	r8,_UC_GREGS+(PT_R5*4)(r11)
+	stw	r9,_UC_GREGS+(PT_R6*4)(r11)
+	stw	r10,_UC_GREGS+(PT_R7*4)(r11)
+	lwz	r8,8(r1)
+	lwz	r9,12(r1)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r11)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r11)
+
+	/* Set the NIP to the start of the function */
+	stw	r4,_UC_GREGS+(PT_NIP*4)(r11)
+
+	/* Set the function's r31 to ucp->uc_link for the exitcode below. */
+	lwz	r7,_UC_LINK(r3)
+	stw	r7,_UC_GREGS+(PT_R31*4)(r11)
+
+	/* Set the function's LR to point to the exitcode below. */
+#ifdef PIC
+	mflr	r0
+	bl	1f
+1:	mflr	r6
+	addi	r6,r6,L(novec_exitcode)-1b
+	mtlr	r0
+#else
+	lis	r6,L(novec_exitcode)@ha
+	addi	r6,r6,L(novec_exitcode)@l
+#endif
+	stw	r6,_UC_GREGS+(PT_LNK*4)(r11)
+
+	/*
+	 * Set up the stack frame for the function.
+	 * If we have more than 5 args to the function (8 args to makecontext),
+	 * there will be some arguments on the stack which have to end up
+	 * in registers.  If there are more than 8 args to the function,
+	 * we have to copy (argc - 8) args from our stack to the functions'
+	 * stack (and allow space for them in the frame).
+	 */
+	lwz	r4,_UC_STACK_SP(r3)
+	lwz	r8,_UC_STACK_SIZE(r3)
+	add	r4,r4,r8
+	rlwinm	r4,r4,0,0,27	/* round down to 16-byte boundary */
+	addi	r7,r4,-16	/* stack frame for fn's caller */
+	cmpwi	r5,8
+	blt	2f		/* less than 8 args is easy */
+	lwz	r10,16(r1)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r11)
+	beq	2f		/* if exactly 8 args */
+	subi	r9,r5,3
+	subi	r5,r5,8
+	rlwinm	r9,r9,2,0,27
+	subf	r7,r9,r4
+	mtctr	r5		/* copy the 9th and following args */
+	addi	r6,r1,16
+	addi	r8,r7,4
+3:	lwzu	r10,4(r6)
+	stwu	r10,4(r8)
+	bdnz	3b
+2:	stw	r7,_UC_GREGS+(PT_R1*4)(r11)
+	li	r6,0
+	stw	r6,0(r7)
+
+	blr
+
+/*
+ * If the function returns, it comes here.  We put ucp->uc_link in
+ * r31, which is a callee-saved register.  We have to continue with
+ * the context that r31 points to, or exit if it is 0.
+ */
+L(novec_exitcode):
+	mr.	r3,r31
+	beq	4f
+	bl	JUMPTARGET(__novec_setcontext)
+4:	bl	HIDDEN_JUMPTARGET(exit)
+	b	4b
+
+END(__novec_makecontext)
+	.previous
+
+compat_symbol (libc, __novec_makecontext, makecontext, GLIBC_2_3_3)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_3_3)
+
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+	compat_text_section
+ENTRY (__makecontext_stub)
+	li	r3,ENOSYS
+	b	JUMPTARGET(__syscall_error)
+END (__makecontext_stub)
+	.previous
+
+compat_symbol (libc, __makecontext_stub, makecontext, GLIBC_2_1)
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise64.c	2004-03-10 20:25:55.000000000 +0100
@@ -0,0 +1,78 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+int __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise);
+int __posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise);
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+#ifdef __NR_fadvise64_64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64_64, err, 6, fd, advise,
+			      __LONG_LONG_PAIR ((long)(offset >> 32), (long)offset),
+			      __LONG_LONG_PAIR ((long)(len >> 32), (long)len));
+  if (!INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return 0;
+# ifndef __ASSUME_FADVISE64_64_SYSCALL
+  if (INTERNAL_SYSCALL_ERRNO (ret, err) != ENOSYS)
+# endif
+   return INTERNAL_SYSCALL_ERRNO (ret, err);
+#endif
+#ifndef __ASSUME_FADVISE64_64_SYSCALL
+# ifdef __NR_fadvise64
+  if (len != (off_t) len)
+    return EOVERFLOW;
+
+  INTERNAL_SYSCALL_DECL (err2);
+  int ret2 = INTERNAL_SYSCALL (fadvise64, err2, 6, fd, 0,
+			       __LONG_LONG_PAIR ((long)(offset >> 32), (long)offset),
+			       (off_t) len, advise);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret2, err2))
+    return 0;
+  return INTERNAL_SYSCALL_ERRNO (ret2, err2);
+# else
+  return ENOSYS;
+# endif
+#endif
+}
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise)
+{
+  return __posix_fadvise64_l64 (fd, offset, len, advise);
+}
+
+versioned_symbol (libc, __posix_fadvise64_l64, posix_fadvise64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fadvise64_l32, posix_fadvise64, GLIBC_2_2);
+#else
+strong_alias (__posix_fadvise64_l64, posix_fadvise64);
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/posix_fadvise.c	2003-09-02 02:39:23.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 6, fd, 0,
+			      __LONG_LONG_PAIR (offset >> 31, offset), len,
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pread64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/pread64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pread64.c	2003-01-07 01:32:27.000000000 +0100
@@ -0,0 +1,88 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
+				  off64_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count,
+			       0, (long) (offset >> 32),
+			       (long) offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count,
+			   0, (long) (offset >> 32),
+			   (long) offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
+
+# define __libc_pread64(fd, buf, count, offset) \
+     static internal_function __emulate_pread64 (fd, buf, count, offset)
+#endif
+
+# if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pread.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/pread.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pread.c	2003-01-07 01:33:41.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread (int fd, void *buf, size_t count,
+				off_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count,
+			       0, offset >> 31, offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+  
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count,
+			       0, offset >> 31, offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__libc_pread, pread)
+
+# define __libc_pread(fd, buf, count, offset) \
+     static internal_function __emulate_pread (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite64.c	2003-01-07 01:32:53.000000000 +0100
@@ -0,0 +1,89 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
+				   off64_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+  /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count,
+			       0, (long) (offset >> 32),
+			       (long) offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count,
+			   0, (long) (offset >> 32),
+			   (long) offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+# define __libc_pwrite64(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/pwrite.c	2003-01-07 01:32:38.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
+				 off_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count,
+			       0, offset >> 31, offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count,
+			   0, offset >> 31, offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__libc_pwrite, pwrite)
+
+# define __libc_pwrite(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/setcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/setcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/setcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/setcontext.S	2004-07-26 06:23:04.000000000 +0200
@@ -0,0 +1,414 @@
+/* Jump to a new context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+
+	.machine	"altivec"
+ENTRY(__setcontext)
+	mflr	r0
+	stwu	r1,-16(r1)
+	stw	r0,20(r1)
+	stw	r31,12(r1)
+	lwz	r31,_UC_REGS_PTR(r3)
+
+	/*
+	 * If this ucontext refers to the point where we were interrupted
+	 * by a signal, we have to use the rt_sigreturn system call to
+	 * return to the context so we get both LR and CTR restored.
+	 *
+	 * Otherwise, the context we are restoring is either just after
+	 * a procedure call (getcontext/swapcontext) or at the beginning
+	 * of a procedure call (makecontext), so we don't need to restore
+	 * r0, xer, ctr.  We don't restore r2 since it will be used as
+	 * the TLS pointer.
+	 */
+	lwz	r0,_UC_GREGS+(PT_MSR*4)(r31)
+	cmpwi	r0,0
+	bne	L(do_sigret)
+
+	/* Restore the signal mask */
+	li	r5,0
+	addi	r4,r3,_UC_SIGMASK
+	li	r3,SIG_SETMASK
+	bl	JUMPTARGET(__sigprocmask)
+	cmpwi	r3,0
+	bne	L(error_exit)
+
+#ifdef PIC
+	mflr    r8
+	bl      _GLOBAL_OFFSET_TABLE_@local-4
+	mflr    r7
+# ifdef SHARED
+	lwz     r7,_rtld_global_ro@got(r7)
+	mtlr    r8
+	lwz     r7,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r7)
+# else
+	lwz     r7,_dl_hwcap@got(r7)
+	mtlr    r8
+	lwz     r7,0(r7)
+# endif
+#else
+	lis	r7,_dl_hwcap@ha
+	lwz     r7,_dl_hwcap@l(r7)
+#endif
+	andis.	r7,r7,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+	la	r10,(_UC_VREGS)(r31)
+	beq	L(has_no_vec)
+
+	lwz   r0,(32*16)(r10)
+	li    r9,(32*16)
+	cmpwi r0,0
+	mtspr VRSAVE,r0
+	beq   L(has_no_vec)
+
+	lvx   v19,r9,r10
+	la    r9,(16)(r10)
+
+	lvx   v0,0,r10
+	lvx   v1,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	mtvscr  v19
+	lvx   v2,0,r10
+	lvx   v3,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v4,0,r10
+	lvx   v5,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v6,0,r10
+	lvx   v7,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v8,0,r10
+	lvx   v9,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v10,0,r10
+	lvx   v11,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v12,0,r10
+	lvx   v13,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v14,0,r10
+	lvx   v15,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v16,0,r10
+	lvx   v17,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v18,0,r10
+	lvx   v19,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v20,0,r10
+	lvx   v21,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v22,0,r10
+	lvx   v23,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v24,0,r10
+	lvx   v25,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v26,0,r10
+	lvx   v27,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v28,0,r10
+	lvx   v29,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v30,0,r10
+	lvx   v31,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v10,0,r10
+	lvx   v11,0,r9
+
+L(has_no_vec):
+	/* Restore the floating-point registers */
+	lfd	fp31,_UC_FREGS+(32*8)(r31)
+	lfd	fp0,_UC_FREGS+(0*8)(r31)
+	mtfsf	0xff,fp31
+	lfd	fp1,_UC_FREGS+(1*8)(r31)
+	lfd	fp2,_UC_FREGS+(2*8)(r31)
+	lfd	fp3,_UC_FREGS+(3*8)(r31)
+	lfd	fp4,_UC_FREGS+(4*8)(r31)
+	lfd	fp5,_UC_FREGS+(5*8)(r31)
+	lfd	fp6,_UC_FREGS+(6*8)(r31)
+	lfd	fp7,_UC_FREGS+(7*8)(r31)
+	lfd	fp8,_UC_FREGS+(8*8)(r31)
+	lfd	fp9,_UC_FREGS+(9*8)(r31)
+	lfd	fp10,_UC_FREGS+(10*8)(r31)
+	lfd	fp11,_UC_FREGS+(11*8)(r31)
+	lfd	fp12,_UC_FREGS+(12*8)(r31)
+	lfd	fp13,_UC_FREGS+(13*8)(r31)
+	lfd	fp14,_UC_FREGS+(14*8)(r31)
+	lfd	fp15,_UC_FREGS+(15*8)(r31)
+	lfd	fp16,_UC_FREGS+(16*8)(r31)
+	lfd	fp17,_UC_FREGS+(17*8)(r31)
+	lfd	fp18,_UC_FREGS+(18*8)(r31)
+	lfd	fp19,_UC_FREGS+(19*8)(r31)
+	lfd	fp20,_UC_FREGS+(20*8)(r31)
+	lfd	fp21,_UC_FREGS+(21*8)(r31)
+	lfd	fp22,_UC_FREGS+(22*8)(r31)
+	lfd	fp23,_UC_FREGS+(23*8)(r31)
+	lfd	fp24,_UC_FREGS+(24*8)(r31)
+	lfd	fp25,_UC_FREGS+(25*8)(r31)
+	lfd	fp26,_UC_FREGS+(26*8)(r31)
+	lfd	fp27,_UC_FREGS+(27*8)(r31)
+	lfd	fp28,_UC_FREGS+(28*8)(r31)
+	lfd	fp29,_UC_FREGS+(29*8)(r31)
+	lfd	fp30,_UC_FREGS+(30*8)(r31)
+	lfd	fp31,_UC_FREGS+(31*8)(r31)
+
+	/* Restore LR and CCR, and set CTR to the NIP value */
+	lwz	r3,_UC_GREGS+(PT_LNK*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_NIP*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_CCR*4)(r31)
+	mtlr	r3
+	mtctr	r4
+	mtcr	r5
+
+	/* Restore the general registers */
+	lwz	r1,_UC_GREGS+(PT_R1*4)(r31)
+	lwz	r3,_UC_GREGS+(PT_R3*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_R4*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_R5*4)(r31)
+	lwz	r6,_UC_GREGS+(PT_R6*4)(r31)
+	lwz	r7,_UC_GREGS+(PT_R7*4)(r31)
+	lwz	r8,_UC_GREGS+(PT_R8*4)(r31)
+	lwz	r9,_UC_GREGS+(PT_R9*4)(r31)
+	lwz	r10,_UC_GREGS+(PT_R10*4)(r31)
+	lwz	r11,_UC_GREGS+(PT_R11*4)(r31)
+	lwz	r12,_UC_GREGS+(PT_R12*4)(r31)
+	lwz	r13,_UC_GREGS+(PT_R13*4)(r31)
+	lwz	r14,_UC_GREGS+(PT_R14*4)(r31)
+	lwz	r15,_UC_GREGS+(PT_R15*4)(r31)
+	lwz	r16,_UC_GREGS+(PT_R16*4)(r31)
+	lwz	r17,_UC_GREGS+(PT_R17*4)(r31)
+	lwz	r18,_UC_GREGS+(PT_R18*4)(r31)
+	lwz	r19,_UC_GREGS+(PT_R19*4)(r31)
+	lwz	r20,_UC_GREGS+(PT_R20*4)(r31)
+	lwz	r21,_UC_GREGS+(PT_R21*4)(r31)
+	lwz	r22,_UC_GREGS+(PT_R22*4)(r31)
+	lwz	r23,_UC_GREGS+(PT_R23*4)(r31)
+	lwz	r24,_UC_GREGS+(PT_R24*4)(r31)
+	lwz	r25,_UC_GREGS+(PT_R25*4)(r31)
+	lwz	r26,_UC_GREGS+(PT_R26*4)(r31)
+	lwz	r27,_UC_GREGS+(PT_R27*4)(r31)
+	lwz	r28,_UC_GREGS+(PT_R28*4)(r31)
+	lwz	r29,_UC_GREGS+(PT_R29*4)(r31)
+	lwz	r30,_UC_GREGS+(PT_R30*4)(r31)
+	lwz	r31,_UC_GREGS+(PT_R31*4)(r31)
+
+	bctr
+
+L(error_exit):
+	lwz	r31,12(r1)
+	lwz	r0,20(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+
+L(do_sigret):
+	addi	r1,r3,-0xd0
+	li	r0,SYS_ify(rt_sigreturn)
+	sc
+	/* NOTREACHED */
+
+END (__setcontext)
+
+versioned_symbol (libc, __setcontext, setcontext, GLIBC_2_3_4)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+
+	compat_text_section
+ENTRY(__novec_setcontext)
+	mflr	r0
+	stwu	r1,-16(r1)
+	stw	r0,20(r1)
+	stw	r31,12(r1)
+	lwz	r31,_UC_REGS_PTR(r3)
+
+	/*
+	 * If this ucontext refers to the point where we were interrupted
+	 * by a signal, we have to use the rt_sigreturn system call to
+	 * return to the context so we get both LR and CTR restored.
+	 *
+	 * Otherwise, the context we are restoring is either just after
+	 * a procedure call (getcontext/swapcontext) or at the beginning
+	 * of a procedure call (makecontext), so we don't need to restore
+	 * r0, xer, ctr.  We don't restore r2 since it will be used as
+	 * the TLS pointer.
+	 */
+	lwz	r0,_UC_GREGS+(PT_MSR*4)(r31)
+	cmpwi	r0,0
+	bne	L(novec_do_sigret)
+
+	/* Restore the signal mask */
+	li	r5,0
+	addi	r4,r3,_UC_SIGMASK
+	li	r3,SIG_SETMASK
+	bl	JUMPTARGET(__sigprocmask)
+	cmpwi	r3,0
+	bne	L(novec_error_exit)
+
+	/* Restore the floating-point registers */
+	lfd	fp31,_UC_FREGS+(32*8)(r31)
+	lfd	fp0,_UC_FREGS+(0*8)(r31)
+	mtfsf	0xff,fp31
+	lfd	fp1,_UC_FREGS+(1*8)(r31)
+	lfd	fp2,_UC_FREGS+(2*8)(r31)
+	lfd	fp3,_UC_FREGS+(3*8)(r31)
+	lfd	fp4,_UC_FREGS+(4*8)(r31)
+	lfd	fp5,_UC_FREGS+(5*8)(r31)
+	lfd	fp6,_UC_FREGS+(6*8)(r31)
+	lfd	fp7,_UC_FREGS+(7*8)(r31)
+	lfd	fp8,_UC_FREGS+(8*8)(r31)
+	lfd	fp9,_UC_FREGS+(9*8)(r31)
+	lfd	fp10,_UC_FREGS+(10*8)(r31)
+	lfd	fp11,_UC_FREGS+(11*8)(r31)
+	lfd	fp12,_UC_FREGS+(12*8)(r31)
+	lfd	fp13,_UC_FREGS+(13*8)(r31)
+	lfd	fp14,_UC_FREGS+(14*8)(r31)
+	lfd	fp15,_UC_FREGS+(15*8)(r31)
+	lfd	fp16,_UC_FREGS+(16*8)(r31)
+	lfd	fp17,_UC_FREGS+(17*8)(r31)
+	lfd	fp18,_UC_FREGS+(18*8)(r31)
+	lfd	fp19,_UC_FREGS+(19*8)(r31)
+	lfd	fp20,_UC_FREGS+(20*8)(r31)
+	lfd	fp21,_UC_FREGS+(21*8)(r31)
+	lfd	fp22,_UC_FREGS+(22*8)(r31)
+	lfd	fp23,_UC_FREGS+(23*8)(r31)
+	lfd	fp24,_UC_FREGS+(24*8)(r31)
+	lfd	fp25,_UC_FREGS+(25*8)(r31)
+	lfd	fp26,_UC_FREGS+(26*8)(r31)
+	lfd	fp27,_UC_FREGS+(27*8)(r31)
+	lfd	fp28,_UC_FREGS+(28*8)(r31)
+	lfd	fp29,_UC_FREGS+(29*8)(r31)
+	lfd	fp30,_UC_FREGS+(30*8)(r31)
+	lfd	fp31,_UC_FREGS+(31*8)(r31)
+
+	/* Restore LR and CCR, and set CTR to the NIP value */
+	lwz	r3,_UC_GREGS+(PT_LNK*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_NIP*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_CCR*4)(r31)
+	mtlr	r3
+	mtctr	r4
+	mtcr	r5
+
+	/* Restore the general registers */
+	lwz	r1,_UC_GREGS+(PT_R1*4)(r31)
+	lwz	r3,_UC_GREGS+(PT_R3*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_R4*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_R5*4)(r31)
+	lwz	r6,_UC_GREGS+(PT_R6*4)(r31)
+	lwz	r7,_UC_GREGS+(PT_R7*4)(r31)
+	lwz	r8,_UC_GREGS+(PT_R8*4)(r31)
+	lwz	r9,_UC_GREGS+(PT_R9*4)(r31)
+	lwz	r10,_UC_GREGS+(PT_R10*4)(r31)
+	lwz	r11,_UC_GREGS+(PT_R11*4)(r31)
+	lwz	r12,_UC_GREGS+(PT_R12*4)(r31)
+	lwz	r13,_UC_GREGS+(PT_R13*4)(r31)
+	lwz	r14,_UC_GREGS+(PT_R14*4)(r31)
+	lwz	r15,_UC_GREGS+(PT_R15*4)(r31)
+	lwz	r16,_UC_GREGS+(PT_R16*4)(r31)
+	lwz	r17,_UC_GREGS+(PT_R17*4)(r31)
+	lwz	r18,_UC_GREGS+(PT_R18*4)(r31)
+	lwz	r19,_UC_GREGS+(PT_R19*4)(r31)
+	lwz	r20,_UC_GREGS+(PT_R20*4)(r31)
+	lwz	r21,_UC_GREGS+(PT_R21*4)(r31)
+	lwz	r22,_UC_GREGS+(PT_R22*4)(r31)
+	lwz	r23,_UC_GREGS+(PT_R23*4)(r31)
+	lwz	r24,_UC_GREGS+(PT_R24*4)(r31)
+	lwz	r25,_UC_GREGS+(PT_R25*4)(r31)
+	lwz	r26,_UC_GREGS+(PT_R26*4)(r31)
+	lwz	r27,_UC_GREGS+(PT_R27*4)(r31)
+	lwz	r28,_UC_GREGS+(PT_R28*4)(r31)
+	lwz	r29,_UC_GREGS+(PT_R29*4)(r31)
+	lwz	r30,_UC_GREGS+(PT_R30*4)(r31)
+	lwz	r31,_UC_GREGS+(PT_R31*4)(r31)
+
+	bctr
+
+L(novec_error_exit):
+	lwz	r31,12(r1)
+	lwz	r0,20(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+
+L(novec_do_sigret):
+	addi	r1,r3,-0xd0
+	li	r0,SYS_ify(rt_sigreturn)
+	sc
+	/* NOTREACHED */
+
+END (__novec_setcontext)
+	.previous
+
+compat_symbol (libc, __novec_setcontext, setcontext, GLIBC_2_3_3)
+
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_3)
+
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+	compat_text_section
+ENTRY (__setcontext_stub)
+	li	r3,ENOSYS
+	b	JUMPTARGET(__syscall_error)
+END (__setcontext_stub)
+	.previous
+
+compat_symbol (libc, __setcontext_stub, setcontext, GLIBC_2_0)
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/socket.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/socket.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/socket.S	2003-07-12 00:46:12.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,7 +16,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 #define P(a, b) P2(a, b)
@@ -47,7 +47,9 @@
 
 	.text
 ENTRY(__socket)
+	cfi_startproc
 	stwu r1,-48(r1)
+	cfi_adjust_cfa_offset(48)
 #if NARGS >= 1
 	stw  r3,stackblock(r1)
 #endif
@@ -75,11 +77,43 @@
 #if NARGS >= 9
 #error too many arguments!
 #endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	bne-	.Lsocket_cancel
+#endif
+
 	li	r3,P(SOCKOP_,socket)
 	addi	r4,r1,stackblock
 	DO_CALL(SYS_ify(socketcall))
 	addi	r1,r1,48
 	PSEUDO_RET
+
+#if defined NEED_CANCELLATION && defined CENABLE
+.Lsocket_cancel:
+	mflr	r9
+	stw	r9,52(r1)
+	cfi_offset (lr, 4)
+	CENABLE
+	stw	r3,16(r1)
+	li	r3,P(SOCKOP_,socket)
+	addi	r4,r1,stackblock
+	DO_CALL(SYS_ify(socketcall))
+	mfcr	r0
+	stw	r3,8(r1)
+	stw	r0,12(r1)
+	lwz	r3,16(r1)
+	CDISABLE
+	lwz	r4,52(r1)
+	lwz	r0,12(r1)
+	lwz	r3,8(r1)
+	mtlr	r4
+	mtcr	r0
+	addi	r1,r1,48
+	PSEUDO_RET
+#endif
+	cfi_endproc
+
 PSEUDO_END (__socket)
 
 weak_alias (__socket, socket)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/swapcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/swapcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/swapcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/swapcontext.S	2004-09-02 20:59:02.000000000 +0200
@@ -0,0 +1,715 @@
+/* Save current context and jump to a new context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+
+	.machine	"altivec"
+ENTRY(__swapcontext)
+	stwu	r1,-16(r1)
+/* Insure that the _UC_REGS start on a quadword boundary.  */
+	stw	r3,_FRAME_PARM_SAVE1(r1)
+	addi	r3,r3,_UC_REG_SPACE+12
+	stw	r4,_FRAME_PARM_SAVE2(r1)	/* new context pointer */
+	clrrwi  r3,r3,4
+
+/* Save the general purpose registers */
+	stw	r0,_UC_GREGS+(PT_R0*4)(r3)
+	mflr	r0
+	stw	r2,_UC_GREGS+(PT_R2*4)(r3)
+	stw	r4,_UC_GREGS+(PT_R4*4)(r3)			
+/* Set the callers LR_SAVE, and the ucontext LR and NIP to the callers
+   return address.  */
+	stw	r0,_UC_GREGS+(PT_LNK*4)(r3)
+	stw	r0,_UC_GREGS+(PT_NIP*4)(r3)
+	stw	r0,_FRAME_LR_SAVE+16(r1)
+	stw	r5,_UC_GREGS+(PT_R5*4)(r3)
+	stw	r6,_UC_GREGS+(PT_R6*4)(r3)
+	stw	r7,_UC_GREGS+(PT_R7*4)(r3)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r3)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r3)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r3)
+	stw	r11,_UC_GREGS+(PT_R11*4)(r3)
+	stw	r12,_UC_GREGS+(PT_R12*4)(r3)
+	stw	r13,_UC_GREGS+(PT_R13*4)(r3)
+	stw	r14,_UC_GREGS+(PT_R14*4)(r3)
+	stw	r15,_UC_GREGS+(PT_R15*4)(r3)
+	stw	r16,_UC_GREGS+(PT_R16*4)(r3)
+	stw	r17,_UC_GREGS+(PT_R17*4)(r3)
+	stw	r18,_UC_GREGS+(PT_R18*4)(r3)
+	stw	r19,_UC_GREGS+(PT_R19*4)(r3)
+	stw	r20,_UC_GREGS+(PT_R20*4)(r3)
+	stw	r21,_UC_GREGS+(PT_R21*4)(r3)
+	stw	r22,_UC_GREGS+(PT_R22*4)(r3)
+	stw	r23,_UC_GREGS+(PT_R23*4)(r3)
+	stw	r24,_UC_GREGS+(PT_R24*4)(r3)
+	stw	r25,_UC_GREGS+(PT_R25*4)(r3)
+	stw	r26,_UC_GREGS+(PT_R26*4)(r3)
+	stw	r27,_UC_GREGS+(PT_R27*4)(r3)
+	stw	r28,_UC_GREGS+(PT_R28*4)(r3)
+	stw	r29,_UC_GREGS+(PT_R29*4)(r3)
+	stw	r30,_UC_GREGS+(PT_R30*4)(r3)
+	stw	r31,_UC_GREGS+(PT_R31*4)(r3)
+	
+/* Save the value of R1.  We had to push the stack before we
+   had the address of uc_reg_space.  So compute the address of
+   the callers stack pointer and save it as R1.  */
+	addi	r8,r1,16
+	li	r0,0
+/* Save the count, exception and condition registers.  */
+	mfctr	r11
+	mfxer	r10
+	mfcr	r9
+	stw	r8,_UC_GREGS+(PT_R1*4)(r3)
+	stw	r11,_UC_GREGS+(PT_CTR*4)(r3)
+	stw	r10,_UC_GREGS+(PT_XER*4)(r3)
+	stw	r9,_UC_GREGS+(PT_CCR*4)(r3)
+/* Set the return value of getcontext to "success".  R3 is the only
+   register whose value is not preserved in the saved context.  */
+	stw	r0,_UC_GREGS+(PT_R3*4)(r3)
+
+	/* Zero fill fields that can't be set in user state. */
+	stw	r0,_UC_GREGS+(PT_MSR*4)(r3)
+	stw	r0,_UC_GREGS+(PT_MQ*4)(r3)
+
+	/* Save the floating-point registers */
+	stfd	fp0,_UC_FREGS+(0*8)(r3)
+	stfd	fp1,_UC_FREGS+(1*8)(r3)
+	stfd	fp2,_UC_FREGS+(2*8)(r3)
+	stfd	fp3,_UC_FREGS+(3*8)(r3)
+	stfd	fp4,_UC_FREGS+(4*8)(r3)
+	stfd	fp5,_UC_FREGS+(5*8)(r3)
+	stfd	fp6,_UC_FREGS+(6*8)(r3)
+	stfd	fp7,_UC_FREGS+(7*8)(r3)
+	stfd	fp8,_UC_FREGS+(8*8)(r3)
+	stfd	fp9,_UC_FREGS+(9*8)(r3)
+	stfd	fp10,_UC_FREGS+(10*8)(r3)
+	stfd	fp11,_UC_FREGS+(11*8)(r3)
+	stfd	fp12,_UC_FREGS+(12*8)(r3)
+	stfd	fp13,_UC_FREGS+(13*8)(r3)
+	stfd	fp14,_UC_FREGS+(14*8)(r3)
+	stfd	fp15,_UC_FREGS+(15*8)(r3)
+	stfd	fp16,_UC_FREGS+(16*8)(r3)
+	stfd	fp17,_UC_FREGS+(17*8)(r3)
+	stfd	fp18,_UC_FREGS+(18*8)(r3)
+	stfd	fp19,_UC_FREGS+(19*8)(r3)
+	stfd	fp20,_UC_FREGS+(20*8)(r3)
+	stfd	fp21,_UC_FREGS+(21*8)(r3)
+	stfd	fp22,_UC_FREGS+(22*8)(r3)
+	stfd	fp23,_UC_FREGS+(23*8)(r3)
+	stfd	fp24,_UC_FREGS+(24*8)(r3)
+	stfd	fp25,_UC_FREGS+(25*8)(r3)
+	stfd	fp26,_UC_FREGS+(26*8)(r3)
+	stfd	fp27,_UC_FREGS+(27*8)(r3)
+	stfd	fp28,_UC_FREGS+(28*8)(r3)
+	stfd	fp29,_UC_FREGS+(29*8)(r3)
+	mffs	fp0
+	stfd	fp30,_UC_FREGS+(30*8)(r3)
+	stfd	fp31,_UC_FREGS+(31*8)(r3)
+	stfd	fp0,_UC_FREGS+(32*8)(r3)
+#ifdef PIC
+	mflr    r8
+	bl      _GLOBAL_OFFSET_TABLE_@local-4
+	mflr    r7
+# ifdef SHARED
+	lwz     r7,_rtld_global_ro@got(r7)
+	mtlr    r8
+	lwz     r7,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r7)
+# else
+	lwz     r7,_dl_hwcap@got(r7)
+	mtlr    r8
+	lwz     r7,0(r7)
+# endif
+#else
+	lis	r7,_dl_hwcap@ha
+	lwz     r7,_dl_hwcap@l(r7)
+#endif
+	andis.	r7,r7,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+
+	la	r10,(_UC_VREGS)(r3)
+	la	r9,(_UC_VREGS+16)(r3)
+	
+	beq	L(no_vec)
+/* address of the combined VSCR/VSAVE quadword.  */	
+	la	r8,(_UC_VREGS+512)(r3)
+
+/* Save the vector registers */
+	stvx  v0,0,r10
+	stvx  v1,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+/* We need to get the Vector Status and Control Register early to avoid
+   store order problems later with the VSAVE register that shares the
+   same quadword.  */
+	mfvscr	v0
+
+	stvx  v2,0,r10
+	stvx  v3,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+	
+	stvx	v0,0,r8
+
+	stvx  v4,0,r10
+	stvx  v5,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v6,0,r10
+	stvx  v7,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v8,0,r10
+	stvx  v9,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v10,0,r10
+	stvx  v11,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v12,0,r10
+	stvx  v13,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v14,0,r10
+	stvx  v15,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v16,0,r10
+	stvx  v17,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v18,0,r10
+	stvx  v19,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v20,0,r10
+	stvx  v21,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v22,0,r10
+	stvx  v23,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v24,0,r10
+	stvx  v25,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v26,0,r10
+	stvx  v27,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	stvx  v28,0,r10
+	stvx  v29,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	mfvscr	v0
+	stvx  v30,0,r10
+	stvx  v31,0,r9
+
+ 	stw	r0,0(r8)
+
+L(no_vec):
+/* Restore ucontext (parm1) from stack.  */
+	lwz	r12,_FRAME_PARM_SAVE1(r1)
+	li	r4,0
+	stw	r3,_UC_REGS_PTR(r12)
+	addi	r5,r12,_UC_SIGMASK
+	li	r3,SIG_SETMASK
+	bl	JUMPTARGET(__sigprocmask)
+	cmpwi	r3,0
+	bne	L(error_exit)
+
+	/*
+	 * If the new ucontext refers to the point where we were interrupted
+	 * by a signal, we have to use the rt_sigreturn system call to
+	 * return to the context so we get both LR and CTR restored.
+	 *
+	 * Otherwise, the context we are restoring is either just after
+	 * a procedure call (getcontext/swapcontext) or at the beginning
+	 * of a procedure call (makecontext), so we don't need to restore
+	 * r0, xer, ctr.  We don't restore r2 since it will be used as
+	 * the TLS pointer.
+	 */
+	lwz	r4,_FRAME_PARM_SAVE2(r1)
+	lwz	r31,_UC_REGS_PTR(r4)
+	lwz	r0,_UC_GREGS+(PT_MSR*4)(r31)
+	cmpwi	r0,0
+	bne	L(do_sigret)
+
+#ifdef PIC
+	mflr    r8
+	bl      _GLOBAL_OFFSET_TABLE_@local-4
+	mflr    r7
+# ifdef SHARED
+	lwz     r7,_rtld_global_ro@got(r7)
+	mtlr    r8
+	lwz     r7,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r7)
+# else
+	lwz     r7,_dl_hwcap@got(r7)
+	mtlr    r8
+	lwz     r7,0(r7)
+# endif
+#else
+	lis	r7,_dl_hwcap@ha
+	lwz     r7,_dl_hwcap@l(r7)
+#endif
+	andis.	r7,r7,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+	la	r10,(_UC_VREGS)(r31)
+	beq	L(has_no_vec)
+
+	lwz   r0,(32*16)(r10)
+	li    r9,(32*16)
+	cmpwi r0,0
+	mtspr VRSAVE,r0
+	beq   L(has_no_vec)
+
+	lvx   v19,r9,r10
+	la    r9,(16)(r10)
+
+	lvx   v0,0,r10
+	lvx   v1,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	mtvscr  v19
+	lvx   v2,0,r10
+	lvx   v3,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v4,0,r10
+	lvx   v5,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v6,0,r10
+	lvx   v7,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v8,0,r10
+	lvx   v9,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v10,0,r10
+	lvx   v11,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v12,0,r10
+	lvx   v13,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v14,0,r10
+	lvx   v15,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v16,0,r10
+	lvx   v17,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v18,0,r10
+	lvx   v19,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v20,0,r10
+	lvx   v21,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v22,0,r10
+	lvx   v23,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v24,0,r10
+	lvx   v25,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v26,0,r10
+	lvx   v27,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v28,0,r10
+	lvx   v29,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v30,0,r10
+	lvx   v31,0,r9
+	addi  r10,r10,32
+	addi  r9,r9,32
+
+	lvx   v10,0,r10
+	lvx   v11,0,r9
+
+L(has_no_vec):
+	/* Restore the floating-point registers */
+	lfd	fp31,_UC_FREGS+(32*8)(r31)
+	lfd	fp0,_UC_FREGS+(0*8)(r31)
+	mtfsf	0xff,fp31
+	lfd	fp1,_UC_FREGS+(1*8)(r31)
+	lfd	fp2,_UC_FREGS+(2*8)(r31)
+	lfd	fp3,_UC_FREGS+(3*8)(r31)
+	lfd	fp4,_UC_FREGS+(4*8)(r31)
+	lfd	fp5,_UC_FREGS+(5*8)(r31)
+	lfd	fp6,_UC_FREGS+(6*8)(r31)
+	lfd	fp7,_UC_FREGS+(7*8)(r31)
+	lfd	fp8,_UC_FREGS+(8*8)(r31)
+	lfd	fp9,_UC_FREGS+(9*8)(r31)
+	lfd	fp10,_UC_FREGS+(10*8)(r31)
+	lfd	fp11,_UC_FREGS+(11*8)(r31)
+	lfd	fp12,_UC_FREGS+(12*8)(r31)
+	lfd	fp13,_UC_FREGS+(13*8)(r31)
+	lfd	fp14,_UC_FREGS+(14*8)(r31)
+	lfd	fp15,_UC_FREGS+(15*8)(r31)
+	lfd	fp16,_UC_FREGS+(16*8)(r31)
+	lfd	fp17,_UC_FREGS+(17*8)(r31)
+	lfd	fp18,_UC_FREGS+(18*8)(r31)
+	lfd	fp19,_UC_FREGS+(19*8)(r31)
+	lfd	fp20,_UC_FREGS+(20*8)(r31)
+	lfd	fp21,_UC_FREGS+(21*8)(r31)
+	lfd	fp22,_UC_FREGS+(22*8)(r31)
+	lfd	fp23,_UC_FREGS+(23*8)(r31)
+	lfd	fp24,_UC_FREGS+(24*8)(r31)
+	lfd	fp25,_UC_FREGS+(25*8)(r31)
+	lfd	fp26,_UC_FREGS+(26*8)(r31)
+	lfd	fp27,_UC_FREGS+(27*8)(r31)
+	lfd	fp28,_UC_FREGS+(28*8)(r31)
+	lfd	fp29,_UC_FREGS+(29*8)(r31)
+	lfd	fp30,_UC_FREGS+(30*8)(r31)
+	lfd	fp31,_UC_FREGS+(31*8)(r31)
+
+	/* Restore LR and CCR, and set CTR to the NIP value */
+	lwz	r3,_UC_GREGS+(PT_LNK*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_NIP*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_CCR*4)(r31)
+	mtlr	r3
+	mtctr	r4
+	mtcr	r5
+
+	/* Restore the general registers */
+	lwz	r1,_UC_GREGS+(PT_R1*4)(r31)
+	lwz	r3,_UC_GREGS+(PT_R3*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_R4*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_R5*4)(r31)
+	lwz	r6,_UC_GREGS+(PT_R6*4)(r31)
+	lwz	r7,_UC_GREGS+(PT_R7*4)(r31)
+	lwz	r8,_UC_GREGS+(PT_R8*4)(r31)
+	lwz	r9,_UC_GREGS+(PT_R9*4)(r31)
+	lwz	r10,_UC_GREGS+(PT_R10*4)(r31)
+	lwz	r11,_UC_GREGS+(PT_R11*4)(r31)
+	lwz	r12,_UC_GREGS+(PT_R12*4)(r31)
+	lwz	r13,_UC_GREGS+(PT_R13*4)(r31)
+	lwz	r14,_UC_GREGS+(PT_R14*4)(r31)
+	lwz	r15,_UC_GREGS+(PT_R15*4)(r31)
+	lwz	r16,_UC_GREGS+(PT_R16*4)(r31)
+	lwz	r17,_UC_GREGS+(PT_R17*4)(r31)
+	lwz	r18,_UC_GREGS+(PT_R18*4)(r31)
+	lwz	r19,_UC_GREGS+(PT_R19*4)(r31)
+	lwz	r20,_UC_GREGS+(PT_R20*4)(r31)
+	lwz	r21,_UC_GREGS+(PT_R21*4)(r31)
+	lwz	r22,_UC_GREGS+(PT_R22*4)(r31)
+	lwz	r23,_UC_GREGS+(PT_R23*4)(r31)
+	lwz	r24,_UC_GREGS+(PT_R24*4)(r31)
+	lwz	r25,_UC_GREGS+(PT_R25*4)(r31)
+	lwz	r26,_UC_GREGS+(PT_R26*4)(r31)
+	lwz	r27,_UC_GREGS+(PT_R27*4)(r31)
+	lwz	r28,_UC_GREGS+(PT_R28*4)(r31)
+	lwz	r29,_UC_GREGS+(PT_R29*4)(r31)
+	lwz	r30,_UC_GREGS+(PT_R30*4)(r31)
+	lwz	r31,_UC_GREGS+(PT_R31*4)(r31)
+
+	bctr
+
+L(error_exit):
+	lwz	r0,_FRAME_LR_SAVE+16(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+
+L(do_sigret):
+	addi	r1,r4,-0xd0
+	li	r0,SYS_ify(rt_sigreturn)
+	sc
+	/* NOTREACHED */
+
+END(__swapcontext)
+
+versioned_symbol (libc, __swapcontext, swapcontext, GLIBC_2_3_4)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+
+	compat_text_section
+ENTRY(__novec_swapcontext)
+	/* Save the current context */
+	addi	r3,r3,_UC_REG_SPACE
+	stw	r3,_UC_REGS_PTR - _UC_REG_SPACE(r3)
+	stw	r0,_UC_GREGS+(PT_R0*4)(r3)
+	stw	r1,_UC_GREGS+(PT_R1*4)(r3)
+	mflr	r0
+	stwu	r1,-16(r1)
+	stw	r0,20(r1)
+	stw	r31,12(r1)
+	stw	r31,_UC_GREGS+(PT_R31*4)(r3)
+	mr	r31,r4			/* new context pointer */
+	stw	r0,_UC_GREGS+(PT_LNK*4)(r3)
+	stw	r0,_UC_GREGS+(PT_NIP*4)(r3)
+	stw	r2,_UC_GREGS+(PT_R2*4)(r3)
+	stw	r4,_UC_GREGS+(PT_R4*4)(r3)
+	stw	r5,_UC_GREGS+(PT_R5*4)(r3)
+	stw	r6,_UC_GREGS+(PT_R6*4)(r3)
+	stw	r7,_UC_GREGS+(PT_R7*4)(r3)
+	stw	r8,_UC_GREGS+(PT_R8*4)(r3)
+	stw	r9,_UC_GREGS+(PT_R9*4)(r3)
+	stw	r10,_UC_GREGS+(PT_R10*4)(r3)
+	stw	r11,_UC_GREGS+(PT_R11*4)(r3)
+	stw	r12,_UC_GREGS+(PT_R12*4)(r3)
+	stw	r13,_UC_GREGS+(PT_R13*4)(r3)
+	stw	r14,_UC_GREGS+(PT_R14*4)(r3)
+	stw	r15,_UC_GREGS+(PT_R15*4)(r3)
+	stw	r16,_UC_GREGS+(PT_R16*4)(r3)
+	stw	r17,_UC_GREGS+(PT_R17*4)(r3)
+	stw	r18,_UC_GREGS+(PT_R18*4)(r3)
+	stw	r19,_UC_GREGS+(PT_R19*4)(r3)
+	stw	r20,_UC_GREGS+(PT_R20*4)(r3)
+	stw	r21,_UC_GREGS+(PT_R21*4)(r3)
+	stw	r22,_UC_GREGS+(PT_R22*4)(r3)
+	stw	r23,_UC_GREGS+(PT_R23*4)(r3)
+	stw	r24,_UC_GREGS+(PT_R24*4)(r3)
+	stw	r25,_UC_GREGS+(PT_R25*4)(r3)
+	stw	r26,_UC_GREGS+(PT_R26*4)(r3)
+	stw	r27,_UC_GREGS+(PT_R27*4)(r3)
+	stw	r28,_UC_GREGS+(PT_R28*4)(r3)
+	stw	r29,_UC_GREGS+(PT_R29*4)(r3)
+	stw	r30,_UC_GREGS+(PT_R30*4)(r3)
+	mfctr	r0
+	stw	r0,_UC_GREGS+(PT_CTR*4)(r3)
+	mfxer	r0
+	stw	r0,_UC_GREGS+(PT_XER*4)(r3)
+	mfcr	r0
+	stw	r0,_UC_GREGS+(PT_CCR*4)(r3)
+
+	/* Set the return value of swapcontext to "success".  R3 is the only
+	   register whose value is not preserved in the saved context.  */
+	li	r0,0
+	stw	r0,_UC_GREGS+(PT_R3*4)(r3)
+
+	/* Zero fill fields that can't be set in user state. */
+	stw	r0,_UC_GREGS+(PT_MSR*4)(r3)
+	stw	r0,_UC_GREGS+(PT_MQ*4)(r3)
+
+	/* Save the floating-point registers */
+	stfd	fp0,_UC_FREGS+(0*8)(r3)
+	stfd	fp1,_UC_FREGS+(1*8)(r3)
+	stfd	fp2,_UC_FREGS+(2*8)(r3)
+	stfd	fp3,_UC_FREGS+(3*8)(r3)
+	stfd	fp4,_UC_FREGS+(4*8)(r3)
+	stfd	fp5,_UC_FREGS+(5*8)(r3)
+	stfd	fp6,_UC_FREGS+(6*8)(r3)
+	stfd	fp7,_UC_FREGS+(7*8)(r3)
+	stfd	fp8,_UC_FREGS+(8*8)(r3)
+	stfd	fp9,_UC_FREGS+(9*8)(r3)
+	stfd	fp10,_UC_FREGS+(10*8)(r3)
+	stfd	fp11,_UC_FREGS+(11*8)(r3)
+	stfd	fp12,_UC_FREGS+(12*8)(r3)
+	stfd	fp13,_UC_FREGS+(13*8)(r3)
+	stfd	fp14,_UC_FREGS+(14*8)(r3)
+	stfd	fp15,_UC_FREGS+(15*8)(r3)
+	stfd	fp16,_UC_FREGS+(16*8)(r3)
+	stfd	fp17,_UC_FREGS+(17*8)(r3)
+	stfd	fp18,_UC_FREGS+(18*8)(r3)
+	stfd	fp19,_UC_FREGS+(19*8)(r3)
+	stfd	fp20,_UC_FREGS+(20*8)(r3)
+	stfd	fp21,_UC_FREGS+(21*8)(r3)
+	stfd	fp22,_UC_FREGS+(22*8)(r3)
+	stfd	fp23,_UC_FREGS+(23*8)(r3)
+	stfd	fp24,_UC_FREGS+(24*8)(r3)
+	stfd	fp25,_UC_FREGS+(25*8)(r3)
+	stfd	fp26,_UC_FREGS+(26*8)(r3)
+	stfd	fp27,_UC_FREGS+(27*8)(r3)
+	stfd	fp28,_UC_FREGS+(28*8)(r3)
+	stfd	fp29,_UC_FREGS+(29*8)(r3)
+	mffs	fp0
+	stfd	fp30,_UC_FREGS+(30*8)(r3)
+	stfd	fp31,_UC_FREGS+(31*8)(r3)
+	stfd	fp0,_UC_FREGS+(32*8)(r3)
+
+	addi	r5,r3,_UC_SIGMASK - _UC_REG_SPACE
+	addi	r4,r4,_UC_SIGMASK
+	li	r3,SIG_SETMASK
+	bl	JUMPTARGET(__sigprocmask)
+	cmpwi	r3,0
+	bne	L(novec_error_exit)
+
+	/*
+	 * If the new ucontext refers to the point where we were interrupted
+	 * by a signal, we have to use the rt_sigreturn system call to
+	 * return to the context so we get both LR and CTR restored.
+	 *
+	 * Otherwise, the context we are restoring is either just after
+	 * a procedure call (getcontext/swapcontext) or at the beginning
+	 * of a procedure call (makecontext), so we don't need to restore
+	 * r0, xer, ctr.  We don't restore r2 since it will be used as
+	 * the TLS pointer.
+	 */
+	mr	r4,r31
+	lwz	r31,_UC_REGS_PTR(r31)
+	lwz	r0,_UC_GREGS+(PT_MSR*4)(r31)
+	cmpwi	r0,0
+	bne	L(novec_do_sigret)
+
+	/* Restore the floating-point registers */
+	lfd	fp31,_UC_FREGS+(32*8)(r31)
+	lfd	fp0,_UC_FREGS+(0*8)(r31)
+	mtfsf	0xff,fp31
+	lfd	fp1,_UC_FREGS+(1*8)(r31)
+	lfd	fp2,_UC_FREGS+(2*8)(r31)
+	lfd	fp3,_UC_FREGS+(3*8)(r31)
+	lfd	fp4,_UC_FREGS+(4*8)(r31)
+	lfd	fp5,_UC_FREGS+(5*8)(r31)
+	lfd	fp6,_UC_FREGS+(6*8)(r31)
+	lfd	fp7,_UC_FREGS+(7*8)(r31)
+	lfd	fp8,_UC_FREGS+(8*8)(r31)
+	lfd	fp9,_UC_FREGS+(9*8)(r31)
+	lfd	fp10,_UC_FREGS+(10*8)(r31)
+	lfd	fp11,_UC_FREGS+(11*8)(r31)
+	lfd	fp12,_UC_FREGS+(12*8)(r31)
+	lfd	fp13,_UC_FREGS+(13*8)(r31)
+	lfd	fp14,_UC_FREGS+(14*8)(r31)
+	lfd	fp15,_UC_FREGS+(15*8)(r31)
+	lfd	fp16,_UC_FREGS+(16*8)(r31)
+	lfd	fp17,_UC_FREGS+(17*8)(r31)
+	lfd	fp18,_UC_FREGS+(18*8)(r31)
+	lfd	fp19,_UC_FREGS+(19*8)(r31)
+	lfd	fp20,_UC_FREGS+(20*8)(r31)
+	lfd	fp21,_UC_FREGS+(21*8)(r31)
+	lfd	fp22,_UC_FREGS+(22*8)(r31)
+	lfd	fp23,_UC_FREGS+(23*8)(r31)
+	lfd	fp24,_UC_FREGS+(24*8)(r31)
+	lfd	fp25,_UC_FREGS+(25*8)(r31)
+	lfd	fp26,_UC_FREGS+(26*8)(r31)
+	lfd	fp27,_UC_FREGS+(27*8)(r31)
+	lfd	fp28,_UC_FREGS+(28*8)(r31)
+	lfd	fp29,_UC_FREGS+(29*8)(r31)
+	lfd	fp30,_UC_FREGS+(30*8)(r31)
+	lfd	fp31,_UC_FREGS+(31*8)(r31)
+
+	/* Restore LR and CCR, and set CTR to the NIP value */
+	lwz	r3,_UC_GREGS+(PT_LNK*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_NIP*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_CCR*4)(r31)
+	mtlr	r3
+	mtctr	r4
+	mtcr	r5
+
+	/* Restore the general registers */
+	lwz	r1,_UC_GREGS+(PT_R1*4)(r31)
+	lwz	r3,_UC_GREGS+(PT_R3*4)(r31)
+	lwz	r4,_UC_GREGS+(PT_R4*4)(r31)
+	lwz	r5,_UC_GREGS+(PT_R5*4)(r31)
+	lwz	r6,_UC_GREGS+(PT_R6*4)(r31)
+	lwz	r7,_UC_GREGS+(PT_R7*4)(r31)
+	lwz	r8,_UC_GREGS+(PT_R8*4)(r31)
+	lwz	r9,_UC_GREGS+(PT_R9*4)(r31)
+	lwz	r10,_UC_GREGS+(PT_R10*4)(r31)
+	lwz	r11,_UC_GREGS+(PT_R11*4)(r31)
+	lwz	r12,_UC_GREGS+(PT_R12*4)(r31)
+	lwz	r13,_UC_GREGS+(PT_R13*4)(r31)
+	lwz	r14,_UC_GREGS+(PT_R14*4)(r31)
+	lwz	r15,_UC_GREGS+(PT_R15*4)(r31)
+	lwz	r16,_UC_GREGS+(PT_R16*4)(r31)
+	lwz	r17,_UC_GREGS+(PT_R17*4)(r31)
+	lwz	r18,_UC_GREGS+(PT_R18*4)(r31)
+	lwz	r19,_UC_GREGS+(PT_R19*4)(r31)
+	lwz	r20,_UC_GREGS+(PT_R20*4)(r31)
+	lwz	r21,_UC_GREGS+(PT_R21*4)(r31)
+	lwz	r22,_UC_GREGS+(PT_R22*4)(r31)
+	lwz	r23,_UC_GREGS+(PT_R23*4)(r31)
+	lwz	r24,_UC_GREGS+(PT_R24*4)(r31)
+	lwz	r25,_UC_GREGS+(PT_R25*4)(r31)
+	lwz	r26,_UC_GREGS+(PT_R26*4)(r31)
+	lwz	r27,_UC_GREGS+(PT_R27*4)(r31)
+	lwz	r28,_UC_GREGS+(PT_R28*4)(r31)
+	lwz	r29,_UC_GREGS+(PT_R29*4)(r31)
+	lwz	r30,_UC_GREGS+(PT_R30*4)(r31)
+	lwz	r31,_UC_GREGS+(PT_R31*4)(r31)
+
+	bctr
+
+L(novec_error_exit):
+	lwz	r31,12(r1)
+	lwz	r0,20(r1)
+	addi	r1,r1,16
+	mtlr	r0
+	blr
+
+L(novec_do_sigret):
+	addi	r1,r4,-0xd0
+	li	r0,SYS_ify(rt_sigreturn)
+	sc
+	/* NOTREACHED */
+
+END(__novec_swapcontext)
+	.previous
+
+compat_symbol (libc, __novec_swapcontext, swapcontext, GLIBC_2_3_3)
+
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_3_3)
+
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+	compat_text_section
+ENTRY (__swapcontext_stub)
+	li	r3,ENOSYS
+	b	JUMPTARGET(__syscall_error)
+END (__swapcontext_stub)
+	.previous
+
+compat_symbol (libc, __swapcontext_stub, swapcontext, GLIBC_2_1)
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/syscalls.list
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/syscalls.list	2002-05-30 19:54:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/syscalls.list	2003-09-03 05:17:22.000000000 +0200
@@ -1,54 +1,5 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
 # System calls with wrappers.
-s_ioctl		ioctl	ioctl		i:iiI	__syscall_ioctl
-s_ipc		msgget	ipc		i:iiiip	__syscall_ipc
-s_llseek	llseek	_llseek		i:iiipi	__syscall__llseek
-s_readahead	readahead readahead	i:iiii	__syscall_readahead
-s_chown		chown	chown		i:sii	__syscall_chown
-s_execve	execve	execve		i:spp	__syscall_execve
-rt_sigaction	-	rt_sigaction	i:ippi	__syscall_rt_sigaction
-rt_sigpending	-	rt_sigpending	i:pi	__syscall_rt_sigpending
-rt_sigprocmask	-	rt_sigprocmask	i:ippi	__syscall_rt_sigprocmask
-rt_sigqueueinfo	-	rt_sigqueueinfo	i:iip	__syscall_rt_sigqueueinfo
-rt_sigsuspend	-	rt_sigsuspend	i:pi	__syscall_rt_sigsuspend
-rt_sigtimedwait	-	rt_sigtimedwait	i:pppi	__syscall_rt_sigtimedwait
-s_fcntl		fcntl 	fcntl		i:iiF	__syscall_fcntl
-s_fcntl64	fcntl64	fcntl64		i:iiF	__syscall_fcntl64
-s_fstat64	fxstat64 fstat64	i:ip	__syscall_fstat64
-s_ftruncate64	ftruncate64 ftruncate64	i:iii	__syscall_ftruncate64
-s_getcwd	getcwd	getcwd		i:pi	__syscall_getcwd
-s_getdents	getdents getdents	i:ipi	__syscall_getdents
-s_getdents64	getdents getdents64	i:ipi	__syscall_getdents64
-s_getpmsg	getpmsg	getpmsg		i:ipppp	__syscall_getpmsg
-s_getpriority	getpriority getpriority	i:ii	__syscall_getpriority
-getresgid	-	getresgid	i:ppp	getresgid
-getresuid	-	getresuid	i:ppp	getresuid
-s_getrlimit	getrlimit getrlimit	i:ip	__syscall_getrlimit
-s_lstat64	lxstat64 lstat64	i:sp	__syscall_lstat64
-s_mmap2		mmap64	mmap2		b:aniiii __syscall_mmap2
-s_poll		poll	poll		i:pii	__syscall_poll
-s_pread64	pread64	pread		i:ibnii	__syscall_pread
-s_ptrace	ptrace	ptrace		i:iipp	__syscall_ptrace
-s_putpmsg	putpmsg	putpmsg		i:ippii	__syscall_putpmsg
-s_pwrite64	pwrite64 pwrite		i:ibnii	__syscall_pwrite
-s_reboot	reboot	reboot		i:iii	__syscall_reboot
-s_setrlimit	setrlimit setrlimit	i:ip	__syscall_setrlimit
-s_sigaction	sigaction sigaction	i:ipp	__syscall_sigaction
-s_sigpending	sigpending sigpending	i:p	__syscall_sigpending
-s_sigprocmask	sigprocmask sigprocmask	i:ipp	__syscall_sigprocmask
-s_sigsuspend	sigsuspend sigsuspend	i:iii	__syscall_sigsuspend
-s_stat64	xstat64 stat64		i:sp	__syscall_stat64
-s_sysctl	sysctl	_sysctl		i:p	__syscall__sysctl
-s_truncate64	truncate64 truncate64	i:sii	__syscall_truncate64
-s_ugetrlimit	getrlimit ugetrlimit	i:ip	__syscall_ugetrlimit
-s_ustat		ustat	ustat		i:ip	__syscall_ustat
-s_vfork		vfork	vfork		i:	__syscall_vfork
-sys_fstat	fxstat	fstat		i:ip	__syscall_fstat
-sys_lstat	lxstat	lstat		i:sp	__syscall_lstat
-sys_mknod	xmknod	mknod		i:pii	__syscall_mknod
-sys_readv	readv	readv		i:ipi	__syscall_readv
-sys_stat	xstat	stat		i:sp	__syscall_stat
-sys_writev	writev	writev		i:ipi	__syscall_writev
 oldgetrlimit	EXTRA	getrlimit	i:ip	__old_getrlimit	getrlimit@GLIBC_2.0
 oldsetrlimit	EXTRA	setrlimit	i:ip	__old_setrlimit	setrlimit@GLIBC_2.0
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep.h
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep.h	2002-09-29 19:46:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep.h	2004-09-20 01:46:31.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992,97,98,99,2000,01,02 Free Software Foundation, Inc.
+/* Copyright (C) 1992,1997-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,24 @@
 
 #include <sysdeps/unix/powerpc/sysdep.h>
 
+/* Some systen calls got renamed over time, but retained the same semantics.
+   Handle them here so they can be catched by both C and assembler stubs in
+   glibc.  */
+
+#ifdef __NR_pread64
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#ifdef __NR_pwrite64
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
    of the kernel.  But these symbols do not follow the SYS_* syntax
@@ -37,54 +55,119 @@
 # include <errno.h>
 
 # undef INLINE_SYSCALL
-# define INLINE_SYSCALL(name, nr, args...)	\
-  ({						\
-    long ret, err;				\
-    LOADARGS_##nr(name, args);			\
-    __asm __volatile ("sc\n\t"			\
-		      "mfcr	%1\n\t"		\
-		      : "=r" (r3), "=r" (err)	\
-		      : ASM_INPUT_##nr		\
-		      : "cc", "memory");	\
-    ret = r3;					\
-    if (err & 1 << 28)				\
-      {						\
-	__set_errno (ret);			\
-	ret = -1L;				\
-      }						\
-    ret;					\
+# define INLINE_SYSCALL(name, nr, args...)				\
+  ({									\
+    INTERNAL_SYSCALL_DECL (sc_err);					\
+    long int sc_ret = INTERNAL_SYSCALL (name, sc_err, nr, args);	\
+    if (INTERNAL_SYSCALL_ERROR_P (sc_ret, sc_err))			\
+      {									\
+	__set_errno (INTERNAL_SYSCALL_ERRNO (sc_ret, sc_err));		\
+	sc_ret = -1L;							\
+      }									\
+    sc_ret;								\
+  })
+
+/* Define a macro which expands inline into the wrapper code for a system
+   call. This use is for internal calls that do not need to handle errors
+   normally. It will never touch errno.
+   On powerpc a system call basically clobbers the same registers like a
+   function call, with the exception of LR (which is needed for the
+   "sc; bnslr+" sequence) and CR (where only CR0.SO is clobbered to signal
+   an error return status).  */
+
+# undef INTERNAL_SYSCALL_DECL
+# define INTERNAL_SYSCALL_DECL(err) long int err
+
+# undef INTERNAL_SYSCALL
+# define INTERNAL_SYSCALL_NCS(name, err, nr, args...)			\
+  ({									\
+    register long int r0  __asm__ ("r0");				\
+    register long int r3  __asm__ ("r3");				\
+    register long int r4  __asm__ ("r4");				\
+    register long int r5  __asm__ ("r5");				\
+    register long int r6  __asm__ ("r6");				\
+    register long int r7  __asm__ ("r7");				\
+    register long int r8  __asm__ ("r8");				\
+    register long int r9  __asm__ ("r9");				\
+    register long int r10 __asm__ ("r10");				\
+    register long int r11 __asm__ ("r11");				\
+    register long int r12 __asm__ ("r12");				\
+    LOADARGS_##nr(name, args);						\
+    __asm__ __volatile__						\
+      ("sc   \n\t"							\
+       "mfcr %0"							\
+       : "=&r" (r0),							\
+	 "=&r" (r3), "=&r" (r4), "=&r" (r5),  "=&r" (r6),  "=&r" (r7),	\
+	 "=&r" (r8), "=&r" (r9), "=&r" (r10), "=&r" (r11), "=&r" (r12)	\
+       : ASM_INPUT_##nr							\
+       : "cr0", "ctr", "memory");					\
+    err = r0;								\
+    (int) r3;								\
   })
+# define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_NCS (__NR_##name, err, nr, ##args)
 
-# define LOADARGS_0(name) \
-	register long r0 __asm__ ("r0") = __NR_##name; \
-	register long r3 __asm__ ("r3")
-# define LOADARGS_1(name, arg1) \
-	LOADARGS_0(name) = (long) (arg1)
-# define LOADARGS_2(name, arg1, arg2) \
-	LOADARGS_1(name, arg1); \
-	register long r4 __asm__ ("r4") = (long) (arg2)
-# define LOADARGS_3(name, arg1, arg2, arg3) \
-	LOADARGS_2(name, arg1, arg2); \
-	register long r5 __asm__ ("r5") = (long) (arg3)
-# define LOADARGS_4(name, arg1, arg2, arg3, arg4) \
-	LOADARGS_3(name, arg1, arg2, arg3); \
-	register long r6 __asm__ ("r6") = (long) (arg4)
-# define LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5) \
-	LOADARGS_4(name, arg1, arg2, arg3, arg4); \
-	register long r7 __asm__ ("r7") = (long) (arg5)
-# define LOADARGS_6(name, arg1, arg2, arg3, arg4, arg5, arg6) \
-	LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5); \
-	register long r8 __asm__ ("r8") = (long) (arg6)
-
-# define ASM_INPUT_0 "r" (r0)
-# define ASM_INPUT_1 ASM_INPUT_0, "0" (r3)
-# define ASM_INPUT_2 ASM_INPUT_1, "r" (r4)
-# define ASM_INPUT_3 ASM_INPUT_2, "r" (r5)
-# define ASM_INPUT_4 ASM_INPUT_3, "r" (r6)
-# define ASM_INPUT_5 ASM_INPUT_4, "r" (r7)
-# define ASM_INPUT_6 ASM_INPUT_5, "r" (r8)
+# undef INTERNAL_SYSCALL_ERROR_P
+# define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  (__builtin_expect (err & (1 << 28), 0))
+
+# undef INTERNAL_SYSCALL_ERRNO
+# define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+# define LOADARGS_0(name, dummy) \
+	r0 = name
+# define LOADARGS_1(name, __arg1) \
+	long int arg1 = (long int) (__arg1);	\
+	LOADARGS_0(name, 0); \
+	extern void __illegally_sized_syscall_arg1 (void); \
+	if (__builtin_classify_type (__arg1) != 5 && sizeof (__arg1) > 4) \
+	  __illegally_sized_syscall_arg1 (); \
+	r3 = arg1
+# define LOADARGS_2(name, __arg1, __arg2) \
+	long int arg2 = (long int) (__arg2); \
+	LOADARGS_1(name, __arg1); \
+	extern void __illegally_sized_syscall_arg2 (void); \
+	if (__builtin_classify_type (__arg2) != 5 && sizeof (__arg2) > 4) \
+	  __illegally_sized_syscall_arg2 (); \
+	r4 = arg2
+# define LOADARGS_3(name, __arg1, __arg2, __arg3) \
+	long int arg3 = (long int) (__arg3); \
+	LOADARGS_2(name, __arg1, __arg2); \
+	extern void __illegally_sized_syscall_arg3 (void); \
+	if (__builtin_classify_type (__arg3) != 5 && sizeof (__arg3) > 4) \
+	  __illegally_sized_syscall_arg3 (); \
+	r5 = arg3
+# define LOADARGS_4(name, __arg1, __arg2, __arg3, __arg4) \
+	long int arg4 = (long int) (__arg4); \
+	LOADARGS_3(name, __arg1, __arg2, __arg3); \
+	extern void __illegally_sized_syscall_arg4 (void); \
+	if (__builtin_classify_type (__arg4) != 5 && sizeof (__arg4) > 4) \
+	  __illegally_sized_syscall_arg4 (); \
+	r6 = arg4
+# define LOADARGS_5(name, __arg1, __arg2, __arg3, __arg4, __arg5) \
+	long int arg5 = (long int) (__arg5); \
+	LOADARGS_4(name, __arg1, __arg2, __arg3, __arg4); \
+	extern void __illegally_sized_syscall_arg5 (void); \
+	if (__builtin_classify_type (__arg5) != 5 && sizeof (__arg5) > 4) \
+	  __illegally_sized_syscall_arg5 (); \
+	r7 = arg5
+# define LOADARGS_6(name, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6) \
+	long int arg6 = (long int) (__arg6); \
+	LOADARGS_5(name, __arg1, __arg2, __arg3, __arg4, __arg5); \
+	extern void __illegally_sized_syscall_arg6 (void); \
+	if (__builtin_classify_type (__arg6) != 5 && sizeof (__arg6) > 4) \
+	  __illegally_sized_syscall_arg6 (); \
+	r8 = arg6
+
+# define ASM_INPUT_0 "0" (r0)
+# define ASM_INPUT_1 ASM_INPUT_0, "1" (r3)
+# define ASM_INPUT_2 ASM_INPUT_1, "2" (r4)
+# define ASM_INPUT_3 ASM_INPUT_2, "3" (r5)
+# define ASM_INPUT_4 ASM_INPUT_3, "4" (r6)
+# define ASM_INPUT_5 ASM_INPUT_4, "5" (r7)
+# define ASM_INPUT_6 ASM_INPUT_5, "6" (r8)
 
 #endif /* __ASSEMBLER__ */
 
 
-#endif /* linux/powerpc/sysdep.h */
+#endif /* linux/powerpc/powerpc32/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/truncate64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/truncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/truncate64.c	2003-01-07 01:33:29.000000000 +0100
@@ -0,0 +1,78 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_truncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+int have_no_truncate64;
+#endif
+
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+truncate64 (path, length)
+     const char *path;
+     off64_t length;
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! have_no_truncate64)
+#endif
+    {
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      /* On PPC32 64bit values are aligned in odd/even register pairs.  */
+      int result = INLINE_SYSCALL (truncate64, 4, CHECK_STRING (path), 0,
+				   (long) (length >> 32),
+				   (long) length);
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return truncate (path, (off_t) length);
+#endif
+}
+
+#else
+/* Use the generic implementation.  */
+# include <sysdeps/generic/truncate64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/ucontext_i.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/ucontext_i.h
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/ucontext_i.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/ucontext_i.h	2004-01-16 05:49:35.000000000 +0100
@@ -0,0 +1,43 @@
+/* Offsets and other constants needed in the *context() function
+   implementation.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIG_BLOCK	0
+#define SIG_SETMASK	2
+
+#define _FRAME_BACKCHAIN	0
+#define _FRAME_LR_SAVE	4
+#define _FRAME_PARM_SAVE1	8
+#define _FRAME_PARM_SAVE2	12
+#define _FRAME_PARM_SAVE3	16
+#define _FRAME_PARM_SAVE4	20
+
+#define _UC_LINK	4
+#define _UC_STACK_SP	8
+#define _UC_STACK_SIZE	16
+#define _UC_REGS_PTR	48
+#define _UC_SIGMASK	52
+#define _UC_REG_SPACE	180
+
+/* offsets within mcontext_t */
+#define _UC_GREGS	0
+#define _UC_FREGS	192
+#define _UC_VREGS	464
+#define _UC_VSCR	976
+#define _UC_VRSAVE	980
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/Versions
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/Versions	2002-08-23 21:47:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/Versions	2004-01-16 05:45:46.000000000 +0100
@@ -20,4 +20,11 @@
     # s*
     scandir64;
   }
+  GLIBC_2.3.3 {
+    posix_fadvise64; posix_fallocate64;
+    setcontext; getcontext; swapcontext; makecontext;
+  }
+  GLIBC_2.3.4 {
+    setcontext; getcontext; swapcontext; makecontext;
+  }
 }
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S	2003-02-20 23:18:21.000000000 +0100
@@ -0,0 +1,59 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <kernel-features.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef __NR_vfork
+
+	DO_CALL (SYS_ify (vfork))
+
+# ifdef __ASSUME_VFORK_SYSCALL
+	PSEUDO_RET
+# else
+	bnslr+
+	/* Check if vfork syscall is known at all.  */
+	cmpwi	r3,ENOSYS
+	bne-	.Lsyscall_error
+
+# endif
+#endif
+
+#ifndef __ASSUME_VFORK_SYSCALL
+	/* If we don't have vfork, fork is close enough.  */
+
+	DO_CALL (SYS_ify (fork))
+	bnslr+
+
+.Lsyscall_error:
+	b	JUMPTARGET(__syscall_error)
+#endif
+
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc32/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/xstat.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc32/xstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc32/xstat.c	2004-03-02 19:50:32.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/xstat.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/brk.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/brk.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/brk.S	2002-09-18 01:50:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/brk.S	2004-12-14 22:24:08.000000000 +0100
@@ -24,15 +24,19 @@
 #include <bp-asm.h>
 
 	.comm	__curbrk,8,8
+	.section	".toc","aw"
+.LC__curbrk:
+	.tc __curbrk[TC],__curbrk
 	.section ".text"
 ENTRY (BP_SYM (__brk))
+	CALL_MCOUNT 1
 	DISCARD_BOUNDS (r3)	/* the bounds are meaningless, so toss 'em.  */
 
 	stdu    r1,-64(r1)
 	std	r3,48(r1)
 	DO_CALL(SYS_ify(brk))
 	ld     r6,48(r1)
-	ld	r5,__curbrk@got(r2)
+	ld	r5,.LC__curbrk@toc(r2)
 	std     r3,0(r5)
 	cmpld   r6,r3
 	addi    r1,r1,64
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/clone.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/clone.S	2002-09-18 01:50:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/clone.S	2004-12-15 21:37:06.000000000 +0100
@@ -1,5 +1,5 @@
 /* Wrapper around clone system call.  PowerPC64 version.
-   Copyright (C) 1997,98,99,2000,02 Free Software Foundation, Inc.
+   Copyright (C) 1997,98,99,2000,02, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,22 +23,26 @@
 #include <bp-sym.h>
 #include <bp-asm.h>
 
+#define CLONE_VM	0x00000100
+#define CLONE_THREAD	0x00010000
+
 /* This is the only really unusual system call in PPC linux, but not
    because of any weirdness in the system call itself; because of
    all the freaky stuff we have to do to make the call useful.  */
 
 /* int [r3] clone(int (*fn)(void *arg) [r3], void *child_stack [r4],
-   		  int flags [r5], void *arg [r6]); */
+                  int flags [r5], void *arg [r6], void *parent_tid [r7],
+                  void *tls [r8], void *child_tid [r9]); */
 
 ENTRY (BP_SYM (__clone))
+	CALL_MCOUNT 7
 	/* GKM FIXME: add bounds checks, where sensible.  */
 	DISCARD_BOUNDS (r4)
 	DISCARD_BOUNDS (r6)
 
 	/* Check for child_stack == NULL || fn == NULL.  */
 	cmpdi	cr0,r4,0
-	ld	r7,0(r3)
-	cmpdi	cr1,r7,0
+	cmpdi	cr1,r3,0
 	cror	cr0*4+eq,cr1*4+eq,cr0*4+eq
 	beq-	cr0,L(badargs)
 
@@ -47,6 +51,9 @@
 	std	r29,56(r1)
 	std	r30,64(r1)
 	std	r31,72(r1)
+#ifdef RESET_PID
+	std	r28,48(r1)
+#endif
 
 	/* Set up stack frame for child.  */
 	clrrdi	r4,r4,4
@@ -56,11 +63,18 @@
 	/* Save fn, args, stack across syscall.  */
 	mr	r29,r3			/* Function in r29.  */
 	mr	r30,r4			/* Stack pointer in r30.  */
+#ifdef RESET_PID
+	mr	r28,r5			/* Flags in r28.  */
+#endif
 	mr	r31,r6			/* Argument in r31.  */
 
 	/* 'flags' argument is first parameter to clone syscall. (The other
 	   argument is the stack pointer, already in r4.)  */
 	mr	r3,r5
+  /* Move the parent_tid, child_tid and tls arguments. */
+	mr	r5,r7
+	mr	r6,r8
+	mr	r7,r9
 
 	/* Do the call.  */
 	DO_CALL(SYS_ify(clone))
@@ -70,22 +84,39 @@
 	crandc	cr1*4+eq,cr1*4+eq,cr0*4+so
 	bne-	cr1,L(parent)		/* The '-' is to minimise the race.  */
 
-	/* On at least mklinux DR3a5, clone() doesn't actually change
-	   the stack pointer.  I'm pretty sure this is a bug, because
-	   it adds a race condition if a signal is sent to a thread
-	   just after it is created (in the previous three instructions).  */
-	mr	r1,r30
+#ifdef RESET_PID
+	andis.	r0,r28,CLONE_THREAD>>16
+	bne+	cr0,L(oldpid)
+	andi.	r0,r28,CLONE_VM
+	li	r3,-1
+	bne-	cr0,L(nomoregetpid)
+	DO_CALL(SYS_ify(getpid))
+L(nomoregetpid):
+	stw	r3,TID(r13)
+	stw	r3,PID(r13)
+L(oldpid):
+#endif
+
+	std	r2,40(r1)
 	/* Call procedure.  */
 	ld	r0,0(r29)
 	ld	r2,8(r29)
 	mtctr	r0
 	mr	r3,r31
 	bctrl
+	ld	r2,40(r1)
 	/* Call _exit with result from procedure.  */
+#ifdef SHARED
+	b	JUMPTARGET(__GI__exit)
+#else
 	b	JUMPTARGET(_exit)
+#endif
 
 L(parent):
 	/* Parent.  Restore registers & return.  */
+#ifdef RESET_PID
+	ld	r28,48(r1)
+#endif
 	ld	r31,72(r1)
 	ld	r30,64(r1)
 	ld	r29,56(r1)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Dist
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/Dist	2002-10-02 10:53:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Dist	2003-02-21 08:04:31.000000000 +0100
@@ -1,2 +1,4 @@
 clone.S
+fe_nomask.c
 kernel_stat.h
+ucontext_i.h
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/fcntl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fcntl.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fcntl.c	2004-07-16 20:10:26.000000000 +0200
@@ -0,0 +1,72 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <sysdep-cancel.h>	/* Must come before <fcntl.h>.  */
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sys/syscall.h>
+
+
+#ifndef NO_CANCELLATION
+int
+__fcntl_nocancel (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+}
+#endif
+
+
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (cmd >= F_GETLK64 && cmd <= F_SETLKW64)
+    cmd -= F_GETLK64 - F_GETLK;
+
+  if (SINGLE_THREAD_P || cmd != F_SETLKW)
+    return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__libc_fcntl)
+
+weak_alias (__libc_fcntl, __fcntl)
+libc_hidden_weak (__fcntl)
+weak_alias (__libc_fcntl, fcntl)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/fe_nomask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fe_nomask.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/fe_nomask.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fe_nomask.c	2003-04-12 00:08:59.000000000 +0200
@@ -0,0 +1,43 @@
+/* Procedure definition for FE_NOMASK_ENV for Linux/ppc64.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <errno.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sys/prctl.h>
+#include "kernel-features.h"
+
+const fenv_t *
+__fe_nomask_env (void)
+{
+#if defined PR_SET_FPEXC && defined PR_FP_EXC_PRECISE
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+  result = INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, PR_FP_EXC_PRECISE);
+# ifndef __ASSUME_NEW_PRCTL_SYSCALL
+  if (INTERNAL_SYSCALL_ERROR_P (result, err)
+      && INTERNAL_SYSCALL_ERRNO (result, err) == EINVAL)
+    __set_errno (ENOSYS);
+# endif
+#else  
+  __set_errno (ENOSYS);
+#endif
+  return FE_ENABLED_ENV;
+}
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fxstat64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/fxstat64.c	2002-10-02 10:33:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fxstat64 is in fxstat.c */
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/getcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/getcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/getcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/getcontext.S	2004-12-17 05:17:33.000000000 +0100
@@ -0,0 +1,403 @@
+/* Save current context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+#include "kernel-features.h"
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+#include "ucontext_i.h"
+
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3, GLIBC_2_3_4)
+ENTRY(__novec_getcontext)
+	CALL_MCOUNT 1
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r3)
+  std  r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r3)
+  mflr  r0
+  std  r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r3)
+  std  r0,FRAME_LR_SAVE(r1)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r3)
+  stdu  r1,-128(r1)
+  std  r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r3)
+  std  r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r3)
+  std  r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r3)
+  std  r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r3)
+  std  r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r3)
+  std  r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r3)
+  std  r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r3)
+  std  r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r3)
+  std  r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r3)
+  std  r13,(SIGCONTEXT_GP_REGS+(PT_R13*8))(r3)
+  std  r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r3)
+  std  r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r3)
+  std  r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r3)
+  std  r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r3)
+  std  r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r3)
+  std  r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r3)
+  std  r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r3)
+  std  r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r3)
+  std  r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r3)
+  std  r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r3)
+  std  r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r3)
+  std  r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r3)
+  std  r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r3)
+  std  r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r3)
+  std  r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r3)
+  std  r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r3)
+  std  r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r3)
+  std  r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r3)
+  mfctr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CTR*8))(r3)
+  mfxer  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r3)
+  mfcr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r3)
+
+  /* Set the return value of swapcontext to "success".  R3 is the only
+     register whose value is not preserved in the saved context.  */
+  li   r0,0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r3)
+
+  /* Zero fill fields that can't be set in user state or are unused.  */
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(34*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_SOFTE*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(40*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(41*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(42*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_RESULT*8))(r3)
+
+  /* Set the PT_REGS pointer to the address of sigcontext's gp_regs
+     field.  Struct pt_regs and elf_gregset_t are the same thing.
+     We kept the regs field for backwards compatibility with
+     libraries built before we extended sigcontext.  */
+  addi r0,r3,SIGCONTEXT_GP_REGS
+  std  r0,SIGCONTEXT_PT_REGS(r3)
+
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r3)
+  stfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r3)
+  stfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r3)
+  stfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r3)
+  stfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r3)
+  stfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r3)
+  stfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r3)
+  stfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r3)
+  stfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r3)
+  stfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r3)
+  stfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r3)
+  stfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r3)
+  stfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r3)
+  stfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r3)
+  stfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r3)
+  stfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r3)
+  stfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r3)
+  stfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r3)
+  stfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r3)
+  stfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r3)
+  stfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r3)
+  stfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r3)
+  stfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r3)
+  stfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r3)
+  stfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r3)
+  stfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r3)
+  stfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r3)
+  stfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r3)
+  stfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r3)
+  stfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r3)
+  mffs  fp0
+  stfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r3)
+  stfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r3)
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r3)
+
+  addi  r5,r3,UCONTEXT_SIGMASK
+  li  r4,0
+  li  r3,SIG_BLOCK
+  bl  JUMPTARGET(__sigprocmask)
+  nop
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+#endif
+
+  ld    r0,128+FRAME_LR_SAVE(r1)
+  addi  r1,r1,128
+  mtlr  r0
+  blr
+PSEUDO_END(__novec_getcontext)
+
+compat_symbol (libc, __novec_getcontext, getcontext, GLIBC_2_3)
+
+#endif
+
+	.section	".toc","aw"
+.LC__dl_hwcap:
+#ifdef SHARED
+	.tc _rtld_global_ro[TC],_rtld_global_ro
+#else
+	.tc _dl_hwcap[TC],_dl_hwcap
+#endif
+	.section ".text"
+
+	.machine	"altivec"
+ENTRY(__getcontext)
+	CALL_MCOUNT 1
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r3)
+  std  r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r3)
+  mflr  r0
+  std  r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r3)
+  std  r0,FRAME_LR_SAVE(r1)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r3)
+  stdu  r1,-128(r1)
+  std  r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r3)
+  std  r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r3)
+  std  r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r3)
+  std  r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r3)
+  std  r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r3)
+  std  r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r3)
+  std  r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r3)
+  std  r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r3)
+  std  r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r3)
+  std  r13,(SIGCONTEXT_GP_REGS+(PT_R13*8))(r3)
+  std  r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r3)
+  std  r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r3)
+  std  r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r3)
+  std  r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r3)
+  std  r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r3)
+  std  r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r3)
+  std  r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r3)
+  std  r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r3)
+  std  r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r3)
+  std  r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r3)
+  std  r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r3)
+  std  r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r3)
+  std  r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r3)
+  std  r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r3)
+  std  r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r3)
+  std  r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r3)
+  std  r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r3)
+  std  r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r3)
+  mfctr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CTR*8))(r3)
+  mfxer  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r3)
+  mfcr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r3)
+
+  /* Set the return value of swapcontext to "success".  R3 is the only
+     register whose value is not preserved in the saved context.  */
+  li   r0,0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r3)
+
+  /* Zero fill fields that can't be set in user state or are unused.  */
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(34*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_SOFTE*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(40*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(41*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(42*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_RESULT*8))(r3)
+
+  /* Set the PT_REGS pointer to the address of sigcontext's gp_regs
+     field.  Struct pt_regs and elf_gregset_t are the same thing.
+     We kept the regs field for backwards compatibility with
+     libraries built before we extended sigcontext.  */
+  addi r0,r3,SIGCONTEXT_GP_REGS
+  std  r0,SIGCONTEXT_PT_REGS(r3)
+
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r3)
+  stfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r3)
+  stfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r3)
+  stfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r3)
+  stfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r3)
+  stfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r3)
+  stfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r3)
+  stfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r3)
+  stfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r3)
+  stfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r3)
+  stfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r3)
+  stfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r3)
+  stfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r3)
+  stfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r3)
+  stfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r3)
+  stfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r3)
+  stfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r3)
+  stfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r3)
+  stfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r3)
+  stfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r3)
+  stfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r3)
+  stfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r3)
+  stfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r3)
+  stfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r3)
+  stfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r3)
+  stfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r3)
+  stfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r3)
+  stfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r3)
+  stfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r3)
+  stfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r3)
+  mffs  fp0
+  stfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r3)
+  stfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r3)
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r3)
+
+  ld    r5,.LC__dl_hwcap@toc(r2)
+# ifdef SHARED
+/* Load _rtld-global._dl_hwcap.  */
+  ld    r5,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r5)
+# else
+  ld    r5,0(r5) /* Load extern _dl_hwcap.  */
+# endif
+  la    r10,(SIGCONTEXT_V_RESERVE+8)(r3)
+  la    r9,(SIGCONTEXT_V_RESERVE+24)(r3)
+
+  andis.  r5,r5,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+
+  clrrdi  r10,r10,4
+  beq   L(has_no_vec)
+  clrrdi  r9,r9,4
+  mr    r5,r10	/* Capture *v_regs value in r5.  */
+
+  stvx  v0,0,r10
+  stvx  v1,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v2,0,r10
+  stvx  v3,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v4,0,r10
+  stvx  v5,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v6,0,r10
+  stvx  v7,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v8,0,r10
+  stvx  v9,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v10,0,r10
+  stvx  v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v12,0,r10
+  stvx  v13,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v14,0,r10
+  stvx  v15,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v16,0,r10
+  stvx  v17,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v18,0,r10
+  stvx  v19,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v20,0,r10
+  stvx  v21,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v22,0,r10
+  stvx  v23,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v24,0,r10
+  stvx  v25,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v26,0,r10
+  stvx  v27,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v28,0,r10
+  stvx  v29,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v30,0,r10
+  stvx  v31,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  mfvscr  v0
+  mfspr r0,VRSAVE
+  stvx  v0,0,r10
+  stw   r0,0(9)
+
+L(has_no_vec):
+/*
+   Store either a NULL or a quadword aligned pointer to the Vector register
+   array into *v_regs.
+*/
+  std   r5,(SIGCONTEXT_V_REGS_PTR)(r3)
+
+  addi  r5,r3,UCONTEXT_SIGMASK
+  li  r4,0
+  li  r3,SIG_BLOCK
+  bl  JUMPTARGET(__sigprocmask)
+  nop
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+#endif
+
+  ld    r0,128+FRAME_LR_SAVE(r1)
+  addi  r1,r1,128
+  mtlr  r0
+  blr
+PSEUDO_END(__getcontext)
+
+versioned_symbol (libc, __getcontext, getcontext, GLIBC_2_3_4)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/glob64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/glob64.c	2002-09-18 01:50:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/glob64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-/* glob64 is in glob.c */
-/* File glob64.c is redundent to glob.c in 64-bit. */
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Implies
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Implies	2004-03-24 00:26:24.000000000 +0100
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/lxstat64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/lxstat64.c	2002-10-02 10:33:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* lxstat64 is in lxstat.c */
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/makecontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/makecontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/makecontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/makecontext.S	2004-12-14 22:24:08.000000000 +0100
@@ -0,0 +1,183 @@
+/* Create new context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-features.h"
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+#include <asm/errno.h>
+
+ENTRY(__makecontext)
+	CALL_MCOUNT 3
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  /* Save parameters into the parameter save area of callers frame.  */
+  std  r3,FRAME_PARM1_SAVE(r1) /* ucontext_t *ucp  */
+  std  r4,FRAME_PARM2_SAVE(r1) /* void (*func)(void)  */
+  std  r5,FRAME_PARM3_SAVE(r1) /* int argc  */
+  std  r6,FRAME_PARM4_SAVE(r1) /* ... */
+  std  r7,FRAME_PARM5_SAVE(r1)
+  std  r8,FRAME_PARM6_SAVE(r1)
+  std  r9,FRAME_PARM7_SAVE(r1)
+  std  r10,FRAME_PARM8_SAVE(r1)
+  mflr  r0
+  /* Get the address of the target functions first parameter.  */
+  addi  r6,r1,FRAME_PARM4_SAVE
+  std   r0,FRAME_LR_SAVE(r1)
+  stdu  r1,-128(r1)
+
+  /* Get the ucontexts stack pointer and size.  Compute the top of stack
+     and round down to a quadword boundary.  Then stack a dummy frame
+     with a null back chain.  We store the context pointer in the frames
+     "compiler double word" field so we can recover if is the function
+     returns.  Finally save the callers link register and TOC pointer
+     into this frame so the debugger can display a backtrace.
+  */
+  ld    r7,UCONTEXT_STACK_SP(r3)
+  ld    r0,UCONTEXT_STACK_SIZE(r3)
+  add   r7,r7,r0
+  clrrdi  r7,r7,4
+  li    r0,0
+  stdu  r0,-64(r7)
+  std   r3,FRAME_PARM1_SAVE(r7) /* Store context in dummy parm1.  */
+  mflr  r0
+  std   r2,FRAME_TOC_SAVE(r7)  /* Store the TOC pointer for later.  */
+  std   r0,FRAME_LR_SAVE(r7)
+
+  /* Now we need to stack another frame to hold the parameter save area
+     for the function.  We need to allocate a frame with the minimum 48
+     byte header and 8 parameter register.  However if there are more
+     than 8 parameters addition space is need to hold all the parameters.
+     The total size it rounded up to a quadword multiple then a frame is
+     stacked.  This address is stored in the ucontext as GPR 1.  */
+
+  cmpdi cr1,r5,8
+  sldi  r8,r5,3
+  bgt   cr1,L(gt8)
+  li    r8,64
+L(gt8):
+  addi  r8,r8,FRAME_PARM_SAVE+8 /* Add header plus rounding factor.  */
+  clrrdi  r8,r8,4  /* Round down to quadword.  */
+
+  subf  r8,r8,r7
+  std   r7,0(r8)   /* Stack the frame.  */
+  std   r8,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r3)
+
+  /* Now we need to copy the target functions parameters.  The functions
+     parameters are saved in the parameter save area.  We skip over the
+     first three parameters and copy up to 8 double word into the
+     SIGCONTEXT_GP_REGS starting with R3.  If there are more than 8
+     parameters then doublewords 8-N are copied into the parameter
+     save area of the context frame.  */
+  cmpdi r5,0
+  beq   L(noparms)
+  mr    r0,r5
+  ble   cr1,L(le8)
+  li    r0,8
+L(le8):
+  mtctr r0
+  addi  r7,r6,-8
+  addi  r9,r3,(SIGCONTEXT_GP_REGS+(PT_R3*8)-8)
+L(parmloop2):
+  ldu   r0,8(r7)
+  stdu  r0,8(r9)
+  bdnz  L(parmloop2)
+
+  addi  r0,r5,-8
+  ble   cr1,L(noparms)
+  mtctr r0
+  addi  r9,r8,FRAME_PARM9_SAVE-8
+L(parmloop):
+  ldu   r0,8(r7)
+  stdu  r0,8(r9)
+  bdnz  L(parmloop)
+
+L(noparms):
+
+  /* Load the function address and TOC from the function descriptor
+     and store them in the ucontext as NIP and r2.  Store the 3rd
+     field of the function descriptor into the ucontext as r11 in case
+     the calling language needs the "environment pointer".  */
+  ld    r0,0(r4)
+  ld    r10,8(r4);
+  ld    r9,16(r4);
+  std   r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r3)
+  std   r10,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r3)
+  std   r9,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r3)
+
+  /* If the target function returns we need to do some cleanup.  We use a
+     code trick to get the address of our cleanup function into the link
+     register.  Do not add any code between here and L(exitcode).  */
+  bl  L(gotexitcodeaddr);
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+L(exitcode):
+   /* Recover the ucontext and TOC from the dummy frame.  */
+  ld    r1,FRAME_BACKCHAIN(r1)  /* Unstack the parameter save area frame.  */
+  ld    r3,FRAME_PARM1_SAVE(r1)
+  ld    r2,FRAME_TOC_SAVE(r1)
+  ld    r3,UCONTEXT_LINK(r3)  /* Load the resume context.  */
+  cmpdi r3,0
+  beq   L(BADSTATUS)
+	bl    JUMPTARGET(__setcontext)
+	nop
+
+L(BADSTATUS):
+/* If setcontext returns (which can happen if the syscall fails) we will
+   exit the program with error status (-1).  */
+  li    r3,-1
+#ifdef SHARED
+  b     JUMPTARGET(__GI_exit);
+#else
+  b     JUMPTARGET(exit);
+#endif
+
+  /* The address of the exit code is in the link register.  Store the lr
+     in the ucontext as LNK so the target function will return to our
+     exit code.  */
+L(gotexitcodeaddr):
+  mflr  r0
+  std   r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r3)
+  ld    r0,128+FRAME_LR_SAVE(r1)
+  addi  r1,r1,128
+  mtlr  r0
+  blr
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+  blr
+#endif
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pread64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/pread64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pread64.c	2003-01-12 09:19:45.000000000 +0100
@@ -0,0 +1,84 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
+				  off64_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+                                offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+   result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+                            offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
+
+# define __libc_pread64(fd, buf, count, offset) \
+     static internal_function __emulate_pread64 (fd, buf, count, offset)
+#endif
+
+# if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pread.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/pread.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pread.c	2003-01-12 09:19:31.000000000 +0100
@@ -0,0 +1,85 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread (int fd, void *buf, size_t count,
+				off_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+                                offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+  
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+                            offset);
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__libc_pread, pread)
+
+# define __libc_pread(fd, buf, count, offset) \
+     static internal_function __emulate_pread (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite64.c	2003-01-12 09:20:15.000000000 +0100
@@ -0,0 +1,85 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
+				   off64_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+                                offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+                            offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+# define __libc_pwrite64(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite64.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/pwrite.c	2003-01-12 09:19:59.000000000 +0100
@@ -0,0 +1,85 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
+				 off_t offset) internal_function;
+# endif
+
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+                              offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			                     offset);
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__libc_pwrite, pwrite)
+
+# define __libc_pwrite(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/setcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/setcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/setcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/setcontext.S	2005-02-16 12:18:19.000000000 +0100
@@ -0,0 +1,459 @@
+/* Switch to context.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+#include "kernel-features.h"
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+#include <asm/errno.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3, GLIBC_2_3_4)
+ENTRY(__novec_setcontext)
+	CALL_MCOUNT 1
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  mflr  r0
+  std   r31,-8(1)
+  std   r0,FRAME_LR_SAVE(r1)
+  stdu  r1,-128(r1)
+  mr    r31,r3
+
+/*
+ * If this ucontext refers to the point where we were interrupted
+ * by a signal, we have to use the rt_sigreturn system call to
+ * return to the context so we get both LR and CTR restored.
+ *
+ * Otherwise, the context we are restoring is either just after
+ * a procedure call (getcontext/swapcontext) or at the beginning
+ * of a procedure call (makecontext), so we don't need to restore
+ * msr and ctr.  We don't restore r13 since it will be used as
+ * the TLS pointer.  */
+  ld	  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r31)
+  cmpdi r0,0
+  bne	  L(nv_do_sigret)
+
+  li    r5,0
+  addi  r4,r3,UCONTEXT_SIGMASK
+  li    r3,SIG_SETMASK
+  bl    JUMPTARGET(__sigprocmask)
+  nop
+  cmpdi r3,0
+  bne   L(nv_error_exit)
+
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r31)
+  lfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r31)
+  lfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r31)
+  mtfsf  0xff,fp0
+  lfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r31)
+  lfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r31)
+  lfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r31)
+  lfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r31)
+  lfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r31)
+  lfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r31)
+  lfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r31)
+  lfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r31)
+  lfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r31)
+  lfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r31)
+  lfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r31)
+  lfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r31)
+  lfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r31)
+  lfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r31)
+  lfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r31)
+  lfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r31)
+  lfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r31)
+  lfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r31)
+  lfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r31)
+  lfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r31)
+  lfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r31)
+  lfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r31)
+  lfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r31)
+  lfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r31)
+  lfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r31)
+  lfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r31)
+  lfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r31)
+  lfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r31)
+  lfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r31)
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r31)
+
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r31)
+  ld   r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r31)
+  mtlr r0
+  ld   r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r31)
+  ld   r3,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r31)
+  mtxer r0
+  ld   r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r31)
+  ld   r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r31)
+  mtcr r0
+  ld   r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r31)
+  ld   r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r31)
+  ld   r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r31)
+  ld   r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r31)
+  ld   r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r31)
+  ld   r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r31)
+  ld   r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r31)
+  /* Don't reload the thread ID or TLS pointer (r13).  */
+  ld   r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r31)
+  ld   r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r31)
+  ld   r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r31)
+  ld   r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r31)
+  ld   r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r31)
+  ld   r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r31)
+  ld   r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r31)
+  ld   r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r31)
+  ld   r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r31)
+  ld   r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r31)
+  ld   r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r31)
+  ld   r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r31)
+  ld   r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r31)
+  ld   r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r31)
+  ld   r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r31)
+  ld   r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r31)
+  ld   r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r31)
+
+  /* Now we branch to the "Next Instruction Pointer" from the saved
+     context.  With the powerpc64 instruction set there is no good way to
+     do this (from user state) without clobbering either the LR or CTR.
+     The makecontext and swapcontext functions depend on the callers
+     LR being preserved so we use the CTR.  */
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r31)
+  mtctr r0
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r31)
+  ld   r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r31)
+  bctr
+
+L(nv_error_exit):
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+	ld   r31,-8(r1)
+  blr
+
+  /* At this point we assume that the ucontext was created by a
+     rt_signal and we should use rt_sigreturn to restore the original
+     state.  As of the 2.4.21 kernel the ucontext is the first thing
+     (offset 0) in the rt_signal frame and rt_sigreturn expects the
+     ucontext address in R1.  Normally the rt-signal trampoline handles
+     this by popping dummy frame before the rt_signal syscall.  In our
+     case the stack may not be in its original (signal handler return with
+     R1 pointing at the dummy frame) state.  We do have the ucontext
+     address in R3, so simply copy R3 to R1 before the syscall.  */
+L(nv_do_sigret):
+  mr   r1,r3,
+  li   r0,SYS_ify(rt_sigreturn)
+  sc
+  /* No return.  */
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+  blr
+#endif
+
+PSEUDO_END(__novec_setcontext)
+
+compat_symbol (libc, __novec_setcontext, setcontext, GLIBC_2_3)
+
+#endif
+
+	.section	".toc","aw"
+.LC__dl_hwcap:
+#ifdef SHARED
+	.tc _rtld_global_ro[TC],_rtld_global_ro
+#else
+	.tc _dl_hwcap[TC],_dl_hwcap
+#endif
+	.section ".text"
+
+	.machine	"altivec"
+ENTRY(__setcontext)
+	CALL_MCOUNT 1
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  mflr  r0
+  std   r31,-8(1)
+  std   r0,FRAME_LR_SAVE(r1)
+  stdu  r1,-128(r1)
+  mr    r31,r3
+
+/*
+ * If this ucontext refers to the point where we were interrupted
+ * by a signal, we have to use the rt_sigreturn system call to
+ * return to the context so we get both LR and CTR restored.
+ *
+ * Otherwise, the context we are restoring is either just after
+ * a procedure call (getcontext/swapcontext) or at the beginning
+ * of a procedure call (makecontext), so we don't need to restore
+ * msr and ctr.  We don't restore r13 since it will be used as
+ * the TLS pointer.  */
+  ld	  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r31)
+  cmpdi r0,0
+  bne	  L(do_sigret)
+
+  li    r5,0
+  addi  r4,r3,UCONTEXT_SIGMASK
+  li    r3,SIG_SETMASK
+  bl    JUMPTARGET(__sigprocmask)
+  nop
+  cmpdi r3,0
+  bne   L(error_exit)
+
+  ld    r5,.LC__dl_hwcap@toc(r2)
+  ld    r10,(SIGCONTEXT_V_REGS_PTR)(r31)
+# ifdef SHARED
+/* Load _rtld-global._dl_hwcap.  */
+  ld    r5,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r5)
+# else
+  ld    r5,0(r5) /* Load extern _dl_hwcap.  */
+# endif
+  andis.  r5,r5,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+  beq   L(has_no_vec)
+
+  cmpdi r10,0
+  beq   L(has_no_vec)
+  lwz   r0,(33*16)(r10)
+
+  li    r9,(16*32)
+  mtspr VRSAVE,r0
+  cmpwi r0,0
+  beq   L(has_no_vec)
+
+  lvx   v19,r9,r10
+  la    r9,(16)(r10)
+
+  lvx   v0,0,r10
+  lvx   v1,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  mtvscr  v19
+  lvx   v2,0,r10
+  lvx   v3,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v4,0,r10
+  lvx   v5,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v6,0,r10
+  lvx   v7,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v8,0,r10
+  lvx   v9,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v10,0,r10
+  lvx   v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v12,0,r10
+  lvx   v13,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v14,0,r10
+  lvx   v15,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v16,0,r10
+  lvx   v17,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v18,0,r10
+  lvx   v19,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v20,0,r10
+  lvx   v21,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v22,0,r10
+  lvx   v23,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v24,0,r10
+  lvx   v25,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v26,0,r10
+  lvx   v27,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v28,0,r10
+  lvx   v29,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v30,0,r10
+  lvx   v31,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v10,0,r10
+  lvx   v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+L(has_no_vec):
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r31)
+  lfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r31)
+  lfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r31)
+  mtfsf  0xff,fp0
+  lfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r31)
+  lfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r31)
+  lfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r31)
+  lfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r31)
+  lfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r31)
+  lfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r31)
+  lfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r31)
+  lfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r31)
+  lfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r31)
+  lfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r31)
+  lfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r31)
+  lfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r31)
+  lfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r31)
+  lfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r31)
+  lfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r31)
+  lfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r31)
+  lfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r31)
+  lfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r31)
+  lfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r31)
+  lfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r31)
+  lfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r31)
+  lfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r31)
+  lfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r31)
+  lfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r31)
+  lfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r31)
+  lfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r31)
+  lfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r31)
+  lfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r31)
+  lfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r31)
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r31)
+
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r31)
+  ld   r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r31)
+  mtlr r0
+  ld   r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r31)
+  ld   r3,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r31)
+  mtxer r0
+  ld   r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r31)
+  ld   r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r31)
+  ld   r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r31)
+  ld   r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r31)
+  ld   r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r31)
+  ld   r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r31)
+  mtcr r0
+  ld   r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r31)
+  ld   r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r31)
+  ld   r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r31)
+  /* Don't reload the thread ID or TLS pointer (r13).  */
+  ld   r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r31)
+  ld   r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r31)
+  ld   r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r31)
+  ld   r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r31)
+  ld   r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r31)
+  ld   r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r31)
+  ld   r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r31)
+  ld   r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r31)
+  ld   r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r31)
+  ld   r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r31)
+  ld   r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r31)
+  ld   r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r31)
+  ld   r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r31)
+  ld   r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r31)
+  ld   r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r31)
+  ld   r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r31)
+  ld   r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r31)
+
+  /* Now we branch to the "Next Instruction Pointer" from the saved
+     context.  With the powerpc64 instruction set there is no good way to
+     do this (from user state) without clobbering either the LR or CTR.
+     The makecontext and swapcontext functions depend on the callers
+     LR being preserved so we use the CTR.  */
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r31)
+  mtctr r0
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r31)
+  ld   r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r31)
+  bctr
+
+L(error_exit):
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+	ld   r31,-8(r1)
+  blr
+
+  /* At this point we assume that the ucontext was created by a
+     rt_signal and we should use rt_sigreturn to restore the original
+     state.  As of the 2.4.21 kernel the ucontext is the first thing
+     (offset 0) in the rt_signal frame and rt_sigreturn expects the
+     ucontext address in R1.  Normally the rt-signal trampoline handles
+     this by popping dummy frame before the rt_signal syscall.  In our
+     case the stack may not be in its original (signal handler return with
+     R1 pointing at the dummy frame) state.  We do have the ucontext
+     address in R3, so simply copy R3 to R1 before the syscall.  */
+L(do_sigret):
+  mr   r1,r3,
+  li   r0,SYS_ify(rt_sigreturn)
+  sc
+  /* No return.  */
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+  blr
+#endif
+
+PSEUDO_END(__setcontext)
+
+versioned_symbol (libc, __setcontext, setcontext, GLIBC_2_3_4)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/socket.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/socket.S	2002-09-18 01:50:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/socket.S	2004-12-14 22:24:08.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,7 +16,7 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 #define P(a, b) P2(a, b)
@@ -39,19 +39,22 @@
 #define NARGS 3
 #endif
 
-#define stackblock 48 /* offset to parm save area */
+#define stackblock 80 /* offset to socket parm area.  */
 
 #ifndef socket
 /* If this is just socket.S leave it alone! */
 #else
 #ifndef __socket
-#define __socket P(__,socket) 
+#define __socket P(__,socket)
 #endif
 #endif
 
 	.text
 ENTRY(__socket)
-	stdu r1,-112(r1)
+	CALL_MCOUNT NARGS
+	cfi_startproc
+	stdu r1,-144(r1)
+	cfi_adjust_cfa_offset(144)
 #if NARGS >= 1
 	std  r3,stackblock(r1)
 #endif
@@ -79,11 +82,42 @@
 #if NARGS >= 9
 #error too many arguments!
 #endif
-	li	r3,P(SOCKOP_,socket)
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	bne-	.Lsocket_cancel
+#endif
+
+	li    r3,P(SOCKOP_,socket)
+	addi	r4,r1,stackblock
+	DO_CALL(SYS_ify(socketcall))
+	addi	r1,r1,144
+	PSEUDO_RET
+
+#if defined NEED_CANCELLATION && defined CENABLE
+.Lsocket_cancel:
+	mflr	r9
+	std   r9,144+16(r1)
+	cfi_offset (lr, 16)
+	CENABLE
+	std  	r3,72(r1)
+	li	  r3,P(SOCKOP_,socket)
 	addi	r4,r1,stackblock
 	DO_CALL(SYS_ify(socketcall))
-	addi	r1,r1,112
+	mfcr	r0
+	std   r3,64(r1)
+	std   r0,8(r1)
+	ld  	r3,72(r1)
+	CDISABLE
+	ld    r4,144+16(r1)
+	ld    r0,8(r1)
+	ld    r3,64(r1)
+	mtlr	r4
+	mtcr	r0
+	addi	r1,r1,144
 	PSEUDO_RET
+#endif
+	cfi_endproc
 PSEUDO_END (__socket)
 
 weak_alias (__socket, socket)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/swapcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/swapcontext.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/swapcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/swapcontext.S	2005-02-16 12:18:20.000000000 +0100
@@ -0,0 +1,760 @@
+/* Save current context and install the given one.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <rtld-global-offsets.h>
+#include <shlib-compat.h>
+#include "kernel-features.h"
+
+#define __ASSEMBLY__
+#include <asm/ptrace.h>
+#include "ucontext_i.h"
+#include <asm/errno.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3, GLIBC_2_3_4)
+ENTRY(__novec_swapcontext)
+	CALL_MCOUNT 2
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r3)
+  std  r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r3)
+  mflr  r0
+  std   r31,-8(1)
+  std  r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r3)
+  std  r0,FRAME_LR_SAVE(r1)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r3)
+  stdu  r1,-128(r1)
+  std  r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r3)
+  std  r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r3)
+  std  r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r3)
+  std  r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r3)
+  std  r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r3)
+  std  r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r3)
+  std  r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r3)
+  std  r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r3)
+  std  r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r3)
+  std  r13,(SIGCONTEXT_GP_REGS+(PT_R13*8))(r3)
+  std  r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r3)
+  std  r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r3)
+  std  r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r3)
+  std  r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r3)
+  std  r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r3)
+  std  r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r3)
+  std  r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r3)
+  std  r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r3)
+  std  r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r3)
+  std  r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r3)
+  std  r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r3)
+  std  r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r3)
+  std  r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r3)
+  std  r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r3)
+  std  r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r3)
+  std  r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r3)
+  std  r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r3)
+  std  r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r3)
+  mfctr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CTR*8))(r3)
+  mfxer  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r3)
+  mfcr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r3)
+
+  /* Set the return value of swapcontext to "success".  R3 is the only
+     register whose value is not preserved in the saved context.  */
+  li   r0,0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r3)
+
+  /* Zero fill fields that can't be set in user state or are unused.  */
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(34*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_SOFTE*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(40*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(41*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(42*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_RESULT*8))(r3)
+
+  /* Set the PT_REGS pointer to the address of sigcontext gp_regs
+     field.  Struct pt_regs and elf_gregset_t are the same thing.
+     We kept the regs field for backwards compatibility with
+     libraries built before we extended sigcontext.  */
+  addi r0,r3,SIGCONTEXT_GP_REGS
+  std  r0,SIGCONTEXT_PT_REGS(r3)
+
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r3)
+  stfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r3)
+  stfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r3)
+  stfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r3)
+  stfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r3)
+  stfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r3)
+  stfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r3)
+  stfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r3)
+  stfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r3)
+  stfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r3)
+  stfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r3)
+  stfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r3)
+  stfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r3)
+  stfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r3)
+  stfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r3)
+  stfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r3)
+  stfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r3)
+  stfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r3)
+  stfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r3)
+  stfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r3)
+  stfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r3)
+  stfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r3)
+  stfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r3)
+  stfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r3)
+  stfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r3)
+  stfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r3)
+  stfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r3)
+  stfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r3)
+  stfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r3)
+  stfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r3)
+  mffs  fp0
+  stfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r3)
+  stfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r3)
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r3)
+
+  mr    r31,r4
+  addi  r5,r3,UCONTEXT_SIGMASK
+  addi  r4,r4,UCONTEXT_SIGMASK
+  li    r3,SIG_SETMASK
+  bl    JUMPTARGET(__sigprocmask)
+  nop
+  cmpdi  r3,0
+  bne   L(nv_error_exit)
+
+/*
+ * If this new ucontext refers to the point where we were interrupted
+ * by a signal, we have to use the rt_sigreturn system call to
+ * return to the context so we get both LR and CTR restored.
+ *
+ * Otherwise, the context we are restoring is either just after
+ * a procedure call (getcontext/swapcontext) or at the beginning
+ * of a procedure call (makecontext), so we don't need to restore
+ * msr and ctr.  We don't restore r13 since it will be used as
+ * the TLS pointer.  */
+  ld	  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r31)
+  cmpdi r0,0
+  bne	  L(nv_do_sigret)
+
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r31)
+  lfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r31)
+  lfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r31)
+  mtfsf  0xff,fp0
+  lfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r31)
+  lfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r31)
+  lfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r31)
+  lfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r31)
+  lfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r31)
+  lfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r31)
+  lfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r31)
+  lfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r31)
+  lfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r31)
+  lfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r31)
+  lfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r31)
+  lfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r31)
+  lfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r31)
+  lfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r31)
+  lfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r31)
+  lfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r31)
+  lfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r31)
+  lfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r31)
+  lfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r31)
+  lfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r31)
+  lfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r31)
+  lfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r31)
+  lfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r31)
+  lfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r31)
+  lfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r31)
+  lfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r31)
+  lfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r31)
+  lfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r31)
+  lfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r31)
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r31)
+
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r31)
+  ld   r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r31)
+  mtlr r0
+  ld   r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r31)
+  ld   r3,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r31)
+  mtxer r0
+  ld   r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r31)
+  ld   r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r31)
+  mtcr r0
+  ld   r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r31)
+  ld   r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r31)
+  ld   r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r31)
+  ld   r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r31)
+  ld   r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r31)
+  ld   r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r31)
+  ld   r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r31)
+  /* Don't reload the thread ID or TLS pointer (r13).  */
+  ld   r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r31)
+  ld   r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r31)
+  ld   r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r31)
+  ld   r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r31)
+  ld   r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r31)
+  ld   r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r31)
+  ld   r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r31)
+  ld   r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r31)
+  ld   r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r31)
+  ld   r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r31)
+  ld   r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r31)
+  ld   r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r31)
+  ld   r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r31)
+  ld   r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r31)
+  ld   r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r31)
+  ld   r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r31)
+  ld   r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r31)
+
+  /* Now we branch to the "Next Instruction Pointer" from the saved
+     context.  With the powerpc64 instruction set there is no good way to
+     do this (from user state) without clobbering either the LR or CTR.
+     The makecontext and swapcontext functions depend on the callers
+     LR being preserved so we use the CTR.  */
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r31)
+  mtctr r0
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r31)
+  ld   r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r31)
+  bctr
+
+L(nv_error_exit):
+  ld    r0,128+FRAME_LR_SAVE(r1)
+  addi  r1,r1,128
+  mtlr  r0
+  ld    r31,-8(r1)
+  blr
+
+  /* At this point we assume that the ucontext was created by a
+     rt_signal and we should use rt_sigreturn to restore the original
+     state.  As of the 2.4.21 kernel the ucontext is the first thing
+     (offset 0) in the rt_signal frame and rt_sigreturn expects the
+     ucontext address in R1.  Normally the rt-signal trampoline handles
+     this by popping dummy frame before the rt_signal syscall.  In our
+     case the stack may not be in its original (signal handler return with
+     R1 pointing at the dummy frame) state.  We do have the ucontext
+     address in R3, so simply copy R3 to R1 before the syscall.  */
+L(nv_do_sigret):
+  mr   r1,r3,
+  li   r0,SYS_ify(rt_sigreturn)
+  sc
+  /* No return.  */
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+  blr
+#endif
+
+PSEUDO_END(__novec_swapcontext)
+
+compat_symbol (libc, __novec_swapcontext, swapcontext, GLIBC_2_3)
+
+#endif
+
+	.section	".toc","aw"
+.LC__dl_hwcap:
+#ifdef SHARED
+	.tc _rtld_global_ro[TC],_rtld_global_ro
+#else
+	.tc _dl_hwcap[TC],_dl_hwcap
+#endif
+	.section ".text"
+
+	.machine	"altivec"
+ENTRY(__swapcontext)
+	CALL_MCOUNT 2
+#ifdef __ASSUME_NEW_RT_SIGRETURN_SYSCALL
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r3)
+  std  r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r3)
+  mflr  r0
+  std   r31,-8(1)
+  std  r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r3)
+  std  r0,FRAME_LR_SAVE(r1)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r3)
+  stdu  r1,-128(r1)
+  std  r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r3)
+  std  r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r3)
+  std  r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r3)
+  std  r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r3)
+  std  r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r3)
+  std  r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r3)
+  std  r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r3)
+  std  r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r3)
+  std  r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r3)
+  std  r13,(SIGCONTEXT_GP_REGS+(PT_R13*8))(r3)
+  std  r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r3)
+  std  r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r3)
+  std  r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r3)
+  std  r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r3)
+  std  r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r3)
+  std  r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r3)
+  std  r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r3)
+  std  r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r3)
+  std  r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r3)
+  std  r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r3)
+  std  r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r3)
+  std  r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r3)
+  std  r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r3)
+  std  r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r3)
+  std  r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r3)
+  std  r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r3)
+  std  r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r3)
+  std  r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r3)
+  mfctr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CTR*8))(r3)
+  mfxer  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r3)
+  mfcr  r0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r3)
+
+  /* Set the return value of swapcontext to "success".  R3 is the only
+     register whose value is not preserved in the saved context.  */
+  li   r0,0
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r3)
+
+  /* Zero fill fields that can't be set in user state or are unused.  */
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(34*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_SOFTE*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(40*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(41*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(42*8))(r3)
+  std  r0,(SIGCONTEXT_GP_REGS+(PT_RESULT*8))(r3)
+
+  /* Set the PT_REGS pointer to the address of sigcontext gp_regs
+     field.  Struct pt_regs and elf_gregset_t are the same thing.
+     We kept the regs field for backwards compatibility with
+     libraries built before we extended sigcontext.  */
+  addi r0,r3,SIGCONTEXT_GP_REGS
+  std  r0,SIGCONTEXT_PT_REGS(r3)
+
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r3)
+  stfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r3)
+  stfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r3)
+  stfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r3)
+  stfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r3)
+  stfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r3)
+  stfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r3)
+  stfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r3)
+  stfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r3)
+  stfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r3)
+  stfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r3)
+  stfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r3)
+  stfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r3)
+  stfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r3)
+  stfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r3)
+  stfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r3)
+  stfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r3)
+  stfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r3)
+  stfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r3)
+  stfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r3)
+  stfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r3)
+  stfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r3)
+  stfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r3)
+  stfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r3)
+  stfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r3)
+  stfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r3)
+  stfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r3)
+  stfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r3)
+  stfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r3)
+  stfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r3)
+  mffs  fp0
+  stfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r3)
+  stfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r3)
+  stfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r3)
+
+  ld    r8,.LC__dl_hwcap@toc(r2)
+#ifdef SHARED
+/* Load _rtld-global._dl_hwcap.  */
+  ld    r8,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r8)
+#else
+  ld    r8,0(r8) /* Load extern _dl_hwcap.  */
+#endif
+  la    r10,(SIGCONTEXT_V_RESERVE+8)(r3)
+  la    r9,(SIGCONTEXT_V_RESERVE+24)(r3)
+
+  andis.  r8,r8,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+
+  clrrdi  r10,r10,4
+  beq   L(has_no_vec)
+
+  clrrdi  r9,r9,4
+  mr    r8,r10	/* Capture *v_regs value in r5.  */
+
+  stvx  v0,0,r10
+  stvx  v1,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v2,0,r10
+  stvx  v3,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v4,0,r10
+  stvx  v5,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v6,0,r10
+  stvx  v7,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v8,0,r10
+  stvx  v9,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v10,0,r10
+  stvx  v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v12,0,r10
+  stvx  v13,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v14,0,r10
+  stvx  v15,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v16,0,r10
+  stvx  v17,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v18,0,r10
+  stvx  v19,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v20,0,r10
+  stvx  v21,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v22,0,r10
+  stvx  v23,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v24,0,r10
+  stvx  v25,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v26,0,r10
+  stvx  v27,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v28,0,r10
+  stvx  v29,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  stvx  v30,0,r10
+  stvx  v31,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  mfvscr  v0
+  mfspr r0,VRSAVE
+  stvx  v0,0,r10
+  stw   r0,0(r9)
+
+L(has_no_vec):
+/*
+   Store either a NULL or a quadword aligned pointer to the Vector register
+   array into *v_regs.
+*/
+  std   r8,(SIGCONTEXT_V_REGS_PTR)(r3)
+
+  mr    r31,r4
+  addi  r5,r3,UCONTEXT_SIGMASK
+  addi  r4,r4,UCONTEXT_SIGMASK
+  li    r3,SIG_SETMASK
+  bl    JUMPTARGET(__sigprocmask)
+  nop
+  cmpdi  r3,0
+  bne   L(error_exit)
+
+/*
+ * If this new ucontext refers to the point where we were interrupted
+ * by a signal, we have to use the rt_sigreturn system call to
+ * return to the context so we get both LR and CTR restored.
+ *
+ * Otherwise, the context we are restoring is either just after
+ * a procedure call (getcontext/swapcontext) or at the beginning
+ * of a procedure call (makecontext), so we don't need to restore
+ * msr and ctr.  We don't restore r13 since it will be used as
+ * the TLS pointer.  */
+  ld	  r0,(SIGCONTEXT_GP_REGS+(PT_MSR*8))(r31)
+  cmpdi r0,0
+  bne	  L(do_sigret)
+
+  ld    r8,.LC__dl_hwcap@toc(r2)
+  ld    r10,(SIGCONTEXT_V_REGS_PTR)(r31)
+# ifdef SHARED
+/* Load _rtld-global._dl_hwcap.  */
+  ld    r8,RTLD_GLOBAL_RO_DL_HWCAP_OFFSET(r8)
+# else
+  ld    r8,0(r8) /* Load extern _dl_hwcap.  */
+# endif
+  andis.  r8,r8,(PPC_FEATURE_HAS_ALTIVEC >> 16)
+  beq   L(has_no_vec2)
+
+  cmpdi r10,0
+  beq   L(has_no_vec2)
+  lwz   r0,(33*16)(r10)
+
+  li    r9,(16*32)
+  mtspr VRSAVE,r0
+  cmpwi r0,0
+  beq   L(has_no_vec2)
+
+  lvx   v19,r9,r10
+  la    r9,(16)(r10)
+
+  lvx   v0,0,r10
+  lvx   v1,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  mtvscr  v19
+  lvx   v2,0,r10
+  lvx   v3,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v4,0,r10
+  lvx   v5,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v6,0,r10
+  lvx   v7,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v8,0,r10
+  lvx   v9,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v10,0,r10
+  lvx   v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v12,0,r10
+  lvx   v13,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v14,0,r10
+  lvx   v15,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v16,0,r10
+  lvx   v17,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v18,0,r10
+  lvx   v19,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v20,0,r10
+  lvx   v21,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v22,0,r10
+  lvx   v23,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v24,0,r10
+  lvx   v25,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v26,0,r10
+  lvx   v27,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v28,0,r10
+  lvx   v29,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v30,0,r10
+  lvx   v31,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+  lvx   v10,0,r10
+  lvx   v11,0,r9
+  addi  r10,r10,32
+  addi  r9,r9,32
+
+L(has_no_vec2):
+
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(32*8))(r31)
+  lfd  fp31,(SIGCONTEXT_FP_REGS+(PT_R31*8))(r31)
+  lfd  fp30,(SIGCONTEXT_FP_REGS+(PT_R30*8))(r31)
+  mtfsf  0xff,fp0
+  lfd  fp29,(SIGCONTEXT_FP_REGS+(PT_R29*8))(r31)
+  lfd  fp28,(SIGCONTEXT_FP_REGS+(PT_R28*8))(r31)
+  lfd  fp27,(SIGCONTEXT_FP_REGS+(PT_R27*8))(r31)
+  lfd  fp26,(SIGCONTEXT_FP_REGS+(PT_R26*8))(r31)
+  lfd  fp25,(SIGCONTEXT_FP_REGS+(PT_R25*8))(r31)
+  lfd  fp24,(SIGCONTEXT_FP_REGS+(PT_R24*8))(r31)
+  lfd  fp23,(SIGCONTEXT_FP_REGS+(PT_R23*8))(r31)
+  lfd  fp22,(SIGCONTEXT_FP_REGS+(PT_R22*8))(r31)
+  lfd  fp21,(SIGCONTEXT_FP_REGS+(PT_R21*8))(r31)
+  lfd  fp20,(SIGCONTEXT_FP_REGS+(PT_R20*8))(r31)
+  lfd  fp19,(SIGCONTEXT_FP_REGS+(PT_R19*8))(r31)
+  lfd  fp18,(SIGCONTEXT_FP_REGS+(PT_R18*8))(r31)
+  lfd  fp17,(SIGCONTEXT_FP_REGS+(PT_R17*8))(r31)
+  lfd  fp16,(SIGCONTEXT_FP_REGS+(PT_R16*8))(r31)
+  lfd  fp15,(SIGCONTEXT_FP_REGS+(PT_R15*8))(r31)
+  lfd  fp14,(SIGCONTEXT_FP_REGS+(PT_R14*8))(r31)
+  lfd  fp13,(SIGCONTEXT_FP_REGS+(PT_R13*8))(r31)
+  lfd  fp12,(SIGCONTEXT_FP_REGS+(PT_R12*8))(r31)
+  lfd  fp11,(SIGCONTEXT_FP_REGS+(PT_R11*8))(r31)
+  lfd  fp10,(SIGCONTEXT_FP_REGS+(PT_R10*8))(r31)
+  lfd  fp9,(SIGCONTEXT_FP_REGS+(PT_R9*8))(r31)
+  lfd  fp8,(SIGCONTEXT_FP_REGS+(PT_R8*8))(r31)
+  lfd  fp7,(SIGCONTEXT_FP_REGS+(PT_R7*8))(r31)
+  lfd  fp6,(SIGCONTEXT_FP_REGS+(PT_R6*8))(r31)
+  lfd  fp5,(SIGCONTEXT_FP_REGS+(PT_R5*8))(r31)
+  lfd  fp4,(SIGCONTEXT_FP_REGS+(PT_R4*8))(r31)
+  lfd  fp3,(SIGCONTEXT_FP_REGS+(PT_R3*8))(r31)
+  lfd  fp2,(SIGCONTEXT_FP_REGS+(PT_R2*8))(r31)
+  lfd  fp1,(SIGCONTEXT_FP_REGS+(PT_R1*8))(r31)
+  lfd  fp0,(SIGCONTEXT_FP_REGS+(PT_R0*8))(r31)
+
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_LNK*8))(r31)
+  ld   r1,(SIGCONTEXT_GP_REGS+(PT_R1*8))(r31)
+  mtlr r0
+  ld   r2,(SIGCONTEXT_GP_REGS+(PT_R2*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_XER*8))(r31)
+  ld   r3,(SIGCONTEXT_GP_REGS+(PT_R3*8))(r31)
+  mtxer r0
+  ld   r4,(SIGCONTEXT_GP_REGS+(PT_R4*8))(r31)
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_CCR*8))(r31)
+  ld   r5,(SIGCONTEXT_GP_REGS+(PT_R5*8))(r31)
+  ld   r6,(SIGCONTEXT_GP_REGS+(PT_R6*8))(r31)
+  ld   r7,(SIGCONTEXT_GP_REGS+(PT_R7*8))(r31)
+  ld   r8,(SIGCONTEXT_GP_REGS+(PT_R8*8))(r31)
+  ld   r9,(SIGCONTEXT_GP_REGS+(PT_R9*8))(r31)
+  mtcr r0
+  ld   r10,(SIGCONTEXT_GP_REGS+(PT_R10*8))(r31)
+  ld   r11,(SIGCONTEXT_GP_REGS+(PT_R11*8))(r31)
+  ld   r12,(SIGCONTEXT_GP_REGS+(PT_R12*8))(r31)
+  /* Don't reload the thread ID or TLS pointer (r13).  */
+  ld   r14,(SIGCONTEXT_GP_REGS+(PT_R14*8))(r31)
+  ld   r15,(SIGCONTEXT_GP_REGS+(PT_R15*8))(r31)
+  ld   r16,(SIGCONTEXT_GP_REGS+(PT_R16*8))(r31)
+  ld   r17,(SIGCONTEXT_GP_REGS+(PT_R17*8))(r31)
+  ld   r18,(SIGCONTEXT_GP_REGS+(PT_R18*8))(r31)
+  ld   r19,(SIGCONTEXT_GP_REGS+(PT_R19*8))(r31)
+  ld   r20,(SIGCONTEXT_GP_REGS+(PT_R20*8))(r31)
+  ld   r21,(SIGCONTEXT_GP_REGS+(PT_R21*8))(r31)
+  ld   r22,(SIGCONTEXT_GP_REGS+(PT_R22*8))(r31)
+  ld   r23,(SIGCONTEXT_GP_REGS+(PT_R23*8))(r31)
+  ld   r24,(SIGCONTEXT_GP_REGS+(PT_R24*8))(r31)
+  ld   r25,(SIGCONTEXT_GP_REGS+(PT_R25*8))(r31)
+  ld   r26,(SIGCONTEXT_GP_REGS+(PT_R26*8))(r31)
+  ld   r27,(SIGCONTEXT_GP_REGS+(PT_R27*8))(r31)
+  ld   r28,(SIGCONTEXT_GP_REGS+(PT_R28*8))(r31)
+  ld   r29,(SIGCONTEXT_GP_REGS+(PT_R29*8))(r31)
+  ld   r30,(SIGCONTEXT_GP_REGS+(PT_R30*8))(r31)
+
+  /* Now we branch to the "Next Instruction Pointer" from the saved
+     context.  With the powerpc64 instruction set there is no good way to
+     do this (from user state) without clobbering either the LR or CTR.
+     The makecontext and swapcontext functions depend on the callers
+     LR being preserved so we use the CTR.  */
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_NIP*8))(r31)
+  mtctr r0
+  ld   r0,(SIGCONTEXT_GP_REGS+(PT_R0*8))(r31)
+  ld   r31,(SIGCONTEXT_GP_REGS+(PT_R31*8))(r31)
+  bctr
+
+L(error_exit):
+  ld    r0,128+FRAME_LR_SAVE(r1)
+  addi  r1,r1,128
+  mtlr  r0
+  ld    r31,-8(r1)
+  blr
+
+  /* At this point we assume that the ucontext was created by a
+     rt_signal and we should use rt_sigreturn to restore the original
+     state.  As of the 2.4.21 kernel the ucontext is the first thing
+     (offset 0) in the rt_signal frame and rt_sigreturn expects the
+     ucontext address in R1.  Normally the rt-signal trampoline handles
+     this by popping dummy frame before the rt_signal syscall.  In our
+     case the stack may not be in its original (signal handler return with
+     R1 pointing at the dummy frame) state.  We do have the ucontext
+     address in R3, so simply copy R3 to R1 before the syscall.  */
+L(do_sigret):
+  mr   r1,r3,
+  li   r0,SYS_ify(rt_sigreturn)
+  sc
+  /* No return.  */
+#else
+  /* If the kernel is not at least 2.4.21 then generate a ENOSYS stub.  */
+  mflr r0
+  std  r0,FRAME_LR_SAVE(r1)
+  stdu r1,-128(r1)
+  li   r3,ENOSYS
+  bl   JUMPTARGET(__syscall_error)
+  nop
+  li   r3,-1
+  ld   r0,128+FRAME_LR_SAVE(r1)
+  addi r1,r1,128
+  mtlr r0
+  blr
+#endif
+
+PSEUDO_END(__swapcontext)
+
+versioned_symbol (libc, __swapcontext, swapcontext, GLIBC_2_3_4)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/syscalls.list
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/syscalls.list	2002-09-18 01:50:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/syscalls.list	2004-03-24 00:25:52.000000000 +0100
@@ -1,52 +1,3 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
-# System calls with wrappers.
-s_ioctl		ioctl	ioctl		i:iiI	__syscall_ioctl
-s_ipc		msgget	ipc		i:iiiip	__syscall_ipc
-s_llseek	llseek	_llseek		i:iiipi	__syscall__llseek
-s_readahead	readahead readahead	i:iiii	__syscall_readahead
-s_chown		chown	chown		i:sii	__syscall_chown
-s_execve	execve	execve		i:spp	__syscall_execve
-rt_sigaction	-	rt_sigaction	i:ippi	__syscall_rt_sigaction
-rt_sigpending	-	rt_sigpending	i:pi	__syscall_rt_sigpending
-rt_sigprocmask	-	rt_sigprocmask	i:ippi	__syscall_rt_sigprocmask
-rt_sigqueueinfo	-	rt_sigqueueinfo	i:iip	__syscall_rt_sigqueueinfo
-rt_sigsuspend	-	rt_sigsuspend	i:pi	__syscall_rt_sigsuspend
-rt_sigtimedwait	-	rt_sigtimedwait	i:pppi	__syscall_rt_sigtimedwait
-s_fcntl		fcntl 	fcntl		i:iiF	__syscall_fcntl
-s_fcntl64	fcntl64	fcntl64		i:iiF	__syscall_fcntl64
-s_fstat64	fxstat64 fstat64	i:ip	__syscall_fstat64
-s_ftruncate64	ftruncate64 ftruncate64	i:iii	__syscall_ftruncate64
-s_getcwd	getcwd	getcwd		i:pi	__syscall_getcwd
-s_getdents	getdents getdents	i:ipi	__syscall_getdents
-s_getdents64	getdents getdents64	i:ipi	__syscall_getdents64
-s_getpmsg	getpmsg	getpmsg		i:ipppp	__syscall_getpmsg
-s_getpriority	getpriority getpriority	i:ii	__syscall_getpriority
-getresgid	-	getresgid	i:ppp	getresgid
-getresuid	-	getresuid	i:ppp	getresuid
-s_getrlimit	getrlimit getrlimit	i:ip	__syscall_getrlimit
-s_lstat64	lxstat64 lstat64	i:sp	__syscall_lstat64
-s_mmap2		mmap64	mmap2		b:aniiii __syscall_mmap2
-s_poll		poll	poll		i:pii	__syscall_poll
-s_pread64	pread64	pread		i:ibnii	__syscall_pread
-s_ptrace	ptrace	ptrace		i:iipp	__syscall_ptrace
-s_putpmsg	putpmsg	putpmsg		i:ippii	__syscall_putpmsg
-s_pwrite64	pwrite64 pwrite		i:ibnii	__syscall_pwrite
-s_reboot	reboot	reboot		i:iii	__syscall_reboot
-s_setrlimit	setrlimit setrlimit	i:ip	__syscall_setrlimit
-s_sigaction	sigaction sigaction	i:ipp	__syscall_sigaction
-s_sigpending	sigpending sigpending	i:p	__syscall_sigpending
-s_sigprocmask	sigprocmask sigprocmask	i:ipp	__syscall_sigprocmask
-s_sigsuspend	sigsuspend sigsuspend	i:iii	__syscall_sigsuspend
-s_stat64	xstat64 stat64		i:sp	__syscall_stat64
-s_sysctl	sysctl	_sysctl		i:p	__syscall__sysctl
-s_truncate64	truncate64 truncate64	i:sii	__syscall_truncate64
-s_ugetrlimit	getrlimit ugetrlimit	i:ip	__syscall_ugetrlimit
-s_ustat		ustat	ustat		i:ip	__syscall_ustat
-s_vfork		vfork	vfork		i:	__syscall_vfork
-sys_fstat	fxstat	fstat		i:ip	__syscall_fstat
-sys_lstat	lxstat	lstat		i:sp	__syscall_lstat
-sys_mknod	xmknod	mknod		i:pii	__syscall_mknod
-sys_readv	readv	readv		i:ipi	__syscall_readv
-sys_stat	xstat	stat		i:sp	__syscall_stat
-sys_writev	writev	writev		i:ipi	__syscall_writev
+getrlimit	-	ugetrlimit	i:ip	__getrlimit	getrlimit getrlimit64
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep.h
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep.h	2002-09-29 19:46:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep.h	2004-09-20 01:46:31.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002
+/* Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,7 +16,7 @@
    License along with the GNU C Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
-		
+
 /* Alan Modra <amodra@bigpond.net.au> rewrote the INLINE_SYSCALL macro */
 
 #ifndef _LINUX_POWERPC_SYSDEP_H
@@ -29,6 +29,24 @@
 #include <errno.h>
 #endif
 
+/* Some systen calls got renamed over time, but retained the same semantics.
+   Handle them here so they can be catched by both C and assembler stubs in
+   glibc.  */
+
+#ifdef __NR_pread64
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#ifdef __NR_pwrite64
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
    of the kernel.  But these symbols do not follow the SYS_* syntax
@@ -51,121 +69,108 @@
 #endif	/* __ASSEMBLER__ */
 
 #undef INLINE_SYSCALL
-#if 1
-#define INLINE_SYSCALL(name, nr, args...)	\
-  ({						\
-    DECLARGS_##nr;				\
-    long ret, err;				\
-    LOADARGS_##nr(name, args);			\
-    __asm __volatile ("sc\n\t"			\
-		      "mfcr	%1\n\t"		\
-		      : "=r" (r3), "=r" (err)	\
-		      : ASM_INPUT_##nr		\
-		      : "cc", "memory");	\
-    ret = r3;					\
-    if (err & 1 << 28)				\
-      {						\
-	__set_errno (ret);			\
-	ret = -1L;				\
-      }						\
-    ret;					\
-  })
-
-#define DECLARGS_0 register long r0 __asm__ ("r0");	\
-		   register long r3 __asm__ ("r3")
-#define DECLARGS_1 DECLARGS_0
-#define DECLARGS_2 DECLARGS_1; register long r4 __asm__ ("r4")
-#define DECLARGS_3 DECLARGS_2; register long r5 __asm__ ("r5")
-#define DECLARGS_4 DECLARGS_3; register long r6 __asm__ ("r6")
-#define DECLARGS_5 DECLARGS_4; register long r7 __asm__ ("r7")
-#define DECLARGS_6 DECLARGS_5; register long r8 __asm__ ("r8")
-
-#define LOADARGS_0(name) \
-	r0 = __NR_##name
-#define LOADARGS_1(name, arg1) \
-	LOADARGS_0(name); \
-	r3 = (long) (arg1)
-#define LOADARGS_2(name, arg1, arg2) \
-	LOADARGS_1(name, arg1); \
-	r4 = (long) (arg2)
-#define LOADARGS_3(name, arg1, arg2, arg3) \
-	LOADARGS_2(name, arg1, arg2); \
-	r5 = (long) (arg3)
-#define LOADARGS_4(name, arg1, arg2, arg3, arg4) \
-	LOADARGS_3(name, arg1, arg2, arg3); \
-	r6 = (long) (arg4)
-#define LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5) \
-	LOADARGS_4(name, arg1, arg2, arg3, arg4); \
-	r7 = (long) (arg5)
-#define LOADARGS_6(name, arg1, arg2, arg3, arg4, arg5, arg6) \
-	LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5); \
-	r8 = (long) (arg6)
-
-#define ASM_INPUT_0 "r" (r0)
-#define ASM_INPUT_1 ASM_INPUT_0, "0" (r3)
-#define ASM_INPUT_2 ASM_INPUT_1, "r" (r4)
-#define ASM_INPUT_3 ASM_INPUT_2, "r" (r5)
-#define ASM_INPUT_4 ASM_INPUT_3, "r" (r6)
-#define ASM_INPUT_5 ASM_INPUT_4, "r" (r7)
-#define ASM_INPUT_6 ASM_INPUT_5, "r" (r8)
 
-#else
 /* This version is for kernels that implement system calls that
    behave like function calls as far as register saving.  */
-#define INLINE_SYSCALL(name, nr, args...)			\
-  ({								\
-    register long r0 __asm__ ("r0");				\
-    register long r3 __asm__ ("r3");				\
-    register long r4 __asm__ ("r4");				\
-    register long r5 __asm__ ("r5");				\
-    register long r6 __asm__ ("r6");				\
-    register long r7 __asm__ ("r7");				\
-    register long r8 __asm__ ("r8");				\
-    long ret, err;						\
-    LOADARGS_##nr(name, args);					\
-    __asm __volatile ("sc\n\t"					\
-		      "mfcr	%7\n\t"				\
-		      : "=r" (r0), "=r" (r3), "=r" (r4),	\
-		        "=r" (r5), "=r" (r6), "=r" (r7),	\
-		        "=r" (r8), "=r" (err)			\
-		      : ASM_INPUT_##nr				\
-		      : "r9", "r10", "r11", "r12",		\
-		        "fr0", "fr1", "fr2", "fr3",		\
-			"fr4", "fr5", "fr6", "fr7",		\
-			"fr8", "fr9", "fr10", "fr11",		\
-			"fr12", "fr13",				\
-			"ctr", "lr",				\
-			"cr0", "cr1", "cr5", "cr6", "cr7",	\
-			"memory");				\
-    ret = r3;							\
-    if (err & 1 << 28)						\
-      {								\
-	__set_errno (ret);					\
-	ret = -1L;						\
-      }								\
-    ret;							\
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({									\
+    INTERNAL_SYSCALL_DECL (sc_err);					\
+    long int sc_ret = INTERNAL_SYSCALL (name, sc_err, nr, args);	\
+    if (INTERNAL_SYSCALL_ERROR_P (sc_ret, sc_err))			\
+      {									\
+        __set_errno (INTERNAL_SYSCALL_ERRNO (sc_ret, sc_err));		\
+        sc_ret = -1L;							\
+      }									\
+    sc_ret;								\
+  })
+
+/* Define a macro which expands inline into the wrapper code for a system
+   call. This use is for internal calls that do not need to handle errors
+   normally. It will never touch errno. This returns just what the kernel
+   gave back in the non-error (CR0.SO cleared) case, otherwise (CR0.SO set)
+   the negation of the return value in the kernel gets reverted.  */
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									\
+    register long int r0  __asm__ ("r0");				\
+    register long int r3  __asm__ ("r3");				\
+    register long int r4  __asm__ ("r4");				\
+    register long int r5  __asm__ ("r5");				\
+    register long int r6  __asm__ ("r6");				\
+    register long int r7  __asm__ ("r7");				\
+    register long int r8  __asm__ ("r8");				\
+    LOADARGS_##nr(name, args);						\
+    __asm__ __volatile__						\
+      ("sc\n\t"								\
+       "mfcr  %0\n\t"							\
+       "0:"								\
+       : "=&r" (r0),							\
+         "=&r" (r3), "=&r" (r4), "=&r" (r5),				\
+         "=&r" (r6), "=&r" (r7), "=&r" (r8)				\
+       : ASM_INPUT_##nr							\
+       : "r9", "r10", "r11", "r12",					\
+         "cr0", "ctr", "memory");					\
+	  err = r0;  \
+    (int) r3;  \
   })
+#define INTERNAL_SYSCALL(name, err, nr, args...)			\
+  INTERNAL_SYSCALL_NCS (__NR_##name, err, nr, ##args)
 
-#define LOADARGS_0(name) \
-	r0 = __NR_##name
-#define LOADARGS_1(name, arg1) \
-	LOADARGS_0(name); \
-	r3 = (long) (arg1)
-#define LOADARGS_2(name, arg1, arg2) \
-	LOADARGS_1(name, arg1); \
-	r4 = (long) (arg2)
-#define LOADARGS_3(name, arg1, arg2, arg3) \
-	LOADARGS_2(name, arg1, arg2); \
-	r5 = (long) (arg3)
-#define LOADARGS_4(name, arg1, arg2, arg3, arg4) \
-	LOADARGS_3(name, arg1, arg2, arg3); \
-	r6 = (long) (arg4)
-#define LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5) \
-	LOADARGS_4(name, arg1, arg2, arg3, arg4); \
-	r7 = (long) (arg5)
-#define LOADARGS_6(name, arg1, arg2, arg3, arg4, arg5, arg6) \
-	LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5); \
-	r8 = (long) (arg6)
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) long int err
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  (__builtin_expect (err & (1 << 28), 0))
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+#define LOADARGS_0(name, dummy) \
+	r0 = name
+#define LOADARGS_1(name, __arg1) \
+	long int arg1 = (long int) (__arg1); \
+	LOADARGS_0(name, 0); \
+	extern void __illegally_sized_syscall_arg1 (void); \
+	if (__builtin_classify_type (__arg1) != 5 && sizeof (__arg1) > 8) \
+	  __illegally_sized_syscall_arg1 (); \
+	r3 = arg1
+#define LOADARGS_2(name, __arg1, __arg2) \
+	long int arg2 = (long int) (__arg2); \
+	LOADARGS_1(name, __arg1); \
+	extern void __illegally_sized_syscall_arg2 (void); \
+	if (__builtin_classify_type (__arg2) != 5 && sizeof (__arg2) > 8) \
+	  __illegally_sized_syscall_arg2 (); \
+	r4 = arg2
+#define LOADARGS_3(name, __arg1, __arg2, __arg3) \
+	long int arg3 = (long int) (__arg3); \
+	LOADARGS_2(name, __arg1, __arg2); \
+	extern void __illegally_sized_syscall_arg3 (void); \
+	if (__builtin_classify_type (__arg3) != 5 && sizeof (__arg3) > 8) \
+	  __illegally_sized_syscall_arg3 (); \
+	r5 = arg3
+#define LOADARGS_4(name, __arg1, __arg2, __arg3, __arg4) \
+	long int arg4 = (long int) (__arg4); \
+	LOADARGS_3(name, __arg1, __arg2, __arg3); \
+	extern void __illegally_sized_syscall_arg4 (void); \
+	if (__builtin_classify_type (__arg4) != 5 && sizeof (__arg4) > 8) \
+	  __illegally_sized_syscall_arg4 (); \
+	r6 = arg4
+#define LOADARGS_5(name, __arg1, __arg2, __arg3, __arg4, __arg5) \
+	long int arg5 = (long int) (__arg5); \
+	LOADARGS_4(name, __arg1, __arg2, __arg3, __arg4); \
+	extern void __illegally_sized_syscall_arg5 (void); \
+	if (__builtin_classify_type (__arg5) != 5 && sizeof (__arg5) > 8) \
+	  __illegally_sized_syscall_arg5 (); \
+	r7 = arg5
+#define LOADARGS_6(name, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6) \
+	long int arg6 = (long int) (__arg6); \
+	LOADARGS_5(name, __arg1, __arg2, __arg3, __arg4, __arg5); \
+	extern void __illegally_sized_syscall_arg6 (void); \
+	if (__builtin_classify_type (__arg6) != 5 && sizeof (__arg6) > 8) \
+	  __illegally_sized_syscall_arg6 (); \
+	r8 = arg6
 
 #define ASM_INPUT_0 "0" (r0)
 #define ASM_INPUT_1 ASM_INPUT_0, "1" (r3)
@@ -175,6 +180,4 @@
 #define ASM_INPUT_5 ASM_INPUT_4, "5" (r7)
 #define ASM_INPUT_6 ASM_INPUT_5, "6" (r8)
 
-#endif
-
 #endif /* linux/powerpc/powerpc64/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/ucontext_i.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/ucontext_i.h
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/ucontext_i.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/ucontext_i.h	2004-01-16 05:49:59.000000000 +0100
@@ -0,0 +1,60 @@
+/* Offsets and other constants needed in the *context() function
+   implementation.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIG_BLOCK	0
+#define SIG_SETMASK	2
+
+/* Offsets of the fields in the powerpc64 ABI stack frame.  */
+
+#define FRAME_BACKCHAIN 0
+#define FRAME_CR_SAVE 8
+#define FRAME_LR_SAVE 16
+#define FRAME_COMPILER_DW 24
+#define FRAME_LINKER_DW 32
+#define FRAME_TOC_SAVE 40
+#define FRAME_PARM_SAVE 48
+#define FRAME_PARM1_SAVE 48
+#define FRAME_PARM2_SAVE 56
+#define FRAME_PARM3_SAVE 64
+#define FRAME_PARM4_SAVE 72
+#define FRAME_PARM5_SAVE 80
+#define FRAME_PARM6_SAVE 88
+#define FRAME_PARM7_SAVE 96
+#define FRAME_PARM8_SAVE 104
+#define FRAME_PARM9_SAVE 112
+
+
+/* Offsets of the fields in the ucontext_t structure.  */
+
+#define UCONTEXT_LINK 8
+#define UCONTEXT_STACK 16
+#define UCONTEXT_STACK_SP 16
+#define UCONTEXT_STACK_FLAGS 24
+#define UCONTEXT_STACK_SIZE 32
+#define UCONTEXT_SIGMASK 40
+#define UCONTEXT_MCONTEXT 168
+#define SIGCONTEXT_SIGNAL 200
+#define SIGCONTEXT_HANDLER 208
+#define SIGCONTEXT_OLDMASK 216
+#define SIGCONTEXT_PT_REGS 224
+#define SIGCONTEXT_GP_REGS 232
+#define SIGCONTEXT_FP_REGS 616
+#define SIGCONTEXT_V_REGS_PTR 880
+#define SIGCONTEXT_V_RESERVE 888
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/umount.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/umount.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/umount.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/umount.c	2004-04-09 20:21:54.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/hppa/umount.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Versions
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/Versions	2002-10-02 10:53:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/Versions	2004-01-16 05:45:45.000000000 +0100
@@ -14,4 +14,9 @@
     # s*
     scandir64; 
   }
+  GLIBC_2.3.4 {
+    getcontext;
+    setcontext; 
+    swapcontext;
+  }
 }
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S	2004-12-14 22:24:08.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <kernel-features.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+	CALL_MCOUNT 0
+
+#ifdef __NR_vfork
+
+	DO_CALL (SYS_ify (vfork))
+
+# ifdef __ASSUME_VFORK_SYSCALL
+	PSEUDO_RET
+# else
+	bnslr+
+	/* Check if vfork syscall is known at all.  */
+	cmpdi	r3,ENOSYS
+	bne	JUMPTARGET(__syscall_error)
+
+# endif
+#endif
+
+#ifndef __ASSUME_VFORK_SYSCALL
+	/* If we don't have vfork, fork is close enough.  */
+
+	DO_CALL (SYS_ify (fork))
+	PSEUDO_RET
+#endif
+
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/powerpc/powerpc64/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/xstat64.c
--- sysdeps/unix/sysv/linux/powerpc/powerpc64/xstat64.c	2002-10-02 10:33:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/powerpc64/xstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* xstat64 is in xstat.c */
diff -Nur sysdeps/unix/sysv/linux/powerpc/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pread64.c
--- sysdeps/unix/sysv/linux/powerpc/pread64.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pread64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#ifdef __NR_pread
-
-extern ssize_t __syscall_pread (int fd, void *buf, size_t count,
-				off64_t offset);
-
-static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
-				  off64_t offset) internal_function;
-
-
-ssize_t
-__libc_pread64 (fd, buf, count, offset)
-     int fd;
-     void *buf;
-     size_t count;
-     off64_t offset;
-{
-  ssize_t result;
-
-  /* First try the syscall.  */
-  result = __syscall_pread (fd, buf, count, offset);
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use the emulation.  */
-    result = __emulate_pread64 (fd, buf, count, offset);
-
-  return result;
-}
-
-weak_alias (__libc_pread64, __pread64)
-weak_alias (__libc_pread64, pread64)
-
-#define __libc_pread64(fd, buf, count, offset) \
-     static internal_function __emulate_pread64 (fd, buf, count, offset)
-#endif
-#include <sysdeps/posix/pread64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pread.c
--- sysdeps/unix/sysv/linux/powerpc/pread.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pread.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#ifdef __NR_pread
-
-extern ssize_t __syscall_pread (int fd, void *buf, size_t count,
-				off64_t offset);
-
-static ssize_t __emulate_pread (int fd, void *buf, size_t count,
-				off_t offset) internal_function;
-
-
-ssize_t
-__libc_pread (fd, buf, count, offset)
-     int fd;
-     void *buf;
-     size_t count;
-     off_t offset;
-{
-  ssize_t result;
-
-  /* First try the syscall.  */
-  result = __syscall_pread (fd, buf, count, (off64_t) offset);
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use the emulation.  */
-    result = __emulate_pread (fd, buf, count, offset);
-
-  return result;
-}
-
-strong_alias (__libc_pread, __pread)
-weak_alias (__libc_pread, pread)
-
-#define __libc_pread(fd, buf, count, offset) \
-     static internal_function __emulate_pread (fd, buf, count, offset)
-#endif
-#include <sysdeps/posix/pread.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/putpmsg.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/putpmsg.c
--- sysdeps/unix/sysv/linux/powerpc/putpmsg.c	1999-12-21 17:01:29.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/putpmsg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/putpmsg.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pwrite64.c
--- sysdeps/unix/sysv/linux/powerpc/pwrite64.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#ifdef __NR_pwrite
-
-extern ssize_t __syscall_pwrite (int fd, const void *buf, size_t count,
-				   off64_t offset);
-
-static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
-				   off64_t offset) internal_function;
-
-
-ssize_t
-__libc_pwrite64 (fd, buf, count, offset)
-     int fd;
-     const void *buf;
-     size_t count;
-     off64_t offset;
-{
-  ssize_t result;
-
-  /* First try the syscall.  */
-  result = __syscall_pwrite (fd, buf, count, offset);
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use the emulation.  */
-    result = __emulate_pwrite64 (fd, buf, count, offset);
-
-  return result;
-}
-
-weak_alias (__libc_pwrite64, __pwrite64)
-libc_hidden_def (__pwrite64)
-weak_alias (__libc_pwrite64, pwrite64)
-
-#define __libc_pwrite64(fd, buf, count, offset) \
-     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
-#endif
-#include <sysdeps/posix/pwrite64.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pwrite.c
--- sysdeps/unix/sysv/linux/powerpc/pwrite.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/pwrite.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#ifdef __NR_pwrite
-
-extern ssize_t __syscall_pwrite (int fd, const void *buf, size_t count,
-				   off64_t offset);
-
-static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
-				 off_t offset) internal_function;
-
-
-ssize_t
-__libc_pwrite (fd, buf, count, offset)
-     int fd;
-     const void *buf;
-     size_t count;
-     off_t offset;
-{
-  ssize_t result;
-
-  /* First try the syscall.  */
-  result = __syscall_pwrite (fd, buf, count, (off64_t) offset);
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use the emulation.  */
-    result = __emulate_pwrite (fd, buf, count, offset);
-
-  return result;
-}
-
-strong_alias (__libc_pwrite, __pwrite)
-weak_alias (__libc_pwrite, pwrite)
-
-#define __libc_pwrite(fd, buf, count, offset) \
-     static internal_function __emulate_pwrite (fd, buf, count, offset)
-#endif
-#include <sysdeps/posix/pwrite.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/rt-sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/rt-sysdep.c
--- sysdeps/unix/sysv/linux/powerpc/rt-sysdep.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/rt-sysdep.c	2004-04-19 08:18:21.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdep.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/sys/procfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sys/procfs.h
--- sysdeps/unix/sysv/linux/powerpc/sys/procfs.h	2002-01-17 18:37:24.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sys/procfs.h	2003-12-18 00:09:34.000000000 +0100
@@ -32,6 +32,10 @@
 
 __BEGIN_DECLS
 
+/* These definitions are normally provided by ucontext.h via 
+   asm/sigcontext.h, asm/ptrace.h, and asm/elf.h.  Otherwise we define 
+   them here.  */ 
+#ifndef __PPC64_ELF_H
 #define ELF_NGREG       48      /* includes nip, msr, lr, etc. */
 #define ELF_NFPREG      33      /* includes fpscr */
 #define ELF_NVRREG      33      /* includes vscr */
@@ -52,6 +56,7 @@
 /* Altivec registers */
 typedef __uint128_t elf_vrreg_t;
 typedef elf_vrreg_t elf_vrregset_t[ELF_NVRREG];
+#endif
 
 struct elf_siginfo
   {
diff -Nur sysdeps/unix/sysv/linux/powerpc/sys/ucontext.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sys/ucontext.h
--- sysdeps/unix/sysv/linux/powerpc/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sys/ucontext.h	2004-01-16 05:44:35.000000000 +0100
@@ -0,0 +1,179 @@
+/* Copyright (C) 1998, 1999, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+#if __WORDSIZE == 32
+
+/* Number of general registers.  */
+# define NGREG	48
+
+/* Container for all general registers.  */
+typedef unsigned long gregset_t[NGREG];
+
+/* Container for floating-point registers and status */
+typedef struct _libc_fpstate
+{
+	double fpregs[32];
+	double fpscr;
+	unsigned int _pad[2];
+} fpregset_t;
+
+/* Container for Altivec/VMX registers and status.
+   Needs to be aligned on a 16-byte boundary. */
+typedef struct _libc_vrstate
+{
+	unsigned int vrregs[32][4];
+	unsigned int vrsave;
+	unsigned int _pad[2];
+	unsigned int vscr;
+} vrregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+{
+	gregset_t gregs;
+	fpregset_t fpregs;
+	vrregset_t vrregs __attribute__((__aligned__(16)));
+} mcontext_t;
+
+#else
+
+/* For 64-bit kernels with Altivec support, a machine context is exactly 
+ * a sigcontext.  For older kernel (without Altivec) the sigcontext matches 
+ * the mcontext upto but not including the v_regs field.  For kernels that 
+ * don't AT_HWCAP or return AT_HWCAP without PPC_FEATURE_HAS_ALTIVEC the 
+ * v_regs field may not exit and should not be referenced.  The v_regd field
+ * can be refernced safely only after verifying that PPC_FEATURE_HAS_ALTIVEC
+ * is set in AT_HWCAP.  */
+    
+# include <asm/types.h>
+
+/* Number of general registers.  */
+# define NGREG	48	/* includes r0-r31, nip, msr, lr, etc.   */
+# define NFPREG	33	/* includes fp0-fp31 &fpscr.  */
+# define NVRREG	34	/* includes v0-v31, vscr, & vrsave in split vectors */
+
+typedef unsigned long gregset_t[NGREG];
+typedef double fpregset_t[NFPREG];
+
+/* Container for Altivec/VMX Vector Status and Control Register.  Only 32-bits
+   but can only be copied to/from a 128-bit vector register.  So we allocated 
+   a whole quadword speedup save/restore.  */
+typedef struct _libc_vscr
+{
+	unsigned int __pad[3];
+	unsigned int vscr_word;
+} vscr_t;
+
+/* Container for Altivec/VMX registers and status.
+   Must to be aligned on a 16-byte boundary. */
+typedef struct _libc_vrstate
+{
+	unsigned int	vrregs[32][4];
+	vscr_t		vscr;
+	unsigned int	vrsave;
+	unsigned int	__pad[3];
+} vrregset_t  __attribute__((__aligned__(16)));
+
+typedef struct {
+	unsigned long	__unused[4];
+	int		signal;
+	int		__pad0;
+	unsigned long	handler;
+	unsigned long	oldmask;
+	struct pt_regs	*regs;
+	gregset_t	gp_regs;
+	fpregset_t	fp_regs;
+/*
+ * To maintain compatibility with current implementations the sigcontext is 
+ * extended by appending a pointer (v_regs) to a quadword type (elf_vrreg_t) 
+ * followed by an unstructured (vmx_reserve) field of 69 doublewords.  This 
+ * allows the array of vector registers to be quadword aligned independent of 
+ * the alignment of the containing sigcontext or ucontext. It is the 
+ * responsibility of the code setting the sigcontext to set this pointer to 
+ * either NULL (if this processor does not support the VMX feature) or the 
+ * address of the first quadword within the allocated (vmx_reserve) area.
+ *
+ * The pointer (v_regs) of vector type (elf_vrreg_t) is essentually  
+ * an array of 34 quadword entries.  The entries with 
+ * indexes 0-31 contain the corresponding vector registers.  The entry with 
+ * index 32 contains the vscr as the last word (offset 12) within the 
+ * quadword.  This allows the vscr to be stored as either a quadword (since 
+ * it must be copied via a vector register to/from storage) or as a word.  
+ * The entry with index 33 contains the vrsave as the first word (offset 0) 
+ * within the quadword.
+ */
+	vrregset_t	*v_regs;
+	long		vmx_reserve[NVRREG+NVRREG+1];
+} mcontext_t;
+
+#endif
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+#if __WORDSIZE == 32
+    /*
+     * These fields are set up this way to maximize source and
+     * binary compatibility with code written for the old
+     * ucontext_t definition, which didn't include space for the
+     * registers.
+     *
+     * Different versions of the kernel have stored the registers on
+     * signal delivery at different offsets from the ucontext struct.
+     * Programs should thus use the uc_mcontext.uc_regs pointer to
+     * find where the registers are actually stored.  The registers
+     * will be stored within the ucontext_t struct but not necessarily
+     * at a fixed address.  As a side-effect, this lets us achieve
+     * 16-byte alignment for the register storage space if the
+     * Altivec registers are to be saved, without requiring 16-byte
+     * alignment on the whole ucontext_t.
+     *
+     * The uc_mcontext.regs field is included for source compatibility
+     * with programs written against the older ucontext_t definition,
+     * and its name should therefore not change.  The uc_pad field
+     * is for binary compatibility with programs compiled against the
+     * old ucontext_t; it ensures that uc_mcontext.regs and uc_sigmask
+     * are at the same offset as previously.
+     */
+    int uc_pad[7];
+    union uc_regs_ptr {
+      struct pt_regs *regs;
+      mcontext_t *uc_regs;
+    } uc_mcontext;
+    sigset_t    uc_sigmask;
+    char uc_reg_space[sizeof(mcontext_t) + 12];  /* last for extensibility */
+#else /* 64-bit */
+    sigset_t    uc_sigmask;
+    mcontext_t  uc_mcontext;  /* last for extensibility */
+#endif
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -Nur sysdeps/unix/sysv/linux/powerpc/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/syscall.S
--- sysdeps/unix/sysv/linux/powerpc/syscall.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/syscall.S	2003-01-12 20:37:36.000000000 +0100
@@ -25,6 +25,7 @@
 	mr   r5,r6
 	mr   r6,r7
 	mr   r7,r8
+	mr   r8,r9
 	sc
 	PSEUDO_RET
 PSEUDO_END (syscall)
diff -Nur sysdeps/unix/sysv/linux/powerpc/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/syscalls.list
--- sysdeps/unix/sysv/linux/powerpc/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/syscalls.list	2003-09-03 04:55:30.000000000 +0200
@@ -0,0 +1,3 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+waitpid		-	waitpid		Ci:ipi	__waitpid	waitpid	__libc_waitpid
diff -Nur sysdeps/unix/sysv/linux/powerpc/sysdep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sysdep.c
--- sysdeps/unix/sysv/linux/powerpc/sysdep.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/sysdep.c	2002-10-11 12:51:16.000000000 +0200
@@ -27,8 +27,3 @@
   __set_errno (err_no);
   return -1;
 }
-
-/* We also have to have a 'real' definition of errno.  */
-#undef errno
-int errno = 0;
-weak_alias (errno, _errno)
diff -Nur sysdeps/unix/sysv/linux/powerpc/tcgetattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/tcgetattr.c
--- sysdeps/unix/sysv/linux/powerpc/tcgetattr.c	1998-10-15 00:36:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/tcgetattr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-/* We must use __syscall_ioctl since __ioctl does some extra work.  */
-extern int __syscall_ioctl (int __fd, unsigned long int __request, ...);
-#define __ioctl __syscall_ioctl
-#include <sysdeps/unix/sysv/linux/tcgetattr.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/tcsetattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/tcsetattr.c
--- sysdeps/unix/sysv/linux/powerpc/tcsetattr.c	1998-10-15 00:36:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/tcsetattr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-/* We must use __syscall_ioctl since __ioctl does some extra work.  */
-extern int __syscall_ioctl (int __fd, unsigned long int __request, ...);
-#define __ioctl __syscall_ioctl
-#include <sysdeps/unix/sysv/linux/tcsetattr.c>
diff -Nur sysdeps/unix/sysv/linux/powerpc/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/truncate64.c
--- sysdeps/unix/sysv/linux/powerpc/truncate64.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/powerpc/truncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sys/types.h>
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-#include "kernel-features.h"
-
-#ifdef __NR_truncate64
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-/* The variable is shared between all wrappers around *truncate64 calls.  */
-int have_no_truncate64;
-#endif
-
-extern int __syscall_truncate64 (const char *path, off64_t length);
-
-
-/* Truncate the file FD refers to to LENGTH bytes.  */
-int
-truncate64 (path, length)
-     const char *path;
-     off64_t length;
-{
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-  if (! have_no_truncate64)
-#endif
-    {
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      int saved_errno = errno;
-#endif
-      int result = __syscall_truncate64 (path, length);
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      if (result != -1 || errno != ENOSYS)
-#endif
-	return result;
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-      __set_errno (saved_errno);
-      have_no_truncate64 = 1;
-#endif
-    }
-
-#ifndef __ASSUME_TRUNCATE64_SYSCALL
-  if ((off_t) length != length)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-  return truncate (path, (off_t) length);
-#endif
-}
-
-#else
-/* Use the generic implementation.  */
-# include <sysdeps/generic/truncate64.c>
-#endif
diff -Nur sysdeps/unix/sysv/linux/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pread64.c
--- sysdeps/unix/sysv/linux/pread64.c	2002-09-15 04:26:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pread64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -21,7 +21,7 @@
 #include <endian.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
@@ -36,21 +36,14 @@
 
 #if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
 
-extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
-				off_t offset_hi, off_t offset_lo);
-
 # if __ASSUME_PREAD_SYSCALL == 0
 static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
 				  off64_t offset) internal_function;
 # endif
 
 
-ssize_t
-__libc_pread64 (fd, buf, count, offset)
-     int fd;
-     void *buf;
-     size_t count;
-     off64_t offset;
+static ssize_t
+do_pread64 (int fd, void *buf, size_t count, off64_t offset)
 {
   ssize_t result;
 
@@ -67,6 +60,26 @@
   return result;
 }
 
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pread64 (fd, buf, count, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pread64 (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
 weak_alias (__libc_pread64, __pread64)
 weak_alias (__libc_pread64, pread64)
 
diff -Nur sysdeps/unix/sysv/linux/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pread.c
--- sysdeps/unix/sysv/linux/pread.c	2002-09-15 04:26:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pread.c	2004-07-06 06:11:06.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,7 +22,7 @@
 #include <endian.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
@@ -37,22 +37,17 @@
 
 #if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
 
-/* The order of hi, lo depends on endianness.  */
-extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
-				off_t offset_hi, off_t offset_lo);
-
 # if __ASSUME_PREAD_SYSCALL == 0
 static ssize_t __emulate_pread (int fd, void *buf, size_t count,
 				off_t offset) internal_function;
 # endif
 
 
-ssize_t
-__libc_pread (fd, buf, count, offset)
-     int fd;
-     void *buf;
-     size_t count;
-     off_t offset;
+static ssize_t
+#ifdef NO_CANCELLATION
+inline __attribute ((always_inline))
+#endif
+do_pread (int fd, void *buf, size_t count, off_t offset)
 {
   ssize_t result;
 
@@ -69,6 +64,26 @@
   return result;
 }
 
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pread (fd, buf, count, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pread (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
 strong_alias (__libc_pread, __pread)
 weak_alias (__libc_pread, pread)
 
diff -Nur sysdeps/unix/sysv/linux/prof-freq.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/prof-freq.c
--- sysdeps/unix/sysv/linux/prof-freq.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/prof-freq.c	2004-03-05 11:14:48.000000000 +0100
@@ -0,0 +1,51 @@
+/* Determine realtime clock frequency.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/time.h>
+#include <libc-internal.h>
+#include "kernel-features.h"
+#include <ldsodefs.h>
+
+
+int
+__profile_frequency (void)
+{
+#ifdef __ASSUME_AT_CLKTCK
+  return GLRO(dl_clktck);
+#else
+  if (GLRO(dl_clktck) != 0)
+    return GLRO(dl_clktck);
+
+  struct itimerval tim;
+
+  tim.it_interval.tv_sec = 0;
+  tim.it_interval.tv_usec = 1;
+  tim.it_value.tv_sec = 0;
+  tim.it_value.tv_usec = 0;
+
+  __setitimer (ITIMER_REAL, &tim, 0);
+  __setitimer (ITIMER_REAL, 0, &tim);
+
+  if (tim.it_interval.tv_usec < 2)
+    return 0;
+
+  return 1000000 / tim.it_interval.tv_usec;
+#endif
+}
+libc_hidden_def (__profile_frequency)
diff -Nur sysdeps/unix/sysv/linux/ptrace.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ptrace.c
--- sysdeps/unix/sysv/linux/ptrace.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ptrace.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,1998,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,9 +26,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern long int __syscall_ptrace (int, pid_t, void *__unbounded,
-				  void *__unbounded);
-
 long int
 ptrace (enum __ptrace_request request, ...)
 {
diff -Nur sysdeps/unix/sysv/linux/ptsname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ptsname.c
--- sysdeps/unix/sysv/linux/ptsname.c	2002-09-24 07:12:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ptsname.c	2003-01-16 19:11:14.000000000 +0100
@@ -35,7 +35,7 @@
    || (major ((Dev)) == 4 && minor ((Dev)) >= 128 && minor ((Dev)) < 192)     \
    || (major ((Dev)) >= 128 && major ((Dev)) < 136))
 
-/* Check if DEV corresponds to a master pseudo terminal device.  */
+/* Check if DEV corresponds to a slave pseudo terminal device.  */
 #define SLAVE_P(Dev)                                                          \
   (major ((Dev)) == 3                                                         \
    || (major ((Dev)) == 4 && minor ((Dev)) >= 192 && minor ((Dev)) < 256)     \
diff -Nur sysdeps/unix/sysv/linux/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pwrite64.c
--- sysdeps/unix/sysv/linux/pwrite64.c	2002-09-15 04:26:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pwrite64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -21,7 +21,7 @@
 #include <endian.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
@@ -31,26 +31,19 @@
 # ifdef __NR_pwrite
 #  error "__NR_pwrite and __NR_pwrite64 both defined???"
 # endif
-# define __NR_pwrite __NR_pread64
+# define __NR_pwrite __NR_pwrite64
 #endif
 
 #if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
 
-extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf, size_t count,
-				 off_t offset_hi, off_t offset_lo);
-
 # if __ASSUME_PWRITE_SYSCALL == 0
 static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
 				   off64_t offset) internal_function;
 # endif
 
 
-ssize_t
-__libc_pwrite64 (fd, buf, count, offset)
-     int fd;
-     const void *buf;
-     size_t count;
-     off64_t offset;
+static ssize_t
+do_pwrite64 (int fd, const void *buf, size_t count, off64_t offset)
 {
   ssize_t result;
 
@@ -67,6 +60,26 @@
   return result;
 }
 
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pwrite64 (fd, buf, count, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pwrite64 (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
 weak_alias (__libc_pwrite64, __pwrite64)
 libc_hidden_weak (__pwrite64)
 weak_alias (__libc_pwrite64, pwrite64)
diff -Nur sysdeps/unix/sysv/linux/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pwrite.c
--- sysdeps/unix/sysv/linux/pwrite.c	2002-09-15 04:26:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/pwrite.c	2004-07-06 06:11:06.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -22,7 +22,7 @@
 #include <endian.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
@@ -32,27 +32,22 @@
 # ifdef __NR_pwrite
 #  error "__NR_pwrite and __NR_pwrite64 both defined???"
 # endif
-# define __NR_pwrite __NR_pread64
+# define __NR_pwrite __NR_pwrite64
 #endif
 
 #if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
 
-/* The order of hi, lo depends on endianness.  */
-extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf, size_t count,
-				 off_t offset_hi, off_t offset_lo);
-
 # if __ASSUME_PWRITE_SYSCALL == 0
 static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
 				 off_t offset) internal_function;
 # endif
 
 
-ssize_t
-__libc_pwrite (fd, buf, count, offset)
-     int fd;
-     const void *buf;
-     size_t count;
-     off_t offset;
+static ssize_t
+#ifdef NO_CANCELLATION
+inline __attribute ((always_inline))
+#endif
+do_pwrite (int fd, const void *buf, size_t count, off_t offset)
 {
   ssize_t result;
 
@@ -69,6 +64,26 @@
   return result;
 }
 
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pwrite (fd, buf, count, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pwrite (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
 strong_alias (__libc_pwrite, __pwrite)
 weak_alias (__libc_pwrite, pwrite)
 
diff -Nur sysdeps/unix/sysv/linux/readahead.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readahead.c
--- sysdeps/unix/sysv/linux/readahead.c	2002-05-30 20:37:24.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readahead.c	2004-01-21 00:21:34.000000000 +0100
@@ -1,5 +1,5 @@
 /* Provide kernel hint to read ahead.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,6 +18,7 @@
    02111-1307 USA.  */
 
 #include <errno.h>
+#include <fcntl.h>
 #include <sys/types.h>
 
 #include <sysdep.h>
@@ -26,19 +27,15 @@
 
 #ifdef __NR_readahead
 
-extern int __syscall_readahead (int fd, off_t offset_hi, off_t offset_lo,
-				size_t count);
-
-
 ssize_t
-__readahead (int fd, loff_t offset, size_t count)
+__readahead (int fd, off64_t offset, size_t count)
 {
   return INLINE_SYSCALL (readahead, 4, fd, (off_t) (offset >> 32),
 			 (off_t) (offset & 0xffffffff), count);
 }
 #else
 ssize_t
-__readahead (int fd, loff_t offset, size_t count)
+__readahead (int fd, off64_t offset, size_t count)
 {
   __set_errno (ENOSYS);
   return -1;
diff -Nur sysdeps/unix/sysv/linux/readonly-area.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readonly-area.c
--- sysdeps/unix/sysv/linux/readonly-area.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readonly-area.c	2004-10-18 06:17:11.000000000 +0200
@@ -0,0 +1,90 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libio/libioP.h"
+
+/* Return 1 if the whole area PTR .. PTR+SIZE is not writable.
+   Return -1 if it is writable.  */
+
+int
+__readonly_area (const char *ptr, size_t size)
+{
+  const void *ptr_end = ptr + size;
+
+  FILE *fp = fopen ("/proc/self/maps", "rc");
+  if (fp == NULL)
+    return -1;
+
+  /* We need no locking.  */
+  __fsetlocking (fp, FSETLOCKING_BYCALLER);
+
+  char *line = NULL;
+  size_t linelen = 0;
+
+  while (! feof_unlocked (fp))
+    {
+      if (_IO_getdelim (&line, &linelen, '\n', fp) <= 0)
+	break;
+
+      char *p;
+      uintptr_t from = strtoul (line, &p, 16);
+
+      if (p == line || *p++ != '-')
+	break;
+
+      char *q;
+      uintptr_t to = strtoul (p, &q, 16);
+
+      if (q == p || *q++ != ' ')
+	break;
+
+      if (from < (uintptr_t) ptr_end && to > (uintptr_t) ptr)
+	{
+	  /* Found an entry that at least partially covers the area.  */
+	  if (*q++ != 'r' || *q++ != '-')
+	    break;
+
+	  if (from <= (uintptr_t) ptr && to >= (uintptr_t) ptr_end)
+	    {
+	      size = 0;
+	      break;
+	    }
+	  else if (from <= (uintptr_t) ptr)
+	    size -= to - (uintptr_t) ptr;
+	  else if (to >= (uintptr_t) ptr_end)
+	    size -= (uintptr_t) ptr_end - from;
+	  else
+	    size -= to - from;
+
+	  if (!size)
+	    break;
+	}
+    }
+
+  fclose (fp);
+  free (line);
+
+  /* If the whole area between ptr and ptr_end is covered by read-only
+     VMAs, return 1.  Otherwise return -1.  */
+  return size == 0 ? 1 : -1;
+}
diff -Nur sysdeps/unix/sysv/linux/readv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readv.c
--- sysdeps/unix/sysv/linux/readv.c	2002-07-18 09:38:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/readv.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* readv supports all Linux kernels >= 2.0.
-   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,11 +22,10 @@
 #include <sys/param.h>
 #include <sys/uio.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern ssize_t __syscall_readv (int, __const struct iovec *__unbounded, int);
 static ssize_t __atomic_readv_replacement (int, __const struct iovec *,
 					   int) internal_function;
 
@@ -39,11 +38,8 @@
 
 /* We should deal with kernel which have a smaller UIO_FASTIOV as well
    as a very big count.  */
-ssize_t
-__readv (fd, vector, count)
-     int fd;
-     const struct iovec *vector;
-     int count;
+static ssize_t
+do_readv (int fd, const struct iovec *vector, int count)
 {
   ssize_t bytes_read;
 
@@ -54,7 +50,27 @@
 
   return __atomic_readv_replacement (fd, vector, count);
 }
-weak_alias (__readv, readv)
 
-#define __readv static internal_function __atomic_readv_replacement
+
+ssize_t
+__libc_readv (fd, vector, count)
+     int fd;
+     const struct iovec *vector;
+     int count;
+{
+  if (SINGLE_THREAD_P)
+    return do_readv (fd, vector, count);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_readv (fd, vector, count);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+strong_alias (__libc_readv, __readv)
+weak_alias (__libc_readv, readv)
+
+#define __libc_readv static internal_function __atomic_readv_replacement
 #include <sysdeps/posix/readv.c>
diff -Nur sysdeps/unix/sysv/linux/reboot.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/reboot.c
--- sysdeps/unix/sysv/linux/reboot.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/reboot.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,8 +22,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_reboot (int magic, int magic_too, int flag);
-
 /* Call kernel with additional two arguments the syscall requires.  */
 int
 reboot (int howto)
diff -Nur sysdeps/unix/sysv/linux/recvfrom.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recvfrom.S
--- sysdeps/unix/sysv/linux/recvfrom.S	2002-05-15 01:46:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recvfrom.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,5 +1,6 @@
 #define	socket	recvfrom
 #define	__socket __libc_recvfrom
 #define	NARGS	6
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_recvfrom, __recvfrom)
diff -Nur sysdeps/unix/sysv/linux/recvmsg.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recvmsg.S
--- sysdeps/unix/sysv/linux/recvmsg.S	2002-05-15 01:46:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recvmsg.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,5 +1,6 @@
 #define	socket	recvmsg
 #define	__socket __libc_recvmsg
 #define	NARGS	3
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_recvmsg, __recvmsg)
diff -Nur sysdeps/unix/sysv/linux/recv.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recv.S
--- sysdeps/unix/sysv/linux/recv.S	1998-01-21 18:01:45.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/recv.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,5 +1,6 @@
 #define	socket	recv
 #define	__socket __libc_recv
 #define	NARGS	4
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_recv, __recv)
diff -Nur sysdeps/unix/sysv/linux/rt_sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigaction.c
--- sysdeps/unix/sysv/linux/rt_sigaction.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigaction.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-
-int
-__syscall_rt_sigaction (int sig, const struct sigaction *act,
-			struct sigaction *oact, size_t setsize)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigpending.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigpending.c
--- sysdeps/unix/sysv/linux/rt_sigpending.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigpending.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-
-int
-__syscall_rt_sigpending (sigset_t *set, size_t setsize)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigprocmask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigprocmask.c
--- sysdeps/unix/sysv/linux/rt_sigprocmask.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigprocmask.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-
-int
-__syscall_rt_sigprocmask (int how, const sigset_t *set, sigset_t *oset,
-			  size_t setsize)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigqueueinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigqueueinfo.c
--- sysdeps/unix/sysv/linux/rt_sigqueueinfo.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigqueueinfo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <sys/types.h>
-
-int
-__syscall_rt_sigqueueinfo (pid_t pid, int sig, siginfo_t *uinfo)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigreturn.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigreturn.c
--- sysdeps/unix/sysv/linux/rt_sigreturn.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigreturn.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-
-int
-__syscall_rt_sigreturn (struct sigcontext *ctx)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigsuspend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigsuspend.c
--- sysdeps/unix/sysv/linux/rt_sigsuspend.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigsuspend.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-#define __need_NULL
-#include <stddef.h>
-
-int
-__syscall_rt_sigsuspend (const sigset_t *set, size_t setsize)
-{
-  if (set == NULL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/rt_sigtimedwait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigtimedwait.c
--- sysdeps/unix/sysv/linux/rt_sigtimedwait.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/rt_sigtimedwait.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-#define __need_NULL
-#include <stddef.h>
-
-int
-__syscall_rt_sigtimedwait (const sigset_t *set, siginfo_t *info,
-			   const struct timespec *timeout, size_t setsize)
-{
-  if (set == NULL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/s390/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/environments.h
--- sysdeps/unix/sysv/linux/s390/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/environments.h	2004-11-26 09:11:04.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* Environments with 32-bit wide pointers are optionally provided.
+   Therefore following macros aren't defined:
+   # undef _POSIX_V6_ILP32_OFF32
+   # undef _POSIX_V6_ILP32_OFFBIG
+   # undef _XBS5_ILP32_OFF32
+   # undef _XBS5_ILP32_OFFBIG
+   and users need to check at runtime.  */
+
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* Environments with 64-bit wide pointers can be provided,
+   so these macros aren't defined:
+   # undef _POSIX_V6_LP64_OFF64
+   # undef _POSIX_V6_LPBIG_OFFBIG
+   # undef _XBS5_LP64_OFF64
+   # undef _XBS5_LPBIG_OFFBIG
+   and sysconf tests for it at runtime.  */
+
+#endif /* __WORDSIZE == 32 */
+
+#define __ILP32_OFF32_CFLAGS	"-m31"
+#define __ILP32_OFFBIG_CFLAGS	"-m31 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+#define __ILP32_OFF32_LDFLAGS	"-m31"
+#define __ILP32_OFFBIG_LDFLAGS	"-m31"
+#define __LP64_OFF64_CFLAGS	"-m64"
+#define __LP64_OFF64_LDFLAGS	"-m64"
diff -Nur sysdeps/unix/sysv/linux/s390/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/fcntl.h
--- sysdeps/unix/sysv/linux/s390/bits/fcntl.h	2002-07-11 23:39:17.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/fcntl.h	2004-08-23 09:28:45.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,6 +45,7 @@
 # define O_DIRECT	 040000	/* Direct disk access.	*/
 # define O_DIRECTORY	0200000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_NOATIME     01000000 /* Do not set atime.  */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -93,7 +94,7 @@
 # define F_SETLKW64	14	/* Set record locking info (blocking).	*/
 #endif
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -197,3 +198,11 @@
 #  define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 # endif
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/s390/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/mman.h
--- sysdeps/unix/sysv/linux/s390/bits/mman.h	2002-07-11 23:39:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/mman.h	2003-09-25 18:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/s390 version.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
@@ -52,12 +56,14 @@
 
 /* These are Linux-specific.  */
 #ifdef __USE_MISC
-# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
-# define MAP_GROWSUP	0x0200		/* Register stack-like segment */
-# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
-# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
-# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_GROWSUP	0x00200		/* Register stack-like segment */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
 #endif
 
 /* Flags to `msync'.  */
diff -Nur sysdeps/unix/sysv/linux/s390/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/resource.h
--- sysdeps/unix/sysv/linux/s390/bits/resource.h	2002-07-11 23:40:18.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,219 +0,0 @@
-/* Bit values & structures for resource limits.  Linux version.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-#include <bits/wordsize.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#if __WORDSIZE == 64
-# define RLIM_INFINITY ~0UL
-#else
-# ifndef __USE_FILE_OFFSET64
-#  define RLIM_INFINITY ((unsigned long int) (~0UL))
-# else
-#  define RLIM_INFINITY 0xffffffffffffffffuLL
-# endif
-#endif
-
-#ifdef __USE_LARGEFILE64
-# if __WORDSIZE == 64
-#  define RLIM64_INFINITY ~0UL
-# else
-#  define RLIM64_INFINITY 0xffffffffffffffffuLL
-# endif
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#if __WORDSIZE != 64 && !defined(__USE_FILE_OFFSET64)
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/s390/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/shm.h
--- sysdeps/unix/sysv/linux/s390/bits/shm.h	2002-08-24 00:20:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/shm.h	2004-08-12 19:27:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,6 +36,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -77,6 +79,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST	01000	/* segment will be destroyed on last detach */
 # define SHM_LOCKED	02000	/* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
 
 struct	shminfo
   {
@@ -102,3 +105,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/s390/bits/siginfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/siginfo.h
--- sysdeps/unix/sysv/linux/s390/bits/siginfo.h	2002-07-11 23:41:33.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/siginfo.h	2003-04-21 09:27:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* siginfo_t, sigevent and constants.  S/390 version.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -69,8 +69,9 @@
 	/* POSIX.1b timers.  */
 	struct
 	  {
-	    unsigned int _timer1;
-	    unsigned int _timer2;
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
 	  } _timer;
 
 	/* POSIX.1b signals.  */
@@ -111,8 +112,8 @@
 /* X/Open requires some more fields with fixed names.  */
 # define si_pid		_sifields._kill.si_pid
 # define si_uid		_sifields._kill.si_uid
-# define si_timer1	_sifields._timer._timer1
-# define si_timer2	_sifields._timer._timer2
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
 # define si_status	_sifields._sigchld.si_status
 # define si_utime	_sifields._sigchld.si_utime
 # define si_stime	_sifields._sigchld.si_stime
@@ -129,8 +130,10 @@
    signals.  */
 enum
 {
-  SI_ASYNCNL = -6,		/* Sent by asynch name lookup completion.  */
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
 # define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
   SI_SIGIO,			/* Sent by queued SIGIO. */
 # define SI_SIGIO	SI_SIGIO
   SI_ASYNCIO,			/* Sent by AIO completion.  */
@@ -269,9 +272,6 @@
 #  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
 # endif
 
-/* Forward declaration of the `pthread_attr_t' type.  */
-struct __pthread_attr_s;
-
 typedef struct sigevent
   {
     sigval_t sigev_value;
@@ -284,8 +284,8 @@
 
 	struct
 	  {
-	    void (*_function) (sigval_t);	  /* Function to start.	 */
-	    struct __pthread_attr_s *_attribute;  /* Really pthread_attr_t.  */
+	    void (*_function) (sigval_t);	/* Function to start.	 */
+	    void *_attribute;			/* Really pthread_attr_t.  */
 	  } _sigev_thread;
       } _sigev_un;
   } sigevent_t;
@@ -301,8 +301,11 @@
 # define SIGEV_SIGNAL	SIGEV_SIGNAL
   SIGEV_NONE,			/* Other notification: meaningless.  */
 # define SIGEV_NONE	SIGEV_NONE
-  SIGEV_THREAD			/* Deliver via thread creation.	 */
+  SIGEV_THREAD,			/* Deliver via thread creation.	 */
 # define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
 };
 
 #endif	/* have _SIGNAL_H.  */
diff -Nur sysdeps/unix/sysv/linux/s390/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/socket.h
--- sysdeps/unix/sysv/linux/s390/bits/socket.h	2002-07-11 23:41:52.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,325 +0,0 @@
-/* System-specific socket constants and types.  Linux/s390 version.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef __BITS_SOCKET_H
-#define __BITS_SOCKET_H
-
-#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
-# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
-#endif
-
-#include <bits/wordsize.h>
-
-#define	__need_size_t
-#define __need_NULL
-#include <stddef.h>
-
-#include <limits.h>
-#include <sys/types.h>
-
-/* Type for length arguments in socket calls.  */
-#ifndef __socklen_t_defined
-typedef __socklen_t socklen_t;
-# define __socklen_t_defined
-#endif
-
-/* Types of sockets.  */
-enum __socket_type
-{
-  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
-				   byte streams.  */
-#define SOCK_STREAM SOCK_STREAM
-  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
-				   of fixed maximum length.  */
-#define SOCK_DGRAM SOCK_DGRAM
-  SOCK_RAW = 3,			/* Raw protocol interface.  */
-#define SOCK_RAW SOCK_RAW
-  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
-#define SOCK_RDM SOCK_RDM
-  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
-				   datagrams of fixed maximum length.  */
-#define SOCK_SEQPACKET SOCK_SEQPACKET
-  SOCK_PACKET = 10		/* Linux specific way of getting packets
-				   at the dev level.  For writing rarp and
-				   other similar things on the user level. */
-#define SOCK_PACKET SOCK_PACKET
-};
-
-/* Protocol families.  */
-#define	PF_UNSPEC	0	/* Unspecified.  */
-#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
-#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
-#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
-#define	PF_INET		2	/* IP protocol family.  */
-#define	PF_AX25		3	/* Amateur Radio AX.25.  */
-#define	PF_IPX		4	/* Novell Internet Protocol.  */
-#define	PF_APPLETALK	5	/* Appletalk DDP.  */
-#define	PF_NETROM	6	/* Amateur radio NetROM.  */
-#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
-#define	PF_ATMPVC	8	/* ATM PVCs.  */
-#define	PF_X25		9	/* Reserved for X.25 project.  */
-#define	PF_INET6	10	/* IP version 6.  */
-#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
-#define	PF_DECnet	12	/* Reserved for DECnet project.  */
-#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
-#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
-#define	PF_KEY		15	/* PF_KEY key management API.  */
-#define	PF_NETLINK	16
-#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
-#define	PF_PACKET	17	/* Packet family.  */
-#define	PF_ASH		18	/* Ash.  */
-#define	PF_ECONET	19	/* Acorn Econet.  */
-#define	PF_ATMSVC	20	/* ATM SVCs.  */
-#define	PF_SNA		22	/* Linux SNA Project */
-#define	PF_IRDA		23	/* IRDA sockets.  */
-#define	PF_PPPOX	24	/* PPPoX sockets.  */
-#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
-#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
-#define	PF_MAX		32	/* For now..  */
-
-/* Address families.  */
-#define	AF_UNSPEC	PF_UNSPEC
-#define	AF_LOCAL	PF_LOCAL
-#define	AF_UNIX		PF_UNIX
-#define	AF_FILE		PF_FILE
-#define	AF_INET		PF_INET
-#define	AF_AX25		PF_AX25
-#define	AF_IPX		PF_IPX
-#define	AF_APPLETALK	PF_APPLETALK
-#define	AF_NETROM	PF_NETROM
-#define	AF_BRIDGE	PF_BRIDGE
-#define	AF_ATMPVC	PF_ATMPVC
-#define	AF_X25		PF_X25
-#define	AF_INET6	PF_INET6
-#define	AF_ROSE		PF_ROSE
-#define	AF_DECnet	PF_DECnet
-#define	AF_NETBEUI	PF_NETBEUI
-#define	AF_SECURITY	PF_SECURITY
-#define	AF_KEY		PF_KEY
-#define	AF_NETLINK	PF_NETLINK
-#define	AF_ROUTE	PF_ROUTE
-#define	AF_PACKET	PF_PACKET
-#define	AF_ASH		PF_ASH
-#define	AF_ECONET	PF_ECONET
-#define	AF_ATMSVC	PF_ATMSVC
-#define	AF_SNA		PF_SNA
-#define	AF_IRDA		PF_IRDA
-#define	AF_PPPOX	PF_PPPOX
-#define	AF_WANPIPE	PF_WANPIPE
-#define	AF_BLUETOOTH	PF_BLUETOOTH
-#define	AF_MAX		PF_MAX
-
-/* Socket level values.  Others are defined in the appropriate headers.
-
-   XXX These definitions also should go into the appropriate headers as
-   far as they are available.  */
-#define SOL_RAW		255
-#define SOL_DECNET      261
-#define SOL_X25         262
-#define SOL_PACKET	263
-#define SOL_ATM		264	/* ATM layer (cell level).  */
-#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
-#define SOL_IRDA	266
-
-/* Maximum queue length specifiable by listen.  */
-#define SOMAXCONN	128
-
-/* Get the definition of the macro to define the common sockaddr members.  */
-#include <bits/sockaddr.h>
-
-/* Structure describing a generic socket address.  */
-struct sockaddr
-  {
-    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
-    char sa_data[14];		/* Address data.  */
-  };
-
-
-/* Structure large enough to hold any socket address (with the historical
-   exception of AF_UNIX).  We reserve 128 bytes.  */
-#if ULONG_MAX > 0xffffffff
-# define __ss_aligntype	__uint64_t
-#else
-# define __ss_aligntype	__uint32_t
-#endif
-#define _SS_SIZE	128
-#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
-
-struct sockaddr_storage
-  {
-    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
-    __ss_aligntype __ss_align;	/* Force desired alignment.  */
-    char __ss_padding[_SS_PADSIZE];
-  };
-
-
-/* Bits in the FLAGS argument to `send', `recv', et al.  */
-enum
-  {
-    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
-#define MSG_OOB		MSG_OOB
-    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
-#define MSG_PEEK	MSG_PEEK
-    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
-#define MSG_DONTROUTE	MSG_DONTROUTE
-#ifdef __USE_GNU
-    /* DECnet uses a different name.  */
-    MSG_TRYHARD		= MSG_DONTROUTE,
-# define MSG_TRYHARD	MSG_DONTROUTE
-#endif
-    MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
-#define MSG_CTRUNC	MSG_CTRUNC
-    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
-#define MSG_PROXY	MSG_PROXY
-    MSG_TRUNC		= 0x20,
-#define	MSG_TRUNC	MSG_TRUNC
-    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
-#define	MSG_DONTWAIT	MSG_DONTWAIT
-    MSG_EOR		= 0x80, /* End of record.  */
-#define	MSG_EOR		MSG_EOR
-    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
-#define	MSG_WAITALL	MSG_WAITALL
-    MSG_FIN		= 0x200,
-#define	MSG_FIN		MSG_FIN
-    MSG_SYN		= 0x400,
-#define	MSG_SYN		MSG_SYN
-    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
-#define	MSG_CONFIRM	MSG_CONFIRM
-    MSG_RST		= 0x1000,
-#define	MSG_RST		MSG_RST
-    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
-#define	MSG_ERRQUEUE	MSG_ERRQUEUE
-    MSG_NOSIGNAL	= 0x4000, /* Do not generate SIGPIPE.  */
-#define	MSG_NOSIGNAL	MSG_NOSIGNAL
-    MSG_MORE		= 0x8000  /* Sender will send more.  */
-#define	MSG_MORE	MSG_MORE
-  };
-
-
-/* Structure describing messages sent by
-   `sendmsg' and received by `recvmsg'.  */
-struct msghdr
-  {
-    void *msg_name;		/* Address to send to/receive from.  */
-    socklen_t msg_namelen;	/* Length of address data.  */
-
-    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
-#if __WORDSIZE == 64
-    size_t msg_iovlen;		/* Number of elements in the vector.  */
-#else
-    int msg_iovlen;		/* Number of elements in the vector.  */
-#endif
-
-    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-#if __WORDSIZE == 64
-    size_t msg_controllen;	/* Ancillary data buffer length.  */
-#else
-    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
-#endif
-
-    int msg_flags;		/* Flags on received message.  */
-  };
-
-/* Structure used for storage of ancillary data object information.  */
-struct cmsghdr
-  {
-    size_t cmsg_len;		/* Length of data in cmsg_data plus length
-				   of cmsghdr structure.  */
-    int cmsg_level;		/* Originating protocol.  */
-    int cmsg_type;		/* Protocol specific type.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
-#endif
-  };
-
-/* Ancillary data object manipulation macros.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
-#else
-# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
-#endif
-#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
-#define CMSG_FIRSTHDR(mhdr) \
-  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
-   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
-#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
-			 & (size_t) ~(sizeof (size_t) - 1))
-#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
-			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
-#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
-
-extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
-				      struct cmsghdr *__cmsg) __THROW;
-#ifdef __USE_EXTERN_INLINES
-# ifndef _EXTERN_INLINE
-#  define _EXTERN_INLINE extern __inline
-# endif
-_EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
-{
-  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
-    return 0;
-
-  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
-			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
-					 + __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return 0;
-  return __cmsg;
-}
-#endif	/* Use `extern inline'.  */
-
-/* Socket level message types.  This must match the definitions in
-   <linux/socket.h>.  */
-enum
-  {
-    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
-#define SCM_RIGHTS SCM_RIGHTS
-#ifdef __USE_BSD
-    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
-# define SCM_CREDENTIALS SCM_CREDENTIALS
-#endif
-    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
-  };
-
-/* User visible structure for SCM_CREDENTIALS message */
-
-struct ucred
-{
-  pid_t pid;			/* PID of sending process.  */
-  uid_t uid;			/* UID of sending process.  */
-  gid_t gid;			/* GID of sending process.  */
-};
-
-/* Get socket manipulation related informations from kernel headers.  */
-#include <asm/socket.h>
-
-
-/* Structure used to manipulate the SO_LINGER option.  */
-struct linger
-  {
-    int l_onoff;		/* Nonzero to linger on close.  */
-    int l_linger;		/* Time to linger.  */
-  };
-
-#endif	/* bits/socket.h */
diff -Nur sysdeps/unix/sysv/linux/s390/bits/statfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/statfs.h
--- sysdeps/unix/sysv/linux/s390/bits/statfs.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/statfs.h	2003-07-12 21:30:45.000000000 +0200
@@ -0,0 +1,67 @@
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t.  */
+
+struct statfs
+  {
+    int f_type;
+    int f_bsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    int f_namelen;
+    int f_frsize;
+    int f_spare[5];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    int f_type;
+    int f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    int f_namelen;
+    int f_frsize;
+    int f_spare[5];
+  };
+#endif
+
+/* Tell code we have this member.  */
+#define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
diff -Nur sysdeps/unix/sysv/linux/s390/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/stat.h
--- sysdeps/unix/sysv/linux/s390/bits/stat.h	2002-07-11 23:42:06.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -56,12 +56,27 @@
     int pad0;
     __dev_t st_rdev;		/* Device number, if device.  */
     __off_t st_size;		/* Size of file, in bytes.  */
-    __time_t st_atime;		/* Time of last access.	 */
-    long int __reserved0;	/* Reserved for atime.nanoseconds.  */
-    __time_t st_mtime;		/* Time of last modification.  */
-    long int __reserved1;	/* Reserved for mtime.nanoseconds.  */
-    __time_t st_ctime;		/* Time of last status change.	*/
-    long int __reserved2;	/* Reserved for ctime.nanoseconds.  */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.	*/
     __blkcnt_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
     long int __unused[3];
@@ -94,12 +109,27 @@
 # else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 # endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
 # ifndef __USE_FILE_OFFSET64
     unsigned long int __unused4;
     unsigned long int __unused5;
@@ -123,12 +153,27 @@
     int pad0;
     __dev_t st_rdev;		/* Device number, if device.  */
     __off_t st_size;		/* Size of file, in bytes.  */
-    __time_t st_atime;		/* Time of last access.	 */
-    long int __reserved0;	/* Reserved for atime.nanoseconds.  */
-    __time_t st_mtime;		/* Time of last modification.  */
-    long int __reserved1;	/* Reserved for mtime.nanoseconds.  */
-    __time_t st_ctime;		/* Time of last status change.	*/
-    long int __reserved2;	/* Reserved for ctime.nanoseconds.  */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.	*/
     __blkcnt64_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
     long int __unused[3];
@@ -150,12 +195,27 @@
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
 
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int __unused1;
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int __unused2;
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int __unused3;
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
     __ino64_t st_ino;			/* File serial number.		*/
   };
 # endif
@@ -164,6 +224,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/s390/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/types.h
--- sysdeps/unix/sysv/linux/s390/bits/types.h	2002-07-11 23:42:25.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,161 +0,0 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <sys/types.h> instead.
- */
-
-#ifndef	_BITS_TYPES_H
-#define	_BITS_TYPES_H	1
-
-#include <features.h>
-
-#define __need_size_t
-#include <stddef.h>
-
-#include <bits/wordsize.h>
-
-/* Convenience types.  */
-typedef unsigned char __u_char;
-typedef unsigned short __u_short;
-typedef unsigned int __u_int;
-typedef unsigned long __u_long;
-#if __WORDSIZE == 64
-typedef unsigned long __u_quad_t;
-typedef long __quad_t;
-#else
-# ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef unsigned long long int __u_quad_t;
-__extension__ typedef long long int __quad_t;
-# else
-typedef struct
-  {
-    long int __val[2];
-  } __quad_t;
-typedef struct
-  {
-    __u_long __val[2];
-  } __u_quad_t;
-# endif
-#endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#if __WORDSIZE == 64
-typedef signed long int __int64_t;
-typedef unsigned long int __uint64_t;
-#else
-# ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef signed long long int __int64_t;
-__extension__ typedef unsigned long long int __uint64_t;
-# endif
-#endif
-typedef __quad_t *__qaddr_t;
-
-typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
-typedef __u_int __uid_t;		/* Type of user identifications.  */
-typedef __u_int __gid_t;		/* Type of group identifications.  */
-typedef __u_long __ino_t;		/* Type of file serial numbers.	 */
-typedef __u_int __mode_t;		/* Type of file attribute bitmasks.  */
-typedef __u_long __nlink_t;		/* Type of file link counts.  */
-typedef long int  __off_t;		/* Type of file sizes and offsets.  */
-typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
-typedef int __pid_t;			/* Type of process identifications.  */
-typedef long __ssize_t;			/* Type of a byte count, or error.  */
-typedef __u_long __rlim_t;		/* Type of resource counts.  */
-typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
-typedef __u_int __id_t;			/* General type for ID.  */
-
-typedef struct
-  {
-    int __val[2];
-  } __fsid_t;				/* Type of file system IDs.  */
-
-/* Everythin' else.  */
-typedef int __daddr_t;			/* The type of a disk address.  */
-typedef char *__caddr_t;
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef long int __suseconds_t;
-typedef long int __swblk_t;		/* Type of a swap block maybe?	*/
-
-typedef long int __clock_t;
-
-/* Clock ID used in clock and timer functions.	*/
-typedef int __clockid_t;
-
-/* Timer ID returned by `timer_create'.	 */
-typedef int __timer_t;
-
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define __FD_SETSIZE	1024
-
-
-typedef int __key_t;
-
-/* Used in `struct shmid_ds'.  */
-#if __WORDSIZE == 64
-typedef int __ipc_pid_t;
-#else
-typedef unsigned short int __ipc_pid_t;
-#endif
-
-/* Type to represent block size. */
-typedef long int __blksize_t;
-
-/* Types from the Large File Support interface.  */
-
-/* Type to count number os disk blocks.  */
-typedef long int __blkcnt_t;
-typedef __quad_t __blkcnt64_t;
-
-/* Type to count file system blocks.  */
-typedef __u_long __fsblkcnt_t;
-typedef __u_quad_t __fsblkcnt64_t;
-
-/* Type to count file system inodes.  */
-typedef __u_long __fsfilcnt_t;
-typedef __u_quad_t __fsfilcnt64_t;
-
-/* Type of file serial numbers.  */
-typedef __u_quad_t __ino64_t;
-
-/* Type of file sizes and offsets.  */
-typedef __loff_t __off64_t;
-
-/* Used in XTI.	 */
-typedef int __t_scalar_t;
-typedef unsigned int __t_uscalar_t;
-
-/* Duplicates info from stdint.h but this is used in unistd.h.	*/
-typedef long int __intptr_t;
-
-/* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
-
-
-/* Now add the thread types.  */
-#if defined __USE_POSIX199506 || defined __USE_UNIX98
-# include <bits/pthreadtypes.h>
-#endif
-
-#endif /* bits/types.h */
diff -Nur sysdeps/unix/sysv/linux/s390/bits/typesizes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
--- sysdeps/unix/sysv/linux/s390/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/bits/typesizes.h	2003-09-14 10:01:45.000000000 +0200
@@ -0,0 +1,72 @@
+/* bits/typesizes.h -- underlying types for *_t.  Linux/s390 version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#if defined __GNUC__ && __GNUC__ <= 2
+/* Compatibility with g++ 2.95.x.  */
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#else
+/* size_t is unsigned long int on s390 -m31.  */
+#define __SSIZE_T_TYPE		__SLONGWORD_TYPE
+#endif
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff -Nur sysdeps/unix/sysv/linux/s390/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/dl-cache.h
--- sysdeps/unix/sysv/linux/s390/dl-cache.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/dl-cache.h	2003-06-25 10:03:17.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>
diff -Nur sysdeps/unix/sysv/linux/s390/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/Makefile
--- sysdeps/unix/sysv/linux/s390/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/Makefile	2004-04-18 04:28:53.000000000 +0200
@@ -0,0 +1,4 @@
+64bit-predefine = __s390x__
+ifeq ($(subdir),rt)
+librt-routines += rt-sysdep
+endif
diff -Nur sysdeps/unix/sysv/linux/s390/rt-sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/rt-sysdep.S
--- sysdeps/unix/sysv/linux/s390/rt-sysdep.S	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/rt-sysdep.S	2004-04-18 04:28:40.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdep.S>
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/chown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/chown.c
--- sysdeps/unix/sysv/linux/s390/s390-32/chown.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/chown.c	2004-03-10 20:22:04.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,14 +37,9 @@
   has therefore to route calls to chown to the old chown function.
 */
 
-extern int __syscall_chown (const char *__file,
-			    __kernel_uid_t __owner, __kernel_gid_t __group);
-
 /* Running under Linux > 2.1.80.  */
 
 #ifdef __NR_chown32
-extern int __syscall_chown32 (const char *__file,
-			      __kernel_uid32_t owner, __kernel_gid32_t group);
 # if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
@@ -55,13 +50,16 @@
 int
 __real_chown (const char *file, uid_t owner, gid_t group)
 {
+#if __ASSUME_32BITUIDS > 0
+  return INLINE_SYSCALL (chown32, 3, CHECK_STRING (file), owner, group);
+#else
   static int __libc_old_chown;
   int result;
 
   if (!__libc_old_chown)
     {
       int saved_errno = errno;
-#ifdef __NR_chown32
+# ifdef __NR_chown32
       if (__libc_missing_32bit_uids <= 0)
 	{
 	  int result;
@@ -74,7 +72,7 @@
 	  __set_errno (saved_errno);
 	  __libc_missing_32bit_uids = 1;
 	}
-#endif /* __NR_chown32 */
+# endif /* __NR_chown32 */
       if (((owner + 1) > (uid_t) ((__kernel_uid_t) -1U))
 	  || ((group + 1) > (gid_t) ((__kernel_gid_t) -1U)))
 	{
@@ -92,12 +90,14 @@
     }
 
   return __lchown (file, owner, group);
+#endif
 }
 
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
 /* Compiling for compatibiity.  */
 int
+attribute_compat_text_section
 __chown_is_lchown (const char *file, uid_t owner, gid_t group)
 {
   return __lchown (file, owner, group);
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/clone.S
--- sysdeps/unix/sysv/linux/s390/s390-32/clone.S	2002-02-07 18:30:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/clone.S	2004-12-15 18:45:21.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
 
@@ -21,48 +21,56 @@
    and invokes a function in the right context after its all over.  */
 
 #include <sysdep.h>
+#include <tls.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
 
-/*int __clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg);*/
-/* sys_clone(void *child_stack, unsigned long flags) */
+/* int __clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+               pid_t *parent_tid, void *tls, pid_t *child_tid);  */
+/* sys_clone  (void *child_stack, unsigned long flags,
+               pid_t *parent_tid, pid_t *child_tid, void *tls);  */
 
 	.text
 ENTRY(__clone)
-	/* Sanity check arguments & move registers */
-	ltr     %r1,%r2			/* no NULL function pointers */
-	lhi     %r2,-EINVAL
-	jz      SYSCALL_ERROR_LABEL
-	ltr     %r3,%r3			/* no NULL stack pointers */
-	jz      SYSCALL_ERROR_LABEL
-	/* move child_stack and flags, then call SVC */
-	lr      %r2,%r3
-	lr      %r3,%r4
-	svc     SYS_ify(clone)
-	ltr     %r2,%r2			/* check return code */
-	jm      SYSCALL_ERROR_LABEL
-	jz      thread_start
-	br      %r14
-
+	st	%r6,24(%r15)		/* store %r6 to save area */
+	cfi_offset (%r6, -72)
+	lr	%r0,%r5			/* move *arg out of the way */
+	ltr     %r1,%r2			/* check fn and move to %r1 */
+	jz      error			/* no NULL function pointers */
+	ltr     %r2,%r3			/* check child_stack and move to %r2 */
+	jz	error			/* no NULL stack pointers */
+	lr	%r3,%r4			/* move flags to %r3 */
+	lr	%r4,%r6			/* move parent_tid to %r4 */
+	l	%r5,100(%r15)		/* load child_tid from stack */
+	l	%r6,96(%r15)		/* load tls from stack */
+	svc	SYS_ify(clone)
+	ltr	%r2,%r2			/* check return code */
+	jz	thread_start
+	l	%r6,24(%r15)		/* restore %r6 */
+	jm	SYSCALL_ERROR_LABEL
+	br	%r14
+error:
+	lhi	%r2,-EINVAL
+	j	SYSCALL_ERROR_LABEL
+PSEUDO_END (__clone)
+	
 thread_start:
-	/* fn is in gpr 1, arg in gpr 5 */
-	lr      %r2,%r5         /* set first parameter to void *arg */
-	sr      %r11,%r11	/* terminate the stack frame */
+#ifdef RESET_PID
+	tmh	%r3,1		/* CLONE_THREAD == 0x00010000 */
+	jne	1f
+	lhi	%r2,-1
+	tml	%r3,256		/* CLONE_VM == 0x00000100 */
+	jne	2f
+	svc	SYS_ify(getpid)
+2:	ear	%r3,%a0
+	st	%r2,PID(%r3)
+	st	%r2,TID(%r3)
+1:
+#endif
+	/* fn is in gpr 1, arg in gpr 0 */
+	lr      %r2,%r0         /* set first parameter to void *arg */
 	ahi     %r15,-96        /* make room on the stack for the save area */
+	xc	0(4,%r15),0(%r15)
 	basr    %r14,%r1        /* jump to fn */
-#ifdef PIC
-	basr    %r12,0
-.L0:    lr      %r1,%r12
-	al      %r12,.L1-.L0(%r12)
-	al      %r1,.L2-.L0(%r1)
-	br      %r1             /* branch to _exit -> thread termination */
-.L1:	.long   _GLOBAL_OFFSET_TABLE_ - .L0
-.L2:	.long   _exit@PLT - .L0
-#else
-	basr    %r1,0
-.L0:	al      %r1,.L1-.L0(0,%r1)
-	br      %r1             /* branch to _exit -> thread termination */
-.L1:	.long   _exit - .L0
-#endif
-PSEUDO_END (__clone)
+	DO_CALL (exit, 1)
 weak_alias (__clone, clone)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/lchown.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/lchown.c
--- sysdeps/unix/sysv/linux/s390/s390-32/lchown.c	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/lchown.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,13 +26,7 @@
 #include <linux/posix_types.h>
 #include "kernel-features.h"
 
-extern int __syscall_lchown (const char *__unbounded __file,
-			     __kernel_uid_t __owner, __kernel_gid_t __group);
-
 # ifdef __NR_lchown32
-extern int __syscall_lchown32 (const char *__unbounded __file,
-			       __kernel_uid32_t __owner,
-			       __kernel_gid32_t __group);
 #  if __ASSUME_32BITUIDS == 0
 /* This variable is shared with all files that need to check for 32bit
    uids.  */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/Makefile
--- sysdeps/unix/sysv/linux/s390/s390-32/Makefile	2001-11-16 00:09:38.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/Makefile	2002-10-14 03:02:53.000000000 +0200
@@ -1,5 +1,4 @@
 ifeq ($(subdir),misc)
-sysdep_routines += setfsgid setfsuid setresgid setresuid
 sysdep_headers += sys/elf.h
 endif
 
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/mmap64.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/mmap64.S
--- sysdeps/unix/sysv/linux/s390/s390-32/mmap64.S	2001-07-16 08:31:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/mmap64.S	2003-12-06 01:18:40.000000000 +0100
@@ -26,8 +26,19 @@
 ENTRY(__mmap64)
 	/* Save registers and setup stack frame.  */
 	stm	%r6,%r15,24(%r15)
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	cfi_offset (%r12, -48)
+	cfi_offset (%r11, -52)
+	cfi_offset (%r10, -56)
+	cfi_offset (%r9, -60)
+	cfi_offset (%r8, -64)
+	cfi_offset (%r7, -68)
+	cfi_offset (%r6, -72)
 	lr	%r1,%r15
 	ahi	%r15,-120		/* Buy stack space.   */
+	cfi_adjust_cfa_offset (120)
 	st	%r1,0(%r15)		/* Store back chain.  */
 
 	/* Store parameters on stack, because mmap2 and old_mmap
@@ -56,6 +67,7 @@
 #endif
 
 	l	%r15,0(%r15)		/* Load back chain.  */
+	cfi_adjust_cfa_offset (-120)
 	lm	%r6,%r15,24(%r15)	/* Load registers.  */
 
 	/* Check gpr 2 for error.  */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/mmap.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/mmap.S
--- sysdeps/unix/sysv/linux/s390/s390-32/mmap.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/mmap.S	2003-12-06 01:18:40.000000000 +0100
@@ -25,8 +25,19 @@
 ENTRY(__mmap)
 	/* Save registers and setup stack frame.  */
 	stm     %r6,%r15,24(%r15)
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	cfi_offset (%r12, -48)
+	cfi_offset (%r11, -52)
+	cfi_offset (%r10, -56)
+	cfi_offset (%r9, -60)
+	cfi_offset (%r8, -64)
+	cfi_offset (%r7, -68)
+	cfi_offset (%r6, -72)
 	lr      %r1,%r15
 	ahi     %r15,-120               /* buy stack space */
+	cfi_adjust_cfa_offset (120)
 	st      %r1,0(%r15)             /* store back chain */
 
 	/* Store parameters on stack, because old_mmap/mmap2
@@ -57,6 +68,7 @@
 #endif
 
 1:	l       %r15,0(%r15)            /* Load back chain.  */
+	cfi_adjust_cfa_offset (-120)
 	lm      %r6,%r15,24(%r15)       /* Load registers.  */
 
 	/* check gpr 2 for error */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/posix_fadvise64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/posix_fadvise64.c
--- sysdeps/unix/sysv/linux/s390/s390-32/posix_fadvise64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/posix_fadvise64.c	2004-03-10 20:22:28.000000000 +0100
@@ -0,0 +1,91 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+int __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise);
+int __posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise);
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+struct fadvise64_64_layout
+{
+  int fd;
+  off64_t offset;
+  off64_t len;
+  int advise;
+};
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+#ifdef __NR_fadvise64_64
+  struct fadvise64_64_layout parameters;
+  INTERNAL_SYSCALL_DECL (err);
+  
+  parameters.fd = fd;
+  parameters.offset = offset;
+  parameters.len = len;
+  parameters.advise = advise;
+  int ret = INTERNAL_SYSCALL (fadvise64_64, err, 1, &parameters);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return 0;
+# ifndef __ASSUME_FADVISE64_64_SYSCALL
+  if (INTERNAL_SYSCALL_ERRNO (ret, err) != ENOSYS)
+# endif
+   return INTERNAL_SYSCALL_ERRNO (ret, err);
+#endif
+#ifndef __ASSUME_FADVISE64_64_SYSCALL
+# ifdef __NR_fadvise64
+  if (len != (off_t) len)
+    return EOVERFLOW;
+
+  INTERNAL_SYSCALL_DECL (err2);
+  int ret2 = INTERNAL_SYSCALL (fadvise64, err2, 5, fd,
+			       __LONG_LONG_PAIR ((long) (offset >> 32),
+						 (long) offset),
+			       (off_t) len, advise);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret2, err2))
+    return 0;
+  return INTERNAL_SYSCALL_ERRNO (ret2, err2);
+# else
+  return ENOSYS;
+# endif
+#endif
+}
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise)
+{
+  return __posix_fadvise64_l64 (fd, offset, len, advise);
+}
+
+versioned_symbol (libc, __posix_fadvise64_l64, posix_fadvise64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fadvise64_l32, posix_fadvise64, GLIBC_2_2);
+#else
+strong_alias (__posix_fadvise64_l64, posix_fadvise64);
+#endif
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/socket.S
--- sysdeps/unix/sysv/linux/s390/s390-32/socket.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/socket.S	2003-12-06 01:15:55.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -17,7 +17,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 /* &%/$&!! preprocessor */
@@ -47,12 +47,22 @@
 
 .globl __socket
 ENTRY(__socket)
-
 	/* Save registers and setup stack.  */
 	stm     %r6,%r15,24(%r15)       /* save registers */
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	cfi_offset (%r12, -48)
+	cfi_offset (%r11, -52)
+	cfi_offset (%r10, -56)
+	cfi_offset (%r9, -60)
+	cfi_offset (%r8, -64)
+	cfi_offset (%r7, -68)
+	cfi_offset (%r6, -72)
 	lr      %r1,%r15
 	l       %r0,4(0,%r15)           /* load eos */
 	ahi     %r15,-120               /* buy stack space */
+	cfi_adjust_cfa_offset (120)
 	st      %r1,0(0,%r15)           /* store back chain */
 	st      %r0,4(0,%r15)           /* store eos */
 
@@ -73,6 +83,12 @@
 	st      %r3,0x64(0,%r15)        /* store into parameter list */
 	st      %r2,0x60(0,%r15)
 #endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P (%r4)
+	jne	L(socket_cancel)
+#endif
+
 	/* load subcode for socket syscall */
 	lhi     %r2,P(SOCKOP_,socket)
 	la      %r3,0x60(0,%r15)        /* load address of parameter list */
@@ -80,6 +96,7 @@
 	/* Do the system call trap.  */
 	svc     SYS_ify(socketcall)
 
+4:
 	l       %r15,0(0,%r15)          /* load back chain */
 	lm      %r6,15,24(%r15)         /* load registers */
 
@@ -91,7 +108,35 @@
 	/* Successful; return the syscall's value.  */
 	br      %r14
 
-PSEUDO_END (__socket)
+#if defined NEED_CANCELLATION && defined CENABLE
+L(socket_cancel):
+	basr	%r13,0
+1:	l	%r1,2f-1b(%r13)
+	/* call CENABLE.  */
+	bas	%r14,0(%r13,%r1)
+	lr	%r0,%r2
+
+	/* load subcode for socket syscall */
+	lhi     %r2,P(SOCKOP_,socket)
+	la      %r3,0x60(0,%r15)        /* load address of parameter list */
+
+	/* Do the system call trap.  */
+	svc     SYS_ify(socketcall)
+
+	l	%r3,3f-1b(%r13)
+	lr	%r12,%r2
+	lr	%r2,%r0
+	/* call CDISABLE.  */
+	bas     %r14,0(%r13,%r3)
+	lr	%r2,%r12
+	j	4b
+
+2:	.long	CENABLE-1b
+3:	.long	CDISABLE-1b
+#endif
+
+	SYSCALL_ERROR_HANDLER
+END (__socket)
 
 #ifndef NO_WEAK_ALIAS
 weak_alias (__socket, socket)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/syscall.S
--- sysdeps/unix/sysv/linux/s390/s390-32/syscall.S	2001-07-07 21:21:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/syscall.S	2003-12-06 01:18:52.000000000 +0100
@@ -25,9 +25,20 @@
 ENTRY (syscall)
 	/* Save registers and setup stack.  */
 	stm     %r6,%r15,24(%r15)  /* save registers */
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	cfi_offset (%r12, -48)
+	cfi_offset (%r11, -52)
+	cfi_offset (%r10, -56)
+	cfi_offset (%r9, -60)
+	cfi_offset (%r8, -64)
+	cfi_offset (%r7, -68)
+	cfi_offset (%r6, -72)
 	lr      %r1,%r15
 	l       %r0,4(0,%r15)      /* load eos */
 	ahi     %r15,-96           /* buy stack space */
+	cfi_adjust_cfa_offset (96)
 	st      %r1,0(0,%r15)      /* store back chain */
 	st      %r0,4(0,%r15)      /* store eos */
 
@@ -37,15 +48,20 @@
 	lr     %r4,%r5             /* third parameter  */
 	lr     %r5,%r6             /* fourth parameter */
 	l      %r6,192(%r15)       /* fifth parameter  */
-	basr   %r7,0
-.L0:    ex     %r1,.L1-.L0(%r7)    /* lsb of R1 is subsituted as SVC number */
 
-	l       %r15,0(0,%r15)     /* load back chain */
-	lm      %r6,15,24(%r15)    /* load registers */
+	basr   %r7,0
+0:	cl     %r1,4f-0b(%r7)      /* svc number < 256? */
+	jl     2f
+1:	svc    0
+	j      3f
+2:	ex     %r1,1b-0b(%r7)      /* lsb of R1 is subsituted as SVC number */
+3:	l      %r15,0(%r15)        /* load back chain */
+	cfi_adjust_cfa_offset (-96)
+	lm     %r6,15,24(%r15)     /* load registers */
 
 	lhi    %r0,-4095
 	clr    %r2,%r0             /* check R2 for error */
 	jnl    SYSCALL_ERROR_LABEL
 	br     %r14                /* return to caller */
-.L1:    .word  0x0A00              /* opcode for SVC 0 */
+4:	.long  256
 PSEUDO_END (syscall)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/syscalls.list
--- sysdeps/unix/sysv/linux/s390/s390-32/syscalls.list	2001-03-16 09:29:03.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/syscalls.list	2003-01-12 23:59:39.000000000 +0100
@@ -2,3 +2,4 @@
 
 oldgetrlimit	EXTRA	getrlimit	i:ip	__old_getrlimit	getrlimit@GLIBC_2.0
 oldsetrlimit	EXTRA	setrlimit	i:ip	__old_setrlimit	setrlimit@GLIBC_2.0
+vfork		-	vfork		0	__vfork		vfork
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h
--- sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h	2002-08-26 23:16:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h	2004-10-05 17:39:19.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000,01,02 Free Software Foundation, Inc.
+/* Copyright (C) 2000,01,02,03,04 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -22,6 +22,7 @@
 
 #include <sysdeps/s390/s390-32/sysdep.h>
 #include <sysdeps/unix/sysdep.h>
+#include <dl-sysdep.h>	/* For RTLD_PRIVATE_ERRNO.  */
 
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
@@ -33,10 +34,6 @@
 #undef SYS_ify
 #define SYS_ify(syscall_name)	__NR_##syscall_name
 
-/* ELF-like local names start with `.L'.  */
-#undef L
-#define L(name)	.L##name
-
 #ifdef __ASSEMBLER__
 
 /* Linux uses a negative return value to indicate syscall errors, unlike
@@ -49,8 +46,6 @@
    number.  Linus said he will make sure the no syscall returns a value
    in -1 .. -4095 as a valid result so we can savely test with -4095.  */
 
-#define SYSCALL_ERROR_LABEL 0f
-
 #undef PSEUDO
 #define	PSEUDO(name, syscall_name, args)				      \
   .text;                                                                      \
@@ -58,42 +53,91 @@
     DO_CALL (syscall_name, args);                                             \
     lhi  %r4,-4095 ;                                                          \
     clr  %r2,%r4 ;		                                              \
-    jnl  SYSCALL_ERROR_LABEL ;                                                \
-  L(pseudo_end):
+    jnl  SYSCALL_ERROR_LABEL
 
 #undef PSEUDO_END
 #define PSEUDO_END(name)						      \
   SYSCALL_ERROR_HANDLER;						      \
   END (name)
 
-#ifndef _LIBC_REENTRANT
+#undef PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;                                                                      \
+  ENTRY (name)							              \
+    DO_CALL (syscall_name, args)
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#undef PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args)				      \
+  .text;                                                                      \
+  ENTRY (name)							              \
+    DO_CALL (syscall_name, args);					      \
+    lcr %r2,%r2
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(name)						      \
+  END (name)
+
 #ifndef PIC
-#define SYSCALL_ERROR_HANDLER                                                 \
-0:  lcr     %r2,%r2 ;                                                         \
-    basr    %r1,0 ;                                                           \
-1:  l       %r1,2f-1b(%r1)                                                    \
-    st      %r2,0(%r1)                                                        \
-    lhi     %r2,-1                                                            \
-    br      %r14                                                              \
-2:  .long   errno
+# define SYSCALL_ERROR_LABEL 0f
+# define SYSCALL_ERROR_HANDLER \
+0:  basr  %r1,0;							      \
+1:  l     %r1,2f-1b(%r1);						      \
+    br    %r1;								      \
+2:  .long syscall_error
 #else
-#define SYSCALL_ERROR_HANDLER						      \
-0:  basr    %r1,0 ;                                                           \
-1:  al      %r1,2f-1b(%r1) ;                                                  \
-    l       %r1,errno@GOT12(%r1) ;                                            \
-    lcr     %r2,%r2 ;							      \
-    st      %r2,0(%r1) ;						      \
-    lhi     %r2,-1 ;                                                          \
-    br      %r14 ;                                                            \
-2:  .long   _GLOBAL_OFFSET_TABLE_-1b
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_LABEL 0f
+#  define SYSCALL_ERROR_HANDLER \
+0:  basr  %r1,0;							      \
+1:  al    %r1,2f-1b(%r1);						      \
+    lcr   %r2,%r2;							      \
+    st    %r2,0(%r1);							      \
+    lhi   %r2,-1;							      \
+    br    %r14;								      \
+2:  .long rtld_errno-1b
+# elif defined _LIBC_REENTRANT
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
+#   define SYSCALL_ERROR_LABEL 0f
+#   define SYSCALL_ERROR_HANDLER \
+0:  lcr   %r0,%r2;							      \
+    basr  %r1,0;							      \
+1:  al    %r1,2f-1b(%r1);						      \
+    l     %r1,SYSCALL_ERROR_ERRNO@gotntpoff(%r1)			      \
+    ear   %r2,%a0							      \
+    st    %r0,0(%r1,%r2);						      \
+    lhi   %r2,-1;							      \
+    br    %r14;								      \
+2:  .long _GLOBAL_OFFSET_TABLE_-1b
+#  else
+#   define SYSCALL_ERROR_LABEL 0f
+#   define SYSCALL_ERROR_HANDLER \
+0:  basr  %r1,0;							      \
+1:  al    %r1,2f-1b(%r1);						      \
+    br    %r1;								      \
+2:  .long syscall_error@plt-1b
+#  endif
+# else
+#  define SYSCALL_ERROR_LABEL 0f
+#  define SYSCALL_ERROR_HANDLER \
+0:  basr  %r1,0;							      \
+1:  al    %r1,2f-1b(%r1);						      \
+    l     %r1,errno@GOT(%r1);						      \
+    lcr   %r2,%r2;							      \
+    st    %r2,0(%r1);							      \
+    lhi   %r2,-1;							      \
+    br    %r14;								      \
+2:  .long _GLOBAL_OFFSET_TABLE_-1b
+# endif /* _LIBC_REENTRANT */
 #endif /* PIC */
-#else
-#define SYSCALL_ERROR_HANDLER                                                 \
-0:  basr    %r1,0 ;                                                           \
-1:  al      %r1,2f-1b(%r1) ;                                                  \
-    br      %r1 ;                                                             \
-2:  .long   __syscall_error@PLT-1b
-#endif /* _LIBC_REENTRANT */
 
 /* Linux takes system call arguments in registers:
 
@@ -111,102 +155,110 @@
  */
 
 #define DO_CALL(syscall, args)						      \
-    svc     SYS_ify (syscall)
+  .if SYS_ify (syscall) < 256;						      \
+    svc SYS_ify (syscall);						      \
+  .else;								      \
+    lhi %r1,SYS_ify (syscall);						      \
+    svc 0;								      \
+  .endif
 
 #define ret                                                                   \
     br      14
 
-#endif /* __ASSEMBLER__ */
-
-#undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...)                                     \
-  ({                                                                          \
-    DECLARGS_##nr(args)                                                       \
-    int err;                                                                  \
-    asm volatile (                                                            \
-    LOADARGS_##nr                                                             \
-    "svc    %b1\n\t"                                                          \
-    "lr     %0,%%r2\n\t"                                                      \
-    : "=d" (err)                                                              \
-    : "I" (__NR_##name) ASMFMT_##nr                                           \
-    : "memory", "cc", "2", "3", "4", "5", "6");                               \
-    if (err >= 0xfffff001)                                                    \
-     {                                                                        \
-       __set_errno(-err);                                                     \
-       err = 0xffffffff;                                                      \
-     }                                                                        \
-    (int) err; })
-
-#define DECLARGS_0()
-#define DECLARGS_1(arg1) \
-	unsigned int gpr2 = (unsigned int) (arg1);
-#define DECLARGS_2(arg1, arg2) \
-	DECLARGS_1(arg1) \
-	unsigned int gpr3 = (unsigned int) (arg2);
-#define DECLARGS_3(arg1, arg2, arg3) \
-	DECLARGS_2(arg1, arg2) \
-	unsigned int gpr4 = (unsigned int) (arg3);
-#define DECLARGS_4(arg1, arg2, arg3, arg4) \
-	DECLARGS_3(arg1, arg2, arg3) \
-	unsigned int gpr5 = (unsigned int) (arg4);
-#define DECLARGS_5(arg1, arg2, arg3, arg4, arg5) \
-	DECLARGS_4(arg1, arg2, arg3, arg4) \
-	unsigned int gpr6 = (unsigned int) (arg5);
+#define ret_NOERRNO							      \
+    br      14
 
-#define LOADARGS_0
-#define LOADARGS_1            "L     2,%2\n\t"
-#define LOADARGS_2 LOADARGS_1 "L     3,%3\n\t"
-#define LOADARGS_3 LOADARGS_2 "L     4,%4\n\t"
-#define LOADARGS_4 LOADARGS_3 "L     5,%5\n\t"
-#define LOADARGS_5 LOADARGS_4 "L     6,%6\n\t"
+#define ret_ERRVAL							      \
+    br      14
 
-#define ASMFMT_0
-#define ASMFMT_1 , "m" (gpr2)
-#define ASMFMT_2 , "m" (gpr2), "m" (gpr3)
-#define ASMFMT_3 , "m" (gpr2), "m" (gpr3), "m" (gpr4)
-#define ASMFMT_4 , "m" (gpr2), "m" (gpr3), "m" (gpr4), "m" (gpr5)
-#define ASMFMT_5 , "m" (gpr2), "m" (gpr3), "m" (gpr4), "m" (gpr5), "m" (gpr6)
+#endif /* __ASSEMBLER__ */
 
-#if 0
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...)                                     \
-  ({                                                                          \
-    DECLARGS_##nr(args)                                                       \
-    asm volatile (                                                            \
-    "svc    %b1\n\t"                                                          \
-    : "+d" (gpr2)                                                             \
-    : "I" (__NR_##name) ASMFMT_##nr : "memory", "cc");                        \
-    if (gpr2 >= 0xfffff001)                                                   \
-     {                                                                        \
-       __set_errno(-gpr2);                                                    \
-       gpr2 = 0xffffffff;                                                     \
-     }                                                                        \
-    (int) gpr2; })
+#define INLINE_SYSCALL(name, nr, args...)				      \
+  ({									      \
+    unsigned int _ret = INTERNAL_SYSCALL (name, , nr, args);		      \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_ret, ), 0))	      \
+     {									      \
+       __set_errno (INTERNAL_SYSCALL_ERRNO (_ret, ));			      \
+       _ret = 0xffffffff;						      \
+     }									      \
+    (int) _ret; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_DIRECT
+#define INTERNAL_SYSCALL_DIRECT(name, err, nr, args...)			      \
+  ({									      \
+    DECLARGS_##nr(args)							      \
+    register int _ret asm("2");						      \
+    asm volatile (							      \
+    "svc    %b1\n\t"							      \
+    : "=d" (_ret)							      \
+    : "i" (__NR_##name) ASMFMT_##nr					      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL_SVC0
+#define INTERNAL_SYSCALL_SVC0(name, err, nr, args...)			      \
+  ({									      \
+    DECLARGS_##nr(args)							      \
+    register unsigned long _nr asm("1") = (unsigned long)(__NR_##name);	      \
+    register int _ret asm("2");						      \
+    asm volatile (							      \
+    "svc    0\n\t"							      \
+    : "=d" (_ret)							      \
+    : "d" (_nr) ASMFMT_##nr						      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(no, err, nr, args...)			      \
+  ({									      \
+    DECLARGS_##nr(args)							      \
+    register unsigned long _nr asm("1") = (unsigned long)(no);		      \
+    register int _ret asm("2");						      \
+    asm volatile (							      \
+    "svc    0\n\t"							      \
+    : "=d" (_ret)							      \
+    : "d" (_nr) ASMFMT_##nr						      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)			      \
+  (((__NR_##name) < 256) ?						      \
+    INTERNAL_SYSCALL_DIRECT(name, err, nr, args) :			      \
+    INTERNAL_SYSCALL_SVC0(name, err,nr, args))
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)				      \
+  ((unsigned int) (val) >= 0xfffff001u)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
-#define DECLARGS_0() \
-	register unsigned int gpr2 asm("2");
+#define DECLARGS_0()
 #define DECLARGS_1(arg1) \
-	register unsigned int gpr2 asm("2") = (unsigned int) (arg1);
+	register unsigned long gpr2 asm ("2") = (unsigned long)(arg1);
 #define DECLARGS_2(arg1, arg2) \
 	DECLARGS_1(arg1) \
-	register unsigned int gpr3 asm("3") = (unsigned int) (arg2);
+	register unsigned long gpr3 asm ("3") = (unsigned long)(arg2);
 #define DECLARGS_3(arg1, arg2, arg3) \
 	DECLARGS_2(arg1, arg2) \
-	register unsigned int gpr4 asm("4") = (unsigned int) (arg3);
+	register unsigned long gpr4 asm ("4") = (unsigned long)(arg3);
 #define DECLARGS_4(arg1, arg2, arg3, arg4) \
 	DECLARGS_3(arg1, arg2, arg3) \
-	register unsigned int gpr5 asm("5") = (unsigned int) (arg4);
+	register unsigned long gpr5 asm ("5") = (unsigned long)(arg4);
 #define DECLARGS_5(arg1, arg2, arg3, arg4, arg5) \
 	DECLARGS_4(arg1, arg2, arg3, arg4) \
-	register unsigned int gpr6 asm("6") = (unsigned int) (arg5);
+	register unsigned long gpr6 asm ("6") = (unsigned long)(arg5);
 
 #define ASMFMT_0
-#define ASMFMT_1
-#define ASMFMT_2 , "d" (gpr3)
-#define ASMFMT_3 , "d" (gpr3), "d" (gpr4)
-#define ASMFMT_4 , "d" (gpr3), "d" (gpr4), "d" (gpr5)
-#define ASMFMT_5 , "d" (gpr3), "d" (gpr4), "d" (gpr5), "d" (gpr6)
-
-#endif /* 0 */
+#define ASMFMT_1 , "0" (gpr2)
+#define ASMFMT_2 , "0" (gpr2), "d" (gpr3)
+#define ASMFMT_3 , "0" (gpr2), "d" (gpr3), "d" (gpr4)
+#define ASMFMT_4 , "0" (gpr2), "d" (gpr3), "d" (gpr4), "d" (gpr5)
+#define ASMFMT_5 , "0" (gpr2), "d" (gpr3), "d" (gpr4), "d" (gpr5), "d" (gpr6)
 
 #endif /* _LINUX_S390_SYSDEP_H */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.S
--- sysdeps/unix/sysv/linux/s390/s390-32/sysdep.S	2002-08-25 01:20:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.S	2004-10-04 22:59:35.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -18,20 +18,7 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
-
-/* The Linux version is in fact S390-32/ELF and the start.? file for this
-   system (sysdeps/s390/s390-32/elf/start.S) is also used by The Hurd.
-   This file must not contain the definition of the `errno' variable,
-   we have to define it somewhere else.
-
-    ...and this place is here.  */
-	.bss
-	.globl	errno
-	.type errno,@object
-	.size errno,4
-errno:
-	.space	4
-weak_alias (errno, _errno)
+#include <tls.h>
 
 /* The following code is only used in the shared library when we
    compile the reentrant version.  Otherwise each system call defines
@@ -45,59 +32,106 @@
 	.text
 ENTRY(__syscall_error)
 #ifndef PIC
-#ifndef _LIBC_REENTRANT
-	lcr     %r2,%r2
-	basr    %r1,0
-.L0:    l       %r1,.L1-.L0(%r1)
-	st      %r2,0(0,%r1)
-	lhi     %r2,-1
-	br      %r14
-.L1:    .long  errno
-#else
-	stm     %r11,%r15,44(%r15)
-	lr      %r0,%r15
-	ahi     %r15,-96
-	st      %r0,0(%r15)
-	lcr     %r11,%r2
-	basr    %r13,0
-.L0:	l       %r1,.L1-.L0(%r13)
-	basr    %r14,%r1
-	st      %r11,0(%r2)
-	lhi     %r2,-1
-	l       %r15,0(%r15)
-	lm      %r11,%r15,44(%r15)
-	br      %r14
-.L1:	.long  __errno_location
+# if USE___THREAD
+#  ifndef NOT_IN_libc
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+	basr	%r1,0
+0:	l	%r1,1f-0b(%r1)
+	ear	%r3,%a0
+	lcr	%r2,%r2
+	st	%r2,0(%r1,%r3)
+	lhi	%r2,-1
+	br	%r14
+1:	.long	SYSCALL_ERROR_ERRNO@ntpoff
+# elif !defined _LIBC_REENTRANT
+	basr	%r1,0
+0:	l	%r1,1f-0b(%r1)
+	lcr	%r2,%r2
+	st	%r2,0(%r1)
+	lhi	%r2,-1
+	br	%r14
+1:	.long  errno
+# else
+	stm	%r13,%r15,52(%r15)
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	lr	%r0,%r15
+	ahi	%r15,-96
+	cfi_adjust_cfa_offset (96)
+	lcr	%r13,%r2
+	st	%r0,0(%r15)
+	basr	%r1,0
+0:	l	%r1,1f-0b(%r1)
+	basr	%r14,%r1
+	st	%r13,0(%r2)
+	lm	%r13,%r15,148(%r15)
+	cfi_adjust_cfa_offset (-96)
+	lhi	%r2,-1
+	br	%r14
+1:	.long  __errno_location
 #endif
 #else
-#ifndef _LIBC_REENTRANT
-	basr    %r1,0
-.L0:    al      %r1,.L1-.L0(%r1)
-	l       %r1,errno@GOT12(%r1)
-	lcr     %r2,%r2
-	st      %r2,0(0,%r1)
-	lhi     %r2,-1
-	br      %r14
-.L1:    .long   _GLOBAL_OFFSET_TABLE_-0b
-#else
-	stm     %r11,%r15,44(%r15)
-	lr      %r0,%r15
-	ahi     %r15,-96
-	st      %r0,0(%r15)
-	lcr     %r11,%r2
-	basr    %r13,0
-.L0:	l       %r12,.L1-.L0(%r13)
-	ar      %r12,%r13
-	l       %r14,.L2-.L0(%r13)
-	bas     %r14,0(%r14,%r13)
-	st      %r11,0(0,%r2)
-	lhi     %r2,-1
-	l       %r15,0(%r15)
-	lm      %r11,%r15,44(%r15)
-	br      %r14
-.L1:	.long _GLOBAL_OFFSET_TABLE_ - .L0
-.L2:    .long __errno_location@PLT - .L0
-#endif
+# if RTLD_PRIVATE_ERRNO
+	basr	%r1,0
+0:	al	%r1,1f-0b(%r1)
+	lcr	%r2,%r2
+	st	%r2,0(%r1)
+	lhi	%r2,-1
+	br	%r14
+1:	.long	rtld_errno - 0b
+# elif USE___THREAD
+#  ifndef NOT_IN_libc
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+	basr	%r1,0
+0:	al	%r1,1f-0b(%r1)
+	ear	%r3,%a0
+	l	%r1,SYSCALL_ERROR_ERRNO@gotntpoff(%r1)
+	lcr	%r2,%r2
+	st	%r2,0(%r1,%r3)
+	lhi	%r2,-1
+	br	%r14
+1:	.long	_GLOBAL_OFFSET_TABLE_-0b
+# elif !defined _LIBC_REENTRANT
+	basr	%r1,0
+0:	al	%r1,1f-0b(%r1)
+	l	%r1,errno@GOT(%r1)
+	lcr	%r2,%r2
+	st	%r2,0(0,%r1)
+	lhi	%r2,-1
+	br	%r14
+1:	.long	_GLOBAL_OFFSET_TABLE_-0b
+# else
+	stm	%r11,%r15,44(%r15)
+	cfi_offset (%r15, -36)
+	cfi_offset (%r14, -40)
+	cfi_offset (%r13, -44)
+	cfi_offset (%r12, -48)
+	cfi_offset (%r11, -52)
+	lr	%r0,%r15
+	ahi	%r15,-96
+	cfi_adjust_cfa_offset (96)
+	lcr	%r11,%r2
+	st	%r0,0(%r15)
+	basr	%r13,0
+0:	l	%r12,1f-0b(%r13)
+	l	%r1,2f-0b(%r13)
+	la	%r12,0(%r12,%r13)
+	bas	%r14,0(%r1,%r13)
+	st	%r11,0(%r2)
+	lm	%r11,%r15,140(%r15)
+	cfi_adjust_cfa_offset (-96)
+	lhi	%r2,-1
+	br	%r14
+1:	.long _GLOBAL_OFFSET_TABLE_-0b
+2:	.long __errno_location@PLT-0b
+# endif
 #endif
 
 END (__syscall_error)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-32/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/Versions
--- sysdeps/unix/sysv/linux/s390/s390-32/Versions	2002-08-23 21:47:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-32/Versions	2003-08-22 20:10:45.000000000 +0200
@@ -23,5 +23,7 @@
     # v*
     versionsort64;
   }
+  GLIBC_2.3.3 {
+    posix_fadvise64; posix_fallocate64;
+  }
 }
-
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/clone.S
--- sysdeps/unix/sysv/linux/s390/s390-64/clone.S	2002-02-07 18:30:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/clone.S	2004-12-15 18:45:23.000000000 +0100
@@ -1,5 +1,5 @@
 /* Wrapper around clone system call.  64 bit S/390 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -22,35 +22,58 @@
    and invokes a function in the right context after its all over.  */
 
 #include <sysdep.h>
+#include <tls.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
 
+/* int __clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+               pid_t *parent_tid, void *tls, pid_t *child_tid);  */
+/* sys_clone  (void *child_stack, unsigned long flags,
+               pid_t *parent_tid, pid_t *child_tid, void *tls);  */
+
 	.text
 ENTRY(__clone)
-	/* Sanity check arguments & move registers */
-	ltgr	%r1,%r2			/* no NULL function pointers */
-	lghi	%r2,-EINVAL
-	jz	SYSCALL_ERROR_LABEL
-	ltgr	%r3,%r3			/* no NULL stack pointers */
-	jz	SYSCALL_ERROR_LABEL
-	/* move child_stack and flags, then call SVC */
-	lgr	%r2,%r3
-	lgr	%r3,%r4
+	stg	%r6,48(%r15)		/* store %r6 to save area */
+	cfi_offset (%r6,-112)
+	lgr	%r0,%r5			/* move *arg out of the way */
+	ltgr    %r1,%r2			/* check fn and move to %r1 */
+	jz      error			/* no NULL function pointers */
+	ltgr    %r2,%r3			/* check child_stack and move to %r2 */
+	jz	error			/* no NULL stack pointers */
+	lgr	%r3,%r4			/* move flags to %r3 */
+	lgr	%r4,%r6			/* move parent_tid to %r4 */
+	lg	%r5,168(%r15)		/* load child_tid from stack */
+	lg	%r6,160(%r15)		/* load tls from stack */
 	svc	SYS_ify(clone)
 	ltgr	%r2,%r2			/* check return code */
-	jm	SYSCALL_ERROR_LABEL
 	jz	thread_start
+	lg	%r6,48(%r15)		/* restore %r6 */
+	jgm	SYSCALL_ERROR_LABEL
 	br	%r14
+error:
+	lghi	%r2,-EINVAL
+	jg	SYSCALL_ERROR_LABEL
+PSEUDO_END (__clone)
 
 thread_start:
-	/* fn is in gpr 1, arg in gpr 5 */
-	lgr	%r2,%r5		/* set first parameter to void *arg */
-	sgr	%r11,%r11	/* terminate the stack frame */
+#ifdef RESET_PID
+	tmh	%r3,1		/* CLONE_THREAD == 0x00010000 */
+	jne	1f
+	lhi	%r2,-1
+	tml	%r3,256		/* CLONE_VM == 0x00000100 */
+	jne	2f
+	svc	SYS_ify(getpid)
+2:	ear	%r3,%a0
+	sllg	%r3,%r3,32
+	ear	%r3,%a1
+	st	%r2,PID(%r3)
+	st	%r2,TID(%r3)
+1:
+#endif
+	/* fn is in gpr 1, arg in gpr 0 */
+	lgr	%r2,%r0		/* set first parameter to void *arg */
 	aghi	%r15,-160	/* make room on the stack for the save area */
+	xc	0(8,%r15),0(%r15)
 	basr	%r14,%r1	/* jump to fn */
-#ifdef PIC
-	larl	%r12,_GLOBAL_OFFSET_TABLE_
-#endif
-	jg	_exit@PLT	/* branch to _exit -> thread termination */
-PSEUDO_END (__clone)
+	DO_CALL	(exit, 1)
 weak_alias (__clone, clone)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Dist
--- sysdeps/unix/sysv/linux/s390/s390-64/Dist	2002-08-27 12:59:14.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Dist	2003-02-20 23:20:34.000000000 +0100
@@ -1,3 +1,2 @@
 clone.S
-kernel_stat.h
 ucontext_i.h
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/fstatfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fstatfs64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/fstatfs64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fstatfs64 is the same as fstatfs. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/ftruncate64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/ftruncate64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* ftruncate64 is the same as ftruncate. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fxstat64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/fxstat64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fxstat64 is in fxstat.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fxstat.c
--- sysdeps/unix/sysv/linux/s390/s390-64/fxstat.c	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/fxstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/* fxstat using old-style Unix fstat system call.  64 bit S/390 version.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
-   will complain since they don't strictly match.  */
-#define __fxstat64 __fxstat64_disable
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/stat.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-extern int __syscall_fstat (int, struct stat *);
-
-/* Get information about the file FD in BUF.  */
-int
-__fxstat (int vers, int fd, struct stat *buf)
-{
-  return INLINE_SYSCALL (fstat, 2, fd, buf);
-}
-
-hidden_def (__fxstat)
-weak_alias (__fxstat, _fxstat);
-#undef __fxstat64
-strong_alias (__fxstat, __fxstat64);
-hidden_ver (__fxstat, __fxstat64)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/getdents64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getdents64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/getdents64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getdents64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getdents64 is in getdents.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/getdents.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getdents.c
--- sysdeps/unix/sysv/linux/s390/s390-64/getdents.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getdents.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#define __getdents64 __no___getdents64_decl
-#include <sysdeps/unix/sysv/linux/getdents.c>
-#undef __getdents64
-weak_alias(__getdents, __getdents64);
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/getrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getrlimit64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/getrlimit64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/getrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getrlimit64 is the same as getrlimit. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/glob64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/glob64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/glob64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* glob64 is in glob.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Implies
--- sysdeps/unix/sysv/linux/s390/s390-64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Implies	2004-03-24 00:26:24.000000000 +0100
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/kernel_stat.h
--- sysdeps/unix/sysv/linux/s390/s390-64/kernel_stat.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/kernel_stat.h	2003-06-12 18:15:15.000000000 +0200
@@ -1,6 +1,5 @@
-/* Definition of `struct stat' used in the kernel.  64 bit S/390 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
+/* Definition of `struct stat' used in the kernel.
+   Copyright (C) 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,29 +17,5 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-struct kernel_stat
-  {
-    unsigned int st_dev;
-    unsigned int st_ino;
-    unsigned int st_mode;
-    unsigned int st_nlink;
-    unsigned int st_uid;
-    unsigned int st_gid;
-    unsigned int st_rdev;
-    unsigned int __pad1;
-    unsigned long int st_size;
-    unsigned long int st_atime;
-    unsigned long int st_mtime;
-    unsigned long int st_ctime;
-    unsigned int  st_blksize;
-    int st_blocks;
-    unsigned long __unused1;
-    unsigned long __unused2;
-  };
-
-extern int __xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf);
-
+#define STAT_IS_KERNEL_STAT 1
 #define XSTAT_IS_XSTAT64 1
-#define _HAVE___UNUSED1
-#define _HAVE___UNUSED2
-
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/lxstat64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/lxstat64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* lxstat64 is in lxstat.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/lxstat.c
--- sysdeps/unix/sysv/linux/s390/s390-64/lxstat.c	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/lxstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/* lxstat using old-style Unix fstat system call.  64 bit S/390 version.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
-   will complain since they don't strictly match.  */
-#define __lxstat64 __lxstat64_disable
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/stat.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-extern int __syscall_lstat (const char *, struct stat *);
-
-/* Get information about the file FD in BUF.  */
-int
-__lxstat (int vers, const char *name, struct stat *buf)
-{
-  return INLINE_SYSCALL (lstat, 2, name, buf);
-}
-
-hidden_def (__lxstat)
-weak_alias (__lxstat, _lxstat);
-#undef __lxstat64
-strong_alias (__lxstat, __lxstat64);
-hidden_ver (__lxstat, __lxstat64)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Makefile
--- sysdeps/unix/sysv/linux/s390/s390-64/Makefile	2002-02-07 18:30:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/Makefile	2002-10-14 03:02:54.000000000 +0200
@@ -1,5 +1,4 @@
 ifeq ($(subdir),misc)
-sysdep_routines += setfsgid setfsuid setresgid setresuid
 sysdep_headers += sys/elf.h
 endif
 
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/mmap64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/mmap64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/mmap64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* mmap64 is the same as mmap. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/mmap.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/mmap.S
--- sysdeps/unix/sysv/linux/s390/s390-64/mmap.S	2002-02-07 18:30:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/mmap.S	2003-12-06 01:18:40.000000000 +0100
@@ -27,9 +27,20 @@
 ENTRY(__mmap)
 	/* Save registers and setup stack frame.  */
         stmg    %r6,%r15,48(%r15)
+	cfi_offset (%r15,-40)
+	cfi_offset (%r14,-48)
+	cfi_offset (%r13,-56)
+	cfi_offset (%r12,-64)
+	cfi_offset (%r11,-72)
+	cfi_offset (%r10,-80)
+	cfi_offset (%r9,-88)
+	cfi_offset (%r8,-96)
+	cfi_offset (%r7,-104)
+	cfi_offset (%r6,-112)
         lgr     %r1,%r15
         lg      %r0,8(%r15)             /* Load eos.  */
         aghi    %r15,-208               /* Buy stack space.  */
+	cfi_adjust_cfa_offset (208)
         stg     %r1,0(%r15)             /* Store back chain.  */
         stg     %r0,8(%r15)             /* Store eos.  */
 
@@ -50,12 +61,13 @@
         svc     SYS_ify(mmap)
 
         lg      %r15,0(%r15)            /* Load back chain.  */
+	cfi_adjust_cfa_offset (-208)
         lmg     %r6,%r15,48(%r15)       /* Load registers.  */
 
         /* Check gpr 2 for error.  */ 
         lghi    %r0,-4096
         clgr    %r2,%r0
-        jnl     SYSCALL_ERROR_LABEL
+        jgnl    SYSCALL_ERROR_LABEL
 
         /* Successful; return the syscall's value.  */
         br      %r14
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/pread64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/pread64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/pread64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/pwrite64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/pwrite64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pwrite syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/readdir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/readdir64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64 is in readdir.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/readdir64_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir64_r.c
--- sysdeps/unix/sysv/linux/s390/s390-64/readdir64_r.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir64_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64_r is in readdir_r.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/readdir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir.c
--- sysdeps/unix/sysv/linux/s390/s390-64/readdir.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-#define readdir64 __no_readdir64_decl
-#define __readdir64 __no___readdir64_decl
-#include <sysdeps/unix/readdir.c>
-#undef __readdir64
-strong_alias (__readdir, __readdir64)
-#undef readdir64
-weak_alias (__readdir, readdir64)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/readdir_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir_r.c
--- sysdeps/unix/sysv/linux/s390/s390-64/readdir_r.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/readdir_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#define readdir64_r __no_readdir64_r_decl
-#include <sysdeps/unix/readdir_r.c>
-#undef readdir64_r
-weak_alias (__readdir_r, readdir64_r)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/setrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/setrlimit64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/setrlimit64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/setrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* setrlimit64 is the same as setrlimit. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigaction.c
--- sysdeps/unix/sysv/linux/s390/s390-64/sigaction.c	2002-09-18 19:59:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigaction.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,9 +26,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_rt_sigaction (int, const struct sigaction *,
-				   struct sigaction *, size_t);
-
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  This is the definition.  */
 
@@ -46,6 +43,9 @@
   return INLINE_SYSCALL (rt_sigaction, 4, sig, act, oact, _NSIG / 8);
 }
 libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction)
+#endif
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sigpending.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigpending.c
--- sysdeps/unix/sysv/linux/s390/s390-64/sigpending.c	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigpending.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,9 +26,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_rt_sigpending (sigset_t *, size_t);
-
-
 /* Change the set of blocked signals to SET,
    wait until a signal arrives, and restore the set of blocked signals.  */
 int
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sigprocmask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigprocmask.c
--- sysdeps/unix/sysv/linux/s390/s390-64/sigprocmask.c	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigprocmask.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,9 +26,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_rt_sigprocmask (int, const sigset_t *,
-				     sigset_t *, size_t);
-
 /* Get and/or change the set of blocked signals.  */
 int
 __sigprocmask (how, set, oset)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sigsuspend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigsuspend.c
--- sysdeps/unix/sysv/linux/s390/s390-64/sigsuspend.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sigsuspend.c	2003-09-03 05:21:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,12 +20,9 @@
 #include <signal.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 
-extern int __syscall_rt_sigsuspend (const sigset_t *, size_t);
-
-
 /* Change the set of blocked signals to SET,
    wait until a signal arrives, and restore the set of blocked signals.  */
 int
@@ -34,7 +31,17 @@
 {
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
-  return INLINE_SYSCALL (rt_sigsuspend, 2, set, _NSIG / 8);
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (rt_sigsuspend, 2, set, _NSIG / 8);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (rt_sigsuspend, 2, set, _NSIG / 8);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 libc_hidden_def (__sigsuspend)
 weak_alias (__sigsuspend, sigsuspend)
+strong_alias (__sigsuspend, __libc_sigsuspend)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/socket.S
--- sysdeps/unix/sysv/linux/s390/s390-64/socket.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/socket.S	2003-12-06 01:15:55.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -17,7 +17,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 /* &%/$&!! preprocessor */
@@ -47,12 +47,22 @@
 
 .globl __socket
 ENTRY(__socket)
-
 	/* Save registers and setup stack.  */
         stmg    %r6,%r15,48(%r15)       /* Save registers.  */
+	cfi_offset (%r15,-40)
+	cfi_offset (%r14,-48)
+	cfi_offset (%r13,-56)
+	cfi_offset (%r12,-64)
+	cfi_offset (%r11,-72)
+	cfi_offset (%r10,-80)
+	cfi_offset (%r9,-88)
+	cfi_offset (%r8,-96)
+	cfi_offset (%r7,-104)
+	cfi_offset (%r6,-112)
         lgr     %r1,%r15
         lg      %r0,8(%r15)             /* Load eos.  */
         ahi     %r15,-208               /* Buy stack space.  */
+	cfi_adjust_cfa_offset (208)
         stg     %r1,0(%r15)             /* Store back chain.  */
         stg     %r0,8(%r15)             /* Store eos.  */
 
@@ -73,6 +83,12 @@
         stg     %r3,168(%r15)           /* Store into parameter list.  */
 	stg     %r2,160(%r15)
 #endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	jne	L(socket_cancel)
+#endif
+
         /* Load subcode for socket syscall.  */
         lghi    %r2,P(SOCKOP_,socket)
 	la      %r3,160(%r15)           /* Load address of parameter list.  */
@@ -80,18 +96,39 @@
         /* Do the system call trap.  */
         svc     SYS_ify(socketcall)
 
+4:
         lg      %r15,0(%r15)            /* Load back chain.  */
         lmg     %r6,15,48(%r15)         /* Load registers.  */
 
 	/* gpr2 is < 0 if there was an error.  */
         lghi    %r0,-125 
         clgr    %r2,%r0
-        jnl     SYSCALL_ERROR_LABEL
+        jgnl    SYSCALL_ERROR_LABEL
  
 	/* Successful; return the syscall's value.  */
 	br      %r14
 
-PSEUDO_END (__socket)
+#if defined NEED_CANCELLATION && defined CENABLE
+L(socket_cancel):
+	brasl	%r14,CENABLE
+	lr	%r0,%r2
+
+	/* Load subcode for socket syscall.  */
+	lghi	%r2,P(SOCKOP_,socket)
+	la	%r3,160(%r15)		/* Load address of parameter list.  */
+
+	/* Do the system call trap.  */
+	svc	SYS_ify(socketcall)
+
+	lgr	%r12,%r2
+	lr	%r2,%r0
+	brasl	%r14,CDISABLE
+
+	lgr	%r2,%r12
+	j	4b
+#endif
+
+END (__socket)
 
 #ifndef NO_WEAK_ALIAS
 weak_alias (__socket, socket)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/statfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/statfs64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/statfs64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/statfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* statfs64 is the same as statfs. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/syscall.S
--- sysdeps/unix/sysv/linux/s390/s390-64/syscall.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/syscall.S	2003-12-06 01:18:52.000000000 +0100
@@ -25,9 +25,20 @@
 ENTRY (syscall)
 	/* Save registers and setup stack.  */
 	stmg	%r6,%r15,48(%r15)  /* Save registers.  */
+	cfi_offset (%r15,-40)
+	cfi_offset (%r14,-48)
+	cfi_offset (%r13,-56)
+	cfi_offset (%r12,-64)
+	cfi_offset (%r11,-72)
+	cfi_offset (%r10,-80)
+	cfi_offset (%r9,-88)
+	cfi_offset (%r8,-96)
+	cfi_offset (%r7,-104)
+	cfi_offset (%r6,-112)
 	lgr	%r1,%r15
 	lg	%r0,8(%r15)	   /* Load eos.	 */
 	aghi	%r15,-160	   /* Buy stack space.	*/
+	cfi_adjust_cfa_offset (160)
 	stg	%r1,0(%r15)	   /* Store back chain.	 */
 	stg	%r0,8(%r15)	   /* Store eos.  */
 	
@@ -37,16 +48,21 @@
 	lgr    %r4,%r5		   /* Third parameter.	*/
 	lgr    %r5,%r6		   /* Fourth parameter.	 */
 	lg     %r6,320(%r15)	   /* Fifth parameter.	*/
-	basr   %r7,0
-.L0:	ex     %r1,.L1-.L0(%r7)	   /* Lsb of R1 is subsituted as SVC number.  */
 
-	lg	%r15,0(%r15)	   /* Load back chain.	*/
+	basr   %r7,0
+0:	clg    %r1,4f-0b(%r7)      /* svc number < 256? */
+	jl     2f
+1:	svc    0
+	j      3f
+2:	ex     %r1,1b-0b(%r7)      /* lsb of R1 is subsituted as SVC number */
+3:	lg     %r15,0(%r15)        /* load back chain */
+	cfi_adjust_cfa_offset (-160)
 	lmg	%r6,15,48(%r15)	   /* Load registers.  */
 
 	lghi   %r0,-4095
 	clgr   %r2,%r0		   /* Check R2 for error.  */
-	jnl    SYSCALL_ERROR_LABEL
+	jgnl   SYSCALL_ERROR_LABEL
 	br     %r14		   /* Return to caller.	 */
-.L1:	.word  0x0A00		   /* Opcode for SVC 0.	 */
+4:	.quad  256
 PSEUDO_END (syscall)
 
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/syscalls.list
--- sysdeps/unix/sysv/linux/s390/s390-64/syscalls.list	2002-08-10 20:09:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/syscalls.list	2004-03-24 00:31:18.000000000 +0100
@@ -1,22 +1,13 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
-llseek		EXTRA	lseek		3	__libc_lseek	__lseek lseek __libc_lseek64 __llseek llseek __lseek64 lseek64
-lseek		llseek	-
-pread		-	pread		4	__libc_pread	__libc_pread64 __pread pread __pread64 pread64
-pwrite		-	pwrite		4	__libc_pwrite	__libc_pwrite64 __pwrite pwrite __pwrite64 pwrite64
-fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs fstatfs64 __fstatfs64
-statfs		-	statfs		i:sp	__statfs	statfs statfs64
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
-ftruncate	-	ftruncate	2	__ftruncate	ftruncate ftruncate64 __ftruncate64
-truncate	-	truncate	2	truncate	truncate64
-getrlimit	-	getrlimit	2	__getrlimit	getrlimit getrlimit64
-setrlimit	-	setrlimit	2	__setrlimit	setrlimit setrlimit64
+vfork		-	vfork		0	__vfork		vfork
 
 # semaphore and shm system calls
 msgctl		-	msgctl		i:iip	__msgctl	msgctl
 msgget		-	msgget		i:ii	__msgget	msgget
-msgrcv		-	msgrcv		i:ibnii	__msgrcv	msgrcv
-msgsnd		-	msgsnd		i:ibni	__msgsnd	msgsnd
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
 shmat		-	shmat		i:ipi	__shmat		shmat
 shmctl		-	shmctl		i:iip	__shmctl	shmctl
 shmdt		-	shmdt		i:s	__shmdt		shmdt
@@ -26,30 +17,20 @@
 semctl		-	semctl		i:iiii	__semctl	semctl
 
 # proper socket implementations:
-accept		-	accept		i:iBN	__libc_accept	__accept accept
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
 bind		-	bind		i:ipi	__bind		bind
-connect		-	connect		i:ipi	__libc_connect	__connect_internal __connect connect
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
 getsockname	-	getsockname	i:ipp	__getsockname	getsockname
 getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
 listen		-	listen		i:ii	__listen	listen
-recv		-	recv		i:ibni	__libc_recv	__recv recv
-recvfrom	-	recvfrom	i:ibniBN	__libc_recvfrom	__recvfrom recvfrom
-recvmsg		-	recvmsg		i:ipi	__libc_recvmsg	__recvmsg recvmsg
-send		-	send		i:ibni	__libc_send	__send send
-sendmsg		-	sendmsg		i:ipi	__libc_sendmsg	__sendmsg sendmsg
-sendto		-	sendto		i:ibnibn	__libc_sendto	__sendto sendto
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
 setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
 socket		-	socket		i:iii	__socket	socket
 socketpair	-	socketpair	i:iiif	__socketpair	socketpair
-
-getresuid	-	getresuid	i:ppp	getresuid
-getresgid	-	getresgid	i:ppp	getresgid
-
-rt_sigaction	EXTRA	rt_sigaction	i:ippi	__syscall_rt_sigaction		rt_sigaction
-rt_sigpending	EXTRA	rt_sigpending	i:pi	__syscall_rt_sigpending		rt_sigpending
-rt_sigprocmask	EXTRA	rt_sigprocmask	i:ippi	__syscall_rt_sigprocmask	rt_sigprocmask
-rt_sigqueueinfo	EXTRA	rt_sigqueueinfo	i:iip	__syscall_rt_sigqueueinfo	rt_sigqueueinfo
-rt_sigsuspend	EXTRA	rt_sigsuspend	i:pi	__syscall_rt_sigsuspend		rt_sigsuspend
-rt_sigtimedwait	EXTRA	rt_sigtimedwait	i:pppi	__syscall_rt_sigtimedwait	rt_sigtimedwait
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h
--- sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h	2002-08-26 23:16:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h	2004-10-05 17:39:19.000000000 +0200
@@ -1,5 +1,5 @@
 /* Assembler macros for 64 bit S/390.
-   Copyright (C) 2001,02 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -19,10 +19,11 @@
    02111-1307 USA.  */
 
 #ifndef _LINUX_S390_SYSDEP_H
-#define _LINUX_S390_SYSEDP_H
+#define _LINUX_S390_SYSDEP_H
 
 #include <sysdeps/s390/s390-64/sysdep.h>
 #include <sysdeps/unix/sysdep.h>
+#include <dl-sysdep.h>	/* For RTLD_PRIVATE_ERRNO.  */
 
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
@@ -31,13 +32,20 @@
 /* In newer 2.1 kernels __NR_syscall is missing so we define it here.  */
 #define __NR_syscall 0
 
+/*
+ * Newer kernel versions redefined __NR_pread and __NR_pwrite to
+ * __NR_pread64 and __NR_pwrite64.
+ */
+#ifndef __NR_pread
+# define __NR_pread __NR_pread64
+#endif
+#ifndef __NR_pwrite
+# define __NR_pwrite __NR_pwrite64
+#endif
+
 #undef SYS_ify
 #define SYS_ify(syscall_name)	__NR_##syscall_name
 
-/* ELF-like local names start with `.L'.  */
-#undef L
-#define L(name)	.L##name
-
 #ifdef __ASSEMBLER__
 
 /* Linux uses a negative return value to indicate syscall errors, unlike
@@ -50,8 +58,6 @@
    number.  Linus said he will make sure the no syscall returns a value
    in -1 .. -4095 as a valid result so we can savely test with -4095.  */
 
-#define SYSCALL_ERROR_LABEL 0f
-
 #undef PSEUDO
 #define	PSEUDO(name, syscall_name, args)				      \
   .text;								      \
@@ -59,35 +65,81 @@
     DO_CALL (syscall_name, args);					      \
     lghi %r4,-4095 ;							      \
     clgr %r2,%r4 ;							      \
-    jnl SYSCALL_ERROR_LABEL ;						      \
-  L(pseudo_end):
+    jgnl SYSCALL_ERROR_LABEL
 
 #undef PSEUDO_END
 #define PSEUDO_END(name)						      \
   SYSCALL_ERROR_HANDLER;						      \
   END (name)
 
-#ifndef _LIBC_REENTRANT
+#undef PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name)					      \
+  SYSCALL_ERROR_HANDLER;						      \
+  END (name)
+
+#undef PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    lcgr %r2,%r2
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(name)						      \
+  SYSCALL_ERROR_HANDLER;						      \
+  END (name)
+
 #ifndef PIC
-#define SYSCALL_ERROR_HANDLER						      \
-0:  lcr	    %r2,%r2 ;							      \
-    larl    %r1,errno ;							      \
-    st	    %r2,0(%r1) ;						      \
-    lghi    %r2,-1 ;							      \
-    br	    %r14
+# define SYSCALL_ERROR_LABEL syscall_error
+# define SYSCALL_ERROR_HANDLER
 #else
-#define SYSCALL_ERROR_HANDLER						      \
-0:  larl    %r1,_GLOBAL_OFFSET_TABLE_ ;					      \
-    lg	    %r1,errno@GOT(%r1) ;					      \
-    lcr	    %r2,%r2 ;							      \
-    st	    %r2,0(%r1) ;						      \
-    lghi    %r2,-1 ;							      \
-    br	    %r14
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_LABEL 0f
+#  define SYSCALL_ERROR_HANDLER \
+0:  larl  %r1,rtld_errno;						      \
+    lcr   %r2,%r2;							      \
+    st    %r2,0(%r1);							      \
+    lghi  %r2,-1;							      \
+    br    %r14
+# elif defined _LIBC_REENTRANT
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
+#   define SYSCALL_ERROR_LABEL 0f
+#   define SYSCALL_ERROR_HANDLER \
+0:  lcr   %r0,%r2;							      \
+    larl  %r1,SYSCALL_ERROR_ERRNO@indntpoff;				      \
+    lg    %r1,0(%r1);							      \
+    ear   %r2,%a0;							      \
+    sllg  %r2,%r2,32;							      \
+    ear   %r2,%a1;							      \
+    st    %r0,0(%r1,%r2);						      \
+    lghi   %r2,-1;							      \
+    br    %r14
+#  else
+#   define SYSCALL_ERROR_LABEL syscall_error@plt
+#   define SYSCALL_ERROR_HANDLER
+#  endif
+# else
+#  define SYSCALL_ERROR_LABEL 0f
+#  define SYSCALL_ERROR_HANDLER \
+0:  larl  %r1,_GLOBAL_OFFSET_TABLE_;					      \
+    lg    %r1,errno@GOT(%r1);						      \
+    lcr   %r2,%r2;							      \
+    st    %r2,0(%r1);							      \
+    lghi  %r2,-1;							      \
+    br    %r14
+# endif /* _LIBC_REENTRANT */
 #endif /* PIC */
-#else
-#define SYSCALL_ERROR_HANDLER						      \
-0:  jg	    __syscall_error@PLT
-#endif /* _LIBC_REENTRANT */
 
 /* Linux takes system call arguments in registers:
 
@@ -105,60 +157,110 @@
  */
 
 #define DO_CALL(syscall, args)						      \
-    svc	    SYS_ify (syscall)
+  .if SYS_ify (syscall) < 256;						      \
+    svc SYS_ify (syscall);						      \
+  .else;								      \
+    lghi %r1,SYS_ify (syscall);						      \
+    svc 0;								      \
+  .endif
 
 #define ret								      \
     br	    14
 
+#define ret_NOERRNO							      \
+    br	    14
+
+#define ret_ERRVAL							      \
+    br	    14
+
 #endif /* __ASSEMBLER__ */
 
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...)				      \
   ({									      \
+    long _ret = INTERNAL_SYSCALL (name, , nr, args);			      \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_ret, ), 0))	      \
+     {									      \
+       __set_errno (INTERNAL_SYSCALL_ERRNO (_ret, ));			      \
+       _ret = -1;							      \
+     }									      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_DIRECT
+#define INTERNAL_SYSCALL_DIRECT(name, err, nr, args...)			      \
+  ({									      \
     DECLARGS_##nr(args)							      \
-    int err;								      \
+    register long _ret asm("2");					      \
     asm volatile (							      \
-    LOADARGS_##nr							      \
     "svc    %b1\n\t"							      \
-    "lgr    %0,%%r2\n\t"						      \
-    : "=d" (err)							      \
-    : "I" (__NR_##name) ASMFMT_##nr					      \
-    : "memory", "cc", "2", "3", "4", "5", "6");				      \
-    if (err >= 0xfffff001)						      \
-     {									      \
-       __set_errno(-err);						      \
-       err = -1;							      \
-     }									      \
-    (int) err; })
+    : "=d" (_ret)							      \
+    : "i" (__NR_##name) ASMFMT_##nr					      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL_SVC0
+#define INTERNAL_SYSCALL_SVC0(name, err, nr, args...)			      \
+  ({									      \
+    DECLARGS_##nr(args)							      \
+    register unsigned long _nr asm("1") = (unsigned long)(__NR_##name);	      \
+    register long _ret asm("2");					      \
+    asm volatile (							      \
+    "svc    0\n\t"							      \
+    : "=d" (_ret)							      \
+    : "d" (_nr) ASMFMT_##nr						      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(no, err, nr, args...)			      \
+  ({									      \
+    DECLARGS_##nr(args)							      \
+    register unsigned long _nr asm("1") = (unsigned long)(no);		      \
+    register long _ret asm("2");					      \
+    asm volatile (							      \
+    "svc    0\n\t"							      \
+    : "=d" (_ret)							      \
+    : "d" (_nr) ASMFMT_##nr						      \
+    : "memory" );							      \
+    _ret; })
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)			      \
+  (((__NR_##name) < 256) ?						      \
+    INTERNAL_SYSCALL_DIRECT(name, err, nr, args) :			      \
+    INTERNAL_SYSCALL_SVC0(name, err,nr, args))
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)				      \
+  ((unsigned long) (val) >= -4095UL)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
 #define DECLARGS_0()
 #define DECLARGS_1(arg1) \
-	unsigned long gpr2 = (unsigned long) (arg1);
+	register unsigned long gpr2 asm ("2") = (unsigned long)(arg1);
 #define DECLARGS_2(arg1, arg2) \
 	DECLARGS_1(arg1) \
-	unsigned long gpr3 = (unsigned long) (arg2);
+	register unsigned long gpr3 asm ("3") = (unsigned long)(arg2);
 #define DECLARGS_3(arg1, arg2, arg3) \
 	DECLARGS_2(arg1, arg2) \
-	unsigned long gpr4 = (unsigned long) (arg3);
+	register unsigned long gpr4 asm ("4") = (unsigned long)(arg3);
 #define DECLARGS_4(arg1, arg2, arg3, arg4) \
 	DECLARGS_3(arg1, arg2, arg3) \
-	unsigned long gpr5 = (unsigned long) (arg4);
+	register unsigned long gpr5 asm ("5") = (unsigned long)(arg4);
 #define DECLARGS_5(arg1, arg2, arg3, arg4, arg5) \
 	DECLARGS_4(arg1, arg2, arg3, arg4) \
-	unsigned long gpr6 = (unsigned long) (arg5);
-
-#define LOADARGS_0
-#define LOADARGS_1	      "LG    2,%2\n\t"
-#define LOADARGS_2 LOADARGS_1 "LG    3,%3\n\t"
-#define LOADARGS_3 LOADARGS_2 "LG    4,%4\n\t"
-#define LOADARGS_4 LOADARGS_3 "LG    5,%5\n\t"
-#define LOADARGS_5 LOADARGS_4 "LG    6,%6\n\t"
+	register unsigned long gpr6 asm ("6") = (unsigned long)(arg5);
 
 #define ASMFMT_0
-#define ASMFMT_1 , "m" (gpr2)
-#define ASMFMT_2 , "m" (gpr2), "m" (gpr3)
-#define ASMFMT_3 , "m" (gpr2), "m" (gpr3), "m" (gpr4)
-#define ASMFMT_4 , "m" (gpr2), "m" (gpr3), "m" (gpr4), "m" (gpr5)
-#define ASMFMT_5 , "m" (gpr2), "m" (gpr3), "m" (gpr4), "m" (gpr5), "m" (gpr6)
+#define ASMFMT_1 , "0" (gpr2)
+#define ASMFMT_2 , "0" (gpr2), "d" (gpr3)
+#define ASMFMT_3 , "0" (gpr2), "d" (gpr3), "d" (gpr4)
+#define ASMFMT_4 , "0" (gpr2), "d" (gpr3), "d" (gpr4), "d" (gpr5)
+#define ASMFMT_5 , "0" (gpr2), "d" (gpr3), "d" (gpr4), "d" (gpr5), "d" (gpr6)
 
 #endif /* _LINUX_S390_SYSDEP_H */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.S
--- sysdeps/unix/sysv/linux/s390/s390-64/sysdep.S	2002-08-25 01:20:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.S	2004-10-04 22:59:34.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.
 
@@ -18,20 +18,8 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
+#include <tls.h>
 
-/* The Linux version is in fact S390-64/ELF and the start.? file for this
-   system (sysdeps/s390/s390-64/elf/start.S) is also used by The Hurd.
-   This file must not contain the definition of the `errno' variable,
-   we have to define it somewhere else.
-
-    ...and this place is here.  */
-	.bss
-	.globl	errno
-	.type errno,@object
-	.size errno,4
-errno:
-	.space	4
-weak_alias (errno, _errno)
 
 /* The following code is only used in the shared library when we
    compile the reentrant version.  Otherwise each system call defines
@@ -42,47 +30,94 @@
 #undef CALL_MCOUNT
 #define CALL_MCOUNT
 
-        .text
+.text
 ENTRY(__syscall_error)
 #ifndef PIC
-#ifndef _LIBC_REENTRANT
-	lcr     %r2,%r2
-	larl    %r1,errno
-	st      %r2,0(%r1)
-	lghi    %r2,-1
-	br      %r14
-#else
-        stmg    %r13,%r15,104(%r15)
-        lgr     %r0,%r15
-        aghi    %r15,-160
-        lcr     %r13,%r2
-        stg     %r0,0(%r15)
-	brasl   %r14,__errno_location
-	st      %r13,0(%r2)
-	lmg     %r13,%r15,264(%r15)
-	lghi    %r2,-1
-	br      %r14
+# if USE___THREAD
+#  ifndef NOT_IN_libc
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+	basr	%r1,0
+0:	lg	%r1,1f-0b(%r1)
+	ear	%r3,%a0
+	sllg	%r3,%r3,32
+	ear	%r3,%a1
+	lcr	%r2,%r2
+	st	%r2,0(%r1,%r3)
+	lghi	%r2,-1
+	br	%r14
+1:	.quad	SYSCALL_ERROR_ERRNO@ntpoff
+# elif !defined _LIBC_REENTRANT
+	larl	%r1,errno
+	lcr	%r2,%r2
+	st	%r2,0(%r1)
+	lghi	%r2,-1
+	br	%r14
+# else
+	stmg	%r13,%r15,104(%r15)
+	cfi_offset (%r15,-40)
+	cfi_offset (%r14,-48)
+	cfi_offset (%r13,-56)
+	lgr	%r0,%r15
+	aghi	%r15,-160
+	cfi_adjust_cfa_offset (160)
+	lcr	%r13,%r2
+	stg	%r0,0(%r15)
+	brasl	%r14,__errno_location
+	st	%r13,0(%r2)
+	lmg	%r13,%r15,264(%r15)
+	cfi_adjust_cfa_offset (-160)
+	lghi	%r2,-1
+	br	%r14
 #endif
 #else
-#ifndef _LIBC_REENTRANT
-	larl    %r1,_GLOBAL_OFFSET_TABLE_
-	lg      %r1,errno@GOT(%r1)
-	lcr     %r2,%r2
-	st      %r2,0(%r1)
-	lghi    %r2,-1
-	br      %r14
-#else
-        stmg    %r13,%r15,104(%r15)
-        lgr     %r0,%r15
-        aghi    %r15,-160
-        lcr     %r13,%r2
-        stg     %r0,0(%r15)
-	brasl   %r14,__errno_location@PLT
-	st      %r13,0(%r2)
-	lmg     %r13,%r15,264(%r15)
-	lghi    %r2,-1
-	br      %r14
-#endif
+# if RTLD_PRIVATE_ERRNO
+	larl	%r1,rtld_errno
+	lcr	%r2,%r2
+	st	%r2,0(%r1)
+	lghi	%r2,-1
+	br	%r14
+# elif USE___THREAD
+#  ifndef NOT_IN_libc
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+	larl	%r1,_GLOBAL_OFFSET_TABLE_
+	lg	%r1,SYSCALL_ERROR_ERRNO@gotntpoff(%r1)
+	ear	%r3,%a0
+	sllg	%r3,%r3,32
+	ear	%r3,%a1
+	lcr	%r2,%r2
+	st	%r2,0(%r1,%r3)
+	lghi	%r2,-1
+	br	%r14
+# elif !defined _LIBC_REENTRANT
+	larl	%r1,_GLOBAL_OFFSET_TABLE_
+	lg	%r1,errno@GOT(%r1)
+	lcr	%r2,%r2
+	st	%r2,0(%r1)
+	lghi	%r2,-1
+	br	%r14
+# else
+	stmg	%r13,%r15,104(%r15)
+	cfi_offset (%r15,-40)
+	cfi_offset (%r14,-48)
+	cfi_offset (%r13,-56)
+	lgr	%r0,%r15
+	aghi	%r15,-160
+	cfi_adjust_cfa_offset (160)
+	lcr	%r13,%r2
+	stg	%r0,0(%r15)
+	brasl	%r14,__errno_location@PLT
+	st	%r13,0(%r2)
+	lmg	%r13,%r15,264(%r15)
+	cfi_adjust_cfa_offset (-160)
+	lghi	%r2,-1
+	br	%r14
+# endif
 #endif
 
 END (__syscall_error)
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/truncate64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/truncate64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/truncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* truncate64 is the same as truncate. */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/xstat64.c
--- sysdeps/unix/sysv/linux/s390/s390-64/xstat64.c	2001-03-16 09:26:18.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/xstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* xstat64 is in xstat.c */
diff -Nur sysdeps/unix/sysv/linux/s390/s390-64/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/xstat.c
--- sysdeps/unix/sysv/linux/s390/s390-64/xstat.c	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/s390-64/xstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* xstat using old-style Unix stat system call.  64 bit S/390 version.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
-   will complain since they don't strictly match.  */
-#define __xstat64 __xstat64_disable
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/stat.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-
-extern int __syscall_stat (const char *, struct stat *);
-
-/* Get information about the file NAME in BUF.  */
-int
-__xstat (int vers, const char *name, struct stat *buf)
-{
-  return INLINE_SYSCALL (stat, 2, name, buf);
-}
-hidden_def (__xstat)
-weak_alias (__xstat, _xstat);
-#undef __xstat64
-strong_alias (__xstat, __xstat64);
-hidden_ver (__xstat, __xstat64)
diff -Nur sysdeps/unix/sysv/linux/s390/semtimedop.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/semtimedop.c
--- sysdeps/unix/sysv/linux/s390/semtimedop.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/semtimedop.c	2003-06-28 10:03:40.000000000 +0200
@@ -0,0 +1,38 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Martin Schwidefsky <schwidefsky@de.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Perform user-defined atomical operation of array of semaphores.  */
+
+int
+semtimedop (semid, sops, nsops, timeout)
+     int semid;
+     struct sembuf *sops;
+     size_t nsops;
+     const struct timespec *timeout;
+{
+  return INLINE_SYSCALL (ipc, 5, IPCOP_semtimedop,
+			 semid, (int) nsops, timeout, sops);
+}
diff -Nur sysdeps/unix/sysv/linux/s390/sys/procfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/sys/procfs.h
--- sysdeps/unix/sysv/linux/s390/sys/procfs.h	2002-07-11 23:21:43.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/sys/procfs.h	2003-12-06 01:11:20.000000000 +0100
@@ -118,6 +118,59 @@
 typedef struct elf_prstatus prstatus_t;
 typedef struct elf_prpsinfo prpsinfo_t;
 
+#if __WORDSIZE == 64
+
+/* Provide 32-bit variants so that BFD can read 32-bit
+   core files.  */
+#define ELF_NGREG32	36
+typedef unsigned int elf_greg_t32;
+typedef elf_greg_t32 elf_gregset_t32[ELF_NGREG32];
+typedef elf_fpregset_t elf_fpregset_t32;
+
+struct elf_prstatus32
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned int pr_sigpend;	/* Set of pending signals.  */
+    unsigned int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct
+      {
+	int tv_sec, tv_usec;
+      } pr_utime,			/* User time.  */
+        pr_stime,			/* System time.  */
+        pr_cutime,			/* Cumulative user time.  */
+        pr_cstime;			/* Cumulative system time.  */
+    elf_gregset_t32 pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+struct elf_prpsinfo32
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+typedef elf_gregset_t32 prgregset32_t;
+typedef elf_fpregset_t32 prfpregset32_t;
+
+typedef struct elf_prstatus32 prstatus32_t;
+typedef struct elf_prpsinfo32 prpsinfo32_t;
+
+#endif
+
 __END_DECLS
 
 #endif	/* sys/procfs.h */
diff -Nur sysdeps/unix/sysv/linux/s390/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/system.c
--- sysdeps/unix/sysv/linux/s390/system.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s390/system.c	2003-05-21 21:19:07.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <kernel-features.h>
+
+/* We have to and actually can handle cancelable system().  The big
+   problem: we have to kill the child process if necessary.  To do
+   this a cleanup handler has to be registered and is has to be able
+   to find the PID of the child.  The main problem is to reliable have
+   the PID when needed.  It is not necessary for the parent thread to
+   return.  It might still be in the kernel when the cancellation
+   request comes.  Therefore we have to use the clone() calls ability
+   to have the kernel write the PID into the user-level variable.  */
+#ifdef __ASSUME_CLONE_THREAD_FLAGS
+# define FORK() \
+  INLINE_SYSCALL (clone, 3, 0, CLONE_PARENT_SETTID | SIGCHLD, &pid)
+#endif
+
+#include "../system.c"
diff -Nur sysdeps/unix/sysv/linux/sched_getaffinity.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sched_getaffinity.c
--- sysdeps/unix/sysv/linux/sched_getaffinity.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sched_getaffinity.c	2004-03-29 23:58:46.000000000 +0200
@@ -0,0 +1,58 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+
+
+#ifdef __NR_sched_getaffinity
+int
+__sched_getaffinity_new (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)
+{
+  int res = INLINE_SYSCALL (sched_getaffinity, 3, pid, sizeof (cpu_set_t),
+			    cpuset);
+  if (res != -1)
+    {
+      /* Clean the rest of the memory the kernel didn't do.  */
+      memset ((char *) cpuset + res, '\0', cpusetsize - res);
+
+      res = 0;
+    }
+  return res;
+}
+versioned_symbol (libc, __sched_getaffinity_new, sched_getaffinity,
+		  GLIBC_2_3_4);
+
+
+# if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+int
+attribute_compat_text_section
+__sched_getaffinity_old (pid_t pid, cpu_set_t *cpuset)
+{
+  /* The old interface by default assumed a 1024 processor bitmap.  */
+  return __sched_getaffinity_new (pid, 128, cpuset);
+}
+compat_symbol (libc, __sched_getaffinity_old, sched_getaffinity, GLIBC_2_3_3);
+# endif
+#else
+# include <sysdeps/generic/sched_getaffinity.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/sched_setaffinity.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sched_setaffinity.c
--- sysdeps/unix/sysv/linux/sched_setaffinity.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sched_setaffinity.c	2004-06-18 04:47:27.000000000 +0200
@@ -0,0 +1,88 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+#include <alloca.h>
+
+
+#ifdef __NR_sched_setaffinity
+static size_t __kernel_cpumask_size;
+
+
+int
+__sched_setaffinity_new (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
+{
+  if (__builtin_expect (__kernel_cpumask_size == 0, 0))
+    {
+      INTERNAL_SYSCALL_DECL (err);
+      int res;
+
+      size_t psize = 128;
+      void *p = alloca (psize);
+
+      while (res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, getpid (),
+				     psize, p),
+	     INTERNAL_SYSCALL_ERROR_P (res, err)
+	     && INTERNAL_SYSCALL_ERRNO (res, err) == EINVAL)
+	p = extend_alloca (p, psize, 2 * psize);
+
+      if (res == 0 || INTERNAL_SYSCALL_ERROR_P (res, err))
+	{
+	  __set_errno (INTERNAL_SYSCALL_ERRNO (res, err));
+	  return -1;
+	}
+
+      __kernel_cpumask_size = res;
+    }
+
+  /* We now know the size of the kernel cpumask_t.  Make sure the user
+     does not request to set a bit beyond that.  */
+  for (size_t cnt = __kernel_cpumask_size; cnt < cpusetsize; ++cnt)
+    if (((char *) cpuset)[cnt] != '\0')
+      {
+        /* Found a nonzero byte.  This means the user request cannot be
+	   fulfilled.  */
+	__set_errno (EINVAL);
+	return -1;
+      }
+
+  return INLINE_SYSCALL (sched_setaffinity, 3, pid, cpusetsize, cpuset);
+}
+versioned_symbol (libc, __sched_setaffinity_new, sched_setaffinity,
+		  GLIBC_2_3_4);
+
+
+# if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+int
+attribute_compat_text_section
+__sched_setaffinity_old (pid_t pid, const cpu_set_t *cpuset)
+{
+  /* The old interface by default assumed a 1024 processor bitmap.  */
+  return __sched_setaffinity_new (pid, 128, cpuset);
+}
+compat_symbol (libc, __sched_setaffinity_old, sched_setaffinity, GLIBC_2_3_3);
+# endif
+#else
+# include <sysdeps/generic/sched_setaffinity.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/segfault.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/segfault.c
--- sysdeps/unix/sysv/linux/segfault.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/segfault.c	2002-11-03 09:52:00.000000000 +0100
@@ -0,0 +1,2 @@
+#define HAVE_PROC_SELF	1
+#include <sysdeps/generic/segfault.c>
diff -Nur sysdeps/unix/sysv/linux/semctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/semctl.c
--- sysdeps/unix/sysv/linux/semctl.c	2002-05-15 05:50:33.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/semctl.c	2004-03-10 20:26:42.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -48,6 +49,7 @@
   struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
   unsigned short int *array;	/* array for GETALL & SETALL */
   struct seminfo *__buf;	/* buffer for IPC_INFO */
+  struct __old_semid_ds *__old_buf;
 };
 
 #include <bp-checks.h>
@@ -62,6 +64,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_semctl (int semid, int semnum, int cmd, ...)
 {
   union semun arg;
@@ -152,7 +155,7 @@
 
     __set_errno(save_errno);
     buf = arg.buf;
-    arg.buf = (struct semid_ds *)&old;
+    arg.__old_buf = &old;
     if (cmd == IPC_SET)
       {
 	old.sem_perm.uid = buf->sem_perm.uid;
diff -Nur sysdeps/unix/sysv/linux/semtimedop.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/semtimedop.c
--- sysdeps/unix/sysv/linux/semtimedop.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/semtimedop.c	2003-05-01 23:39:55.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (C) 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Perform user-defined atomical operation of array of semaphores.  */
+
+int
+semtimedop (semid, sops, nsops, timeout)
+     int semid;
+     struct sembuf *sops;
+     size_t nsops;
+     const struct timespec *timeout;
+{
+  return INLINE_SYSCALL (ipc, 6, IPCOP_semtimedop,
+			 semid, (int) nsops, 0, CHECK_N (sops, nsops),
+			 timeout);
+}
diff -Nur sysdeps/unix/sysv/linux/sendmsg.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sendmsg.S
--- sysdeps/unix/sysv/linux/sendmsg.S	2002-05-15 01:46:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sendmsg.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,5 +1,6 @@
 #define	socket	sendmsg
 #define	__socket __libc_sendmsg
 #define	NARGS	3
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_sendmsg, __sendmsg)
diff -Nur sysdeps/unix/sysv/linux/send.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/send.S
--- sysdeps/unix/sysv/linux/send.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/send.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,6 +1,7 @@
 #define	socket	send
 #define	__socket __libc_send
 #define	NARGS	4
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_send, __send)
 libc_hidden_def (__send)
diff -Nur sysdeps/unix/sysv/linux/sendto.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sendto.S
--- sysdeps/unix/sysv/linux/sendto.S	2002-05-15 01:46:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sendto.S	2002-12-15 11:25:23.000000000 +0100
@@ -1,5 +1,6 @@
 #define	socket	sendto
 #define	__socket __libc_sendto
 #define	NARGS	6
+#define NEED_CANCELLATION
 #include <socket.S>
 weak_alias (__libc_sendto, __sendto)
diff -Nur sysdeps/unix/sysv/linux/setegid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setegid.c
--- sysdeps/unix/sysv/linux/setegid.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setegid.c	2004-11-12 02:15:06.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,11 +17,12 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
 #include <unistd.h>
+#include <setxid.h>
+#include "kernel-features.h"
 
-#ifdef __NR_setresgid
+
+#if defined __NR_setresgid || __ASSUME_SETRESGID_SYSCALL > 0
 
 extern int __setresgid (gid_t rgid, gid_t egid, gid_t sgid);
 
@@ -36,17 +37,25 @@
       return -1;
     }
 
+# if __ASSUME_32BITUIDS > 0 && defined __NR_setresgid32
+  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);
+# else
   /* First try the syscall.  */
-  result = __setresgid (-1, gid, -1);
+  result = INLINE_SETXID_SYSCALL (setresgid, 3, -1, gid, -1);
+#  if __ASSUME_SETRESGID_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use emulation.  This may not work
        since `setregid' also sets the saved group ID when GID is not
        equal to the real group ID, making it impossible to switch back. */
     result = __setregid (-1, gid);
+#  endif
+# endif
 
   return result;
 }
+#ifndef setegid
 libc_hidden_def (setegid)
+#endif
 #else
 # include <sysdeps/unix/bsd/setegid.c>
 #endif
diff -Nur sysdeps/unix/sysv/linux/seteuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/seteuid.c
--- sysdeps/unix/sysv/linux/seteuid.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/seteuid.c	2004-11-12 02:15:06.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,12 +17,11 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
 #include <unistd.h>
-
+#include <setxid.h>
 #include "kernel-features.h"
 
+
 #if defined __NR_setresuid || __ASSUME_SETRESUID_SYSCALL > 0
 
 extern int __setresuid (uid_t ruid, uid_t euid, uid_t suid);
@@ -38,19 +37,25 @@
       return -1;
     }
 
+# if __ASSUME_32BITUIDS > 0 && defined __NR_setresuid32
+  result = INLINE_SETXID_SYSCALL (setresuid32, 3, -1, uid, -1);
+# else
   /* First try the syscall.  */
-  result = __setresuid (-1, uid, -1);
-# if __ASSUME_SETRESUID_SYSCALL == 0
+  result = INLINE_SETXID_SYSCALL (setresuid, 3, -1, uid, -1);
+#  if __ASSUME_SETRESUID_SYSCALL == 0
   if (result == -1 && errno == ENOSYS)
     /* No system call available.  Use emulation.  This may not work
        since `setreuid' also sets the saved user ID when UID is not
        equal to the real user ID, making it impossible to switch back.  */
     result = __setreuid (-1, uid);
+#  endif
 # endif
 
   return result;
 }
+#ifndef seteuid
 libc_hidden_def (seteuid)
+#endif
 #else
 # include <sysdeps/unix/bsd/seteuid.c>
 #endif
diff -Nur sysdeps/unix/sysv/linux/setgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setgid.c
--- sysdeps/unix/sysv/linux/setgid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setgid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+
+int
+__setgid (gid_t gid)
+{
+  return INLINE_SETXID_SYSCALL (setgid, 1, gid);
+}
+#ifndef __setgid
+weak_alias (__setgid, setgid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/setipv4sourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setipv4sourcefilter.c
--- sysdeps/unix/sysv/linux/setipv4sourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setipv4sourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,65 @@
+/* Set IPv4 source filter.  Linux version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+
+int
+setipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,
+		     uint32_t fmode, uint32_t numsrc,
+		     const struct in_addr *slist)
+{
+  /* We have to create an struct ip_msfilter object which we can pass
+     to the kernel.  */
+  size_t needed = IP_MSFILTER_SIZE (numsrc);
+  int use_alloca = __libc_use_alloca (needed);
+
+  struct ip_msfilter *imsf;
+  if (use_alloca)
+    imsf = (struct ip_msfilter *) alloca (needed);
+  else
+    {
+      imsf = (struct ip_msfilter *) malloc (needed);
+      if (imsf == NULL)
+	return -1;
+    }
+
+  imsf->imsf_multiaddr = group;
+  imsf->imsf_interface = interface;
+  imsf->imsf_fmode = fmode;
+  imsf->imsf_numsrc = numsrc;
+  memcpy (imsf->imsf_slist, slist, numsrc * sizeof (struct in_addr));
+
+  int result = __setsockopt (s, SOL_IP, IP_MSFILTER, imsf, needed);
+
+  if (! use_alloca)
+    {
+      int save_errno = errno;
+      free (imsf);
+      __set_errno (save_errno);
+    }
+
+  return result;
+}
diff -Nur sysdeps/unix/sysv/linux/setregid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setregid.c
--- sysdeps/unix/sysv/linux/setregid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setregid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+
+int
+__setregid (gid_t rgid, gid_t egid)
+{
+  return INLINE_SETXID_SYSCALL (setregid, 2, rgid, egid);
+}
+#ifndef __setregid
+weak_alias (__setregid, setregid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/setresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setresgid.c
--- sysdeps/unix/sysv/linux/setresgid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setresgid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+
+int
+__setresgid (gid_t rgid, gid_t egid, gid_t sgid)
+{
+  return INLINE_SETXID_SYSCALL (setresgid, 3, rgid, egid, sgid);
+}
+libc_hidden_def (__setresgid)
+#ifndef __setresgid
+weak_alias (__setresgid, setresgid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/setresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setresuid.c
--- sysdeps/unix/sysv/linux/setresuid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setresuid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+
+int
+__setresuid (uid_t ruid, uid_t euid, uid_t suid)
+{
+  return INLINE_SETXID_SYSCALL (setresuid, 3, ruid, euid, suid);
+}
+libc_hidden_def (__setresuid)
+#ifndef __setresuid
+weak_alias (__setresuid, setresuid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/setreuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setreuid.c
--- sysdeps/unix/sysv/linux/setreuid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setreuid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+
+int
+__setreuid (uid_t ruid, uid_t euid)
+{
+  return INLINE_SETXID_SYSCALL (setreuid, 2, ruid, euid);
+}
+#ifndef __setreuid
+weak_alias (__setreuid, setreuid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/setsourcefilter.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setsourcefilter.c
--- sysdeps/unix/sysv/linux/setsourcefilter.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setsourcefilter.c	2004-08-07 20:21:41.000000000 +0200
@@ -0,0 +1,77 @@
+/* Set source filter.  Linux version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+
+/* Defined in getsourcefilter.c.  */
+extern int __get_sol (int af, socklen_t len);
+
+
+int
+setsourcefilter (int s, uint32_t interface, const struct sockaddr *group,
+		 socklen_t grouplen, uint32_t fmode, uint32_t numsrc,
+		 const struct sockaddr_storage *slist)
+{
+  /* We have to create an struct ip_msfilter object which we can pass
+     to the kernel.  */
+  size_t needed = GROUP_FILTER_SIZE (numsrc);
+  int use_alloca = __libc_use_alloca (needed);
+
+  struct group_filter *gf;
+  if (use_alloca)
+    gf = (struct group_filter *) alloca (needed);
+  else
+    {
+      gf = (struct group_filter *) malloc (needed);
+      if (gf == NULL)
+	return -1;
+    }
+
+  gf->gf_interface = interface;
+  memcpy (&gf->gf_group, group, grouplen);
+  gf->gf_fmode = fmode;
+  gf->gf_numsrc = numsrc;
+  memcpy (gf->gf_slist, slist, numsrc * sizeof (struct sockaddr_storage));
+
+  /* We need to provide the appropriate socket level value.  */
+  int sol = __get_sol (group->sa_family, grouplen);
+  if (sol == -1)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  int result = __setsockopt (s, sol, MCAST_MSFILTER, gf, needed);
+
+  if (! use_alloca)
+    {
+      int save_errno = errno;
+      free (gf);
+      __set_errno (save_errno);
+    }
+
+  return result;
+}
diff -Nur sysdeps/unix/sysv/linux/setuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setuid.c
--- sysdeps/unix/sysv/linux/setuid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/setuid.c	2004-11-12 02:15:06.000000000 +0100
@@ -0,0 +1,30 @@
+/* Copyright (C) 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <setxid.h>
+
+int
+__setuid (uid_t uid)
+{
+  return INLINE_SETXID_SYSCALL (setuid, 1, uid);
+}
+#ifndef __setuid
+weak_alias (__setuid, setuid)
+#endif
diff -Nur sysdeps/unix/sysv/linux/sh/bits/atomic.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/atomic.h
--- sysdeps/unix/sysv/linux/sh/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/atomic.h	2003-05-05 20:21:38.000000000 +0200
@@ -0,0 +1,419 @@
+/* Atomic operations used inside libc.  Linux/SH version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int16_t atomic16_t;
+typedef uint16_t uatomic16_t;
+typedef int_fast16_t atomic_fast16_t;
+typedef uint_fast16_t uatomic_fast16_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+/* SH kernel has implemented a gUSA ("g" User Space Atomicity) support
+   for the user space atomicity. The atomicity macros use this scheme.
+
+  Reference:
+    Niibe Yutaka, "gUSA: Simple and Efficient User Space Atomicity
+    Emulation with Little Kernel Modification", Linux Conference 2002,
+    Japan. http://lc.linux.or.jp/lc2002/papers/niibe0919h.pdf (in
+    Japanese).
+
+    B.N. Bershad, D. Redell, and J. Ellis, "Fast Mutual Exclusion for
+    Uniprocessors",  Proceedings of the Fifth Architectural Support for
+    Programming Languages and Operating Systems (ASPLOS), pp. 223-233,
+    October 1992. http://www.cs.washington.edu/homes/bershad/Papers/Rcs.ps
+
+  SuperH ABI:
+      r15:    -(size of atomic instruction sequence) < 0
+      r0:     end point
+      r1:     saved stack pointer
+*/
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  ({ __typeof (*(mem)) __result; \
+     __asm __volatile ("\
+	.align 2\n\
+	mova 1f,r0\n\
+	nop\n\
+	mov r15,r1\n\
+	mov #-8,r15\n\
+     0: mov.b @%1,%0\n\
+	cmp/eq %0,%3\n\
+	bf 1f\n\
+	mov.b %2,@%1\n\
+     1: mov r1,r15"\
+	: "=&r" (__result) : "r" (mem), "r" (newval), "r" (oldval) \
+	: "r0", "r1", "t", "memory"); \
+     __result; })
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  ({ __typeof (*(mem)) __result; \
+     __asm __volatile ("\
+	.align 2\n\
+	mova 1f,r0\n\
+	nop\n\
+	mov r15,r1\n\
+	mov #-8,r15\n\
+     0: mov.w @%1,%0\n\
+	cmp/eq %0,%3\n\
+	bf 1f\n\
+	mov.w %2,@%1\n\
+     1: mov r1,r15"\
+	: "=&r" (__result) : "r" (mem), "r" (newval), "r" (oldval) \
+	: "r0", "r1", "t", "memory"); \
+     __result; })
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  ({ __typeof (*(mem)) __result; \
+     __asm __volatile ("\
+	.align 2\n\
+	mova 1f,r0\n\
+	nop\n\
+	mov r15,r1\n\
+	mov #-8,r15\n\
+     0: mov.l @%1,%0\n\
+	cmp/eq %0,%3\n\
+	bf 1f\n\
+	mov.l %2,@%1\n\
+     1: mov r1,r15"\
+	: "=&r" (__result) : "r" (mem), "r" (newval), "r" (oldval) \
+	: "r0", "r1", "t", "memory"); \
+     __result; })
+
+/* XXX We do not really need 64-bit compare-and-exchange.  At least
+   not in the moment.  Using it would mean causing portability
+   problems since not many other 32-bit architectures have support for
+   such an operation.  So don't define any code for now.  */
+
+# define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define atomic_exchange_and_add(mem, value) \
+  ({ __typeof (*(mem)) __result, __tmp, __value = (value); \
+     if (sizeof (*(mem)) == 1) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.b @%2,%0\n\
+	  add %0,%1\n\
+	  mov.b %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "memory"); \
+     else if (sizeof (*(mem)) == 2) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.w @%2,%0\n\
+	  add %0,%1\n\
+	  mov.w %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "memory"); \
+     else if (sizeof (*(mem)) == 4) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.l @%2,%0\n\
+	  add %0,%1\n\
+	  mov.l %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "memory"); \
+     else \
+       { \
+	 __typeof (mem) memp = (mem); \
+	 do \
+	   __result = *memp; \
+	 while (__arch_compare_and_exchange_val_64_acq \
+		 (memp,	__result + __value, __result) == __result); \
+	 (void) __value; \
+       } \
+     __result; })
+
+#define atomic_add(mem, value) \
+  (void) ({ __typeof (*(mem)) __tmp, __value = (value); \
+	    if (sizeof (*(mem)) == 1) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.b @%1,r2\n\
+		add r2,%0\n\
+		mov.b %0,@%1\n\
+	     1: mov r1,r15"\
+		: "=&r" (__tmp) : "r" (mem), "0" (__value) \
+		: "r0", "r1", "r2", "memory"); \
+	    else if (sizeof (*(mem)) == 2) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.w @%1,r2\n\
+		add r2,%0\n\
+		mov.w %0,@%1\n\
+	     1: mov r1,r15"\
+		: "=&r" (__tmp) : "r" (mem), "0" (__value) \
+		: "r0", "r1", "r2", "memory"); \
+	    else if (sizeof (*(mem)) == 4) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.l @%1,r2\n\
+		add r2,%0\n\
+		mov.l %0,@%1\n\
+	     1: mov r1,r15"\
+		: "=&r" (__tmp) : "r" (mem), "0" (__value) \
+		: "r0", "r1", "r2", "memory"); \
+	    else \
+	      { \
+		__typeof (*(mem)) oldval; \
+		__typeof (mem) memp = (mem); \
+		do \
+		  oldval = *memp; \
+		while (__arch_compare_and_exchange_val_64_acq \
+			(memp, oldval + __value, oldval) == oldval); \
+		(void) __value; \
+	      } \
+	    })
+
+#define atomic_add_negative(mem, value) \
+  ({ unsigned char __result; \
+     __typeof (*(mem)) __tmp, __value = (value); \
+     if (sizeof (*(mem)) == 1) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.b @%2,r2\n\
+	  add r2,%1\n\
+	  mov.b %1,@%2\n\
+       1: mov r1,r15\n\
+	  shal %1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else if (sizeof (*(mem)) == 2) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.w @%2,r2\n\
+	  add r2,%1\n\
+	  mov.w %1,@%2\n\
+       1: mov r1,r15\n\
+	  shal %1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else if (sizeof (*(mem)) == 4) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.l @%2,r2\n\
+	  add r2,%1\n\
+	  mov.l %1,@%2\n\
+       1: mov r1,r15\n\
+	  shal %1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else \
+       abort (); \
+     __result; })
+
+#define atomic_add_zero(mem, value) \
+  ({ unsigned char __result; \
+     __typeof (*(mem)) __tmp, __value = (value); \
+     if (sizeof (*(mem)) == 1) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.b @%2,r2\n\
+	  add r2,%1\n\
+	  mov.b %1,@%2\n\
+       1: mov r1,r15\n\
+	  tst %1,%1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else if (sizeof (*(mem)) == 2) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.w @%2,r2\n\
+	  add r2,%1\n\
+	  mov.w %1,@%2\n\
+       1: mov r1,r15\n\
+	  tst %1,%1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else if (sizeof (*(mem)) == 4) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  mov r15,r1\n\
+	  mov #-6,r15\n\
+       0: mov.l @%2,r2\n\
+	  add r2,%1\n\
+	  mov.l %1,@%2\n\
+       1: mov r1,r15\n\
+	  tst %1,%1\n\
+	  movt %0"\
+	: "=r" (__result), "=&r" (__tmp) : "r" (mem), "1" (__value) \
+	: "r0", "r1", "r2", "t", "memory"); \
+     else \
+       abort (); \
+     __result; })
+
+#define atomic_increment_and_test(mem) atomic_add_zero((mem), 1)
+#define atomic_decrement_and_test(mem) atomic_add_zero((mem), -1)
+
+#define atomic_bit_set(mem, bit) \
+  (void) ({ unsigned int __mask = 1 << (bit); \
+	    if (sizeof (*(mem)) == 1) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.b @%0,r2\n\
+		or %1,r2\n\
+		mov.b r2,@%0\n\
+	     1: mov r1,r15"\
+		: : "r" (mem), "r" (__mask) \
+		: "r0", "r1", "r2", "memory"); \
+	    else if (sizeof (*(mem)) == 2) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.w @%0,r2\n\
+		or %1,r2\n\
+		mov.w r2,@%0\n\
+	     1: mov r1,r15"\
+		: : "r" (mem), "r" (__mask) \
+		: "r0", "r1", "r2", "memory"); \
+	    else if (sizeof (*(mem)) == 4) \
+	      __asm __volatile ("\
+		.align 2\n\
+		mova 1f,r0\n\
+		mov r15,r1\n\
+		mov #-6,r15\n\
+	     0: mov.l @%0,r2\n\
+		or %1,r2\n\
+		mov.l r2,@%0\n\
+	     1: mov r1,r15"\
+		: : "r" (mem), "r" (__mask) \
+		: "r0", "r1", "r2", "memory"); \
+	    else \
+	      abort (); \
+	    })
+
+#define atomic_bit_test_set(mem, bit) \
+  ({ unsigned int __mask = 1 << (bit); \
+     unsigned int __result = __mask; \
+     if (sizeof (*(mem)) == 1) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  nop\n\
+	  mov r15,r1\n\
+	  mov #-8,r15\n\
+       0: mov.b @%2,r2\n\
+	  or r2,%1\n\
+	  and r2,%0\n\
+	  mov.b %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__mask) \
+	: "r" (mem), "0" (__result), "1" (__mask) \
+	: "r0", "r1", "r2", "memory"); \
+     else if (sizeof (*(mem)) == 2) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  nop\n\
+	  mov r15,r1\n\
+	  mov #-8,r15\n\
+       0: mov.w @%2,r2\n\
+	  or r2,%1\n\
+	  and r2,%0\n\
+	  mov.w %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__mask) \
+	: "r" (mem), "0" (__result), "1" (__mask) \
+	: "r0", "r1", "r2", "memory"); \
+     else if (sizeof (*(mem)) == 4) \
+       __asm __volatile ("\
+	  .align 2\n\
+	  mova 1f,r0\n\
+	  nop\n\
+	  mov r15,r1\n\
+	  mov #-8,r15\n\
+       0: mov.l @%2,r2\n\
+	  or r2,%1\n\
+	  and r2,%0\n\
+	  mov.l %1,@%2\n\
+       1: mov r1,r15"\
+	: "=&r" (__result), "=&r" (__mask) \
+	: "r" (mem), "0" (__result), "1" (__mask) \
+	: "r0", "r1", "r2", "memory"); \
+     else \
+       abort (); \
+     __result; })
diff -Nur sysdeps/unix/sysv/linux/sh/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/fcntl.h
--- sysdeps/unix/sysv/linux/sh/bits/fcntl.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/fcntl.h	2004-08-23 09:28:45.000000000 +0200
@@ -1,5 +1,6 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,6 +46,7 @@
 # define O_DIRECT	 040000	/* Direct disk access.  */
 # define O_DIRECTORY	0200000	/* Must be a directory.  */
 # define O_NOFOLLOW	0400000	/* Do not follow links.  */
+# define O_NOATIME     01000000 /* Do not set atime.  */
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
@@ -78,7 +80,7 @@
 #define F_SETLK64	13	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	14	/* Set record locking info (blocking).  */
 
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -153,3 +155,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/sh/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/mman.h
--- sysdeps/unix/sysv/linux/sh/bits/mman.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/mman.h	2003-09-25 18:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/SH version.
-   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
diff -Nur sysdeps/unix/sysv/linux/sh/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/resource.h
--- sysdeps/unix/sysv/linux/sh/bits/resource.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* Bit values & structures for resource limits.  Linux/SH version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((unsigned long int)(~0UL))
-#else
-# define RLIM_INFINITY 0xffffffffffffffffuLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0xffffffffffffffffuLL
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#ifndef __USE_FILE_OFFSET64
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/sh/brk.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/brk.c
--- sysdeps/unix/sysv/linux/sh/brk.c	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/brk.c	2003-02-08 03:30:57.000000000 +0100
@@ -1,5 +1,5 @@
 /* brk system call for Linux/SH.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,7 +31,7 @@
   register long r3 asm ("%r3") = SYS_ify (brk);
   register long r4 asm ("%r4") = (long)addr;
 
-  asm volatile ("trapa #0x11"
+  asm volatile ("trapa #0x11\n\t" SYSCALL_INST_PAD
 		: "=z"(newbrk) 
 		: "r" (r3), "r" (r4));
 
diff -Nur sysdeps/unix/sysv/linux/sh/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/clone.S
--- sysdeps/unix/sysv/linux/sh/clone.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/clone.S	2004-12-07 20:37:51.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,37 +22,22 @@
 #include <sysdep.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
+#ifdef RESET_PID
+#include <tcb-offsets.h>
+#endif
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     pid_t *ptid, void *tls, pid_t *ctid); */
 
-/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
-
-        .text
+	.text
 ENTRY(__clone)
 	/* sanity check arguments.  */
 	tst	r4, r4
 	bf/s	1f
 	 tst	r5, r5
 	bf/s	1f
-	 mov.l	.L1, r1
-#ifdef SHARED
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	.LG, r12
-	mova	.LG, r0
-	add	r0, r12
-	mova	.L1, r0
-	add	r0, r1
-	jsr	@r1
-	 mov	#-EINVAL, r4
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-#else
-	jmp	@r1
-	 mov	#-EINVAL, r4
-#endif
-	.align	2
-.L1:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+	 mov	#-EINVAL,r0
+	bra	.Lsyscall_error
+	 nop
 1:
 	/* insert the args onto the new stack */
 	mov.l	r7, @-r5
@@ -61,43 +46,51 @@
 
 	/* do the system call */
 	mov	r6, r4
+	mov.l	@r15, r6
+	mov.l	@(8,r15), r7
+	mov.l	@(4,r15), r0
 	mov	#+SYS_ify(clone), r3
-	trapa	#0x12
+	trapa	#0x15
 	mov     r0, r1
 	mov	#-12, r2
 	shad	r2, r1
 	not	r1, r1			// r1=0 means r0 = -1 to -4095
 	tst	r1, r1			// i.e. error in linux
-	bf	2f
-	mov.l	.L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	.LG, r12
-	mova	.LG, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr	@r1
-	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-#else
-	jmp	@r1
-	 mov	r0, r4
-#endif
-	.align	2
-.L2:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
-
-2:
+	bf	.Lclone_end
+.Lsyscall_error:	
+	SYSCALL_ERROR_HANDLER
+.Lclone_end:
 	tst	r0, r0
-	bt	3f
+	bt	2f
+.Lpseudo_end:
 	rts
 	 nop
+2:
+	/* terminate the stack frame */
+	mov	#0, r14
+#ifdef RESET_PID
+	mov	r4, r0
+	shlr16	r0
+	tst	#1, r0			// CLONE_THREAD = (1 << 16)
+	bf/s	4f
+	 mov	r4, r0
+	/* new pid */
+	shlr8	r0
+	tst	#1, r0			// CLONE_VM = (1 << 8)
+	bf/s	3f
+	 mov	#-1, r0
+	mov	#+SYS_ify(getpid), r3
+	trapa	#0x15
 3:
+	stc	gbr, r1
+	mov.w	.Lpidoff, r2
+	add	r1, r2
+	mov.l	r0, @r2	
+	mov.w	.Ltidoff, r2
+	add	r1, r2
+	mov.l	r0, @r2	
+4:
+#endif
 	/* thread starts */
 	mov.l	@r15, r1
 	jsr	@r1
@@ -128,6 +121,12 @@
 	.long	_GLOBAL_OFFSET_TABLE_
 .L3:
 	.long	PLTJMP(C_SYMBOL_NAME(_exit))
+#ifdef RESET_PID
+.Lpidoff:
+	.word	PID - TLS_PRE_TCB_SIZE
+.Ltidoff:
+	.word	TID - TLS_PRE_TCB_SIZE
+#endif
 PSEUDO_END (__clone)
 
 weak_alias (__clone, clone)
diff -Nur sysdeps/unix/sysv/linux/sh/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/Makefile
--- sysdeps/unix/sysv/linux/sh/Makefile	2001-12-12 19:03:38.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/Makefile	2003-09-03 05:21:28.000000000 +0200
@@ -3,11 +3,5 @@
 endif
 
 ifeq ($(subdir),misc)
-sysdep_routines += setfsgid setfsuid setresgid setresuid
 sysdep_headers += sys/io.h
 endif
-
-ifeq ($(subdir),signal)
-sysdep_routines += rt_sigsuspend rt_sigprocmask rt_sigtimedwait	\
-		   rt_sigqueueinfo rt_sigaction rt_sigpending
-endif
diff -Nur sysdeps/unix/sysv/linux/sh/pipe.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pipe.S
--- sysdeps/unix/sysv/linux/sh/pipe.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pipe.S	2003-01-05 12:07:14.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,37 +26,16 @@
 	shad	r2, r3
 	not	r3, r3			// r1=0 means r0 = -1 to -4095
 	tst	r3, r3			// i.e. error in linux
-	bf	1f
-	mov.l	.L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	0f, r12
-	mova	0f, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr	@r1
-	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-	.align 2
-0:
-	.long	_GLOBAL_OFFSET_TABLE_
-#else
-	jmp	@r1
-	 mov	r0, r4
-#endif
-1:
+	bt	1f
 	mov.l	r0, @r4
 	mov.l	r1, @(4, r4)
 	rts
 	 mov	#0, r0
-	.align	2
-.L2:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+1:
+	SYSCALL_ERROR_HANDLER
+.Lpseudo_end:
+	rts
+	 nop
 PSEUDO_END (__libc_pipe)
 
 weak_alias (__libc_pipe, __pipe)
diff -Nur sysdeps/unix/sysv/linux/sh/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pread64.c
--- sysdeps/unix/sysv/linux/sh/pread64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pread64.c	2004-08-26 18:59:43.000000000 +0200
@@ -0,0 +1,3 @@
+#define NO_SGIDEFS_H
+#define _MIPS_SIM -1
+#include <sysdeps/unix/sysv/linux/mips/pread64.c>
diff -Nur sysdeps/unix/sysv/linux/sh/pread.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pread.c
--- sysdeps/unix/sysv/linux/sh/pread.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pread.c	2004-08-26 18:59:43.000000000 +0200
@@ -0,0 +1,3 @@
+#define NO_SGIDEFS_H
+#define _MIPS_SIM -1
+#include <sysdeps/unix/sysv/linux/mips/pread.c>
diff -Nur sysdeps/unix/sysv/linux/sh/profil-counter.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/profil-counter.h
--- sysdeps/unix/sysv/linux/sh/profil-counter.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/profil-counter.h	2002-10-14 19:26:13.000000000 +0200
@@ -1,5 +1,5 @@
 /* Low-level statistical profiling support function.  Linux/SH version.
-   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,4 +25,9 @@
   void *pc;
   pc = (void *) sc.sc_pc;
   profil_count (pc);
+
+  /* This is a hack to prevent the compiler from implementing the
+     above function call as a sibcall.  The sibcall would overwrite
+     the signal context.  */
+  asm volatile ("");
 }
diff -Nur sysdeps/unix/sysv/linux/sh/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pwrite64.c
--- sysdeps/unix/sysv/linux/sh/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pwrite64.c	2004-08-26 18:59:43.000000000 +0200
@@ -0,0 +1,3 @@
+#define NO_SGIDEFS_H
+#define _MIPS_SIM -1
+#include <sysdeps/unix/sysv/linux/mips/pwrite64.c>
diff -Nur sysdeps/unix/sysv/linux/sh/pwrite.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pwrite.c
--- sysdeps/unix/sysv/linux/sh/pwrite.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/pwrite.c	2004-08-26 18:59:43.000000000 +0200
@@ -0,0 +1,3 @@
+#define NO_SGIDEFS_H
+#define _MIPS_SIM -1
+#include <sysdeps/unix/sysv/linux/mips/pwrite.c>
diff -Nur sysdeps/unix/sysv/linux/sh/sh4/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sh4/sysdep.h
--- sysdeps/unix/sysv/linux/sh/sh4/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sh4/sysdep.h	2003-02-08 03:32:16.000000000 +0100
@@ -0,0 +1,4 @@
+/*  4 instruction cycles not accessing cache and TLB are needed after
+    trapa instruction to avoid an SH-4 silicon bug.  */
+#define NEED_SYSCALL_INST_PAD
+#include <sysdeps/unix/sysv/linux/sh/sysdep.h>
diff -Nur sysdeps/unix/sysv/linux/sh/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/socket.S
--- sysdeps/unix/sysv/linux/sh/socket.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/socket.S	2004-03-20 07:11:49.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,8 +16,9 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <tls.h>
 
 #define P(a, b) P2(a, b)
 #define P2(a, b) a##b
@@ -35,35 +36,70 @@
 #define __socket P(__,socket)
 #endif
 
-#define PUSHARGS_1	mov.l r4,@-r15
-#define PUSHARGS_2	mov.l r5,@-r15; PUSHARGS_1
-#define PUSHARGS_3	mov.l r6,@-r15; PUSHARGS_2
-#define PUSHARGS_4	mov.l r7,@-r15; PUSHARGS_3
+#define PUSHARGS_1	mov.l r4,@-r15;	\
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (r4, 0)
+#define PUSHARGS_2	mov.l r5,@-r15; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (r5, 0); \
+			PUSHARGS_1
+#define PUSHARGS_3	mov.l r6,@-r15; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (r6, 0); \
+			PUSHARGS_2
+#define PUSHARGS_4	mov.l r7,@-r15; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (r7, 0); \
+			PUSHARGS_3
 #define PUSHARGS_5	PUSHARGS_4	/* Caller has already pushed arg 5 */
 #define PUSHARGS_6	PUSHARGS_4	/* Caller has already pushed arg 5,6 */
 
-#define POPARGS_1	add #4,r15
-#define POPARGS_2	add #8,r15
-#define POPARGS_3	add #12,r15
-#define POPARGS_4	add #16,r15
-#define POPARGS_5	add #16,r15
-#define POPARGS_6	add #16,r15 
+#define POPARGS_1	add #4,r15; cfi_adjust_cfa_offset (-4)
+#define POPARGS_2	add #8,r15; cfi_adjust_cfa_offset (-8)
+#define POPARGS_3	add #12,r15; cfi_adjust_cfa_offset (-12)
+#define POPARGS_4	add #16,r15; cfi_adjust_cfa_offset (-16)
+#define POPARGS_5	POPARGS_4
+#define POPARGS_6	POPARGS_4
+
+#define ADJUSTCFI_1	cfi_adjust_cfa_offset (4); \
+			cfi_offset (r4, -4)
+#define ADJUSTCFI_2	cfi_adjust_cfa_offset (8); \
+			cfi_offset (r4, -4); \
+			cfi_offset (r5, -8)
+#define ADJUSTCFI_3	cfi_adjust_cfa_offset (12); \
+			cfi_offset (r4, -4); \
+			cfi_offset (r5, -8); \
+			cfi_offset (r6, -12)
+#define ADJUSTCFI_4	cfi_adjust_cfa_offset (16); \
+			cfi_offset (r4, -4); \
+			cfi_offset (r5, -8); \
+			cfi_offset (r6, -12); \
+			cfi_offset (r7, -16)
+#define ADJUSTCFI_5	ADJUSTCFI_4
+#define ADJUSTCFI_6	ADJUSTCFI_4
 
 #ifndef NARGS
-#define NARGS 3			/* If we were called with no wrapper, this is really socket() */
+/* If we were called with no wrapper, this is really socket().  */
+#define NARGS 3
 #endif
 
 .globl __socket
+	cfi_startproc
 ENTRY (__socket)
 	/* This will not work in the case of a socket call being interrupted
 	   by a signal.  If the signal handler uses any stack the arguments
 	   to socket will be trashed.  The results of a restart of any
-	   socket call are then unpredictable. */
+	   socket call are then unpredictable.  */
 
 	/* Push args onto the stack.  */
 	P(PUSHARGS_,NARGS)
 
-        /* Do the system call trap.  */
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	bf .Lsocket_cancel
+#endif
+
+	/* Do the system call trap.  */
 	mov #+P(SOCKOP_,socket), r4
 	mov r15, r5
 	mov.l .L1,r3
@@ -77,39 +113,63 @@
 	shad	r2, r1
 	not	r1, r1			// r1=0 means r0 = -1 to -4095
 	tst	r1, r1			// i.e. error in linux
-	bf	1f
-
-	mov.l .L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	0f, r12
-	mova	0f, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr @r1
-	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-	.align 2
-0:
-	.long	_GLOBAL_OFFSET_TABLE_
-#else
-	jmp @r1
-	 mov	r0, r4
-#endif
-1:
+	bf	.Lpseudo_end
+.Lsyscall_error:
+	SYSCALL_ERROR_HANDLER
+.Lpseudo_end:
 	/* Successful; return the syscall's value.  */
 	rts
 	 nop
+
+#if defined NEED_CANCELLATION && defined CENABLE
+.Lsocket_cancel:
+	/* Enable asynchronous cancellation.  */
+	P(ADJUSTCFI_,NARGS)
+	sts.l pr,@-r15
+	cfi_adjust_cfa_offset (4)
+	cfi_rel_offset (pr, 0)
+	CENABLE
+	lds.l @r15+,pr
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (pr)
+
+	/* Do the system call trap.  */
+	mov #+P(SOCKOP_,socket), r4
+	mov r15, r5
+	mov.l .L1,r3
+	trapa #0x12
+
+	sts.l pr,@-r15
+	cfi_adjust_cfa_offset (4)
+	cfi_rel_offset (pr, 0)
+	mov.l r0,@-r15
+	cfi_adjust_cfa_offset (4)
+	cfi_rel_offset (r0, 0)
+	CDISABLE
+	mov.l @r15+,r0
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (r0)
+	lds.l @r15+,pr
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (pr)
+
+	/* Pop args off the stack */
+	P(POPARGS_,NARGS)
+
+	mov     r0, r1
+	mov	#-12, r2
+	shad	r2, r1
+	not	r1, r1			// r1=0 means r0 = -1 to -4095
+	tst	r1, r1			// i.e. error in linux
+	bf	.Lpseudo_end
+	bra	.Lsyscall_error
+	 nop
+#endif
+	cfi_endproc
+
 	.align 2
 .L1:
 	.long	SYS_ify(socketcall)
-.L2:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
 
 PSEUDO_END (__socket)
 
diff -Nur sysdeps/unix/sysv/linux/sh/sys/procfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sys/procfs.h
--- sysdeps/unix/sysv/linux/sh/sys/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sys/procfs.h	2004-11-20 18:56:16.000000000 +0100
@@ -0,0 +1,115 @@
+/* Copyright (C) 1996, 1997, 1999, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/ucontext.h>
+#include <sys/user.h>
+#include <asm/elf.h>
+
+__BEGIN_DECLS
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+#if 0
+    long int pr_flags;			/* XXX Process flags.  */
+    short int pr_why;			/* XXX Reason for process halt.  */
+    short int pr_what;			/* XXX More detailed reason.  */
+#endif
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+#if 0
+    struct sigaltstack pr_altstack;	/* Alternate stack info.  */
+    struct sigaction pr_action;		/* Signal action for current sig.  */
+#endif
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+#if 0
+    long int pr_instr;			/* Current instruction.  */
+#endif
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore habe only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff -Nur sysdeps/unix/sysv/linux/sh/sys/user.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sys/user.h
--- sysdeps/unix/sysv/linux/sh/sys/user.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sys/user.h	2003-02-08 03:32:42.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,4 +23,6 @@
 
 #include <asm/user.h>
 
+#undef start_thread
+
 #endif  /* sys/user.h */
diff -Nur sysdeps/unix/sysv/linux/sh/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/syscall.S
--- sysdeps/unix/sysv/linux/sh/syscall.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/syscall.S	2003-01-05 12:07:14.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,36 +33,12 @@
 	shad	r2, r1
 	not	r1, r1			// r1=0 means r0 = -1 to -4095
 	tst	r1, r1			// i.e. error in linux
-	bf	1f
-	mov.l	.L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	0f, r12
-	mova	0f, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr	@r1
-	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-	.align 2
-0:
-	.long	_GLOBAL_OFFSET_TABLE_
-#else
-	jmp	@r1
-	 mov	r0, r4
-#endif
-1:
+	bf	.Lpseudo_end
+	SYSCALL_ERROR_HANDLER
+.Lpseudo_end:
 	rts
 	 nop
 
-	.align	2
-.L2:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
 PSEUDO_END (__syscall)
 
 weak_alias (__syscall, syscall)
diff -Nur sysdeps/unix/sysv/linux/sh/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/syscalls.list
--- sysdeps/unix/sysv/linux/sh/syscalls.list	2000-10-26 04:24:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/syscalls.list	2003-10-13 00:56:00.000000000 +0200
@@ -1,2 +1,3 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
+waitpid		-	waitpid		Ci:ipi	__waitpid	waitpid	__libc_waitpid
diff -Nur sysdeps/unix/sysv/linux/sh/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sysdep.h
--- sysdeps/unix/sysv/linux/sh/sysdep.h	2002-08-26 23:16:21.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sysdep.h	2004-10-04 22:59:37.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1992,93,95-99,2000,02 Free Software Foundation, Inc.
+/* Copyright (C) 1992,1993,1995,1996,1997,1998,1999,2000,2002,2003,2004
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.ai.mit.edu>, August 1995.
    Changed by Kaz Kojima, <kkojima@rr.iij4u.or.jp>.
@@ -45,9 +46,9 @@
    returns a value in -1 .. -4095 as a valid result so we can savely
    test with -4095.  */
 
+#define _IMM1 #-1
 #define _IMM12 #-12
 #undef	PSEUDO
-#ifdef SHARED
 #define	PSEUDO(name, syscall_name, args) \
  .text; \
  ENTRY (name); \
@@ -57,50 +58,138 @@
     shad r2,r1; \
     not r1,r1; \
     tst r1,r1; \
-    bf 1f; \
-    mov r0,r4; \
-    mov.l r12,@-r15; \
-    sts.l pr,@-r15; \
-    mov.l 0f,r12; \
-    mova 0f,r0; \
-    add r0,r12; \
-    mov.l 2f,r1; \
-    mova 2f,r0; \
-    add r0,r1; \
-    jsr @r1; \
-     nop; \
-    lds.l @r15+,pr; \
-    rts; \
-     mov.l @r15+,r12; \
-    .align 2; \
- 2: .long PLTJMP(C_SYMBOL_NAME(__syscall_error)); \
- 0: .long _GLOBAL_OFFSET_TABLE_; \
- 1:
-#else
-#define	PSEUDO(name, syscall_name, args) \
- .text; \
- ENTRY (name); \
-    DO_CALL (syscall_name, args); \
-    mov r0,r1; \
-    mov _IMM12,r2; \
-    shad r2,r1; \
-    not r1,r1; \
-    tst r1,r1; \
-    bf 1f; \
-    mov.l 2f,r1; \
-    jmp @r1; \
-     mov r0, r4; \
-    .align 2; \
- 2: .long PLTJMP(C_SYMBOL_NAME(__syscall_error)); \
- 1:
-#endif
+    bf .Lpseudo_end; \
+    SYSCALL_ERROR_HANDLER; \
+ .Lpseudo_end:
 
 #undef	PSEUDO_END
 #define	PSEUDO_END(name) \
-  SYSCALL_ERROR_HANDLER \
   END (name)
 
-#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+ .text; \
+ ENTRY (name); \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+ .text; \
+ ENTRY (name); \
+    DO_CALL (syscall_name, args);
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+# define SYSCALL_ERROR_HANDLER	\
+	mov.l 0f,r1; \
+	jmp @r1; \
+	 mov r0,r4; \
+	.align 2; \
+     0: .long __syscall_error
+#else
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER	\
+	neg r0,r1; \
+	mov.l 0f,r12; \
+	mova 0f,r0; \
+	add r0,r12; \
+	mov.l 1f,r0; \
+	mov.l r1,@(r0,r12)
+	bra .Lpseudo_end; \
+	 mov _IMM1,r0; \
+	.align 2; \
+     0: .long _GLOBAL_OFFSET_TABLE_; \
+     1: .long rtld_errno@GOTOFF
+
+# elif defined _LIBC_REENTRANT
+
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
+#   define SYSCALL_ERROR_HANDLER \
+	neg r0,r1; \
+	mov r12,r2; \
+	mov.l 0f,r12; \
+	mova 0f,r0; \
+	add r0,r12; \
+	mov.l 1f,r0; \
+	stc gbr, r4; \
+	mov.l @(r0,r12),r0; \
+	mov r2,r12; \
+	add r4,r0; \
+	mov.l r1,@r0; \
+	bra .Lpseudo_end; \
+	 mov _IMM1,r0; \
+	.align 2; \
+     0: .long _GLOBAL_OFFSET_TABLE_; \
+     1: .long SYSCALL_ERROR_ERRNO@GOTTPOFF
+#  else
+#   define SYSCALL_ERROR_HANDLER \
+	neg r0,r1; \
+	mov.l r14,@-r15; \
+	mov.l r12,@-r15; \
+	mov.l r1,@-r15; \
+	mov.l 0f,r12; \
+	mova 0f,r0; \
+	add r0,r12; \
+	sts.l pr,@-r15; \
+	mov r15,r14; \
+	mov.l 1f,r1; \
+	bsrf r1; \
+         nop; \
+     2: mov r14,r15; \
+	lds.l @r15+,pr; \
+	mov.l @r15+,r1; \
+	mov.l r1,@r0; \
+	mov.l @r15+,r12; \
+	mov.l @r15+,r14; \
+	bra .Lpseudo_end; \
+	 mov _IMM1,r0; \
+	.align 2; \
+     0: .long _GLOBAL_OFFSET_TABLE_; \
+     1: .long PLTJMP(C_SYMBOL_NAME(__errno_location))-(2b-.)
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+#  endif
+# else
+/* Store (-r0) into errno through the GOT.  */
+#  define SYSCALL_ERROR_HANDLER						      \
+	neg r0,r1; \
+	mov r12,r2; \
+	mov.l 0f,r12; \
+	mova 0f,r0; \
+	add r0,r12; \
+	mov.l 1f,r0; \
+	mov.l @(r0,r12),r0; \
+	mov r2,r12; \
+	mov.l r1,@r0; \
+	bra .Lpseudo_end; \
+	 mov _IMM1,r0; \
+	.align 2; \
+     0: .long _GLOBAL_OFFSET_TABLE_; \
+     1: .long errno@GOT
+# endif	/* _LIBC_REENTRANT */
+#endif	/* PIC */
+
+# ifdef NEED_SYSCALL_INST_PAD
+#  define SYSCALL_INST_PAD \
+	or r0,r0; or r0,r0; or r0,r0; or r0,r0; or r0,r0
+# else
+#  define SYSCALL_INST_PAD
+# endif
 
 #define SYSCALL_INST0	trapa #0x10
 #define SYSCALL_INST1	trapa #0x11
@@ -114,6 +203,7 @@
 #define DO_CALL(syscall_name, args)	\
     mov.l 1f,r3;			\
     SYSCALL_INST##args;			\
+    SYSCALL_INST_PAD;			\
     bra 2f;				\
      nop;				\
     .align 2;				\
@@ -130,6 +220,13 @@
 #define SYSCALL_INST_STR5	"trapa #0x15\n\t"
 #define SYSCALL_INST_STR6	"trapa #0x16\n\t"
 
+# ifdef NEED_SYSCALL_INST_PAD
+#  define SYSCALL_INST_PAD "\
+	or r0,r0; or r0,r0; or r0,r0; or r0,r0; or r0,r0"
+# else
+#  define SYSCALL_INST_PAD
+# endif
+
 #define ASMFMT_0
 #define ASMFMT_1 \
 	, "r" (r4)
@@ -147,61 +244,119 @@
 	, "r" (r4), "r" (r5), "r" (r6), "r" (r7), "0" (r0), "r" (r1), "r" (r2)
 
 #define SUBSTITUTE_ARGS_0()
-#define SUBSTITUTE_ARGS_1(arg1)					\
-	register long r4 asm ("%r4") = (long)(arg1)
-#define SUBSTITUTE_ARGS_2(arg1, arg2)				\
-	register long r4 asm ("%r4") = (long)(arg1);		\
-	register long r5 asm ("%r5") = (long)(arg2)
-#define SUBSTITUTE_ARGS_3(arg1, arg2, arg3)			\
-	register long r4 asm ("%r4") = (long)(arg1);		\
-	register long r5 asm ("%r5") = (long)(arg2);		\
-	register long r6 asm ("%r6") = (long)(arg3)
-#define SUBSTITUTE_ARGS_4(arg1, arg2, arg3, arg4)		\
-	register long r4 asm ("%r4") = (long)(arg1);		\
-	register long r5 asm ("%r5") = (long)(arg2);		\
-	register long r6 asm ("%r6") = (long)(arg3);		\
-	register long r7 asm ("%r7") = (long)(arg4)
-#define SUBSTITUTE_ARGS_5(arg1, arg2, arg3, arg4, arg5) 	\
-	register long r4 asm ("%r4") = (long)(arg1);		\
-	register long r5 asm ("%r5") = (long)(arg2);		\
-	register long r6 asm ("%r6") = (long)(arg3);		\
-	register long r7 asm ("%r7") = (long)(arg4);		\
-	register long r0 asm ("%r0") = (long)(arg5)
-#define SUBSTITUTE_ARGS_6(arg1, arg2, arg3, arg4, arg5, arg6)		\
-	register long r4 asm ("%r4") = (long)(arg1);			\
-	register long r5 asm ("%r5") = (long)(arg2);			\
-	register long r6 asm ("%r6") = (long)(arg3);			\
-	register long r7 asm ("%r7") = (long)(arg4);			\
-	register long r0 asm ("%r0") = (long)(arg5);			\
-	register long r1 asm ("%r1") = (long)(arg6)
-#define SUBSTITUTE_ARGS_7(arg1, arg2, arg3, arg4, arg5, arg6, arg7)	\
-	register long r4 asm ("%r4") = (long)(arg1);			\
-	register long r5 asm ("%r5") = (long)(arg2);			\
-	register long r6 asm ("%r6") = (long)(arg3);			\
-	register long r7 asm ("%r7") = (long)(arg4);			\
-	register long r0 asm ("%r0") = (long)(arg5)			\
-	register long r1 asm ("%r1") = (long)(arg6);			\
-	register long r2 asm ("%r2") = (long)(arg7)
+#define SUBSTITUTE_ARGS_1(arg1) \
+	long int _arg1 = (long int) (arg1);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1)
+#define SUBSTITUTE_ARGS_2(arg1, arg2) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2)
+#define SUBSTITUTE_ARGS_3(arg1, arg2, arg3) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	long int _arg3 = (long int) (arg3);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2);		      \
+	register long int r6 asm ("%r6") = (long int) (_arg3)
+#define SUBSTITUTE_ARGS_4(arg1, arg2, arg3, arg4) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	long int _arg3 = (long int) (arg3);				      \
+	long int _arg4 = (long int) (arg4);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2);		      \
+	register long int r6 asm ("%r6") = (long int) (_arg3);		      \
+	register long int r7 asm ("%r7") = (long int) (_arg4)
+#define SUBSTITUTE_ARGS_5(arg1, arg2, arg3, arg4, arg5) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	long int _arg3 = (long int) (arg3);				      \
+	long int _arg4 = (long int) (arg4);				      \
+	long int _arg5 = (long int) (arg5);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2);		      \
+	register long int r6 asm ("%r6") = (long int) (_arg3);		      \
+	register long int r7 asm ("%r7") = (long int) (_arg4);		      \
+	register long int r0 asm ("%r0") = (long int) (_arg5)
+#define SUBSTITUTE_ARGS_6(arg1, arg2, arg3, arg4, arg5, arg6) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	long int _arg3 = (long int) (arg3);				      \
+	long int _arg4 = (long int) (arg4);				      \
+	long int _arg5 = (long int) (arg5);				      \
+	long int _arg6 = (long int) (arg6);				      \
+	register long int r4 asm ("%r4") = (long int)(_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2);		      \
+	register long int r6 asm ("%r6") = (long int) (_arg3);		      \
+	register long int r7 asm ("%r7") = (long int) (_arg4);		      \
+	register long int r0 asm ("%r0") = (long int) (_arg5);		      \
+	register long int r1 asm ("%r1") = (long int) (_arg6)
+#define SUBSTITUTE_ARGS_7(arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
+	long int _arg1 = (long int) (arg1);				      \
+	long int _arg2 = (long int) (arg2);				      \
+	long int _arg3 = (long int) (arg3);				      \
+	long int _arg4 = (long int) (arg4);				      \
+	long int _arg5 = (long int) (arg5);				      \
+	long int _arg6 = (long int) (arg6);				      \
+	long int _arg7 = (long int) (arg7);				      \
+	register long int r4 asm ("%r4") = (long int) (_arg1);		      \
+	register long int r5 asm ("%r5") = (long int) (_arg2);		      \
+	register long int r6 asm ("%r6") = (long int) (_arg3);		      \
+	register long int r7 asm ("%r7") = (long int) (_arg4);		      \
+	register long int r0 asm ("%r0") = (long int) (_arg5);		      \
+	register long int r1 asm ("%r1") = (long int) (_arg6);		      \
+	register long int r2 asm ("%r2") = (long int) (_arg7)
 
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...) 			\
-  ({								\
-    unsigned long resultvar;					\
-    register long r3 asm ("%r3") = SYS_ify (name);		\
-    SUBSTITUTE_ARGS_##nr(args);					\
-								\
-    asm volatile (SYSCALL_INST_STR##nr				\
-		  : "=z" (resultvar)				\
-		  : "r" (r3) ASMFMT_##nr 			\
-		  : "memory");					\
-								\
-    if (resultvar >= 0xfffff001)			        \
-      {							        \
-	__set_errno (-resultvar);				\
-	resultvar = 0xffffffff;					\
-      }								\
+#define INLINE_SYSCALL(name, nr, args...) \
+  ({                                                                          \
+    unsigned int resultvar = INTERNAL_SYSCALL (name, , nr, args);             \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))         \
+      {                                                                       \
+        __set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));                   \
+        resultvar = 0xffffffff;                                               \
+      }                                                                       \
     (int) resultvar; })
 
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  ({									      \
+    unsigned long int resultvar;					      \
+    register long int r3 asm ("%r3") = SYS_ify (name);			      \
+    SUBSTITUTE_ARGS_##nr(args);						      \
+									      \
+    asm volatile (SYSCALL_INST_STR##nr SYSCALL_INST_PAD			      \
+		  : "=z" (resultvar)					      \
+		  : "r" (r3) ASMFMT_##nr				      \
+		  : "memory");						      \
+									      \
+    (int) resultvar; })
+
+/* The _NCS variant allows non-constant syscall numbers.  */
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    unsigned long int resultvar;					      \
+    register long int r3 asm ("%r3") = (name);			 	      \
+    SUBSTITUTE_ARGS_##nr(args);						      \
+									      \
+    asm volatile (SYSCALL_INST_STR##nr SYSCALL_INST_PAD			      \
+		  : "=z" (resultvar)					      \
+		  : "r" (r3) ASMFMT_##nr				      \
+		  : "memory");						      \
+									      \
+    (int) resultvar; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned int) (val) >= 0xfffff001u)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)        (-(val))
+
 #endif	/* __ASSEMBLER__ */
 
 #endif /* linux/sh/sysdep.h */
diff -Nur sysdeps/unix/sysv/linux/sh/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sysdep.S
--- sysdeps/unix/sysv/linux/sh/sysdep.S	2001-08-21 04:42:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/sysdep.S	2002-10-11 12:51:13.000000000 +0200
@@ -18,18 +18,6 @@
 
 #include <sysdep.h>
 
-/* We define errno here, to be consistent with Linux/i386.  */
-
-	.section .bss
-	.align 2
-	.globl C_SYMBOL_NAME(errno)
-	.type C_SYMBOL_NAME(errno), @object
-	.size C_SYMBOL_NAME(errno), 4
-C_SYMBOL_NAME(errno):
-	.space	4
-weak_alias (errno, _errno)
-	.text
-
 /* The syscall stubs jump here when they detect an error.
    The code for Linux is almost identical to the canonical Unix
    code, except that the error number in R0 is negated.  */
diff -Nur sysdeps/unix/sysv/linux/sh/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/Versions
--- sysdeps/unix/sysv/linux/sh/Versions	2000-10-26 04:24:08.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/Versions	2003-09-01 06:05:09.000000000 +0200
@@ -21,4 +21,7 @@
     # v*
     versionsort64;
   }
+  GLIBC_2.3.3 {
+    posix_fadvise64; posix_fallocate64;
+  }
 }
diff -Nur sysdeps/unix/sysv/linux/sh/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/vfork.S
--- sysdeps/unix/sysv/linux/sh/vfork.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sh/vfork.S	2003-01-05 12:07:14.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -39,28 +39,8 @@
 	mov.w	.L1, r1
 	cmp/eq	r1, r0
 	bt	2f
-	mov.l	.L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-	mov.l	0f, r12
-	mova	0f, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr	@r1
+	bra	.Lsyscall_error
 	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-	.align	2
-0:
-	.long	_GLOBAL_OFFSET_TABLE_
-#else
-	jmp	@r1
-	 mov	r0, r4
-#endif
 .L1:
 	.word	-ENOSYS
 .L3:	.word	__NR_vfork
@@ -78,36 +58,14 @@
 	shad	r2, r1
 	not	r1, r1			// r1=0 means r0 = -1 to -4095
 	tst	r1, r1			// i.e. error in linux
-	bf	1f
-	mov.l	.L2, r1
-#ifdef SHARED
-	mov	r0, r4
-	mov.l	r12, @-r15
-	sts.l	pr, @-r15
-        mov.l	0f, r12
-	mova	0f, r0
-	add	r0, r12
-	mova	.L2, r0
-	add	r0, r1
-	jsr	@r1
-	 nop
-	lds.l	@r15+, pr
-	rts
-	 mov.l	@r15+, r12
-	.align	2
-0:
-	.long	_GLOBAL_OFFSET_TABLE_
-#else
-	jmp	@r1
-	 mov	r0, r4
-#endif
-	.align	2
-.L2:
-	.long	PLTJMP(C_SYMBOL_NAME(__syscall_error))
-1:
+	bf	.Lpseudo_end
+.Lsyscall_error:	
+	SYSCALL_ERROR_HANDLER
+.Lpseudo_end:
 	rts
 	 nop
-	
+
 PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/shmctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/shmctl.c
--- sysdeps/unix/sysv/linux/shmctl.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/shmctl.c	2004-03-10 20:27:26.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -62,6 +63,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_shmctl (int shmid, int cmd, struct __old_shmid_ds *buf)
 {
   return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid,
@@ -74,7 +76,8 @@
 __new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
 {
 #if __ASSUME_IPC64 > 0
-  return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd | __IPC_64, 0, CHECK_1 (buf));
+  return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd | __IPC_64, 0,
+			 CHECK_1 (buf));
 #else
   switch (cmd) {
     case SHM_STAT:
@@ -85,63 +88,69 @@
 #endif
       break;
     default:
-      return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd, 0, CHECK_1 (buf));
+      return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd, 0,
+			     CHECK_1 (buf));
   }
 
   {
     int save_errno = errno, result;
-    struct __old_shmid_ds old;
+    union
+      {
+	struct __old_shmid_ds ds;
+	struct __old_shminfo info;
+      } old;
 
     /* Unfortunately there is no way how to find out for sure whether
        we should use old or new shmctl.  */
-    result = INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd | __IPC_64, 0, CHECK_1 (buf));
+    result = INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd | __IPC_64, 0,
+			     CHECK_1 (buf));
     if (result != -1 || errno != EINVAL)
       return result;
 
     __set_errno(save_errno);
     if (cmd == IPC_SET)
       {
-	old.shm_perm.uid = buf->shm_perm.uid;
-	old.shm_perm.gid = buf->shm_perm.gid;
-	old.shm_perm.mode = buf->shm_perm.mode;
-	if (old.shm_perm.uid != buf->shm_perm.uid ||
-	    old.shm_perm.gid != buf->shm_perm.gid)
+	old.ds.shm_perm.uid = buf->shm_perm.uid;
+	old.ds.shm_perm.gid = buf->shm_perm.gid;
+	old.ds.shm_perm.mode = buf->shm_perm.mode;
+	if (old.ds.shm_perm.uid != buf->shm_perm.uid ||
+	    old.ds.shm_perm.gid != buf->shm_perm.gid)
 	  {
 	    __set_errno (EINVAL);
 	    return -1;
 	  }
       }
-    result = INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd, 0, __ptrvalue (&old));
+    result = INLINE_SYSCALL (ipc, 5, IPCOP_shmctl, shmid, cmd, 0,
+			     __ptrvalue (&old.ds));
     if (result != -1 && (cmd == SHM_STAT || cmd == IPC_STAT))
       {
 	memset(buf, 0, sizeof(*buf));
-	buf->shm_perm.__key = old.shm_perm.__key;
-	buf->shm_perm.uid = old.shm_perm.uid;
-	buf->shm_perm.gid = old.shm_perm.gid;
-	buf->shm_perm.cuid = old.shm_perm.cuid;
-	buf->shm_perm.cgid = old.shm_perm.cgid;
-	buf->shm_perm.mode = old.shm_perm.mode;
-	buf->shm_perm.__seq = old.shm_perm.__seq;
-	buf->shm_atime = old.shm_atime;
-	buf->shm_dtime = old.shm_dtime;
-	buf->shm_ctime = old.shm_ctime;
-	buf->shm_segsz = old.shm_segsz;
-	buf->shm_nattch = old.shm_nattch;
-	buf->shm_cpid = old.shm_cpid;
-	buf->shm_lpid = old.shm_lpid;
+	buf->shm_perm.__key = old.ds.shm_perm.__key;
+	buf->shm_perm.uid = old.ds.shm_perm.uid;
+	buf->shm_perm.gid = old.ds.shm_perm.gid;
+	buf->shm_perm.cuid = old.ds.shm_perm.cuid;
+	buf->shm_perm.cgid = old.ds.shm_perm.cgid;
+	buf->shm_perm.mode = old.ds.shm_perm.mode;
+	buf->shm_perm.__seq = old.ds.shm_perm.__seq;
+	buf->shm_atime = old.ds.shm_atime;
+	buf->shm_dtime = old.ds.shm_dtime;
+	buf->shm_ctime = old.ds.shm_ctime;
+	buf->shm_segsz = old.ds.shm_segsz;
+	buf->shm_nattch = old.ds.shm_nattch;
+	buf->shm_cpid = old.ds.shm_cpid;
+	buf->shm_lpid = old.ds.shm_lpid;
       }
 #if __WORDSIZE != 32
     else if (result != -1 && cmd == IPC_INFO)
       {
-	struct __old_shminfo *oldi = (struct __old_shminfo *)&old;
 	struct shminfo *i = (struct shminfo *)buf;
 
 	memset(i, 0, sizeof(*i));
-	i->shmmax = oldi->shmmax;
-	i->shmmin = oldi->shmmin;
-	i->shmmni = oldi->shmmni;
-	i->shmseg = oldi->shmseg;
-	i->shmall = oldi->shmall;
+	i->shmmax = old.info.shmmax;
+	i->shmmin = old.info.shmmin;
+	i->shmmni = old.info.shmmni;
+	i->shmseg = old.info.shmseg;
+	i->shmall = old.info.shmall;
       }
 #endif
     return result;
diff -Nur sysdeps/unix/sysv/linux/shm_open.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/shm_open.c
--- sysdeps/unix/sysv/linux/shm_open.c	2002-09-06 20:38:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/shm_open.c	2004-04-20 20:57:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -181,6 +181,11 @@
 	  __set_errno (save_errno);
 	}
     }
+  else if (__builtin_expect (errno == EISDIR, 0))
+    /* It might be better to fold this error with EINVAL since
+       directory names are just another example for unsuitable shared
+       object names and the standard does not mention EISDIR.  */
+    __set_errno (EINVAL);
 
   return fd;
 }
@@ -222,18 +227,17 @@
 	     name, namelen + 1);
 
   /* And remove the file.  */
-  return unlink (fname);
+  int ret = unlink (fname);
+  if (ret < 0 && errno == EPERM)
+    __set_errno (EACCES);
+  return ret;
 }
 
 
-static void  __attribute__ ((unused))
-freeit (void)
+/* Make sure the table is freed if we want to free everything before
+   exiting.  */
+libc_freeres_fn (freeit)
 {
   if (mountpoint.dir != defaultdir)
     free (mountpoint.dir);
 }
-
-
-/* Make sure the table is freed if we want to free everything before
-   exiting.  */
-text_set_element (__libc_subfreeres, freeit);
diff -Nur sysdeps/unix/sysv/linux/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigaction.c
--- sysdeps/unix/sysv/linux/sigaction.c	2002-09-18 19:59:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigaction.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,12 +34,7 @@
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  This is the definition.  */
 int __libc_missing_rt_sigs;
-
-extern int __syscall_sigaction (int, const struct old_kernel_sigaction *__unbounded,
-				struct old_kernel_sigaction *__unbounded);
 #endif
-extern int __syscall_rt_sigaction (int, const struct kernel_sigaction *__unbounded,
-				   struct kernel_sigaction *__unbounded, size_t);
 
 
 /* If ACT is not NULL, change the action for SIG to *ACT.
@@ -134,25 +129,8 @@
 }
 libc_hidden_def (__libc_sigaction)
 
-#ifndef SIGCANCEL
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction)
-#else
-int
-__sigaction (sig, act, oact)
-     int sig;
-     const struct sigaction *act;
-     struct sigaction *oact;
-{
-  if (sig == SIGCANCEL)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  return __libc_sigaction (sig, act, oact);
-}
-libc_hidden_weak (__sigaction)
-weak_alias (__sigaction, sigaction)
 #endif
diff -Nur sysdeps/unix/sysv/linux/siglist.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/siglist.h
--- sysdeps/unix/sysv/linux/siglist.h	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/siglist.h	2003-04-01 07:50:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1996,1997,1998,1999,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,4 +20,6 @@
 
 #include_next <siglist.h>	/* Get the canonical list.  */
 
-#define	OLD_SIGLIST_SIZE_STR	"32" /* For GLIBC_2.0 binary compatibility.  */
+#define	OLD_SIGLIST_SIZE	32 /* For GLIBC_2.0 binary compatibility.  */
+
+#define OLD2_SIGLIST_SIZE	64 /* For GLIBC_2.1 binary compatibility.  */
diff -Nur sysdeps/unix/sysv/linux/sigpending.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigpending.c
--- sysdeps/unix/sysv/linux/sigpending.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigpending.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,9 +26,6 @@
 
 #include "kernel-features.h"
 
-extern int __syscall_sigpending (sigset_t *__unbounded);
-extern int __syscall_rt_sigpending (sigset_t *__unbounded, size_t);
-
 
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  The definition is in sigaction.c.  */
diff -Nur sysdeps/unix/sysv/linux/sigprocmask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigprocmask.c
--- sysdeps/unix/sysv/linux/sigprocmask.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigprocmask.c	2004-09-29 00:37:06.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2001,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,6 +18,7 @@
 
 #include <errno.h>
 #include <signal.h>
+#include <string.h>	/* Neede for string function builtin redirection.  */
 #include <unistd.h>
 
 #include <sysdep.h>
@@ -27,11 +28,6 @@
 #include "kernel-features.h"
 
 
-extern int __syscall_sigprocmask (int, const sigset_t *__unbounded,
-				  sigset_t *__unbounded);
-extern int __syscall_rt_sigprocmask (int, const sigset_t *__unbounded,
-				     sigset_t *__unbounded, size_t);
-
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  The definition is in sigaction.c.  */
 extern int __libc_missing_rt_sigs;
@@ -44,6 +40,27 @@
      const sigset_t *set;
      sigset_t *oset;
 {
+#ifdef SIGCANCEL
+  sigset_t local_newmask;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID are not blocked.  */
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      local_newmask = *set;
+      __sigdelset (&local_newmask, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&local_newmask, SIGSETXID);
+# endif
+      set = &local_newmask;
+    }
+#endif
+
 #if __ASSUME_REALTIME_SIGNALS > 0
   return INLINE_SYSCALL (rt_sigprocmask, 4, how, CHECK_SIGSET_NULL_OK (set),
 			 CHECK_SIGSET_NULL_OK (oset), _NSIG / 8);
diff -Nur sysdeps/unix/sysv/linux/sigqueue.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigqueue.c
--- sysdeps/unix/sysv/linux/sigqueue.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigqueue.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,8 +24,6 @@
 #include <sysdep.h>
 #include <sys/syscall.h>
 
-extern int __syscall_rt_sigqueueinfo (int, int, siginfo_t *__unbounded);
-
 #ifdef __NR_rt_sigqueueinfo
 /* Return any pending signal or wait for one for the given time.  */
 int
diff -Nur sysdeps/unix/sysv/linux/sigsuspend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigsuspend.c
--- sysdeps/unix/sysv/linux/sigsuspend.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigsuspend.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1996,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,30 +21,22 @@
 #include <signal.h>
 #include <unistd.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #include "kernel-features.h"
 
-extern int __syscall_sigsuspend (int, unsigned long int, unsigned long int);
-extern int __syscall_rt_sigsuspend (const sigset_t *__unbounded, size_t);
-
 
+#if !__ASSUME_REALTIME_SIGNALS
 /* The variable is shared between all wrappers around signal handling
    functions which have RT equivalents.  The definition is in sigaction.c.  */
 extern int __libc_missing_rt_sigs;
 
 
-/* Change the set of blocked signals to SET,
-   wait until a signal arrives, and restore the set of blocked signals.  */
-int
-__sigsuspend (set)
-     const sigset_t *set;
+static int
+do_sigsuspend (const sigset_t *set)
 {
-#if __ASSUME_REALTIME_SIGNALS
-  return INLINE_SYSCALL (rt_sigsuspend, 2, CHECK_SIGSET (set), _NSIG / 8);
-#else
 # ifdef __NR_rt_sigsuspend
   /* First try the RT signals.  */
   if (!__libc_missing_rt_sigs)
@@ -62,7 +55,40 @@
 # endif
 
   return INLINE_SYSCALL (sigsuspend, 3, 0, 0, set->__val[0]);
+}
+#endif
+
+/* Change the set of blocked signals to SET,
+   wait until a signal arrives, and restore the set of blocked signals.  */
+int
+__sigsuspend (set)
+     const sigset_t *set;
+{
+#if __ASSUME_REALTIME_SIGNALS
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (rt_sigsuspend, 2, CHECK_SIGSET (set), _NSIG / 8);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (rt_sigsuspend, 2, CHECK_SIGSET (set),
+			       _NSIG / 8);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+#else
+  if (SINGLE_THREAD_P)
+    return do_sigsuspend (set);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigsuspend (set);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 #endif
 }
 libc_hidden_def (__sigsuspend)
 weak_alias (__sigsuspend, sigsuspend)
+strong_alias (__sigsuspend, __libc_sigsuspend)
diff -Nur sysdeps/unix/sysv/linux/sigtimedwait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigtimedwait.c
--- sysdeps/unix/sysv/linux/sigtimedwait.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigtimedwait.c	2004-09-29 00:39:17.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,14 +18,52 @@
 
 #include <errno.h>
 #include <signal.h>
+#include <string.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #ifdef __NR_rt_sigtimedwait
-extern int __syscall_rt_sigtimedwait (const sigset_t *__unbounded, siginfo_t *__unbounded,
-				      const struct timespec *__unbounded, size_t);
+
+static int
+do_sigtimedwait (const sigset_t *set, siginfo_t *info,
+		 const struct timespec *timeout)
+{
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      // We are not copying more than we have to.
+      memcpy (&tmpset, set, _NSIG / 8);
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+
+    /* XXX The size argument hopefully will have to be changed to the
+       real size of the user-level sigset_t.  */
+  int result = INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
+			       CHECK_1 (info), timeout, _NSIG / 8);
+
+  /* The kernel generates a SI_TKILL code in si_code in case tkill is
+     used.  tkill is transparently used in raise().  Since having
+     SI_TKILL as a code is useful in general we fold the results
+     here.  */
+  if (result != -1 && info != NULL && info->si_code == SI_TKILL)
+    info->si_code = SI_USER;
+
+  return result;
+}
 
 
 /* Return any pending signal or wait for one for the given time.  */
@@ -35,11 +73,20 @@
      siginfo_t *info;
      const struct timespec *timeout;
 {
+  if (SINGLE_THREAD_P)
+    return do_sigtimedwait (set, info, timeout);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
-  return INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
-			 CHECK_1 (info), timeout, _NSIG / 8);
+  int result = do_sigtimedwait (set, info, timeout);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
+libc_hidden_def (__sigtimedwait)
 weak_alias (__sigtimedwait, sigtimedwait)
 #else
 # include <sysdeps/generic/sigtimedwait.c>
diff -Nur sysdeps/unix/sysv/linux/sigwait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigwait.c
--- sysdeps/unix/sysv/linux/sigwait.c	2002-09-29 23:57:55.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigwait.c	2004-09-29 00:43:12.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,29 +20,56 @@
 #include <signal.h>
 #define __need_NULL
 #include <stddef.h>
+#include <string.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #ifdef __NR_rt_sigtimedwait
-extern int __syscall_rt_sigtimedwait (const sigset_t *__unbounded, siginfo_t *__unbounded,
-				      const struct timespec *__unbounded, size_t);
-
 
 /* Return any pending signal or wait for one for the given time.  */
-int
-__sigwait (set, sig)
-     const sigset_t *set;
-     int *sig;
+static int
+do_sigwait (const sigset_t *set, int *sig)
 {
   int ret;
 
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      // We are not copying more than we have to.
+      memcpy (&tmpset, set, _NSIG / 8);
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
-  /* XXX INLINE_SYSCALL_NOERROR candiate.  */
-  ret =  INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
-			 NULL, NULL, _NSIG / 8);
+#ifdef INTERNAL_SYSCALL
+  INTERNAL_SYSCALL_DECL (err);
+  ret = INTERNAL_SYSCALL (rt_sigtimedwait, err, 4, CHECK_SIGSET (set),
+			  NULL, NULL, _NSIG / 8);
+  if (! INTERNAL_SYSCALL_ERROR_P (ret, err))
+    {
+      *sig = ret;
+      ret = 0;
+    }
+  else
+    ret = INTERNAL_SYSCALL_ERRNO (ret, err);
+#else
+  ret = INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
+			NULL, NULL, _NSIG / 8);
   if (ret != -1)
     {
       *sig = ret;
@@ -50,10 +77,30 @@
     }
   else
     ret = errno;
+#endif
 
   return ret;
 }
+
+int
+__sigwait (set, sig)
+     const sigset_t *set;
+     int *sig;
+{
+  if (SINGLE_THREAD_P)
+    return do_sigwait (set, sig);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigwait (set, sig);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__sigwait)
 weak_alias (__sigwait, sigwait)
 #else
 # include <sysdeps/posix/sigwait.c>
 #endif
+strong_alias (__sigwait, __libc_sigwait)
diff -Nur sysdeps/unix/sysv/linux/sigwaitinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigwaitinfo.c
--- sysdeps/unix/sysv/linux/sigwaitinfo.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sigwaitinfo.c	2004-09-29 00:41:12.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,2000,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,14 +20,51 @@
 #include <signal.h>
 #define __need_NULL
 #include <stddef.h>
+#include <string.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
 #ifdef __NR_rt_sigtimedwait
-extern int __syscall_rt_sigtimedwait (const sigset_t *__unbounded, siginfo_t *__unbounded,
-				      const struct timespec *__unbounded, size_t);
+
+static int
+do_sigwaitinfo (const sigset_t *set, siginfo_t *info)
+{
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      // We are not copying more than we have to.
+      memcpy (&tmpset, set, _NSIG / 8);
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+
+  /* XXX The size argument hopefully will have to be changed to the
+     real size of the user-level sigset_t.  */
+  int result = INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
+			       CHECK_1 (info), NULL, _NSIG / 8);
+
+  /* The kernel generates a SI_TKILL code in si_code in case tkill is
+     used.  tkill is transparently used in raise().  Since having
+     SI_TKILL as a code is useful in general we fold the results
+     here.  */
+  if (result != -1 && info != NULL && info->si_code == SI_TKILL)
+    info->si_code = SI_USER;
+
+  return result;
+}
 
 
 /* Return any pending signal or wait for one for the given time.  */
@@ -36,12 +73,22 @@
      const sigset_t *set;
      siginfo_t *info;
 {
+  if (SINGLE_THREAD_P)
+    return do_sigwaitinfo (set, info);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
   /* XXX The size argument hopefully will have to be changed to the
      real size of the user-level sigset_t.  */
-  return INLINE_SYSCALL (rt_sigtimedwait, 4, CHECK_SIGSET (set),
-			 CHECK_1 (info), NULL, _NSIG / 8);
+  int result = do_sigwaitinfo (set, info);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
+libc_hidden_def (__sigwaitinfo)
 weak_alias (__sigwaitinfo, sigwaitinfo)
 #else
 # include <sysdeps/generic/sigwaitinfo.c>
 #endif
+strong_alias (__sigwaitinfo, __libc_sigwaitinfo)
diff -Nur sysdeps/unix/sysv/linux/sleep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sleep.c
--- sysdeps/unix/sysv/linux/sleep.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sleep.c	2003-07-12 00:49:38.000000000 +0200
@@ -1,5 +1,5 @@
 /* Implementation of the POSIX sleep function using nanosleep.
-   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 1999, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -22,27 +22,61 @@
 #include <time.h>
 #include <signal.h>
 #include <unistd.h>
+#include <sys/param.h>
+
+
+#if 0
+static void
+cl (void *arg)
+{
+  (void) __sigprocmask (SIG_SETMASK, arg, (sigset_t *) NULL);
+}
+#endif
+
 
 /* We are going to use the `nanosleep' syscall of the kernel.  But the
-   kernel does not implement the sstupid SysV SIGCHLD vs. SIG_IGN
+   kernel does not implement the stupid SysV SIGCHLD vs. SIG_IGN
    behaviour for this syscall.  Therefore we have to emulate it here.  */
 unsigned int
 __sleep (unsigned int seconds)
 {
-  struct timespec ts = { tv_sec: (long int) seconds, tv_nsec: 0 };
+  const unsigned int max
+    = (unsigned int) (((unsigned long int) (~((time_t) 0))) >> 1);
+  struct timespec ts;
   sigset_t set, oset;
   unsigned int result;
 
   /* This is not necessary but some buggy programs depend on this.  */
-  if (seconds == 0)
-    return 0;
+  if (__builtin_expect (seconds == 0, 0))
+    {
+#ifdef CANCELLATION_P
+      CANCELLATION_P (THREAD_SELF);
+#endif
+      return 0;
+    }
+
+  ts.tv_sec = 0;
+  ts.tv_nsec = 0;
+ again:
+  if (sizeof (ts.tv_sec) <= sizeof (seconds))
+    {
+      /* Since SECONDS is unsigned assigning the value to .tv_sec can
+	 overflow it.  In this case we have to wait in steps.  */
+      ts.tv_sec += MIN (seconds, max);
+      seconds -= (unsigned int) ts.tv_sec;
+    }
+  else
+    {
+      ts.tv_sec = (time_t) seconds;
+      seconds = 0;
+    }
 
   /* Linux will wake up the system call, nanosleep, when SIGCHLD
      arrives even if SIGCHLD is ignored.  We have to deal with it
      in libc.  We block SIGCHLD first.  */
-  if (__sigemptyset (&set) < 0
-      || __sigaddset (&set, SIGCHLD) < 0
-      || __sigprocmask (SIG_BLOCK, &set, &oset))
+  __sigemptyset (&set);
+  __sigaddset (&set, SIGCHLD);
+  if (__sigprocmask (SIG_BLOCK, &set, &oset))
     return -1;
 
   /* If SIGCHLD is already blocked, we don't have to do anything.  */
@@ -51,8 +85,8 @@
       int saved_errno;
       struct sigaction oact;
 
-      if (__sigemptyset (&set) < 0 || __sigaddset (&set, SIGCHLD) < 0)
-	return -1;
+      __sigemptyset (&set);
+      __sigaddset (&set, SIGCHLD);
 
       /* We get the signal handler for SIGCHLD.  */
       if (__sigaction (SIGCHLD, (struct sigaction *) NULL, &oact) < 0)
@@ -64,29 +98,50 @@
 	  return -1;
 	}
 
+      /* Note the sleep() is a cancellation point.  But since we call
+	 nanosleep() which itself is a cancellation point we do not
+	 have to do anything here.  */
       if (oact.sa_handler == SIG_IGN)
 	{
+	  //__libc_cleanup_push (cl, &oset);
+
 	  /* We should leave SIGCHLD blocked.  */
-	  result = __nanosleep (&ts, &ts);
+	  while (1)
+	    {
+	      result = __nanosleep (&ts, &ts);
+
+	      if (result != 0 || seconds == 0)
+		break;
+
+	      if (sizeof (ts.tv_sec) <= sizeof (seconds))
+		{
+		  ts.tv_sec = MIN (seconds, max);
+		  seconds -= (unsigned int) ts.tv_nsec;
+		}
+	    }
+
+	  //__libc_cleanup_pop (0);
 
 	  saved_errno = errno;
 	  /* Restore the original signal mask.  */
 	  (void) __sigprocmask (SIG_SETMASK, &oset, (sigset_t *) NULL);
 	  __set_errno (saved_errno);
+
+	  goto out;
 	}
-      else
-	{
-	  /* We should unblock SIGCHLD.  Restore the original signal mask.  */
-	  (void) __sigprocmask (SIG_SETMASK, &oset, (sigset_t *) NULL);
-	  result = __nanosleep (&ts, &ts);
-	}
+
+      /* We should unblock SIGCHLD.  Restore the original signal mask.  */
+      (void) __sigprocmask (SIG_SETMASK, &oset, (sigset_t *) NULL);
     }
-  else
-    result = __nanosleep (&ts, &ts);
 
+  result = __nanosleep (&ts, &ts);
+  if (result == 0 && seconds != 0)
+    goto again;
+
+ out:
   if (result != 0)
     /* Round remaining time.  */
-    result = (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
+    result = seconds + (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
 
   return result;
 }
diff -Nur sysdeps/unix/sysv/linux/sparc/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/a.out.h
--- sysdeps/unix/sysv/linux/sparc/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/a.out.h	2003-07-25 11:04:58.000000000 +0200
@@ -0,0 +1,174 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#include <bits/a.out.h>
+
+#define __GNU_EXEC_MACROS__
+
+struct exec
+{
+  unsigned char a_dynamic:1;	/* A __DYNAMIC is in this image.  */
+  unsigned char a_toolversion:7;
+  unsigned char a_machtype;
+  unsigned short a_info;
+  unsigned int a_text;		/* Length of text, in bytes.  */
+  unsigned int a_data;		/* Length of data, in bytes.  */
+  unsigned int a_bss;		/* Length of bss, in bytes.  */
+  unsigned int a_syms;		/* Length of symbol table, in bytes.  */
+  unsigned int a_entry;		/* Where program begins.  */
+  unsigned int a_trsize;
+  unsigned int a_drsize;
+};
+
+enum machine_type
+{
+  M_OLDSUN2 = 0,
+  M_68010 = 1,
+  M_68020 = 2,
+  M_SPARC = 3,
+  M_386 = 100,
+  M_MIPS1 = 151,
+  M_MIPS2 = 152
+};
+
+#define N_MAGIC(exec)	((exec).a_info & 0xffff)
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec)	(((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+  ((exec).a_info = ((magic) & 0xffff)					\
+   | (((int)(type) & 0xff) << 16)					\
+   | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+  ((exec).a_info = ((exec).a_info & 0xffff0000) | ((magic) & 0xffff))
+#define N_SET_MACHTYPE(exec, machtype) \
+  ((exec).a_info =							\
+   ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+#define N_SET_FLAGS(exec, flags) \
+  ((exec).a_info =							\
+   ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+/* This indicates a demand-paged executable with the header in the text. 
+   The first page is unmapped to help trap NULL pointer references.  */
+#define QMAGIC 0314
+/* Code indicating core file.  */
+#define CMAGIC 0421
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+#define N_BADMAG(x) \
+  (N_MAGIC(x) != OMAGIC	&& N_MAGIC(x) != NMAGIC				\
+   && N_MAGIC(x) != ZMAGIC && N_MAGIC(x) != QMAGIC)
+#define _N_HDROFF(x)	(1024 - sizeof (struct exec))
+#define N_TXTOFF(x) \
+  (N_MAGIC(x) == ZMAGIC ? 0 : sizeof (struct exec))
+#define N_DATOFF(x)	(N_TXTOFF(x) + (x).a_text)
+#define N_TRELOFF(x)	(N_DATOFF(x) + (x).a_data)
+#define N_DRELOFF(x)	(N_TRELOFF(x) + N_TRSIZE(x))
+#define N_SYMOFF(x) \
+  (N_TXTOFF(x) + (x).a_text + (x).a_data + (x).a_trsize + (x).a_drsize)
+#define N_STROFF(x)	(N_SYMOFF(x) + N_SYMSIZE(x))
+
+#define SPARC_PGSIZE	0x2000
+
+/* Address of text segment in memory after it is loaded.  */
+#define N_TXTADDR(x) \
+ (unsigned long)(((N_MAGIC(x) == ZMAGIC) && ((x).a_entry < SPARC_PGSIZE)) \
+		 ? 0 : SPARC_PGSIZE)
+
+/* Address of data segment in memory after it is loaded.  */
+#define SEGMENT_SIZE	SPARC_PGSIZE
+
+#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#define N_DATADDR(x) \
+  (N_MAGIC(x)==OMAGIC							\
+   ? (N_TXTADDR(x) + (x).a_text)					\
+   : (unsigned long)(_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
+#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist
+{
+  union
+    {
+      char *n_name;
+      struct nlist *n_next;
+      long n_strx;
+    } n_un;
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#define N_UNDF	0
+#define N_ABS	2
+#define N_TEXT	4
+#define N_DATA	6
+#define N_BSS	8
+#define N_FN	15
+#define N_EXT	1
+#define N_TYPE	036
+#define N_STAB	0340
+#define N_INDR	0xa
+#define	N_SETA	0x14	/* Absolute set element symbol.  */
+#define	N_SETT	0x16	/* Text set element symbol.  */
+#define	N_SETD	0x18	/* Data set element symbol.  */
+#define	N_SETB	0x1A	/* Bss set element symbol.  */
+#define N_SETV	0x1C	/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+enum reloc_type
+{
+  RELOC_8,
+  RELOC_16,
+  RELOC_32,
+  RELOC_DISP8,
+  RELOC_DISP16,
+  RELOC_DISP32,
+  RELOC_WDISP30,
+  RELOC_WDISP22,
+  RELOC_HI22,
+  RELOC_22,
+  RELOC_13,
+  RELOC_LO10,
+  RELOC_SFA_BASE,
+  RELOC_SFA_OFF13,
+  RELOC_BASE10,
+  RELOC_BASE13,
+  RELOC_BASE22,
+  RELOC_PC10,
+  RELOC_PC22,
+  RELOC_JMP_TBL,
+  RELOC_SEGOFF16,
+  RELOC_GLOB_DAT,
+  RELOC_JMP_SLOT,
+  RELOC_RELATIVE
+};
+
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  unsigned int r_address;
+  unsigned int r_index:24;
+  unsigned int r_extern:1;
+  int r_pad:2;
+  enum reloc_type r_type:5;
+  int r_addend;
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#endif /* __A_OUT_GNU_H__ */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/a.out.h
--- sysdeps/unix/sysv/linux/sparc/bits/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/a.out.h	2003-07-25 11:04:58.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+
+/* Signal to users of this header that this architecture really doesn't
+   support a.out binary format.  */
+#define __NO_A_OUT_SUPPORT 1
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/environments.h
--- sysdeps/unix/sysv/linux/sparc/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/environments.h	2004-11-26 09:11:05.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* Environments with 32-bit wide pointers are optionally provided.
+   Therefore following macros aren't defined:
+   # undef _POSIX_V6_ILP32_OFF32
+   # undef _POSIX_V6_ILP32_OFFBIG
+   # undef _XBS5_ILP32_OFF32
+   # undef _XBS5_ILP32_OFFBIG
+   and users need to check at runtime.  */
+
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* Environments with 64-bit wide pointers can be provided,
+   so these macros aren't defined:
+   # undef _POSIX_V6_LP64_OFF64
+   # undef _POSIX_V6_LPBIG_OFFBIG
+   # undef _XBS5_LP64_OFF64
+   # undef _XBS5_LPBIG_OFFBIG
+   and sysconf tests for it at runtime.  */
+
+#endif /* __WORDSIZE == 32 */
+
+#define __ILP32_OFF32_CFLAGS	"-m32"
+#define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+#define __ILP32_OFF32_LDFLAGS	"-m32"
+#define __ILP32_OFFBIG_LDFLAGS	"-m32"
+#define __LP64_OFF64_CFLAGS	"-m64"
+#define __LP64_OFF64_LDFLAGS	"-m64"
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/fcntl.h
--- sysdeps/unix/sysv/linux/sparc/bits/fcntl.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/fcntl.h	2004-08-23 09:28:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* O_*, F_*, FD_* bit values for Linux/SPARC.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -43,6 +44,8 @@
 #ifdef __USE_GNU
 # define O_DIRECTORY	0x10000 /* must be a directory */
 # define O_NOFOLLOW	0x20000 /* don't follow links */
+# define O_DIRECT	0x100000 /* direct disk access hint */
+# define O_NOATIME	0x200000 /* Do not set atime.  */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -75,7 +78,7 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-#if defined __USE_BSD || defined __USE_XOPEN2K
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_GETOWN	5	/* Get owner of socket (receiver of SIGIO).  */
 # define F_SETOWN	6	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -195,3 +198,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/mman.h
--- sysdeps/unix/sysv/linux/sparc/bits/mman.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/mman.h	2003-09-25 18:39:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/SPARC version.
-   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/resource.h
--- sysdeps/unix/sysv/linux/sparc/bits/resource.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/resource.h	2004-08-16 10:51:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* Bit values & structures for resource limits.  Linux/SPARC version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -55,34 +56,43 @@
      This affects swapping; processes that are exceeding their
      resident set size will be more likely to have physical memory
      taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
 
   /* Number of open files.  */
   RLIMIT_NOFILE = 6,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
 #define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
 
   /* Address space limit (?) */
   RLIMIT_AS = 9,
 #define RLIMIT_AS RLIMIT_AS
 
   /* Number of processes.  */
-  RLIMIT_NPROC = 7,
-#define RLIMIT_NPROC RLIMIT_NPROC
+  __RLIMIT_NPROC = 7,
+#define RLIMIT_NPROC __RLIMIT_NPROC
 
   /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+  __RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
 
   /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
 
-  RLIM_NLIMITS = 11
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  __RLIMIT_NLIMITS = 13,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
 };
 
 /* Value to indicate that there is no limit.  */
@@ -153,12 +163,8 @@
 #define RUSAGE_SELF RUSAGE_SELF
 
   /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
+  RUSAGE_CHILDREN = -1
 #define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
 };
 
 #define __need_timeval
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/setjmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/setjmp.h
--- sysdeps/unix/sysv/linux/sparc/bits/setjmp.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/setjmp.h	2003-08-31 19:21:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997,1999,2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1999,2000,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,8 +16,10 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
 
-#ifndef _SETJMP_H
+#if !defined _SETJMP_H && !defined _PTHREAD_H
 # error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
 #endif
 
@@ -78,3 +80,5 @@
   ((int) (address) < (jmpbuf)[JB_SP])
 
 #endif
+
+#endif  /* bits/setjmp.h */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/shm.h
--- sysdeps/unix/sysv/linux/sparc/bits/shm.h	2002-08-24 00:20:17.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/shm.h	2004-08-12 19:27:20.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,6 +37,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -77,6 +80,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST	01000	/* segment will be destroyed on last detach */
 # define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
 
 struct	shminfo
   {
@@ -102,3 +106,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/siginfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/siginfo.h
--- sysdeps/unix/sysv/linux/sparc/bits/siginfo.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/siginfo.h	2003-04-21 09:27:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* siginfo_t, sigevent and constants.  Linux/SPARC version.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -69,8 +69,9 @@
 	/* POSIX.1b timers.  */
 	struct
 	  {
-	    unsigned int _timer1;
-	    unsigned int _timer2;
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
 	  } _timer;
 
 	/* POSIX.1b signals.  */
@@ -111,8 +112,8 @@
 /* X/Open requires some more fields with fixed names.  */
 # define si_pid		_sifields._kill.si_pid
 # define si_uid		_sifields._kill.si_uid
-# define si_timer1	_sifields._timer._timer1
-# define si_timer2	_sifields._timer._timer2
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
 # define si_status	_sifields._sigchld.si_status
 # define si_utime	_sifields._sigchld.si_utime
 # define si_stime	_sifields._sigchld.si_stime
@@ -129,8 +130,10 @@
    signals.  */
 enum
 {
-  SI_ASYNCNL = -6,		/* Sent by asynch name lookup completion.  */
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
 # define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
   SI_SIGIO,			/* Sent by queued SIGIO. */
 # define SI_SIGIO	SI_SIGIO
   SI_ASYNCIO,			/* Sent by AIO completion.  */
@@ -276,9 +279,6 @@
 #  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
 # endif
 
-/* Forward declaration of the `pthread_attr_t' type.  */
-struct __pthread_attr_s;
-
 typedef struct sigevent
   {
     sigval_t sigev_value;
@@ -291,8 +291,8 @@
 
 	struct
 	  {
-	    void (*_function) (sigval_t);	  /* Function to start.  */
-	    struct __pthread_attr_s *_attribute;  /* Really pthread_attr_t.  */
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
 	  } _sigev_thread;
       } _sigev_un;
   } sigevent_t;
@@ -308,8 +308,11 @@
 # define SIGEV_SIGNAL	SIGEV_SIGNAL
   SIGEV_NONE,			/* Other notification: meaningless.  */
 # define SIGEV_NONE	SIGEV_NONE
-  SIGEV_THREAD			/* Deliver via thread creation.  */
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
 # define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
 };
 
 #endif	/* have _SIGNAL_H.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/signum.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/signum.h
--- sysdeps/unix/sysv/linux/sparc/bits/signum.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/signum.h	2003-04-01 08:17:51.000000000 +0200
@@ -1,5 +1,5 @@
 /* Signal number definitions.  Linux/SPARC version.
-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -70,7 +70,7 @@
 #define SIGUSR1		30
 #define SIGUSR2		31
 
-#define	_NSIG		64	/* Biggest signal number + 1
+#define	_NSIG		65	/* Biggest signal number + 1
 				   (including real-time signals).  */
 
 #define SIGRTMIN        (__libc_current_sigrtmin ())
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/socket.h
--- sysdeps/unix/sysv/linux/sparc/bits/socket.h	2001-09-26 07:21:12.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,321 +0,0 @@
-/* System-specific socket constants and types.  Linux/SPARC version.
-   Copyright (C) 1991,1992,1994-1999,2000,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef __BITS_SOCKET_H
-#define __BITS_SOCKET_H
-
-#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
-# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
-#endif
-
-#define	__need_size_t
-#define __need_NULL
-#include <stddef.h>
-
-#include <limits.h>
-#include <sys/types.h>
-
-/* Type for length arguments in socket calls.  */
-#ifndef __socklen_t_defined
-typedef __socklen_t socklen_t;
-# define __socklen_t_defined
-#endif
-
-/* Types of sockets.  */
-enum __socket_type
-{
-  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
-				   byte streams.  */
-#define SOCK_STREAM SOCK_STREAM
-  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
-				   of fixed maximum length.  */
-#define SOCK_DGRAM SOCK_DGRAM
-  SOCK_RAW = 3,			/* Raw protocol interface.  */
-#define SOCK_RAW SOCK_RAW
-  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
-#define SOCK_RDM SOCK_RDM
-  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
-				   datagrams of fixed maximum length.  */
-#define SOCK_SEQPACKET SOCK_SEQPACKET
-  SOCK_PACKET = 10		/* Linux specific way of getting packets
-				   at the dev level.  For writing rarp and
-				   other similar things on the user level. */
-#define SOCK_PACKET SOCK_PACKET
-};
-
-/* Protocol families.  */
-#define	PF_UNSPEC	0	/* Unspecified.  */
-#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
-#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
-#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
-#define	PF_INET		2	/* IP protocol family.  */
-#define	PF_AX25		3	/* Amateur Radio AX.25.  */
-#define	PF_IPX		4	/* Novell Internet Protocol.  */
-#define	PF_APPLETALK	5	/* Appletalk DDP.  */
-#define	PF_NETROM	6	/* Amateur radio NetROM.  */
-#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
-#define	PF_ATMPVC	8	/* ATM PVCs.  */
-#define	PF_X25		9	/* Reserved for X.25 project.  */
-#define	PF_INET6	10	/* IP version 6.  */
-#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
-#define	PF_DECnet	12	/* Reserved for DECnet project.  */
-#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
-#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
-#define	PF_KEY		15	/* PF_KEY key management API.  */
-#define	PF_NETLINK	16
-#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
-#define	PF_PACKET	17	/* Packet family.  */
-#define	PF_ASH		18	/* Ash.  */
-#define	PF_ECONET	19	/* Acorn Econet.  */
-#define	PF_ATMSVC	20	/* ATM SVCs.  */
-#define	PF_SNA		22	/* Linux SNA Project */
-#define	PF_IRDA		23	/* IRDA sockets.  */
-#define	PF_PPPOX	24	/* PPPoX sockets.  */
-#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
-#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
-#define	PF_MAX		32	/* For now..  */
-
-/* Address families.  */
-#define	AF_UNSPEC	PF_UNSPEC
-#define	AF_LOCAL	PF_LOCAL
-#define	AF_UNIX		PF_UNIX
-#define	AF_FILE		PF_FILE
-#define	AF_INET		PF_INET
-#define	AF_AX25		PF_AX25
-#define	AF_IPX		PF_IPX
-#define	AF_APPLETALK	PF_APPLETALK
-#define	AF_NETROM	PF_NETROM
-#define	AF_BRIDGE	PF_BRIDGE
-#define	AF_ATMPVC	PF_ATMPVC
-#define	AF_X25		PF_X25
-#define	AF_INET6	PF_INET6
-#define	AF_ROSE		PF_ROSE
-#define	AF_DECnet	PF_DECnet
-#define	AF_NETBEUI	PF_NETBEUI
-#define	AF_SECURITY	PF_SECURITY
-#define	AF_KEY		PF_KEY
-#define	AF_NETLINK	PF_NETLINK
-#define	AF_ROUTE	PF_ROUTE
-#define	AF_PACKET	PF_PACKET
-#define	AF_ASH		PF_ASH
-#define	AF_ECONET	PF_ECONET
-#define	AF_ATMSVC	PF_ATMSVC
-#define	AF_SNA		PF_SNA
-#define	AF_IRDA		PF_IRDA
-#define	AF_PPPOX	PF_PPPOX
-#define	AF_WANPIPE	PF_WANPIPE
-#define	AF_BLUETOOTH	PF_BLUETOOTH
-#define	AF_MAX		PF_MAX
-
-/* Socket level values.  Others are defined in the appropriate headers.
-
-   XXX These definitions also should go into the appropriate headers as
-   far as they are available.  */
-#define SOL_RAW		255
-#define SOL_DECNET      261
-#define SOL_X25         262
-#define SOL_PACKET	263
-#define SOL_ATM		264	/* ATM layer (cell level).  */
-#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
-#define SOL_IRDA	266
-
-/* Maximum queue length specifiable by listen.  */
-#define SOMAXCONN	128
-
-/* Get the definition of the macro to define the common sockaddr members.  */
-#include <bits/sockaddr.h>
-
-/* Structure describing a generic socket address.  */
-struct sockaddr
-  {
-    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
-    char sa_data[14];		/* Address data.  */
-  };
-
-
-/* Structure large enough to hold any socket address (with the historical
-   exception of AF_UNIX).  We reserve 128 bytes.  */
-#if ULONG_MAX > 0xffffffff
-# define __ss_aligntype	__uint64_t
-#else
-# define __ss_aligntype	__uint32_t
-#endif
-#define _SS_SIZE	128
-#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
-
-struct sockaddr_storage
-  {
-    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
-    __ss_aligntype __ss_align;	/* Force desired alignment.  */
-    char __ss_padding[_SS_PADSIZE];
-  };
-
-
-/* Bits in the FLAGS argument to `send', `recv', et al.  */
-enum
-  {
-    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
-#define MSG_OOB		MSG_OOB
-    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
-#define MSG_PEEK	MSG_PEEK
-    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
-#define MSG_DONTROUTE	MSG_DONTROUTE
-#ifdef __USE_GNU
-    /* DECnet uses a different name.  */
-    MSG_TRYHARD		= MSG_DONTROUTE,
-# define MSG_TRYHARD	MSG_DONTROUTE
-#endif
-    MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
-#define MSG_CTRUNC	MSG_CTRUNC
-    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
-#define MSG_PROXY	MSG_PROXY
-    MSG_TRUNC		= 0x20,
-#define	MSG_TRUNC	MSG_TRUNC
-    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
-#define	MSG_DONTWAIT	MSG_DONTWAIT
-    MSG_EOR		= 0x80, /* End of record.  */
-#define	MSG_EOR		MSG_EOR
-    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
-#define	MSG_WAITALL	MSG_WAITALL
-    MSG_FIN		= 0x200,
-#define	MSG_FIN		MSG_FIN
-    MSG_SYN		= 0x400,
-#define	MSG_SYN		MSG_SYN
-    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
-#define	MSG_CONFIRM	MSG_CONFIRM
-    MSG_RST		= 0x1000,
-#define	MSG_RST		MSG_RST
-    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
-#define	MSG_ERRQUEUE	MSG_ERRQUEUE
-    MSG_NOSIGNAL	= 0x4000, /* Do not generate SIGPIPE.  */
-#define	MSG_NOSIGNAL	MSG_NOSIGNAL
-    MSG_MORE		= 0x8000  /* Sender will send more.  */
-#define	MSG_MORE	MSG_MORE
-  };
-
-
-/* Structure describing messages sent by
-   `sendmsg' and received by `recvmsg'.  */
-struct msghdr
-  {
-    void *msg_name;		/* Address to send to/receive from.  */
-    socklen_t msg_namelen;	/* Length of address data.  */
-
-    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
-#if __WORDSIZE == 32
-    int msg_iovlen;		/* Number of elements in the vector.  */
-
-    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
-#else
-    size_t msg_iovlen;		/* Number of elements in the vector.  */
-
-    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    size_t msg_controllen;	/* Ancillary data buffer length.  */
-#endif
-    int msg_flags;		/* Flags on received message.  */
-  };
-
-/* Structure used for storage of ancillary data object information.  */
-struct cmsghdr
-  {
-    size_t cmsg_len;		/* Length of data in cmsg_data plus length
-				   of cmsghdr structure.  */
-    int cmsg_level;		/* Originating protocol.  */
-    int cmsg_type;		/* Protocol specific type.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
-#endif
-  };
-
-/* Ancillary data object manipulation macros.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
-#else
-# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
-#endif
-#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
-#define CMSG_FIRSTHDR(mhdr) \
-  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
-   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
-#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
-			 & (size_t) ~(sizeof (size_t) - 1))
-#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
-			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
-#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
-
-extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
-				      struct cmsghdr *__cmsg) __THROW;
-#ifdef __USE_EXTERN_INLINES
-# ifndef _EXTERN_INLINE
-#  define _EXTERN_INLINE extern __inline
-# endif
-_EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
-{
-  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
-    return 0;
-
-  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
-			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) >= ((unsigned char *) __mhdr->msg_control
-					 + __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return 0;
-  return __cmsg;
-}
-#endif	/* Use `extern inline'.  */
-
-/* Socket level message types.  This must match the definitions in
-   <linux/socket.h>.  */
-enum
-  {
-    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
-#define SCM_RIGHTS SCM_RIGHTS
-#ifdef __USE_BSD
-    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
-# define SCM_CREDENTIALS SCM_CREDENTIALS
-#endif
-    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
-  };
-
-/* User visible structure for SCM_CREDENTIALS message */
-
-struct ucred
-{
-  pid_t pid;			/* PID of sending process.  */
-  uid_t uid;			/* UID of sending process.  */
-  gid_t gid;			/* GID of sending process.  */
-};
-
-/* Get socket manipulation related informations from kernel headers.  */
-#include <asm/socket.h>
-
-
-/* Structure used to manipulate the SO_LINGER option.  */
-struct linger
-  {
-    int l_onoff;		/* Nonzero to linger on close.  */
-    int l_linger;		/* Time to linger.  */
-  };
-
-#endif	/* bits/socket.h */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/statfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/statfs.h
--- sysdeps/unix/sysv/linux/sparc/bits/statfs.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/statfs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_STATFS_H
-# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
-#endif
-
-#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t*/
-
-struct statfs
-  {
-    long int f_type;
-    long int f_bsize;
-#ifndef __USE_FILE_OFFSET64
-    __fsblkcnt_t f_blocks;
-    __fsblkcnt_t f_bfree;
-    __fsblkcnt_t f_bavail;
-    __fsfilcnt_t f_files;
-    __fsfilcnt_t f_ffree;
-#else
-    __fsblkcnt64_t f_blocks;
-    __fsblkcnt64_t f_bfree;
-    __fsblkcnt64_t f_bavail;
-    __fsfilcnt64_t f_files;
-    __fsfilcnt64_t f_ffree;
-#endif
-    __fsid_t f_fsid;
-    long int f_namelen;
-    long int f_spare[6];
-  };
-
-#ifdef __USE_LARGEFILE64
-struct statfs64
-  {
-    long int f_type;
-    long int f_bsize;
-    __fsblkcnt64_t f_blocks;
-    __fsblkcnt64_t f_bfree;
-    __fsblkcnt64_t f_bavail;
-    __fsfilcnt64_t f_files;
-    __fsfilcnt64_t f_ffree;
-    __fsid_t f_fsid;
-    long int f_namelen;
-    long int f_spare[6];
-  };
-#endif
-
-/* Tell code we have these members.  */
-#define _STATFS_F_NAMELEN
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/stat.h
--- sysdeps/unix/sysv/linux/sparc/bits/stat.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1992,95,96,97,98,99,2000,2001,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -60,12 +60,36 @@
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 #endif
+#if __WORDSIZE == 64
     __time_t st_atime;			/* Time of last access.  */
     unsigned long int __unused1;
     __time_t st_mtime;			/* Time of last modification.  */
     unsigned long int __unused2;
     __time_t st_ctime;			/* Time of last status change.  */
     unsigned long int __unused3;
+#else
+# ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#  define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+#  define st_mtime st_mtim.tv_sec
+#  define st_ctime st_ctim.tv_sec
+# else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+# endif
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
   };
@@ -88,12 +112,36 @@
     __blksize_t st_blksize;		/* Optimal block size for I/O.  */
 
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#if __WORDSIZE == 64
     __time_t st_atime;			/* Time of last access.  */
     unsigned long int __unused1;
     __time_t st_mtime;			/* Time of last modification.  */
     unsigned long int __unused2;
     __time_t st_ctime;			/* Time of last status change.  */
     unsigned long int __unused3;
+#else
+# ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#  define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+#  define st_mtime st_mtim.tv_sec
+#  define st_ctime st_ctim.tv_sec
+# else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+# endif
+#endif
     unsigned long int __unused4;
     unsigned long int __unused5;
   };
@@ -102,6 +150,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/statvfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/statvfs.h
--- sysdeps/unix/sysv/linux/sparc/bits/statvfs.h	2002-07-10 09:24:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/statvfs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-/* Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_STATVFS_H
-# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
-#endif
-
-#include <bits/types.h>  /* For __fsblkcnt_t and __fsfilcnt_t.  */
-
-#if __WORDSIZE == 32
-#define _STATVFSBUF_F_UNUSED
-#endif
-
-struct statvfs
-  {
-    unsigned long int f_bsize;
-    unsigned long int f_frsize;
-#ifndef __USE_FILE_OFFSET64
-    __fsblkcnt_t f_blocks;
-    __fsblkcnt_t f_bfree;
-    __fsblkcnt_t f_bavail;
-    __fsfilcnt_t f_files;
-    __fsfilcnt_t f_ffree;
-    __fsfilcnt_t f_favail;
-#else
-    __fsblkcnt64_t f_blocks;
-    __fsblkcnt64_t f_bfree;
-    __fsblkcnt64_t f_bavail;
-    __fsfilcnt64_t f_files;
-    __fsfilcnt64_t f_ffree;
-    __fsfilcnt64_t f_favail;
-#endif
-    unsigned long int f_fsid;
-#ifdef _STATVFSBUF_F_UNUSED
-    int __f_unused;
-#endif
-    unsigned long int f_flag;
-    unsigned long int f_namemax;
-    int __f_spare[6];
-  };
-
-#ifdef __USE_LARGEFILE64
-struct statvfs64
-  {
-    unsigned long int f_bsize;
-    unsigned long int f_frsize;
-    __fsblkcnt64_t f_blocks;
-    __fsblkcnt64_t f_bfree;
-    __fsblkcnt64_t f_bavail;
-    __fsfilcnt64_t f_files;
-    __fsfilcnt64_t f_ffree;
-    __fsfilcnt64_t f_favail;
-    unsigned long int f_fsid;
-#ifdef _STATVFSBUF_F_UNUSED
-    int __f_unused;
-#endif
-    unsigned long int f_flag;
-    unsigned long int f_namemax;
-    int __f_spare[6];
-  };
-#endif
-
-/* Definitions for the flag in `f_flag'.  These definitions should be
-   kept in sync with the definitions in <sys/mount.h>.  */
-enum
-{
-  ST_RDONLY = 1,		/* Mount read-only.  */
-#define ST_RDONLY	ST_RDONLY
-  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
-#define ST_NOSUID	ST_NOSUID
-#ifdef __USE_GNU
-  ,
-  ST_NODEV = 4,			/* Disallow access to device special files.  */
-# define ST_NODEV	ST_NODEV
-  ST_NOEXEC = 8,		/* Disallow program execution.  */
-# define ST_NOEXEC	ST_NOEXEC
-  ST_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
-# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
-  ST_MANDLOCK = 64,		/* Allow mandatory locks on an FS.  */
-# define ST_MANDLOCK	ST_MANDLOCK
-  ST_WRITE = 128,		/* Write on file/directory/symlink.  */
-# define ST_WRITE	ST_WRITE
-  ST_APPEND = 256,		/* Append-only file.  */
-# define ST_APPEND	ST_APPEND
-  ST_IMMUTABLE = 512,		/* Immutable file.  */
-# define ST_IMMUTABLE	ST_IMMUTABLE
-  ST_NOATIME = 1024,		/* Do not update access times.  */
-# define ST_NOATIME	ST_NOATIME
-  ST_NODIRATIME			/* Do not update directory access times.  */
-# define ST_NODIRATIME	ST_NODIRATIME
-#endif	/* Use GNU.  */
-};
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/termios.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/termios.h
--- sysdeps/unix/sysv/linux/sparc/bits/termios.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/termios.h	2004-03-31 10:53:30.000000000 +0200
@@ -73,6 +73,7 @@
 #define IXANY	0x00000800
 #define IXOFF	0x00001000
 #define IMAXBEL	0x00002000
+#define IUTF8	0x00004000
 
 /* c_oflag bits */
 #define OPOST	0x00000001
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/time.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/time.h
--- sysdeps/unix/sysv/linux/sparc/bits/time.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/time.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* System-dependent timing definitions.  Linux/SPARC version.
-   Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <time.h> instead.
- */
-
-#ifndef __need_timeval
-# ifndef _BITS_TIME_H
-#  define _BITS_TIME_H	1
-
-/* ISO/IEC 9899:1990 7.12.1: <time.h>
-   The macro `CLOCKS_PER_SEC' is the number per second of the value
-   returned by the `clock' function. */
-/* CAE XSH, Issue 4, Version 2: <time.h>
-   The value of CLOCKS_PER_SEC is required to be 1 million on all
-   XSI-conformant systems. */
-#  define CLOCKS_PER_SEC  1000000l
-
-#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
-/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
-   presents the real value for clock ticks per second for the system.  */
-#   include <bits/types.h>
-extern long int __sysconf (int);
-#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
-#  endif
-
-#  ifdef __USE_POSIX199309
-/* Identifier for system-wide realtime clock.  */
-#   define CLOCK_REALTIME		0
-/* High-resolution timer from the CPU.  */
-#   define CLOCK_PROCESS_CPUTIME_ID	2
-/* Thread-specific CPU-time clock.  */
-#   define CLOCK_THREAD_CPUTIME_ID	3
-
-/* Flag to indicate time is absolute.  */
-#   define TIMER_ABSTIME		1
-#  endif
-
-# endif	/* bits/time.h */
-#endif
-
-#ifdef __need_timeval
-# undef __need_timeval
-# ifndef _STRUCT_TIMEVAL
-#  define _STRUCT_TIMEVAL	1
-#  include <bits/types.h>
-
-/* A time value that is accurate to the nearest
-   microsecond but also has a range of years.  */
-struct timeval
-  {
-    __time_t tv_sec;		/* Seconds.  */
-    __suseconds_t tv_usec;	/* Microseconds.  */
-  };
-# endif	/* struct timeval */
-#endif	/* need timeval */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/types.h
--- sysdeps/unix/sysv/linux/sparc/bits/types.h	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-/* Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <sys/types.h> instead.
- */
-
-#ifndef	_BITS_TYPES_H
-#define	_BITS_TYPES_H	1
-
-#include <features.h>
-
-#define __need_size_t
-#include <stddef.h>
-#include <bits/wordsize.h>
-
-/* Convenience types.  */
-typedef unsigned char __u_char;
-typedef unsigned short int __u_short;
-typedef unsigned int __u_int;
-typedef unsigned long int __u_long;
-#if __WORDSIZE == 64
-typedef unsigned long int __u_quad_t;
-typedef long int __quad_t;
-#else
-# ifdef __GNUC__
-__extension__ typedef unsigned long long int __u_quad_t;
-__extension__ typedef long long int __quad_t;
-# else
-typedef struct
-  {
-    long int __val[2];
-  } __quad_t;
-typedef struct
-  {
-    __u_long __val[2];
-  } __u_quad_t;
-# endif
-#endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#if __WORDSIZE == 64
-typedef signed long int __int64_t;
-typedef unsigned long int __uint64_t;
-#else
-# ifdef __GNUC__
-__extension__ typedef signed long long int __int64_t;
-__extension__ typedef unsigned long long int __uint64_t;
-# endif
-#endif
-typedef __quad_t *__qaddr_t;
-
-typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
-typedef __u_int __uid_t;		/* Type of user identifications.  */
-typedef __u_int __gid_t;		/* Type of group identifications.  */
-typedef __u_long __ino_t;		/* Type of file serial numbers.  */
-typedef __u_quad_t __ino64_t;		/* Type of file serial numbers.  */
-typedef __u_int __mode_t;		/* Type of file attribute bitmasks.  */
-typedef __u_int __nlink_t; 		/* Type of file link counts.  */
-typedef long int __off_t;		/* Type of file sizes and offsets.  */
-typedef __quad_t  __off64_t;		/*  "" (LFS) */
-typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
-typedef int __pid_t;			/* Type of process identifications.  */
-#if __WORDSIZE == 64
-typedef long int __ssize_t;		/* Type of a byte count, or error.  */
-#else
-typedef int __ssize_t;			/* Type of a byte count, or error.  */
-#endif
-typedef __u_long __rlim_t;		/* Type of resource counts.  */
-typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
-typedef __u_int __id_t;			/* General type for IDs.  */
-
-typedef struct
-  {
-    int __val[2];
-  } __fsid_t;				/* Type of file system IDs.  */
-
-/* Everythin' else.  */
-typedef int __daddr_t;			/* The type of a disk address.  */
-typedef char *__caddr_t;
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef int __suseconds_t;
-typedef long int __swblk_t;		/* Type of a swap block maybe?  */
-
-typedef long int __clock_t;
-
-/* Clock ID used in clock and timer functions.  */
-typedef int __clockid_t;
-
-/* Timer ID returned by `timer_create'.  */
-typedef int __timer_t;
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define __FD_SETSIZE	1024
-
-
-typedef int __key_t;
-
-/* Used in `struct shmid_ds'.  */
-#if __WORDSIZE == 64
-typedef int		   __ipc_pid_t;
-#else
-typedef unsigned short int __ipc_pid_t;
-#endif
-
-
-/* Type to represent block size.  */
-typedef long int __blksize_t;
-
-/* Types from the Large File Support interface.  */
-
-/* Type to count number os disk blocks.  */
-typedef long int __blkcnt_t;
-typedef __quad_t __blkcnt64_t;
-
-/* Type to count file system blocks.  */
-typedef __u_long     __fsblkcnt_t;
-typedef __u_quad_t __fsblkcnt64_t;
-
-/* Type to count file system inodes.  */
-typedef unsigned long int __fsfilcnt_t;
-typedef __u_quad_t __fsfilcnt64_t;
-
-/* Used in XTI.  */
-typedef long int __t_scalar_t;
-typedef unsigned long int __t_uscalar_t;
-
-/* Duplicates info from stdint.h but this is used in unistd.h.  */
-#if __WORDSIZE == 64
-typedef long int __intptr_t;
-#else
-typedef int      __intptr_t;
-#endif
-
-/* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
-
-
-/* Now add the thread types.  */
-#if defined __USE_POSIX199506 || defined __USE_UNIX98
-# include <bits/pthreadtypes.h>
-#endif
-
-#endif /* bits/types.h */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/typesizes.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
--- sysdeps/unix/sysv/linux/sparc/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h	2003-07-31 21:34:16.000000000 +0200
@@ -0,0 +1,66 @@
+/* bits/typesizes.h -- underlying types for *_t.  Linux/SPARC version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__U32_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__S32_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/utmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/utmp.h
--- sysdeps/unix/sysv/linux/sparc/bits/utmp.h	2002-10-02 23:15:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/utmp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
-   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002 
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMP_H
-# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
-#endif
-
-#include <paths.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <bits/wordsize.h>
-
-
-#define UT_LINESIZE	32
-#define UT_NAMESIZE	32
-#define UT_HOSTSIZE	256
-
-
-/* The structure describing an entry in the database of
-   previous logins.  */
-struct lastlog
-  {
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-    int32_t ll_time;
-#else
-    __time_t ll_time;
-#endif
-    char ll_line[UT_LINESIZE];
-    char ll_host[UT_HOSTSIZE];
-  };
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmp' below.  */
-struct exit_status
-  {
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmp
-{
-  short int ut_type;		/* Type of login.  */
-  pid_t ut_pid;			/* Process ID of login process.  */
-  char ut_line[UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
-  char ut_user[UT_NAMESIZE];	/* Username.  */
-  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled 
-   32- and 64-bit.  This allows files and shared memory to be shared 
-   between 32/64bit applications.  For example /var/run/utmp.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    int32_t tv_sec;		/* Seconds.  */
-    int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-
-  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-/* Backwards compatibility hacks.  */
-#define ut_name		ut_user
-#ifndef _NO_UT_TIME
-/* We have a problem here: `ut_time' is also used otherwise.  Define
-   _NO_UT_TIME if the compiler complains.  */
-# define ut_time	ut_tv.tv_sec
-#endif
-#define ut_xtime	ut_tv.tv_sec
-#define ut_addr		ut_addr_v6[0]
-
-
-/* Values for the `ut_type' field of a `struct utmp'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#define RUN_LVL		1	/* The system's runlevel.  */
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#define ACCOUNTING	9
-
-/* Old Linux name for the EMPTY type.  */
-#define UT_UNKNOWN	EMPTY
-
-
-/* Tell the user that we have a modern system with UT_HOST, UT_PID,
-   UT_TYPE, UT_ID and UT_TV fields.  */
-#define _HAVE_UT_TYPE	1
-#define _HAVE_UT_PID	1
-#define _HAVE_UT_ID	1
-#define _HAVE_UT_TV	1
-#define _HAVE_UT_HOST	1
diff -Nur sysdeps/unix/sysv/linux/sparc/bits/utmpx.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/utmpx.h
--- sysdeps/unix/sysv/linux/sparc/bits/utmpx.h	2002-10-02 22:39:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/bits/utmpx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,102 +0,0 @@
-/* Structures and definitions for the user accounting database.  GNU version.
-   Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMPX_H
-# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
-#endif
-
-#include <bits/types.h>
-#include <sys/time.h>
-
-
-#ifdef __USE_GNU
-# include <paths.h>
-# define _PATH_UTMPX	_PATH_UTMP
-# define _PATH_WTMPX	_PATH_WTMP
-#endif
-
-
-#define __UT_LINESIZE	32
-#define __UT_NAMESIZE	32
-#define __UT_HOSTSIZE	256
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmpx' below.  */
-struct __exit_status
-  {
-#ifdef __USE_GNU
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-#else
-    short int __e_termination;	/* Process termination status.  */
-    short int __e_exit;		/* Process exit status.  */
-#endif
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmpx
-{
-  short int ut_type;		/* Type of login.  */
-  __pid_t ut_pid;		/* Process ID of login process.  */
-  char ut_line[__UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID. */
-  char ut_user[__UT_NAMESIZE];	/* Username.  */
-  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct __exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled
-   32- and 64-bit.  This allows files and shared memory to be shared
-   between 32/64bit applications.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  __int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    __int32_t tv_sec;		/* Seconds.  */
-    __int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-
-/* Values for the `ut_type' field of a `struct utmpx'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#ifdef __USE_GNU
-# define RUN_LVL	1	/* The system's runlevel.  */
-#endif
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#ifdef __USE_GNU
-# define ACCOUNTING	9	/* System accounting.  */
-#endif
diff -Nur sysdeps/unix/sysv/linux/sparc/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/Dist
--- sysdeps/unix/sysv/linux/sparc/Dist	2002-10-03 02:55:28.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/Dist	2003-02-20 23:20:55.000000000 +0100
@@ -1,4 +1,3 @@
-bits/utmpx.h
 kernel_termios.h
 sys/trap.h
 ldd-rewrite.sed
diff -Nur sysdeps/unix/sysv/linux/sparc/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/dl-cache.h
--- sysdeps/unix/sysv/linux/sparc/dl-cache.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/dl-cache.h	2003-06-25 10:03:35.000000000 +0200
@@ -0,0 +1,39 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6 && ! memcmp (path + len - 6, "/lib64", 6))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include <sysdeps/generic/dl-cache.h>
diff -Nur sysdeps/unix/sysv/linux/sparc/fork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/fork.S
--- sysdeps/unix/sysv/linux/sparc/fork.S	2002-06-21 00:39:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/fork.S	2002-12-31 21:37:31.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1999, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
 
@@ -26,4 +26,5 @@
 PSEUDO_END (__libc_fork)
 
 weak_alias (__libc_fork, __fork)
+libc_hidden_def (__fork)
 weak_alias (__libc_fork, fork)
diff -Nur sysdeps/unix/sysv/linux/sparc/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/Makefile
--- sysdeps/unix/sysv/linux/sparc/Makefile	2002-03-29 00:41:52.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/Makefile	2002-10-16 05:02:48.000000000 +0200
@@ -1,44 +1 @@
-ifeq ($(subdir),misc)
-
-no_syscall_list_h = 1
-
-# Generate the list of SYS_* macros for the system calls (__NR_* macros).
-$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/sys/syscall.h
-	rm -f $(@:.h=.d)-t
-	{ \
-	 echo '/* Generated at libc build time from kernel syscall list.  */';\
-	 echo ''; \
-	 echo '#ifndef _SYSCALL_H'; \
-	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
-	 echo '#endif'; \
-	 echo ''; \
-	 SUNPRO_DEPENDENCIES='$(@:.h=.d)-t $@' \
-	 $(CC) -E -x c $(sysincludes) $< -U__sparc_v9__ -U__arch64__ -D_LIBC -dM | \
-	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
-	 LC_ALL=C sort > $(@:.d=.h).new32; \
-	 SUNPRO_DEPENDENCIES='$(@:.h=.d)-t $@' \
-	 $(CC) -E -x c $(sysincludes) $< -D__sparc_v9__ -D__arch64__ -D_LIBC -dM | \
-	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
-	 LC_ALL=C sort > $(@:.d=.h).new64; \
-	 if cmp -s $(@:.d=.h).new32 $(@:.d=.h).new64; then \
-	   cat $(@:.d=.h).new32; \
-	 else \
-	   echo '#include <bits/wordsize.h>'; \
-	   echo ''; \
-	   comm -12 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#if __WORDSIZE == 64'; \
-	   comm -13 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#else'; \
-	   comm -23 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#endif'; \
-	 fi; \
-	 rm -f $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	} > $(@:.d=.h).new
-	mv -f $(@:.d=.h).new $(@:.d=.h)
-	sed < $(@:.h=.d)-t > $(@:.h=.d)-t2 \
-	    -e 's,$(subst .,\.,$@),$(patsubst $(objpfx)%,$$(objpfx)%,\
-					      $(@:.d=.h) $(@:.h=.d)),'
-	rm -f $(@:.h=.d)-t
-	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
-
-endif
+64bit-predefine = __sparc_v9__ __arch64__
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/clone.S
--- sysdeps/unix/sysv/linux/sparc/sparc32/clone.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/clone.S	2004-12-16 17:46:54.000000000 +0100
@@ -1,4 +1,5 @@
-/* Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson (rth@tamu.edu).
 
@@ -22,8 +23,13 @@
 
 #include <asm/errno.h>
 #include <asm/unistd.h>
+#include <tcb-offsets.h>
 
-/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+#define CLONE_VM	0x00000100
+#define CLONE_THREAD	0x00010000
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     pid_t *ptid, void *tls, pid_t *ctid); */
 
 	.text
 	.align	4
@@ -39,6 +45,12 @@
 	 orcc	%i1,%g0,%o1
 	be	.Lerror
 	 mov	%i2,%o0
+	/* ptid */
+	mov	%i4,%o2
+	/* tls */
+	mov	%i5,%o3
+	/* ctid */
+	ld	[%fp+92],%o4
 
 	/* Do the system call */
 	set	__NR_clone,%g1
@@ -62,6 +74,19 @@
 	.type	__thread_start,@function
 
 __thread_start:
+#ifdef RESET_PID
+	sethi	%hi(CLONE_THREAD), %l0
+	andcc	%i2, %l0, %g0
+	bne	1f
+	 andcc	%i2, CLONE_VM, %g0
+	bne,a	2f
+	 mov	-1,%o0
+	set	__NR_getpid,%g1
+	ta	0x10
+2:	st	%o0,[%g7 + PID]
+	st	%o0,[%g7 + TID]
+1:
+#endif
 	call	%i0
 	 mov	%i3,%o0
 	call	_exit,0
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.c	2002-02-01 20:00:17.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.c	2003-07-23 00:07:19.000000000 +0200
@@ -1,5 +1,5 @@
 /* Data for Linux/sparc32 version of processor capability information.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
 
@@ -40,13 +40,14 @@
        needed.
   */
 
-#ifdef PROCINFO_DECL
-EXTERN
+#ifndef PROCINFO_CLASS
+#define PROCINFO_CLASS
 #endif
+
 #if !defined PROCINFO_DECL && defined SHARED
   ._dl_sparc32_cap_flags
 #else
-const char _dl_sparc32_cap_flags[6][7]
+PROCINFO_CLASS const char _dl_sparc32_cap_flags[6][7]
 #endif
 #ifndef PROCINFO_DECL
 = {
@@ -60,3 +61,4 @@
 #endif
 
 #undef PROCINFO_DECL
+#undef PROCINFO_CLASS
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.h
--- sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.h	2002-02-01 20:00:17.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/dl-procinfo.h	2004-03-07 09:38:42.000000000 +0100
@@ -1,5 +1,5 @@
 /* Linux/sparc32 version of processor capability information handling macros.
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999,2000,2001,2002,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jj@ultra.linux.cz>, 1999.
 
@@ -35,7 +35,7 @@
 
   for (i = 0; i < _DL_HWCAP_COUNT; ++i)
     if (word & (1 << i))
-      _dl_printf (" %s", GL(dl_sparc32_cap_flags)[i]);
+      _dl_printf (" %s", GLRO(dl_sparc32_cap_flags)[i]);
 
   _dl_printf ("\n");
 
@@ -46,17 +46,17 @@
 __attribute__ ((unused))
 _dl_hwcap_string (int idx)
 {
-  return GL(dl_sparc32_cap_flags)[idx];
+  return GLRO(dl_sparc32_cap_flags)[idx];
 };
 
 static inline int
-__attribute__ ((unused))
+__attribute__ ((unused, always_inline))
 _dl_string_hwcap (const char *str)
 {
   int i;
   for (i = 0; i < _DL_HWCAP_COUNT; i++)
     {
-      if (strcmp (str, GL(dl_sparc32_cap_flags) [i]) == 0)
+      if (strcmp (str, GLRO(dl_sparc32_cap_flags) [i]) == 0)
 	return i;
     }
   return -1;
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/getpagesize.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/getpagesize.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/getpagesize.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/getpagesize.c	2004-03-22 20:49:39.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,6 +19,7 @@
 #include <unistd.h>
 #include <sys/param.h>
 #include <ldsodefs.h>
+#include <sysdep.h>
 
 /* Return the system page size.  This value will either be 4k or 8k depending
    on whether or not we are running on Sparc v9 machine.  */
@@ -27,14 +28,19 @@
    via the AT_PAGESZ auxiliary argument.  If we are a static program, we
    use the getpagesize system call.  */
 
-extern size_t __syscall_getpagesize(void);
-
 int
 __getpagesize ()
 {
-  if (GL(dl_pagesize) == 0)
-    GL(dl_pagesize) = __syscall_getpagesize();
-  return GL(dl_pagesize);
+  int ret = GLRO(dl_pagesize);
+  if (ret == 0)
+    {
+      INTERNAL_SYSCALL_DECL (err);
+      ret = INTERNAL_SYSCALL (getpagesize, err, 0);
+#ifndef SHARED
+      GLRO(dl_pagesize) = ret;
+#endif
+    }
+  return ret;
 }
 libc_hidden_def (__getpagesize)
 weak_alias (__getpagesize, getpagesize)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/kernel_stat.h
--- sysdeps/unix/sysv/linux/sparc/sparc32/kernel_stat.h	2000-08-11 19:27:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/kernel_stat.h	2002-12-31 14:24:35.000000000 +0100
@@ -9,34 +9,24 @@
     unsigned short int st_gid;
     unsigned short int st_rdev;
     long int st_size;
-    long int st_atime;
-    unsigned long int __unused1;
-    long int st_mtime;
-    unsigned long int __unused2;
-    long int st_ctime;
-    unsigned long int __unused3;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
     long int st_blksize;
     long int st_blocks;
     unsigned long int __unused4;
     unsigned long int __unused5;
   };
 
-#define _HAVE___UNUSED1
-#define _HAVE___UNUSED2
-#define _HAVE___UNUSED3
 #define _HAVE___UNUSED4
 #define _HAVE___UNUSED5
 
-#define _HAVE_STAT___UNUSED1
-#define _HAVE_STAT___UNUSED2
-#define _HAVE_STAT___UNUSED3
 #define _HAVE_STAT___UNUSED4
 #define _HAVE_STAT___UNUSED5
 #define _HAVE_STAT___PAD1
 #define _HAVE_STAT___PAD2
-#define _HAVE_STAT64___UNUSED1
-#define _HAVE_STAT64___UNUSED2
-#define _HAVE_STAT64___UNUSED3
 #define _HAVE_STAT64___UNUSED4
 #define _HAVE_STAT64___UNUSED5
 #define _HAVE_STAT64___PAD2
+#define _HAVE_STAT_NSEC
+#define _HAVE_STAT64_NSEC
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile
--- sysdeps/unix/sysv/linux/sparc/sparc32/Makefile	2000-04-18 08:13:52.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile	2003-08-31 19:22:46.000000000 +0200
@@ -2,10 +2,6 @@
 ASFLAGS-.os += -fPIC
 LD += -melf32_sparc
 
-ifeq ($(subdir),misc)
-sysdep_routines += setfsgid setfsuid
-endif
-
 # When I get this to work, this is the right thing
 ifeq ($(subdir),elf)
 CFLAGS-rtld.c += -mv8
@@ -13,8 +9,3 @@
 sysdep-others += lddlibc4
 install-bin += lddlibc4
 endif   # elf
-
-ifeq ($(subdir),signal)
-sysdep_routines += rt_sigsuspend rt_sigprocmask rt_sigtimedwait	\
-		   rt_sigqueueinfo rt_sigaction rt_sigpending
-endif
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/mmap64.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/mmap64.c	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/mmap64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-#include <bp-checks.h>
-
-#include "kernel-features.h"
-
-#ifdef __NR_mmap2
-extern void *__unbounded __syscall_mmap2 (void *__unbounded, size_t,
-					  int, int, int, off_t);
-# ifndef __ASSUME_MMAP2_SYSCALL
-static int have_no_mmap2;
-# endif
-#endif
-
-__ptr_t
-__mmap64 (__ptr_t addr, size_t len, int prot, int flags, int fd, off64_t offset)
-{
-#ifdef __NR_mmap2
-  if (
-# ifndef __ASSUME_MMAP2_SYSCALL
-      ! have_no_mmap2 &&
-# endif
-      ! (offset & 4095))
-    {
-# ifndef __ASSUME_MMAP2_SYSCALL
-      int saved_errno = errno;
-# endif
-      /* This will be always 12, no matter what page size is.  */
-      __ptr_t result;
-      __ptrvalue (result) =
-	(void *__unbounded) INLINE_SYSCALL (mmap2, 6, addr, len, prot, flags,
-					    fd, (off_t) (offset >> 12));
-# if __BOUNDED_POINTERS__
-      __ptrlow (result) = __ptrvalue (result);
-      __ptrhigh (result) = __ptrvalue (result) + len;
-# endif
-# ifndef __ASSUME_MMAP2_SYSCALL
-      if (result != (__ptr_t) -1 || errno != ENOSYS)
-# endif
-	return result;
-
-# ifndef __ASSUME_MMAP2_SYSCALL
-      __set_errno (saved_errno);
-      have_no_mmap2 = 1;
-# endif
-    }
-#endif
-  if (offset != (off_t) offset || (offset + len) != (off_t) (offset + len))
-    {
-      __set_errno (EINVAL);
-      return MAP_FAILED;
-    }
-
-  return __mmap (addr, len, prot, flags, fd, (off_t) offset);
-}
-
-weak_alias (__mmap64, mmap64)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/pipe.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/pipe.S
--- sysdeps/unix/sysv/linux/sparc/sparc32/pipe.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/pipe.S	2002-12-28 10:17:54.000000000 +0100
@@ -18,19 +18,19 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
+
 	.globl __libc_pipe
 ENTRY (__libc_pipe)
         mov %o0, %o2            /* Save PIPEDES. */
 	mov SYS_ify(pipe),%g1
 	ta 0x10
-	bcc,a 2f
-	nop
-	SYSCALL_ERROR_HANDLER
-2:
+	bcs __syscall_error_handler
+	 nop
 	st %o0, [%o2]           /* PIPEDES[0] = %o0; */
         st %o1, [%o2 + 4]       /* PIPEDES[1] = %o1; */
 	retl
-	clr %o0
+	 clr %o0
+	SYSCALL_ERROR_HANDLER
 
 PSEUDO_END (__libc_pipe)
 weak_alias (__libc_pipe, __pipe)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/semctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/semctl.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/semctl.c	2002-04-26 22:33:51.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/semctl.c	2004-03-10 20:26:23.000000000 +0100
@@ -1,5 +1,6 @@
 /* Semctl for architectures where word sized unions are passed indirectly
-   Copyright (C) 1995, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
 
@@ -49,6 +50,7 @@
   struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
   unsigned short int *array;	/* array for GETALL & SETALL */
   struct seminfo *__buf;	/* buffer for IPC_INFO */
+  struct __old_semid_ds *__old_buf;
 };
 
 #include <bp-checks.h>
@@ -71,6 +73,7 @@
 
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
 int
+attribute_compat_text_section
 __old_semctl (int semid, int semnum, int cmd, ...)
 {
   union semun arg;
@@ -168,7 +171,7 @@
 #endif
 
     buf = arg.buf;
-    arg.buf = (struct semid_ds *)&old;
+    arg.__old_buf = &old;
     if (cmd == IPC_SET)
       {
 	old.sem_perm.uid = buf->sem_perm.uid;
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/setegid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setegid.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/setegid.c	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setegid.c	2004-09-20 01:47:50.000000000 +0200
@@ -1,52 +1 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#ifdef __NR_setresgid32
-
-extern int __setresgid (gid_t rgid, gid_t egid, gid_t sgid);
-
-int
-setegid (gid_t gid)
-{
-  int result;
-
-  if (gid == (gid_t) ~0)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  /* First try the syscall.  */
-  result = __setresgid (-1, gid, -1);
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use emulation.  This may not work
-       since `setregid' also sets the saved group ID when GID is not
-       equal to the real group ID, making it impossible to switch back. */
-    result = __setregid (-1, gid);
-
-  return result;
-}
-libc_hidden_def (setegid)
-#else
-# include <sysdeps/unix/bsd/setegid.c>
-#endif
+#include <sysdeps/unix/sysv/linux/i386/setegid.c>
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/seteuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/seteuid.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/seteuid.c	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/seteuid.c	2004-09-20 01:47:50.000000000 +0200
@@ -1,56 +1 @@
-/* Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include "kernel-features.h"
-
-#if defined __NR_setresuid32 || __ASSUME_SETRESUID_SYSCALL > 0
-
-extern int __setresuid (uid_t ruid, uid_t euid, uid_t suid);
-
-int
-seteuid (uid_t uid)
-{
-  int result;
-
-  if (uid == (uid_t) ~0)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  /* First try the syscall.  */
-  result = __setresuid (-1, uid, -1);
-# if __ASSUME_SETRESUID_SYSCALL == 0
-  if (result == -1 && errno == ENOSYS)
-    /* No system call available.  Use emulation.  This may not work
-       since `setreuid' also sets the saved user ID when UID is not
-       equal to the real user ID, making it impossible to switch back.  */
-    result = __setreuid (-1, uid);
-# endif
-
-  return result;
-}
-libc_hidden_def (seteuid)
-#else
-# include <sysdeps/unix/bsd/seteuid.c>
-#endif
+#include <sysdeps/unix/sysv/linux/i386/seteuid.c>
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/setresgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setresgid.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/setresgid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setresgid.c	2004-09-20 01:51:19.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresgid.c>
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/setresuid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setresuid.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/setresuid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/setresuid.c	2004-09-20 01:51:44.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresuid.c>
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c
--- sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c	2002-09-18 19:59:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c	2003-08-31 19:22:15.000000000 +0200
@@ -1,5 +1,5 @@
 /* POSIX.1 sigaction call for Linux/SPARC.
-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza (miguel@nuclecu.unam.mx), 1997.
 
@@ -23,10 +23,7 @@
 #include <sys/signal.h>
 #include <errno.h>
 #include <kernel_sigaction.h>
-
-extern int __syscall_rt_sigaction (int, const struct kernel_sigaction *,
-				   struct kernel_sigaction *, unsigned long,
-				   size_t);
+#include <sysdep.h>
 
 static void __rt_sigreturn_stub (void);
 static void __sigreturn_stub (void);
@@ -64,9 +61,8 @@
 
       /* XXX The size argument hopefully will have to be changed to the
 	 real size of the user-level sigset_t.  */
-      ret = __syscall_rt_sigaction (sig, act ? &kact : 0,
-				    oact ? &koact : 0,
-				    stub, _NSIG / 8);
+      ret = INLINE_SYSCALL (rt_sigaction, 5, sig, act ? &kact : 0,
+			    oact ? &koact : 0, stub, _NSIG / 8);
 
       if (ret >= 0 || errno != ENOSYS)
 	{
@@ -135,9 +131,12 @@
   return -1;
 }
 libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction);
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction);
+#endif
 
 static void
 __rt_sigreturn_stub (void)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/socket.S
--- sysdeps/unix/sysv/linux/sparc/sparc32/socket.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/socket.S	2003-08-31 19:23:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
 
@@ -17,7 +17,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 #define P(a, b) P2(a, b)
@@ -63,17 +63,45 @@
 #endif
 #endif
 
-	mov P(SOCKOP_,socket), %o0	/* arg 1: socket subfunction */
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	cmp %g1, 0
+	bne .Lsocket_cancel
+#endif
+	 mov P(SOCKOP_,socket), %o0	/* arg 1: socket subfunction */
 	add %sp, 68, %o1		/* arg 2: parameter block */
 	LOADSYSCALL(socketcall)
 	t 0x10
-
-        bcs,a 1f
+        bcs __syscall_error_handler
 	 nop
 	retl
 	 nop
 
-1:	SYSCALL_ERROR_HANDLER
+#if defined NEED_CANCELLATION && defined CENABLE
+.Lsocket_cancel:
+	cfi_startproc
+	save %sp, -96, %sp
+	cfi_def_cfa_register (%fp)
+	cfi_window_save
+	cfi_register (%o7, %i7)
+	CENABLE
+	 nop
+	mov %o0, %l0
+	add %sp, 68 + 96, %o1
+	mov P(SOCKOP_,socket), %o0
+	LOADSYSCALL(socketcall)
+	t 0x10
+	bcs __syscall_error_handler2
+	 mov %o0, %l1
+	CDISABLE
+	 mov %l0, %o0
+	jmpl %i7 + 8, %g0
+	 restore %g0, %l1, %o0
+	cfi_endproc
+	SYSCALL_ERROR_HANDLER2
+#endif
+
+	SYSCALL_ERROR_HANDLER
 
 END (__socket)
 
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/syscall.S
--- sysdeps/unix/sysv/linux/sparc/sparc32/syscall.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/syscall.S	2002-12-28 10:18:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991, 1992, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1991, 1992, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,23 +19,17 @@
 #include <sysdep.h>
 	.text
 ENTRY (syscall)
-	or	%o0,%g0,%g1
-	or	%o1,%g0,%o0
-	or	%o2,%g0,%o1
-	or	%o3,%g0,%o2
-	or	%o4,%g0,%o3
-	or	%o5,%g0,%o4
+	mov	%o0, %g1
+	mov	%o1, %o0
+	mov	%o2, %o1
+	mov	%o3, %o2
+	mov	%o4, %o3
+	mov	%o5, %o4
 	ta	0x10
-	bcc	1f
-	nop
-	save %sp, -96, %sp
-	call __errno_location
-	nop
-	st %i0,[%o0]
-	restore
+	bcs	__syscall_error_handler
+	 nop
 	retl
-	mov -1, %o0
-1:
-	ret
+	 nop
+	SYSCALL_ERROR_HANDLER
 
 PSEUDO_END (syscall)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/syscalls.list
--- sysdeps/unix/sysv/linux/sparc/sparc32/syscalls.list	2000-08-23 19:00:47.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/syscalls.list	2004-09-20 01:52:10.000000000 +0200
@@ -1,27 +1,6 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
-s_getgroups	getgroups getgroups	2	__syscall_getgroups
-s_getpagesize	getpagesize getpagesize	0	__syscall_getpagesize
-s_llseek	llseek	_llseek		5	__syscall__llseek
-s_setfsgid	setfsgid setfsgid	1	__syscall_setfsgid
-s_setfsuid	setfsuid setfsuid	1	__syscall_setfsuid
-s_setgid	setgid	setgid		1	__syscall_setgid
-s_setgroups	setgroups setgroups	2	__syscall_setgroups
-s_setregid	setregid setregid	2	__syscall_setregid
-s_setreuid	setreuid setreuid	2	__syscall_setreuid
 setrlimit	-	setrlimit	2	__setrlimit	setrlimit
 getrlimit	-	getrlimit	2	__getrlimit	getrlimit
-s_ipc		msgget	ipc		5	__syscall_ipc
-s_setuid	setuid	setuid		1	__syscall_setuid
-setresuid	EXTRA	setresuid32	3	__setresuid	setresuid
-setresgid	EXTRA	setresgid32	3	__setresgid	setresgid
-getresuid	EXTRA	getresuid32	3	getresuid
-getresgid	EXTRA	getresgid32	3	getresgid
-
-# System calls with wrappers.
-rt_sigaction	-	rt_sigaction	4	__syscall_rt_sigaction
-rt_sigpending	-	rt_sigpending	2	__syscall_rt_sigpending
-rt_sigprocmask	-	rt_sigprocmask	4	__syscall_rt_sigprocmask
-rt_sigqueueinfo	-	rt_sigqueueinfo	3	__syscall_rt_sigqueueinfo
-rt_sigsuspend	-	rt_sigsuspend	2	__syscall_rt_sigsuspend
-rt_sigtimedwait	-	rt_sigtimedwait	4	__syscall_rt_sigtimedwait
+getresuid	-	getresuid32	3	getresuid
+getresgid	-	getresgid32	3	getresgid
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h
--- sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h	2002-04-11 22:38:23.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/sysdep.h	2004-10-04 22:59:35.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, January 1997.
 
@@ -22,19 +22,22 @@
 
 #include <sysdeps/unix/sparc/sysdep.h>
 
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+#include <tls.h>
+
 #undef SYS_ify
 #define SYS_ify(syscall_name) __NR_##syscall_name
 
 #ifdef __ASSEMBLER__
 
-#ifdef DONT_LOAD_G1
-# define LOADSYSCALL(x)
-#else
-# define LOADSYSCALL(x) mov __NR_##x, %g1
-#endif
+#define LOADSYSCALL(x) mov __NR_##x, %g1
 
 /* Linux/SPARC uses a different trap number */
 #undef PSEUDO
+#undef PSEUDO_NOERRNO
+#undef PSEUDO_ERRVAL
 #undef ENTRY
 #undef END
 #undef LOC
@@ -50,35 +53,116 @@
 
 #define LOC(name)  .L##name
 
-#ifdef PIC
-#define SYSCALL_ERROR_HANDLER					\
-	.global C_SYMBOL_NAME(__errno_location);		\
-        .type   C_SYMBOL_NAME(__errno_location),@function;	\
-	save   %sp,-96,%sp;					\
-	call   __errno_location;				\
-	 nop;							\
-	st	%i0,[%o0];					\
-	jmpl	%i7+8,%g0;					\
-	 restore %g0,-1,%o0;
+#ifdef LINKER_HANDLES_R_SPARC_WDISP22
+/* Unfortunately, we cannot do this yet.  Linker doesn't seem to
+   handle R_SPARC_WDISP22 against non-STB_LOCAL symbols properly .  */
+# define SYSCALL_ERROR_HANDLER_ENTRY(handler)				\
+	.section .gnu.linkonce.t.handler,"ax",@progbits;		\
+	.globl handler;							\
+	.hidden handler;						\
+	.type handler,@function;					\
+handler:
+#else
+# define SYSCALL_ERROR_HANDLER_ENTRY(handler)				\
+	.subsection 3;							\
+handler:
+#endif
+
+#if RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_HANDLER						\
+	.section .gnu.linkonce.t.__sparc_get_pic_l7,"ax",@progbits;	\
+	.globl __sparc_get_pic_l7;					\
+	.hidden __sparc_get_pic_l7;					\
+	.type __sparc_get_pic_l7,@function;				\
+__sparc_get_pic_l7:							\
+	retl;								\
+	 add	%o7, %l7, %l7;						\
+	.previous;							\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	save	%sp,-96,%sp;						\
+	sethi	%hi(_GLOBAL_OFFSET_TABLE_-4), %l7;			\
+	call	__sparc_get_pic_l7;					\
+	 add	%l7, %lo(_GLOBAL_OFFSET_TABLE_+4), %l7;			\
+	ld	[%l7 + rtld_errno], %l0;				\
+	st	%i0, [%l0];						\
+	jmpl	%i7+8, %g0;						\
+	 restore %g0, -1, %o0;						\
+	.previous;
+#elif USE___THREAD
+# ifndef NOT_IN_libc
+#  define SYSCALL_ERROR_ERRNO __libc_errno
+# else
+#  define SYSCALL_ERROR_ERRNO errno
+# endif
+# ifdef SHARED
+#  define SYSCALL_ERROR_HANDLER						\
+	.section .gnu.linkonce.t.__sparc_get_pic_l7,"ax",@progbits;	\
+	.globl __sparc_get_pic_l7;					\
+	.hidden __sparc_get_pic_l7;					\
+	.type __sparc_get_pic_l7,@function;				\
+__sparc_get_pic_l7:							\
+	retl;								\
+	 add	%o7, %l7, %l7;						\
+	.previous;							\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	save	%sp,-96,%sp;						\
+	sethi	%tie_hi22(SYSCALL_ERROR_ERRNO), %l1;			\
+	sethi	%hi(_GLOBAL_OFFSET_TABLE_-4), %l7;			\
+	call	__sparc_get_pic_l7;					\
+	 add	%l7, %lo(_GLOBAL_OFFSET_TABLE_+4), %l7;			\
+	add	%l1, %tie_lo10(SYSCALL_ERROR_ERRNO), %l1;		\
+	ld	[%l7 + %l1], %l1, %tie_ld(SYSCALL_ERROR_ERRNO);		\
+	st	%i0, [%g7 + %l1], %tie_add(SYSCALL_ERROR_ERRNO);	\
+	jmpl	%i7+8, %g0;						\
+	 restore %g0, -1, %o0;						\
+	.previous;
+# else
+#  define SYSCALL_ERROR_HANDLER						\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	sethi	%tie_hi22(SYSCALL_ERROR_ERRNO), %g1;			\
+	sethi	%hi(_GLOBAL_OFFSET_TABLE_), %g2;			\
+	add	%g1, %tie_lo10(SYSCALL_ERROR_ERRNO), %g1;		\
+	add	%g2, %lo(_GLOBAL_OFFSET_TABLE_), %g2;			\
+	ld	[%g2 + %g1], %g1, %tie_ld(SYSCALL_ERROR_ERRNO);		\
+	st	%o0, [%g7 + %g1], %tie_add(SYSCALL_ERROR_ERRNO);	\
+	jmpl	%o7+8, %g0;						\
+	 mov	-1, %o0;						\
+	.previous;
+# endif
 #else
-#define SYSCALL_ERROR_HANDLER					\
-	save	%sp,-96,%sp;					\
-	call	__errno_location;				\
-	nop;							\
-	st	%i0,[%o0];					\
-	jmpl	%i7+8,%g0;					\
-	 restore %g0,-1,%o0;
-#endif   /* PIC */
+# define SYSCALL_ERROR_HANDLER						\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	.global __errno_location;					\
+        .type   __errno_location,@function;				\
+	save   %sp, -96, %sp;						\
+	call   __errno_location;					\
+	 nop;								\
+	st	%i0, [%o0];						\
+	jmpl	%i7+8, %g0;						\
+	 restore %g0, -1, %o0;						\
+	.previous;
+#endif
 
 #define PSEUDO(name, syscall_name, args)			\
 	.text;							\
 	ENTRY(name);						\
 	LOADSYSCALL(syscall_name);				\
 	ta 0x10;						\
-	bcc,a 9000f;						\
-	nop;							\
-	SYSCALL_ERROR_HANDLER;					\
-9000:;
+	bcs __syscall_error_handler;				\
+	 nop;							\
+	SYSCALL_ERROR_HANDLER
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)		\
+	.text;							\
+	ENTRY(name);						\
+	LOADSYSCALL(syscall_name);				\
+	ta 0x10
+
+#define PSEUDO_ERRVAL(name, syscall_name, args)			\
+	.text;							\
+	ENTRY(name);						\
+	LOADSYSCALL(syscall_name);				\
+	ta 0x10
 
 #else  /* __ASSEMBLER__ */
 
@@ -97,7 +181,29 @@
 	" restore %%g0, -1, %%o0;"					\
 	".previous;"
 
-#define __SYSCALL_CLOBBERS "g2", "g3", "g4", "g5", "g7",		\
+#define __CLONE_SYSCALL_STRING						\
+	"ta	0x10;"							\
+	"bcs	2f;"							\
+	" sub	%%o1, 1, %%o1;"						\
+	"and	%%o0, %%o1, %%o0;"					\
+	"1:"								\
+	".subsection 2;"						\
+	"2:"								\
+	"save	%%sp, -192, %%sp;"					\
+	"call	__errno_location;"					\
+	" nop;"								\
+	"st	%%i0, [%%o0];"						\
+	"ba	1b;"							\
+	" restore %%g0, -1, %%o0;"					\
+	".previous;"
+
+#define __INTERNAL_SYSCALL_STRING					\
+	"ta	0x10;"							\
+	"bcs,a	1f;"							\
+	" sub	%%g0, %%o0, %%o0;"					\
+	"1:"
+
+#define __SYSCALL_CLOBBERS "g2", "g3", "g4", "g5", "g6",		\
 	"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",			\
 	"f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",		\
 	"f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",		\
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc32/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/Versions
--- sysdeps/unix/sysv/linux/sparc/sparc32/Versions	2002-08-23 21:47:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc32/Versions	2003-08-22 20:10:44.000000000 +0200
@@ -17,4 +17,7 @@
     # s*
     scandir64;
   }
+  GLIBC_2.3.3 {
+    posix_fadvise64; posix_fallocate64;
+  }
 }
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.c	2002-02-01 20:00:17.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.c	2003-07-23 00:07:19.000000000 +0200
@@ -1,5 +1,5 @@
 /* Data for Linux/sparc64 version of processor capability information.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
 
@@ -40,13 +40,14 @@
        needed.
   */
 
-#ifdef PROCINFO_DECL
-EXTERN
+#ifndef PROCINFO_CLASS
+#define PROCINFO_CLASS
 #endif
+
 #if !defined PROCINFO_DECL && defined SHARED
   ._dl_sparc64_cap_flags
 #else
-const char _dl_sparc64_cap_flags[6][7]
+PROCINFO_CLASS const char _dl_sparc64_cap_flags[6][7]
 #endif
 #ifndef PROCINFO_DECL
 = {
@@ -60,3 +61,4 @@
 #endif
 
 #undef PROCINFO_DECL
+#undef PROCINFO_CLASS
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.h
--- sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.h	2002-02-01 20:00:17.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/dl-procinfo.h	2004-03-07 09:38:42.000000000 +0100
@@ -1,5 +1,5 @@
 /* Linux/sparc64 version of processor capability information handling macros.
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jj@ultra.linux.cz>, 1999.
 
@@ -35,7 +35,7 @@
 
   for (i = 0; i < _DL_HWCAP_COUNT; ++i)
     if (word & (1 << i))
-      _dl_printf (" %s", GL(dl_sparc64_cap_flags)[i]);
+      _dl_printf (" %s", GLRO(dl_sparc64_cap_flags)[i]);
 
   _dl_printf ("\n");
 
@@ -46,7 +46,7 @@
 __attribute__ ((unused))
 _dl_hwcap_string (int idx)
 {
-  return GL(dl_sparc64_cap_flags)[idx];
+  return GLRO(dl_sparc64_cap_flags)[idx];
 };
 
 
@@ -57,7 +57,7 @@
   int i;
   for (i = 0; i < _DL_HWCAP_COUNT; i++)
     {
-      if (strcmp (str, GL(dl_sparc64_cap_flags) [i]) == 0)
+      if (strcmp (str, GLRO(dl_sparc64_cap_flags) [i]) == 0)
 	return i;
     }
   return -1;
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/fstatfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fstatfs64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/fstatfs64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fstatfs64 is the same as fstatfs. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/ftruncate64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/ftruncate64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* ftruncate64 is the same as ftruncate. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fxstat64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/fxstat64.c	1999-12-23 21:32:13.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fxstat64 is in fxstat.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fxstat.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/fxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/fxstat.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+#include "../../fxstat.c"
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/getdents64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getdents64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/getdents64.c	2000-08-11 19:27:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getdents64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getdents64 is in getdents.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/getdents.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getdents.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/getdents.c	2000-08-11 19:27:27.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getdents.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#define __getdents64 __no___getdents64_decl
-#include <sysdeps/unix/sysv/linux/getdents.c>
-#undef __getdents64
-weak_alias(__getdents, __getdents64);
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/getrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getrlimit64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/getrlimit64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/getrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getrlimit64 is the same as getrlimit. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/glob64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/glob64.c	1998-08-10 17:54:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/glob64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* glob64 is in glob.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/Implies
--- sysdeps/unix/sysv/linux/sparc/sparc64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/Implies	2004-03-24 00:26:24.000000000 +0100
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/longjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/longjmp.S
--- sysdeps/unix/sysv/linux/sparc/sparc64/longjmp.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/longjmp.S	2002-12-31 21:37:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson (rth@tamu.edu).
 
@@ -46,6 +46,7 @@
 
 strong_alias(__libc_siglongjmp, __longjmp)
 strong_alias(__libc_siglongjmp, __libc_longjmp)
+libc_hidden_def (__libc_longjmp)
 weak_alias(__libc_siglongjmp, longjmp)
 weak_alias(__libc_siglongjmp, _longjmp)
 weak_alias(__libc_siglongjmp, siglongjmp)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/lxstat64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/lxstat64.c	1999-12-23 21:32:13.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* lxstat64 is in lxstat.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/lxstat.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/lxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/lxstat.c	2004-03-24 00:25:52.000000000 +0100
@@ -0,0 +1 @@
+#include "../../lxstat.c"
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile
--- sysdeps/unix/sysv/linux/sparc/sparc64/Makefile	2000-04-18 08:14:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile	2003-02-21 20:10:29.000000000 +0100
@@ -1,2 +1,2 @@
-sysdep-CFLAGS += -fcall-used-g7
+sysdep-CFLAGS += -fcall-used-g6
 LD += -melf64_sparc
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/mmap64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/mmap64.c	1997-12-28 16:28:54.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/mmap64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* mmap64 is the same as mmap. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/pause.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pause.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/pause.c	1999-06-02 13:10:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pause.c	2003-03-15 00:37:01.000000000 +0100
@@ -1 +1 @@
-#include <sysdeps/unix/common/pause.c>
+#include <sysdeps/posix/pause.c>
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/pipe.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pipe.S
--- sysdeps/unix/sysv/linux/sparc/sparc64/pipe.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pipe.S	2002-12-28 10:19:08.000000000 +0100
@@ -23,14 +23,13 @@
 	mov	%o0, %o2		/* Save PIPEDES. */
 	LOADSYSCALL(pipe)
 	ta	0x6d
-	bcc,pt	%xcc, 2f
+	bcs,pn	%xcc, __syscall_error_handler
 	 nop
-	SYSCALL_ERROR_HANDLER
-
-2:	st	%o0, [%o2]		/* PIPEDES[0] = %o0; */
+	st	%o0, [%o2]		/* PIPEDES[0] = %o0; */
 	st	%o1, [%o2 + 4]		/* PIPEDES[1] = %o1; */
 	retl
 	 clr	%o0
+	SYSCALL_ERROR_HANDLER
 PSEUDO_END (__libc_pipe)
 
 weak_alias (__libc_pipe, __pipe)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pread64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/pread64.c	1997-10-26 21:08:48.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pread64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pwrite64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/pwrite64.c	1997-10-26 21:08:50.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/readdir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/readdir64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64 is in readdir.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/readdir64_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir64_r.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/readdir64_r.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir64_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64_r is in readdir_r.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/readdir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/readdir.c	2000-08-19 18:16:50.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-#define readdir64 __no_readdir64_decl
-#define __readdir64 __no___readdir64_decl
-#include <sysdeps/unix/readdir.c>
-#undef __readdir64
-strong_alias (__readdir, __readdir64)
-#undef readdir64
-weak_alias (__readdir, readdir64)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/readdir_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir_r.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/readdir_r.c	2000-08-19 18:16:50.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/readdir_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#define readdir64_r __no_readdir64_r_decl
-#include <sysdeps/unix/readdir_r.c>
-#undef readdir64_r
-weak_alias (__readdir_r, readdir64_r)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sendfile64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sendfile64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/sendfile64.c	2002-06-07 14:33:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sendfile64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* sendfile64 is alias of sendfile syscall.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/setjmp.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/setjmp.S
--- sysdeps/unix/sysv/linux/sparc/sparc64/setjmp.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/setjmp.S	2002-12-31 21:37:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson (rth@tamu.edu).
 
@@ -34,6 +34,7 @@
 	ba	__sigsetjmp_local
 	 set	0, %o1
 END(_setjmp)
+libc_hidden_def (_setjmp)
 
 /* int setjmp(jmp_buf) */
 
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/setrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/setrlimit64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/setrlimit64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/setrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* setrlimit64 is the same as setrlimit. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c	2002-09-18 19:59:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c	2003-01-03 01:42:12.000000000 +0100
@@ -1,5 +1,5 @@
 /* POSIX.1 sigaction call for Linux/SPARC64.
-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997,1998,1999,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza (miguel@nuclecu.unam.mx) and
 		  Jakub Jelinek (jj@ultra.linux.cz).
@@ -64,9 +64,12 @@
   return ret;
 }
 libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction);
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction);
+#endif
 
 static void
 __rt_sigreturn_stub (void)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sigpending.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigpending.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/sigpending.c	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigpending.c	2003-09-03 05:21:28.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,9 +24,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_rt_sigpending (sigset_t *__unbounded, size_t);
-
-
 /* Change the set of blocked signals to SET,
    wait until a signal arrives, and restore the set of blocked signals.  */
 int
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sigprocmask.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigprocmask.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/sigprocmask.c	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigprocmask.c	2003-09-03 05:21:28.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,9 +24,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_rt_sigprocmask (int, const sigset_t *__unbounded,
-				     sigset_t *__unbounded, size_t);
-
 /* Get and/or change the set of blocked signals.  */
 int
 __sigprocmask (how, set, oset)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sigsuspend.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigsuspend.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/sigsuspend.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sigsuspend.c	2003-04-02 02:06:44.000000000 +0200
@@ -1,40 +1 @@
-/* Copyright (C) 1996,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-#include <bp-checks.h>
-
-extern int __syscall_rt_sigsuspend (const sigset_t *__unbounded, size_t);
-
-/* Change the set of blocked signals to SET,
-   wait until a signal arrives, and restore the set of blocked signals.  */
-int
-__sigsuspend (set)
-     const sigset_t *set;
-{
-  /* XXX The size argument hopefully will have to be changed to the
-     real size of the user-level sigset_t.  */
-  return INLINE_SYSCALL (rt_sigsuspend, 2, CHECK_SIGSET (set), _NSIG / 8);
-}
-libc_hidden_def (__sigsuspend)
-weak_alias (__sigsuspend, sigsuspend)
+#include "../../ia64/sigsuspend.c"
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/socket.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/socket.S
--- sysdeps/unix/sysv/linux/sparc/sparc64/socket.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/socket.S	2004-12-16 17:47:49.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
 
@@ -17,7 +17,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <socketcall.h>
 
 #define P(a, b) P2(a, b)
@@ -63,17 +63,47 @@
 #endif
 #endif
 
-	mov	P(SOCKOP_,socket), %o0		/* arg 1: socket subfunction */
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	cmp	%g1, 0
+	bne	.Lsocket_cancel
+#endif
+	 mov	P(SOCKOP_,socket), %o0		/* arg 1: socket subfunction */
 	add	%sp, STACK_BIAS + 128, %o1	/* arg 2: parameter block */
 	LOADSYSCALL(socketcall)
 	ta	0x6d
 
-        bcs,pn	%xcc, 1f
+	bcs,pn	%xcc, __syscall_error_handler
 	 nop
 	retl
 	 nop
 
-1:	SYSCALL_ERROR_HANDLER
+#if defined NEED_CANCELLATION && defined CENABLE
+.Lsocket_cancel:
+	cfi_startproc
+	save	%sp, -160, %sp
+	cfi_def_cfa_register (%fp)
+	cfi_window_save
+	cfi_register (%o7, %i7)
+	CENABLE
+	 nop
+	mov	%o0, %l0
+	add	%sp, 160 + STACK_BIAS + 128, %o1
+	mov	P(SOCKOP_,socket), %o0
+	LOADSYSCALL(socketcall)
+	ta	0x6d
+
+	bcs,pn	%xcc, __syscall_error_handler2
+	 mov	%o0, %l1
+	CDISABLE
+	 mov	%l0, %o0
+	jmpl	%i7 + 8, %g0
+	 restore %g0, %l1, %o0
+	cfi_endproc
+	SYSCALL_ERROR_HANDLER2
+#endif
+
+	SYSCALL_ERROR_HANDLER
 
 END (__socket)
 
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/statfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/statfs64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/statfs64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/statfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* statfs64 is the same as statfs. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/syscall.S
--- sysdeps/unix/sysv/linux/sparc/sparc64/syscall.S	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/syscall.S	2002-12-28 10:20:01.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1999, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,11 +30,11 @@
 
 	ta	0x6d
 
-	bcc,pt %xcc,1f
+	bcs,pn %xcc,__syscall_error_handler
 	 nop
-	SYSCALL_ERROR_HANDLER
-
-1:	retl
+	retl
 	 nop
 
+	SYSCALL_ERROR_HANDLER
+
 PSEUDO_END (syscall)
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/syscalls.list
--- sysdeps/unix/sysv/linux/sparc/sparc64/syscalls.list	2002-08-03 21:41:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/syscalls.list	2004-03-24 00:31:17.000000000 +0100
@@ -1,37 +1,20 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
-# Whee! 64-bit systems naturally implement llseek.
-llseek		EXTRA	lseek		3	__llseek	llseek	__libc_lseek64 __lseek64 lseek64
-pread		-	pread		4	__libc_pread	__libc_pread64 __pread pread __pread64 pread64
-pwrite		-	pwrite		4	__libc_pwrite	__libc_pwrite64 __pwrite pwrite __pwrite64 pwrite64
-fstatfs		-	fstatfs		2	__fstatfs	fstatfs __fstatfs64 fstatfs64
-statfs		-	statfs		2	__statfs	statfs statfs64
-getrlimit	-	getrlimit	2	__getrlimit	getrlimit getrlimit64
-setrlimit	-	setrlimit	2	__setrlimit	setrlimit64 setrlimit
-ftruncate	-	ftruncate	2	__ftruncate	ftruncate __ftruncate64 ftruncate64
-truncate	-	truncate	2	truncate	truncate64
-mmap		-	mmap		6	__mmap		mmap __mmap64 mmap64
-readahead	EXTRA	readahead	3	__readahead	readahead
-sendfile	-	sendfile	i:iipi	sendfile	sendfile64
-
 # Override select.S in parent directory:
-select		-	select		5	__select	select
-accept		-	accept		3	__libc_accept	__accept accept
+select		-	select		C:5	__select	select
+accept		-	accept		C:3	__libc_accept	__accept accept
 bind		-	bind		3	__bind		bind
-connect		-	connect		3	__libc_connect	__connect_internal __connect connect
+connect		-	connect		C:3	__libc_connect	__connect_internal __connect connect
 getpeername	-	getpeername	3	__getpeername	getpeername
 getsockname	-	getsockname	3	__getsockname	getsockname
 getsockopt	-	getsockopt	5	__getsockopt	getsockopt
 listen		-	listen		2	__listen	listen
-recv		-	recv		4	__libc_recv	__recv recv
-recvfrom	-	recvfrom	6	__libc_recvfrom	__recvfrom recvfrom
-recvmsg		-	recvmsg		3	__libc_recvmsg	__recvmsg recvmsg
-send		-	send		4	__libc_send	__send send
-sendmsg		-	sendmsg		3	__libc_sendmsg	__sendmsg sendmsg
-sendto		-	sendto		6	__libc_sendto	__sendto sendto
+recv		-	recv		C:4	__libc_recv	__recv recv
+recvfrom	-	recvfrom	C:6	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		C:3	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		C:4	__libc_send	__send send
+sendmsg		-	sendmsg		C:3	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		C:6	__libc_sendto	__sendto sendto
 setsockopt	-	setsockopt	5	__setsockopt	setsockopt
 shutdown	-	shutdown	2	__shutdown	shutdown
 socketpair	-	socketpair	4	__socketpair	socketpair
-
-getresuid	-	getresuid	3	getresuid
-getresgid	-	getresgid	3	getresgid
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h
--- sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/sysdep.h	2004-12-16 17:47:26.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson <richard@gnu.ai.mit.edu>, 1997.
 
@@ -22,19 +22,31 @@
 
 #include <sysdeps/unix/sysdep.h>
 
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+
 #undef SYS_ify
 #define SYS_ify(syscall_name) __NR_##syscall_name
 
+/* This is a kludge to make syscalls.list find these under the names
+   pread and pwrite, since some kernel headers define those names
+   and some define the *64 names for the same system calls.  */
+#if !defined __NR_pread && defined __NR_pread64
+# define __NR_pread __NR_pread64
+#endif
+#if !defined __NR_pwrite && defined __NR_pwrite64
+# define __NR_pwrite __NR_pwrite64
+#endif
+
 #ifdef __ASSEMBLER__
 
-#ifdef DONT_LOAD_G1
-# define LOADSYSCALL(x)
-#else
-# define LOADSYSCALL(x) mov __NR_##x, %g1
-#endif
+#define LOADSYSCALL(x) mov __NR_##x, %g1
 
 /* Linux/SPARC uses a different trap number */
 #undef PSEUDO
+#undef PSEUDO_NOERRNO
+#undef PSEUDO_ERRVAL
 #undef ENTRY
 
 #define ENTRY(name)							\
@@ -43,34 +55,96 @@
 	C_LABEL(name);							\
 	.type name,@function;
 
-#define SYSCALL_ERROR_HANDLER						\
+#ifdef LINKER_HANDLES_R_SPARC_WDISP22
+/* Unfortunately, we cannot do this yet.  Linker doesn't seem to
+   handle R_SPARC_WDISP22 against non-STB_LOCAL symbols properly .  */
+# define SYSCALL_ERROR_HANDLER_ENTRY(handler)				\
+	.section .gnu.linkonce.t.handler,"ax",@progbits;		\
+	.globl handler;							\
+	.hidden handler;						\
+	.type handler,@function;					\
+handler:
+#else
+# define SYSCALL_ERROR_HANDLER_ENTRY(handler)				\
+	.subsection 3;							\
+handler:
+#endif
+
+#if RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_HANDLER						\
+	.section .gnu.linkonce.t.__sparc64.get_pic.l7,"ax",@progbits;	\
+	.globl __sparc64.get_pic.l7;					\
+	.hidden __sparc64.get_pic.l7;					\
+	.type __sparc64.get_pic.l7,@function;				\
+__sparc64.get_pic.l7:							\
+	retl;								\
+	 add	%o7, %l7, %l7;						\
+	.previous;							\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	save	%sp, -192, %sp;						\
+	sethi	%hi(_GLOBAL_OFFSET_TABLE_-4), %l7;			\
+	call	__sparc64.get_pic.l7;					\
+	 add	%l7, %lo(_GLOBAL_OFFSET_TABLE_+4), %l7;			\
+	ldx	[%l7 + rtld_errno], %l0;				\
+	st	%i0, [%l0];						\
+	jmpl	%i7+8, %g0;						\
+	 restore %g0, -1, %o0;						\
+	.previous;
+#else
+# define SYSCALL_ERROR_HANDLER						\
+SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler)			\
+	.global __errno_location;					\
+	.type   __errno_location,@function;				\
 	save	%sp, -192, %sp;						\
 	call	__errno_location;					\
 	 nop;								\
 	st	%i0, [%o0];						\
 	jmpl	%i7+8, %g0;						\
-	 restore %g0, -1, %o0
+	 restore %g0, -1, %o0;						\
+	.previous;
+#endif
 
 #define PSEUDO(name, syscall_name, args)				\
 	.text;								\
 	ENTRY(name);							\
 	LOADSYSCALL(syscall_name);					\
 	ta	0x6d;							\
-	bcc,pt	%xcc, 1f;						\
+	bcs,pn	%xcc, __syscall_error_handler;				\
 	 nop;								\
-	SYSCALL_ERROR_HANDLER;						\
-1:
+	SYSCALL_ERROR_HANDLER
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)			\
+	.text;								\
+	ENTRY(name);							\
+	LOADSYSCALL(syscall_name);					\
+	ta	0x6d
+
+#define PSEUDO_ERRVAL(name, syscall_name, args)				\
+	.text;								\
+	ENTRY(name);							\
+	LOADSYSCALL(syscall_name);					\
+	ta	0x6d
 
 #undef PSEUDO_END
 #define PSEUDO_END(name)						\
 	.size name,.-name
 
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name)					\
+	.size name,.-name
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(name)						\
+	.size name,.-name
+
 #undef END
 #define END(name)							\
 	.size name,.-name
 
 /* Careful here!  This "ret" define can interfere; use jmpl if unsure.  */
-#define ret             retl; nop
+#define ret		retl; nop
+#define ret_NOERRNO	retl; nop
+#define ret_ERRVAL	retl; nop
 #define r0              %o0
 #define r1              %o1
 #define MOVE(x,y)       mov x, y
@@ -88,7 +162,25 @@
 	"restore %%g0, -1, %%o0;"					\
 	"1:"
 
-#define __SYSCALL_CLOBBERS "g2", "g3", "g4", "g5", "g7",		\
+#define __CLONE_SYSCALL_STRING						\
+	"ta	0x6d;"							\
+	"bcc,pt	%%xcc, 1f;"						\
+	" sub	%%o1, 1, %%o1;"						\
+	"save	%%sp, -192, %%sp;"					\
+	"call	__errno_location;"					\
+	" mov	-1, %%i1;"						\
+	"st	%%i0,[%%o0];"						\
+	"restore %%g0, -1, %%o0;"					\
+	"1:"								\
+	"and	%%o0, %%o1, %%o0"
+
+#define __INTERNAL_SYSCALL_STRING					\
+	"ta	0x6d;"							\
+	"bcs,a,pt %%xcc, 1f;"						\
+	" sub	%%g0, %%o0, %%o0;"					\
+	"1:"
+
+#define __SYSCALL_CLOBBERS "g2", "g3", "g4", "g5", "g6",		\
 	"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",			\
 	"f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",		\
 	"f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",		\
@@ -101,7 +193,7 @@
 
 #endif	/* __ASSEMBLER__ */
 
-/* This is the offset from the %sp to the backing store above the 
+/* This is the offset from the %sp to the backing store above the
    register windows.  So if you poke stack memory directly you add this.  */
 #define STACK_BIAS	2047
 
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/truncate64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/truncate64.c	1997-12-22 21:43:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/truncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* truncate64 is the same as truncate. */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/xstat64.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/xstat64.c	1999-12-23 21:32:13.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/xstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* xstat64 is in xstat.c */
diff -Nur sysdeps/unix/sysv/linux/sparc/sparc64/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/xstat.c
--- sysdeps/unix/sysv/linux/sparc/sparc64/xstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sparc64/xstat.c	2004-03-24 00:25:52.000000000 +0100
@@ -0,0 +1 @@
+#include "../../xstat.c"
diff -Nur sysdeps/unix/sysv/linux/sparc/sys/sysmacros.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sys/sysmacros.h
--- sysdeps/unix/sysv/linux/sparc/sys/sysmacros.h	2001-07-07 21:21:38.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sys/sysmacros.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* Definitions of macros to access `dev_t' values.
-   Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_SYSMACROS_H
-#define _SYS_SYSMACROS_H	1
-
-#include <bits/wordsize.h>
-
-/* For compatibility we provide alternative names.
-
-   The problem here is that compilers other than GCC probably don't
-   have the `long long' type and so `dev_t' is actually an array.  */
-#if __WORDSIZE == 64 || (defined __GNUC__ && __GNUC__ >= 2)
-# define major(dev) ((int)(((dev) >> 8) & 0xff))
-# define minor(dev) ((int)((dev) & 0xff))
-# define makedev(major, minor) ((((unsigned int) (major)) << 8) \
-				| ((unsigned int) (minor)))
-#else
-# define major(dev) (((dev).__val[1] >> 8) & 0xff)
-# define minor(dev) ((dev).__val[1] & 0xff)
-# define makedev(major, minor) { 0, ((((unsigned int) (major)) << 8) \
-				     | ((unsigned int) (minor))) }
-#endif
-
-#endif /* sys/sysmacros.h */
diff -Nur sysdeps/unix/sysv/linux/sparc/sys/user.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sys/user.h
--- sysdeps/unix/sysv/linux/sparc/sys/user.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sys/user.h	2003-08-15 05:54:43.000000000 +0200
@@ -0,0 +1,85 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+struct sunos_regs
+{
+  unsigned int psr, pc, npc, y;
+  unsigned int regs[15];
+};
+
+struct sunos_fpqueue
+{
+  unsigned int *addr;
+  unsigned int inst;
+};
+
+struct sunos_fp
+{
+  union
+    {
+      unsigned int regs[32];
+      double reg_dbls[16];
+    } fregs;
+  unsigned int fsr;
+  unsigned int flags;
+  unsigned int extra;
+  unsigned int fpq_count;
+  struct sunos_fpqueue fpq[16];
+};
+
+struct sunos_fpu
+{
+  struct sunos_fp fpstatus;
+};
+
+/* The SunOS core file header layout. */
+struct user {
+  unsigned int magic;
+  unsigned int len;
+  struct sunos_regs regs;
+  struct
+    {
+      unsigned char a_dynamic :1;
+      unsigned char a_toolversion :7;
+      unsigned char a_machtype;
+      unsigned short a_info;
+      unsigned int a_text;
+      unsigned int a_data;
+      unsigned int a_bss;
+      unsigned int a_syms;
+      unsigned int a_entry;
+      unsigned int a_trsize;
+      unsigned int a_drsize;
+    } uexec;
+  int           signal;
+  size_t        u_tsize;
+  size_t        u_dsize;
+  size_t        u_ssize;
+  char          u_comm[17];
+  struct sunos_fpu fpu;
+  unsigned int  sigcode;
+};
+
+#define NBPG			0x2000
+#define UPAGES			1
+#define SUNOS_CORE_MAGIC	0x080456
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/sparc/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/syscalls.list
--- sysdeps/unix/sysv/linux/sparc/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/syscalls.list	2003-09-03 04:55:44.000000000 +0200
@@ -0,0 +1,3 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+waitpid		-	waitpid		Ci:ipi	__waitpid	waitpid	__libc_waitpid
diff -Nur sysdeps/unix/sysv/linux/sparc/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sysdep.h
--- sysdeps/unix/sysv/linux/sparc/sysdep.h	2002-09-29 19:46:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sysdep.h	2004-09-23 07:16:32.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2000.
 
@@ -21,82 +21,101 @@
 #define _LINUX_SPARC_SYSDEP_H 1
 
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...) inline_syscall##nr(name, args)
+#define INLINE_SYSCALL(name, nr, args...) \
+  inline_syscall##nr(__SYSCALL_STRING, __NR_##name, args)
 
-#define inline_syscall0(name,dummy...)					\
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  inline_syscall##nr(__INTERNAL_SYSCALL_STRING, __NR_##name, args)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  inline_syscall##nr(__INTERNAL_SYSCALL_STRING, name, args)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned long) (val) >= -515L)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
+
+#define inline_syscall0(string,name,dummy...)				\
 ({									\
 	register long __o0 __asm__ ("o0");				\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1) :					\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall1(name,arg1)					\
+#define inline_syscall1(string,name,arg1)				\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0) :			\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall2(name,arg1,arg2)					\
+#define inline_syscall2(string,name,arg1,arg2)				\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0), "r" (__o1) :		\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall3(name,arg1,arg2,arg3)				\
+#define inline_syscall3(string,name,arg1,arg2,arg3)			\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0), "r" (__o1),		\
 			  "r" (__o2) :					\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall4(name,arg1,arg2,arg3,arg4)			\
+#define inline_syscall4(string,name,arg1,arg2,arg3,arg4)		\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3) :			\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall5(name,arg1,arg2,arg3,arg4,arg5)			\
+#define inline_syscall5(string,name,arg1,arg2,arg3,arg4,arg5)		\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
 	register long __o2 __asm__ ("o2") = (long)(arg3);		\
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
 	register long __o4 __asm__ ("o4") = (long)(arg5);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3), "r" (__o4) :		\
 			  __SYSCALL_CLOBBERS);				\
 	__o0;								\
 })
 
-#define inline_syscall6(name,arg1,arg2,arg3,arg4,arg5,arg6)		\
+#define inline_syscall6(string,name,arg1,arg2,arg3,arg4,arg5,arg6)	\
 ({									\
 	register long __o0 __asm__ ("o0") = (long)(arg1);		\
 	register long __o1 __asm__ ("o1") = (long)(arg2);		\
@@ -104,8 +123,8 @@
 	register long __o3 __asm__ ("o3") = (long)(arg4);		\
 	register long __o4 __asm__ ("o4") = (long)(arg5);		\
 	register long __o5 __asm__ ("o5") = (long)(arg6);		\
-	register long __g1 __asm__ ("g1") = __NR_##name;		\
-	__asm __volatile (__SYSCALL_STRING : "=r" (__g1), "=r" (__o0) :	\
+	register long __g1 __asm__ ("g1") = name;			\
+	__asm __volatile (string : "=r" (__g1), "=r" (__o0) :		\
 			  "0" (__g1), "1" (__o0), "r" (__o1),		\
 			  "r" (__o2), "r" (__o3), "r" (__o4),		\
 			  "r" (__o5) :					\
@@ -113,4 +132,22 @@
 	__o0;								\
 })
 
+#define INLINE_CLONE_SYSCALL(arg1,arg2,arg3,arg4,arg5)			\
+({									\
+	register long __o0 __asm__ ("o0") = (long)(arg1);		\
+	register long __o1 __asm__ ("o1") = (long)(arg2);		\
+	register long __o2 __asm__ ("o2") = (long)(arg3);		\
+	register long __o3 __asm__ ("o3") = (long)(arg4);		\
+	register long __o4 __asm__ ("o4") = (long)(arg5);		\
+	register long __g1 __asm__ ("g1") = __NR_clone;			\
+	__asm __volatile (__CLONE_SYSCALL_STRING :			\
+			  "=r" (__g1), "=r" (__o0), "=r" (__o1)	:	\
+			  "0" (__g1), "1" (__o0), "2" (__o1),		\
+			  "r" (__o2), "r" (__o3), "r" (__o4) :		\
+			  __SYSCALL_CLOBBERS);				\
+	__o0;								\
+})
+
+
+
 #endif /* _LINUX_SPARC_SYSDEP_H */
diff -Nur sysdeps/unix/sysv/linux/sparc/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sysdep.S
--- sysdeps/unix/sysv/linux/sparc/sysdep.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/sysdep.S	2002-10-11 12:51:32.000000000 +0200
@@ -1,30 +1 @@
-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <richard@gnu.ai.mit.edu>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-
-/* Define errno */
-
-	.section .bss
-	.globl errno
-	.align 4
-errno:	.space 4
-	.type errno, @object
-	.size errno, 4
-
-weak_alias (errno, _errno)
+/* Nothing to do here.  */
diff -Nur sysdeps/unix/sysv/linux/sparc/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/system.c
--- sysdeps/unix/sysv/linux/sparc/system.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/system.c	2003-08-31 19:23:57.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <kernel-features.h>
+
+/* We have to and actually can handle cancelable system().  The big
+   problem: we have to kill the child process if necessary.  To do
+   this a cleanup handler has to be registered and is has to be able
+   to find the PID of the child.  The main problem is to reliable have
+   the PID when needed.  It is not necessary for the parent thread to
+   return.  It might still be in the kernel when the cancellation
+   request comes.  Therefore we have to use the clone() calls ability
+   to have the kernel write the PID into the user-level variable.  */
+#ifdef __ASSUME_CLONE_THREAD_FLAGS
+# define FORK() \
+  INLINE_CLONE_SYSCALL (CLONE_PARENT_SETTID | SIGCHLD, 0, &pid, NULL, NULL)
+#endif
+
+#include "../system.c"
diff -Nur sysdeps/unix/sysv/linux/sparc/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/vfork.S
--- sysdeps/unix/sysv/linux/sparc/vfork.S	2001-07-07 21:21:36.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sparc/vfork.S	2002-12-31 21:37:31.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jj@ultra.linux.cz>, 1999.
 
@@ -25,4 +25,5 @@
 	 and	%o0, %o1, %o0
 
 PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/speed.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/speed.c
--- sysdeps/unix/sysv/linux/speed.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/speed.c	2003-09-09 08:44:48.000000000 +0200
@@ -1,5 +1,6 @@
 /* `struct termios' speed frobnication functions.  Linux version.
-   Copyright (C) 1991,92,93,95,96,97,98,2000,02 Free Software Foundation, Inc.
+   Copyright (C) 1991,1992,1993,1995,1996,1997,1998,2000,2002,2003
+	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -66,6 +67,9 @@
       return -1;
     }
 
+#ifdef _HAVE_STRUCT_TERMIOS_C_OSPEED
+  termios_p->c_ospeed = speed;
+#endif
   termios_p->c_cflag &= ~(CBAUD | CBAUDEX);
   termios_p->c_cflag |= speed;
 
@@ -90,6 +94,9 @@
       return -1;
     }
 
+#ifdef _HAVE_STRUCT_TERMIOS_C_ISPEED
+  termios_p->c_ispeed = speed;
+#endif
   if (speed == 0)
     termios_p->c_iflag |= IBAUD0;
   else
diff -Nur sysdeps/unix/sysv/linux/s_pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s_pread64.c
--- sysdeps/unix/sysv/linux/s_pread64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s_pread64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-/* This file is used if no system call is available.  */
-ssize_t
-__syscall_pread64 (int fd, char *buf, size_t count,
-		   off_t offset_hi, off_t offset_lo)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/s_pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s_pwrite64.c
--- sysdeps/unix/sysv/linux/s_pwrite64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/s_pwrite64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-/* This file is used if no system call is available.  */
-ssize_t
-__syscall_pwrite64 (int fd, const char *buf, size_t count,
-		    off_t offset_hi, off_t offset_lo)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
diff -Nur sysdeps/unix/sysv/linux/statfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statfs64.c
--- sysdeps/unix/sysv/linux/statfs64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statfs64.c	2004-04-03 09:47:05.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return information about the filesystem on which FILE resides.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996-2000,2003,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,11 +21,36 @@
 #include <string.h>
 #include <sys/statfs.h>
 #include <stddef.h>
+#include <sysdep.h>
+
+
+# if __ASSUME_STATFS64 == 0
+int __no_statfs64 attribute_hidden;
+#endif
 
 /* Return information about the filesystem on which FILE resides.  */
 int
 __statfs64 (const char *file, struct statfs64 *buf)
 {
+#ifdef __NR_statfs64
+# if __ASSUME_STATFS64 == 0
+  if (! __no_statfs64)
+# endif
+    {
+      int result = INLINE_SYSCALL (statfs64, 3, file, sizeof (*buf), buf);
+
+# if __ASSUME_STATFS64 == 0
+      if (result == 0 || errno != ENOSYS)
+# endif
+	return result;
+
+# if __ASSUME_STATFS64 == 0
+      __no_statfs64 = 1;
+# endif
+    }
+#endif
+
+#if __ASSUME_STATFS64 == 0
   struct statfs buf32;
 
   if (__statfs (file, &buf32) < 0)
@@ -40,8 +65,10 @@
   buf->f_ffree = buf32.f_ffree;
   buf->f_fsid = buf32.f_fsid;
   buf->f_namelen = buf32.f_namelen;
+  buf->f_frsize = buf32.f_frsize;
   memcpy (buf->f_spare, buf32.f_spare, sizeof (buf32.f_spare));
 
   return 0;
+#endif
 }
 weak_alias (__statfs64, statfs64)
diff -Nur sysdeps/unix/sysv/linux/statvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statvfs64.c
--- sysdeps/unix/sysv/linux/statvfs64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statvfs64.c	2004-04-03 09:49:22.000000000 +0200
@@ -1,5 +1,5 @@
 /* Return information about the filesystem on which FILE resides.
-   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2000, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,32 +18,57 @@
    02111-1307 USA.  */
 
 #include <errno.h>
-#include <sys/statvfs.h>
 #include <stddef.h>
 #include <string.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/statvfs.h>
+#include "kernel-features.h"
+
+
+extern void __internal_statvfs64 (const char *name, struct statvfs64 *buf,
+				  struct statfs64 *fsbuf, struct stat64 *st);
+
 
 /* Return information about the filesystem on which FILE resides.  */
 int
 __statvfs64 (const char *file, struct statvfs64 *buf)
 {
-  struct statvfs buf32;
-
-  if (statvfs (file, &buf32) < 0)
-    return -1;
+  struct statfs64 fsbuf;
+  int res = __statfs64 (file, &fsbuf);
 
-  buf->f_bsize = buf32.f_bsize;
-  buf->f_frsize = buf32.f_frsize;
-  buf->f_blocks = buf32.f_blocks;
-  buf->f_bfree = buf32.f_bfree;
-  buf->f_bavail = buf32.f_bavail;
-  buf->f_files = buf32.f_files;
-  buf->f_ffree = buf32.f_ffree;
-  buf->f_favail = buf32.f_favail;
-  buf->f_fsid = buf32.f_fsid;
-  buf->f_flag = buf32.f_flag;
-  buf->f_namemax = buf32.f_namemax;
-  memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
+#ifndef __ASSUME_STATFS64
+  if (res < 0 && errno == ENOSYS)
+    {
+      struct statvfs buf32;
+
+      res = statvfs (file, &buf32);
+      if (res == 0)
+	{
+	  buf->f_bsize = buf32.f_bsize;
+	  buf->f_frsize = buf32.f_frsize;
+	  buf->f_blocks = buf32.f_blocks;
+	  buf->f_bfree = buf32.f_bfree;
+	  buf->f_bavail = buf32.f_bavail;
+	  buf->f_files = buf32.f_files;
+	  buf->f_ffree = buf32.f_ffree;
+	  buf->f_favail = buf32.f_favail;
+	  buf->f_fsid = buf32.f_fsid;
+	  buf->f_flag = buf32.f_flag;
+	  buf->f_namemax = buf32.f_namemax;
+	  memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
+	}
+    }
+#endif
+
+  if (res == 0)
+    {
+      /* Convert the result.  */
+      struct stat64 st;
+      __internal_statvfs64 (file, buf, &fsbuf,
+			    stat64 (file, &st) == -1 ? NULL : &st);
+    }
 
-  return 0;
+  return res;
 }
 weak_alias (__statvfs64, statvfs64)
diff -Nur sysdeps/unix/sysv/linux/statvfs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statvfs.c
--- sysdeps/unix/sysv/linux/statvfs.c	2002-09-21 07:36:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/statvfs.c	2003-09-17 02:46:04.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -17,16 +17,14 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <errno.h>
-#include <mntent.h>
-#include <paths.h>
-#include <stdio_ext.h>
-#include <string.h>
-#include <sys/mount.h>
+#include <stddef.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
 #include <sys/statvfs.h>
 
+extern void __internal_statvfs (const char *name, struct statvfs *buf,
+				struct statfs *fsbuf, struct stat64 *st);
+
 
 int
 statvfs (const char *file, struct statvfs *buf)
@@ -38,8 +36,9 @@
   if (__statfs (file, &fsbuf) < 0)
     return -1;
 
-#define STAT(st) stat64 (file, st)
-#include "internal_statvfs.c"
+  /* Convert the result.  */
+  __internal_statvfs (file, buf, &fsbuf,
+		      stat64 (file, &st) == -1 ? NULL : &st);
 
   /* We signal success if the statfs call succeeded.  */
   return 0;
diff -Nur sysdeps/unix/sysv/linux/sys/epoll.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/epoll.h
--- sysdeps/unix/sysv/linux/sys/epoll.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/epoll.h	2004-01-21 07:19:00.000000000 +0100
@@ -0,0 +1,107 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H	1
+
+#include <stdint.h>
+#include <sys/types.h>
+
+
+enum EPOLL_EVENTS
+  {
+    EPOLLIN = 0x001,
+#define EPOLLIN EPOLLIN
+    EPOLLPRI = 0x002,
+#define EPOLLPRI EPOLLPRI
+    EPOLLOUT = 0x004,
+#define EPOLLOUT EPOLLOUT
+    EPOLLRDNORM = 0x040,
+#define EPOLLRDNORM EPOLLRDNORM
+    EPOLLRDBAND = 0x080,
+#define EPOLLRDBAND EPOLLRDBAND
+    EPOLLWRNORM = 0x100,
+#define EPOLLWRNORM EPOLLWRNORM
+    EPOLLWRBAND = 0x200,
+#define EPOLLWRBAND EPOLLWRBAND
+    EPOLLMSG = 0x400,
+#define EPOLLMSG EPOLLMSG
+    EPOLLERR = 0x008,
+#define EPOLLERR EPOLLERR
+    EPOLLHUP = 0x010,
+#define EPOLLHUP EPOLLHUP
+    EPOLLONESHOT = (1 << 30),
+#define EPOLLONESHOT EPOLLONESHOT
+    EPOLLET = (1 << 31)
+#define EPOLLET EPOLLET
+  };
+
+
+/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */
+#define EPOLL_CTL_ADD 1	/* Add a file decriptor to the interface.  */
+#define EPOLL_CTL_DEL 2	/* Remove a file decriptor from the interface.  */
+#define EPOLL_CTL_MOD 3	/* Change file decriptor epoll_event structure.  */
+
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+};
+
+
+__BEGIN_DECLS
+
+/* Creates an epoll instance.  Returns an fd for the new instance.
+   The "size" parameter is a hint specifying the number of file
+   descriptors to be associated with the new instance.  The fd
+   returned by epoll_create() should be closed with close().  */
+extern int epoll_create (int __size) __THROW;
+
+
+/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
+   -1 in case of error ( the "errno" variable will contain the
+   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
+   constants defined above. The "fd" parameter is the target of the
+   operation. The "event" parameter describes which events the caller
+   is interested in and any associated user data.  */
+extern int epoll_ctl (int __epfd, int __op, int __fd,
+		      struct epoll_event *__event) __THROW;
+
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).  */
+extern int epoll_wait (int __epfd, struct epoll_event *__events,
+		       int __maxevents, int __timeout) __THROW;
+
+__END_DECLS
+
+#endif /* sys/epoll.h */
diff -Nur sysdeps/unix/sysv/linux/sys/mount.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/mount.h
--- sysdeps/unix/sysv/linux/sys/mount.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/mount.h	2004-09-23 16:06:51.000000000 +0200
@@ -1,5 +1,5 @@
 /* Header file for mounting/unmount Linux filesystems.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1996,1997,1998,1999,2000,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -62,7 +62,8 @@
 };
 
 /* Flags that can be altered by MS_REMOUNT  */
-#define MS_RMT_MASK (MS_RDONLY | MS_MANDLOCK)
+#define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_NOATIME \
+		     |MS_NODIRATIME)
 
 
 /* Magic mount flag number. Has to be or-ed to the flag values.  */
@@ -82,6 +83,14 @@
 #define BLKFLSBUF  _IO(0x12, 97) /* Flush buffer cache.  */
 #define BLKRASET   _IO(0x12, 98) /* Set read ahead for block device.  */
 #define BLKRAGET   _IO(0x12, 99) /* Get current read ahead setting.  */
+#define BLKFRASET  _IO(0x12,100) /* Set filesystem read-ahead.  */
+#define BLKFRAGET  _IO(0x12,101) /* Get filesystem read-ahead.  */
+#define BLKSECTSET _IO(0x12,102) /* Set max sectors per request.  */
+#define BLKSECTGET _IO(0x12,103) /* Get max sectors per request.  */
+#define BLKSSZGET  _IO(0x12,104) /* Get block device sector size.  */
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t) /* return device size.  */
 
 
 /* Possible value for FLAGS parameter of `umount2'.  */
diff -Nur sysdeps/unix/sysv/linux/sys/param.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/param.h
--- sysdeps/unix/sysv/linux/sys/param.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/param.h	2003-06-14 07:17:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1995,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -49,10 +49,16 @@
 
 /* Macros for counting and rounding.  */
 #ifndef howmany
-# define howmany(x, y)	(((x)+((y)-1))/(y))
+# define howmany(x, y)	(((x) + ((y) - 1)) / (y))
 #endif
-#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))
-#define powerof2(x)	((((x)-1)&(x))==0)
+#ifdef __GNUC__
+# define roundup(x, y)	(__builtin_constant_p (y) && powerof2 (y)	      \
+			 ? (((x) + (y) - 1) & ~((y) - 1))		      \
+			 : ((((x) + ((y) - 1)) / (y)) * (y)))
+#else
+# define roundup(x, y)	((((x) + ((y) - 1)) / (y)) * (y))
+#endif
+#define powerof2(x)	((((x) - 1) & (x)) == 0)
 
 /* Macros for min/max.  */
 #define	MIN(a,b) (((a)<(b))?(a):(b))
diff -Nur sysdeps/unix/sysv/linux/sys/sysctl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/sysctl.h
--- sysdeps/unix/sysv/linux/sys/sysctl.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/sysctl.h	2004-04-29 22:09:24.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,16 +17,52 @@
    02111-1307 USA.  */
 
 #ifndef	_SYS_SYSCTL_H
-
 #define	_SYS_SYSCTL_H	1
-#include <features.h>
-
-__BEGIN_DECLS
 
+#include <features.h>
 #define __need_size_t
 #include <stddef.h>
+/* Prevent more kernel headers than necessary to be included.  */
+#ifndef _LINUX_KERNEL_H
+# define _LINUX_KERNEL_H	1
+# define __undef_LINUX_KERNEL_H
+#endif
+#ifndef _LINUX_TYPES_H
+# define _LINUX_TYPES_H		1
+# define __undef_LINUX_TYPES_H
+#endif
+#ifndef _LINUX_LIST_H
+# define _LINUX_LIST_H		1
+# define __undef_LINUX_LIST_H
+#endif
+#ifndef __LINUX_COMPILER_H
+# define __LINUX_COMPILER_H	1
+# define __user
+# define __undef__LINUX_COMPILER_H
+#endif
+
 #include <linux/sysctl.h>
 
+#ifdef __undef_LINUX_KERNEL_H
+# undef _LINUX_KERNEL_H
+# undef __undef_LINUX_KERNEL_H
+#endif
+#ifdef __undef_LINUX_TYPES_H
+# undef _LINUX_TYPES_H
+# undef __undef_LINUX_TYPES_H
+#endif
+#ifdef __undef_LINUX_LIST_H
+# undef _LINUX_LIST_H
+# undef __undef_LINUX_LIST_H
+#endif
+#ifdef __undef__LINUX_COMPILER_H
+# undef __LINUX_COMPILER_H
+# undef __user
+# undef __undef__LINUX_COMPILER_H
+#endif
+
+__BEGIN_DECLS
+
 /* Read or write system parameters.  */
 extern int sysctl (int *__name, int __nlen, void *__oldval,
 		   size_t *__oldlenp, void *__newval, size_t __newlen) __THROW;
diff -Nur sysdeps/unix/sysv/linux/sys/sysmacros.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/sysmacros.h
--- sysdeps/unix/sysv/linux/sys/sysmacros.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sys/sysmacros.h	2004-09-08 00:18:59.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions of macros to access `dev_t' values.
-   Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1999, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,30 +20,50 @@
 #ifndef _SYS_SYSMACROS_H
 #define _SYS_SYSMACROS_H	1
 
-/* For compatibility we provide alternative names.
+#include <features.h>
 
-   The problem here is that compilers other than GCC probably don't
-   have the `long long' type and so `dev_t' is actually an array.  */
-#if defined __GNUC__ && __GNUC__ >= 2
-# define major(dev) ((int)(((dev) >> 8) & 0xff))
-# define minor(dev) ((int)((dev) & 0xff))
-# define makedev(major, minor) ((((unsigned int) (major)) << 8) \
-				| ((unsigned int) (minor)))
-#else
-/* We need to know the word order here.  This assumes that the word order
-   is consistent with the byte order.  */
-# include <endian.h>
-# if __BYTE_ORDER == __BIG_ENDIAN
-#  define major(dev) (((dev).__val[1] >> 8) & 0xff)
-#  define minor(dev) ((dev).__val[1] & 0xff)
-#  define makedev(major, minor) { 0, ((((unsigned int) (major)) << 8) \
-				      | ((unsigned int) (minor))) }
-# else
-#  define major(dev) (((dev).__val[0] >> 8) & 0xff)
-#  define minor(dev) ((dev).__val[0] & 0xff)
-#  define makedev(major, minor) { ((((unsigned int) (major)) << 8) \
-				   | ((unsigned int) (minor))), 0 }
+/* If the compiler does not know long long it is out of luck.  We are
+   not going to hack weird hacks to support the dev_t representation
+   they need.  */
+#ifdef __GLIBC_HAVE_LONG_LONG
+__extension__
+extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
+     __THROW;
+__extension__
+extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
+     __THROW;
+__extension__
+extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
+							unsigned int __minor)
+     __THROW;
+
+# if defined __GNUC__ && __GNUC__ >= 2
+__extension__ extern __inline unsigned int
+__NTH (gnu_dev_major (unsigned long long int __dev))
+{
+  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
+}
+
+__extension__ extern __inline unsigned int
+__NTH (gnu_dev_minor (unsigned long long int __dev))
+{
+  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
+}
+
+__extension__ extern __inline unsigned long long int
+__NTH (gnu_dev_makedev (unsigned int __major, unsigned int __minor))
+{
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int) (__minor & ~0xff)) << 12)
+	  | (((unsigned long long int) (__major & ~0xfff)) << 32));
+}
 # endif
+
+
+/* Access the functions with their traditional names.  */
+# define major(dev) gnu_dev_major (dev)
+# define minor(dev) gnu_dev_minor (dev)
+# define makedev(maj, min) gnu_dev_makedev (maj, min)
 #endif
 
 #endif /* sys/sysmacros.h */
diff -Nur sysdeps/unix/sysv/linux/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/syscalls.list
--- sysdeps/unix/sysv/linux/syscalls.list	2002-08-15 14:57:22.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/syscalls.list	2004-11-12 02:15:38.000000000 +0100
@@ -1,27 +1,37 @@
 # File name	Caller	Syscall name	Args	Strong name	Weak names
 
+add_key		EXTRA	add_key		i:pppii	add_key
 adjtimex	adjtime	adjtimex	i:p	__adjtimex	adjtimex ntp_adjtime __adjtimex_internal
 bdflush		EXTRA	bdflush		i:ii	bdflush
 capget		EXTRA	capget		i:pp	capget
 capset		EXTRA	capset		i:pp	capset
+creat		-	creat		Ci:si	__libc_creat creat
 create_module	EXTRA	create_module	3	create_module
 delete_module	EXTRA	delete_module	3	delete_module
+epoll_create	EXTRA	epoll_create	i:i	epoll_create
+epoll_ctl	EXTRA	epoll_ctl	i:iiip	epoll_ctl
+epoll_wait	EXTRA	epoll_wait	i:ipii	epoll_wait
 fdatasync	-	fdatasync	i:i	fdatasync
 flock		-	flock		i:ii	__flock		flock
 fork		-	fork		i:	__libc_fork	__fork fork
 get_kernel_syms	EXTRA	get_kernel_syms	i:p	get_kernel_syms
-getegid		-	getegid		i:	__getegid	getegid
-geteuid		-	geteuid		i:	__geteuid	geteuid
+getegid		-	getegid		Ei:	__getegid	getegid
+geteuid		-	geteuid		Ei:	__geteuid	geteuid
 getpgid		-	getpgid		i:i	__getpgid	getpgid
-getpgrp		-	getpgrp		i:	getpgrp
-getppid		-	getppid		i:	__getppid	getppid
+getpgrp		-	getpgrp		Ei:	getpgrp
+getpmsg		-	getpmsg		i:ipppp	getpmsg
+getppid		-	getppid		Ei:	__getppid	getppid
+getresuid	-	getresuid	i:ppp	getresuid
+getresgid	-	getresgid	i:ppp	getresgid
 getsid		-	getsid		i:i	getsid
 init_module	EXTRA	init_module	5	init_module
 ioperm		-	ioperm		i:iii	ioperm
 iopl		-	iopl		i:i	iopl
+keyctl		EXTRA	keyctl		i:iiiii	keyctl
 klogctl		EXTRA	syslog		i:isi	klogctl
 lchown		-	lchown		i:sii	__lchown	lchown
-madvise		-	madvise		i:pii	posix_madvise	madvise
+posix_madvise	-	madvise		Vi:pii	posix_madvise
+madvise		-	madvise		i:pii	madvise
 mincore		-	mincore		i:anV	mincore
 mlock		-	mlock		i:bn	mlock
 mlockall	-	mlockall	i:i	mlockall
@@ -30,33 +40,32 @@
 mremap		EXTRA	mremap		b:aini	__mremap	mremap
 munlock		-	munlock		i:ai	munlock
 munlockall	-	munlockall	i:	munlockall
-nanosleep	-	nanosleep	i:pp	__libc_nanosleep	__nanosleep nanosleep
+nanosleep	-	nanosleep	Ci:pp	__libc_nanosleep	__nanosleep nanosleep
 nfsservctl	EXTRA	nfsservctl	i:ipp	nfsservctl
-pause		-	pause		i:	__libc_pause	pause
+pause		-	pause		Ci:	__libc_pause	pause
 personality	init-first personality	i:i	__personality	personality
 pipe		-	pipe		i:f	__pipe		pipe
 pivot_root	EXTRA	pivot_root	i:ss	pivot_root
-prctl		EXTRA	prctl		i:iiiii	prctl
+prctl		EXTRA	prctl		i:iiiii	__prctl		prctl
+putpmsg		-	putpmsg		i:ippii	putpmsg
 query_module	EXTRA	query_module	i:sipip	query_module
 quotactl	EXTRA	quotactl	i:isip	quotactl
-sched_getaffinity -	sched_getaffinity	i:iip	sched_getaffinity
+remap_file_pages -	remap_file_pages i:piiii	__remap_file_pages remap_file_pages
+request_key	EXTRA	request_key	i:pppi	request_key
 sched_getp	-	sched_getparam	i:ip	__sched_getparam	sched_getparam
 sched_gets	-	sched_getscheduler	i:i	__sched_getscheduler	sched_getscheduler
 sched_primax	-	sched_get_priority_max	i:i	__sched_get_priority_max	sched_get_priority_max
 sched_primin	-	sched_get_priority_min	i:i	__sched_get_priority_min	sched_get_priority_min
 sched_rr_gi	-	sched_rr_get_interval	i:ip	__sched_rr_get_interval	sched_rr_get_interval
-sched_setaffinity -	sched_setaffinity	i:iip	sched_setaffinity
 sched_setp	-	sched_setparam	i:ip	__sched_setparam	sched_setparam
 sched_sets	-	sched_setscheduler	i:iip	__sched_setscheduler	sched_setscheduler
 sched_yield	-	sched_yield	i:	__sched_yield	sched_yield
-select		-	_newselect	i:iPPPP	__select	select
+select		-	_newselect	Ci:iPPPP	__select	__libc_select select
 sendfile	-	sendfile	i:iipi	sendfile
 sendfile64	-	sendfile64	i:iipi	sendfile64
 setfsgid	EXTRA	setfsgid	i:i	setfsgid
 setfsuid	EXTRA	setfsuid	i:i	setfsuid
 setpgid		-	setpgid		i:ii	__setpgid	setpgid
-setresuid	EXTRA	setresuid	i:iii	__setresuid	setresuid
-setresgid	EXTRA	setresgid	i:iii	__setresgid	setresgid
 sigaltstack	-	sigaltstack	i:PP	__sigaltstack	sigaltstack
 sysinfo		EXTRA	sysinfo		i:p	sysinfo
 swapon		-	swapon		i:si	__swapon	swapon
@@ -65,18 +74,20 @@
 wait4		-	wait4		i:iWiP	__wait4		wait4
 
 chown		-	chown		i:sii	__libc_chown	__chown chown
-fcntl		-	fcntl		i:iiF	__libc_fcntl	__fcntl fcntl
 
-setxattr	EXTRA	setxattr	i:sspii	setxattr
-lsetxattr	EXTRA	lsetxattr	i:sspii	lsetxattr
-fsetxattr	EXTRA	fsetxattr	i:ispii	fsetxattr
-getxattr	EXTRA	getxattr	i:sspi	getxattr
-lgetxattr	EXTRA	lgetxattr	i:sspi	lgetxattr
-fgetxattr	EXTRA	fgetxattr	i:ispi	fgetxattr
-listxattr	EXTRA	listxattr	i:ssi	listxattr
-llistxattr	EXTRA	llistxattr	i:ssi	llistxattr
-flistxattr	EXTRA	flistxattr	i:isi	flistxattr
-removexattr	EXTRA	removexattr	i:ss	removexattr
-lremovexattr	EXTRA	lremovexattr	i:ss	lremovexattr
-fremovexattr	EXTRA	fremovexattr	i:is	fremovexattr
+setxattr	-	setxattr	i:sspii	setxattr
+lsetxattr	-	lsetxattr	i:sspii	lsetxattr
+fsetxattr	-	fsetxattr	i:ispii	fsetxattr
+getxattr	-	getxattr	i:sspi	getxattr
+lgetxattr	-	lgetxattr	i:sspi	lgetxattr
+fgetxattr	-	fgetxattr	i:ispi	fgetxattr
+listxattr	-	listxattr	i:ssi	listxattr
+llistxattr	-	llistxattr	i:ssi	llistxattr
+flistxattr	-	flistxattr	i:isi	flistxattr
+removexattr	-	removexattr	i:ss	removexattr
+lremovexattr	-	lremovexattr	i:ss	lremovexattr
+fremovexattr	-	fremovexattr	i:is	fremovexattr
 
+mq_timedsend	-	mq_timedsend	Ci:ipiip	__GI_mq_timedsend	mq_timedsend
+mq_timedreceive	-	mq_timedreceive	Ci:ipipp	__GI_mq_timedreceive	mq_timedreceive
+mq_setattr	-	mq_getsetattr	i:ipp	__GI_mq_setattr	mq_setattr
diff -Nur sysdeps/unix/sysv/linux/sysconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sysconf.c
--- sysdeps/unix/sysv/linux/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sysconf.c	2004-06-01 20:46:03.000000000 +0200
@@ -0,0 +1,96 @@
+/* Get file-specific information about a file.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+#include <not-cancel.h>
+
+static long int posix_sysconf (int name);
+
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  const char *procfname = NULL;
+
+  switch (name)
+    {
+#ifdef __NR_clock_getres
+    case _SC_MONOTONIC_CLOCK:
+      /* Check using the clock_getres system call.  */
+      {
+	struct timespec ts;
+	INTERNAL_SYSCALL_DECL (err);
+	int r;
+	r = INTERNAL_SYSCALL (clock_getres, err, 2, CLOCK_MONOTONIC, &ts);
+	return INTERNAL_SYSCALL_ERROR_P (r, err) ? -1 : _POSIX_VERSION;
+      }
+#endif
+
+    case _SC_NGROUPS_MAX:
+      /* Try to read the information from the /proc/sys/kernel/ngroups_max
+	 file.  */
+      procfname = "/proc/sys/kernel/ngroups_max";
+      break;
+
+    case _SC_SIGQUEUE_MAX:
+      /* The /proc/sys/kernel/rtsig-max file contains the answer.  */
+      procfname = "/proc/sys/kernel/rtsig-max";
+      break;
+
+    default:
+      break;
+    }
+
+  if (procfname != NULL)
+    {
+      int fd = open_not_cancel_2 (procfname, O_RDONLY);
+      if (fd != -1)
+	{
+	  /* This is more than enough, the file contains a single integer.  */
+	  char buf[32];
+	  ssize_t n;
+	  n = TEMP_FAILURE_RETRY (read_not_cancel (fd, buf, sizeof (buf) - 1));
+	  close_not_cancel_no_status (fd);
+
+	  if (n > 0)
+	    {
+	      /* Terminate the string.  */
+	      buf[n] = '\0';
+
+	      char *endp;
+	      long int res = strtol (buf, &endp, 10);
+	      if (endp != buf && (*endp == '\0' || *endp == '\n'))
+		return res;
+	    }
+	}
+    }
+
+  return posix_sysconf (name);
+}
+
+/* Now the POSIX version.  */
+#undef __sysconf
+#define __sysconf static posix_sysconf
+#include <sysdeps/posix/sysconf.c>
diff -Nur sysdeps/unix/sysv/linux/sysctl.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sysctl.c
--- sysdeps/unix/sysv/linux/sysctl.c	2002-09-17 18:46:11.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/sysctl.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* Read or write system information.  Linux version.
-   Copyright (C) 1996-1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1996-1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,8 +24,6 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall__sysctl (struct __sysctl_args *__unbounded args);
-
 int
 __sysctl (int *name, int nlen, void *oldval, size_t *oldlenp,
 	  void *newval, size_t newlen)
@@ -33,12 +31,12 @@
   /* GKM FIXME: force __sysctl_args decl to have unbounded pointers.  */
   struct __sysctl_args args =
   {
-    name: name,
-    nlen: nlen,
-    oldval: oldval,
-    oldlenp: oldlenp,
-    newval: newval,
-    newlen: newlen
+    .name = name,
+    .nlen = nlen,
+    .oldval = oldval,
+    .oldlenp = oldlenp,
+    .newval = newval,
+    .newlen = newlen
   };
   (void) CHECK_N (name, nlen);
   (void) CHECK_N (oldval, *oldlenp);
diff -Nur sysdeps/unix/sysv/linux/syslog.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/syslog.c
--- sysdeps/unix/sysv/linux/syslog.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/syslog.c	2005-02-16 12:00:15.000000000 +0100
@@ -0,0 +1,10 @@
+#include "kernel-features.h"
+
+#if __ASSUME_MSG_NOSIGNAL
+# define NO_SIGPIPE
+# define send_flags MSG_NOSIGNAL
+#else
+# define send_flags 0
+#endif
+
+#include <sysdeps/generic/syslog.c>
diff -Nur sysdeps/unix/sysv/linux/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/system.c
--- sysdeps/unix/sysv/linux/system.c	1996-09-12 20:29:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/system.c	2003-04-17 18:32:58.000000000 +0200
@@ -1,2 +1,77 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <bits/libc-lock.h>
+#include <kernel-features.h>
+
+/* We have to and actually can handle cancelable system().  The big
+   problem: we have to kill the child process if necessary.  To do
+   this a cleanup handler has to be registered and is has to be able
+   to find the PID of the child.  The main problem is to reliable have
+   the PID when needed.  It is not necessary for the parent thread to
+   return.  It might still be in the kernel when the cancellation
+   request comes.  Therefore we have to use the clone() calls ability
+   to have the kernel write the PID into the user-level variable.  */
+#if defined __ASSUME_CLONE_THREAD_FLAGS && !defined FORK
+# define FORK() \
+  INLINE_SYSCALL (clone, 3, CLONE_PARENT_SETTID | SIGCHLD, 0, &pid)
+#endif
+
+#ifdef _LIBC_REENTRANT
+static void cancel_handler (void *arg);
+
+# define CLEANUP_HANDLER \
+  __libc_cleanup_region_start (1, cancel_handler, &pid)
+
+# define CLEANUP_RESET \
+  __libc_cleanup_region_end (0)
+#endif
+
+
 /* Linux has waitpid(), so override the generic unix version.  */
 #include <sysdeps/posix/system.c>
+
+
+#ifdef _LIBC_REENTRANT
+/* The cancellation handler.  */
+static void
+cancel_handler (void *arg)
+{
+  pid_t child = *(pid_t *) arg;
+
+  INTERNAL_SYSCALL_DECL (err);
+  INTERNAL_SYSCALL (kill, err, 2, child, SIGKILL);
+
+  TEMP_FAILURE_RETRY (__waitpid (child, NULL, 0));
+
+  DO_LOCK ();
+
+  if (SUB_REF () == 0)
+    {
+      (void) __sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
+      (void) __sigaction (SIGINT, &intr, (struct sigaction *) NULL);
+    }
+
+  DO_UNLOCK ();
+}
+#endif
diff -Nur sysdeps/unix/sysv/linux/tcdrain.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcdrain.c
--- sysdeps/unix/sysv/linux/tcdrain.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcdrain.c	2002-12-15 11:25:23.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,14 +16,26 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include <sysdep-cancel.h>
 
 /* Wait for pending output to be written on FD.  */
 int
 __libc_tcdrain (int fd)
 {
+  if (SINGLE_THREAD_P)
+    /* With an argument of 1, TCSBRK for output to be drain.  */
+    return INLINE_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
   /* With an argument of 1, TCSBRK for output to be drain.  */
-  return __ioctl (fd, TCSBRK, 1);
+  int result = INLINE_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 weak_alias (__libc_tcdrain, tcdrain)
diff -Nur sysdeps/unix/sysv/linux/tcgetattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcgetattr.c
--- sysdeps/unix/sysv/linux/tcgetattr.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcgetattr.c	2003-09-10 21:16:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1992, 1995, 1997, 1998 Free Software Foundation, Inc.
+/* Copyright (C) 1992, 1995, 1997, 1998, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,11 +16,13 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
 #include <string.h>
 #include <termios.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
+#include <sysdep.h>
 
 /* The difference here is that the termios structure used in the
    kernel is not the same as we use in the libc.  Therefore we must
@@ -36,18 +38,26 @@
   struct __kernel_termios k_termios;
   int retval;
 
-  retval = __ioctl (fd, TCGETS, &k_termios);
+  retval = INLINE_SYSCALL (ioctl, 3, fd, TCGETS, &k_termios);
 
   termios_p->c_iflag = k_termios.c_iflag;
   termios_p->c_oflag = k_termios.c_oflag;
   termios_p->c_cflag = k_termios.c_cflag;
   termios_p->c_lflag = k_termios.c_lflag;
   termios_p->c_line = k_termios.c_line;
-#ifdef _HAVE_C_ISPEED
+#ifdef _HAVE_STRUCT_TERMIOS_C_ISPEED
+# ifdef _HAVE_C_ISPEED
   termios_p->c_ispeed = k_termios.c_ispeed;
+# else
+  termios_p->c_ispeed = k_termios.c_cflag & (CBAUD | CBAUDEX);
+# endif
 #endif
-#ifdef _HAVE_C_OSPEED
+#ifdef _HAVE_STRUCT_TERMIOS_C_OSPEED
+# ifdef _HAVE_C_OSPEED
   termios_p->c_ospeed = k_termios.c_ospeed;
+# else
+  termios_p->c_ospeed = k_termios.c_cflag & (CBAUD | CBAUDEX);
+# endif
 #endif
   if (sizeof (cc_t) == 1 || _POSIX_VDISABLE == 0
       || (unsigned char) _POSIX_VDISABLE == (unsigned char) -1)
diff -Nur sysdeps/unix/sysv/linux/tcsetattr.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcsetattr.c
--- sysdeps/unix/sysv/linux/tcsetattr.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/tcsetattr.c	2003-09-10 21:16:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1993, 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1993,1996,1997,1998,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +21,7 @@
 #include <termios.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
+#include <sysdep.h>
 
 /* The difference here is that the termios structure used in the
    kernel is not the same as we use in the libc.  Therefore we must
@@ -36,14 +37,7 @@
    We use an unused bit in the `c_iflag' field to keep track of this
    use of `cfsetispeed'.  The value here must correspond to the one used
    in `speed.c'.  */
-#if !defined _HAVE_C_ISPEED || !defined _HAVE_C_OSPEED
-# define IBAUD0	020000000000
-#else
-/* If we have separate values for input and output speed don't bother
-   with this.  Define the value as zero so the compiler sees we don't
-   have to do the AND below.  */
-# define IBAUD0	0
-#endif
+#define IBAUD0	020000000000
 
 
 /* Set the state of FD to *TERMIOS_P.  */
@@ -55,7 +49,6 @@
 {
   struct __kernel_termios k_termios;
   unsigned long int cmd;
-  int retval;
 
   switch (optional_actions)
     {
@@ -78,44 +71,15 @@
   k_termios.c_cflag = termios_p->c_cflag;
   k_termios.c_lflag = termios_p->c_lflag;
   k_termios.c_line = termios_p->c_line;
-#ifdef _HAVE_C_ISPEED
+#if defined _HAVE_C_ISPEED && defined _HAVE_STRUCT_TERMIOS_C_ISPEED
   k_termios.c_ispeed = termios_p->c_ispeed;
 #endif
-#ifdef _HAVE_C_OSPEED
+#if defined _HAVE_C_OSPEED && defined _HAVE_STRUCT_TERMIOS_C_OSPEED
   k_termios.c_ospeed = termios_p->c_ospeed;
 #endif
   memcpy (&k_termios.c_cc[0], &termios_p->c_cc[0],
 	  __KERNEL_NCCS * sizeof (cc_t));
 
-  retval = __ioctl (fd, cmd, &k_termios);
-
-  if (retval == 0 && cmd == TCSETS)
-    {
-      /* The Linux kernel has a bug which silently ignore the invalid
-	 c_cflag on pty. We have to check it here. */
-      int save = errno;
-      retval = __ioctl (fd, TCGETS, &k_termios);
-      if (retval)
-	{
-	  /* We cannot verify if the setting is ok. We don't return
-	     an error (?). */
-	  __set_errno (save);
-	  retval = 0;
-	}
-      else if ((termios_p->c_cflag & (PARENB | CREAD))
-	       != (k_termios.c_cflag & (PARENB | CREAD))
-	       || ((termios_p->c_cflag & CSIZE)
-		   && ((termios_p->c_cflag & CSIZE)
-		       != (k_termios.c_cflag & CSIZE))))
-	{
-	  /* It looks like the Linux kernel silently changed the
-	     PARENB/CREAD/CSIZE bits in c_cflag. Report it as an
-	     error. */
-	  __set_errno (EINVAL);
-	  retval = -1;
-	}
-    }
-
-  return retval;
+  return INLINE_SYSCALL (ioctl, 3, fd, cmd, &k_termios);
 }
 libc_hidden_def (tcsetattr)
diff -Nur sysdeps/unix/sysv/linux/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/truncate64.c
--- sysdeps/unix/sysv/linux/truncate64.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/truncate64.c	2004-06-30 09:37:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2000, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -33,10 +33,6 @@
 int __have_no_truncate64;
 #endif
 
-/* The order of hight, low depends on endianness.  */
-extern int __syscall_truncate64 (const char *__unbounded path,
-				 int high_length, int low_length);
-
 /* Truncate the file FD refers to to LENGTH bytes.  */
 int
 truncate64 (const char *path, off64_t length)
@@ -69,7 +65,7 @@
       __set_errno (EINVAL);
       return -1;
     }
-  return truncate (path, (off_t) length);
+  return __truncate (path, (off_t) length);
 #endif
 }
 
diff -Nur sysdeps/unix/sysv/linux/ttyname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ttyname.c
--- sysdeps/unix/sysv/linux/ttyname.c	2002-09-24 07:12:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ttyname.c	2002-11-01 21:43:39.000000000 +0100
@@ -38,7 +38,7 @@
      internal_function;
 
 
-static char *getttyname_name;
+libc_freeres_ptr (static char *getttyname_name);
 
 static char *
 internal_function
@@ -103,7 +103,7 @@
 
 
 /* Static buffer in `ttyname'.  */
-static char *ttyname_buf;
+libc_freeres_ptr (static char *ttyname_buf);
 
 
 /* Return the pathname of the terminal FD is open on, or NULL on errors.
@@ -186,12 +186,3 @@
 
   return name;
 }
-
-
-static void
-free_mem (void)
-{
-  free (ttyname_buf);
-  free (getttyname_name);
-}
-text_set_element (__libc_subfreeres, free_mem);
diff -Nur sysdeps/unix/sysv/linux/ttyname_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ttyname_r.c
--- sysdeps/unix/sysv/linux/ttyname_r.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ttyname_r.c	2003-02-25 03:05:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,92,93,1995-1999,2000,2001 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,93,1995-2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -115,26 +115,33 @@
       return ERANGE;
     }
 
+  /* We try using the /proc filesystem.  */
+  *_fitoa_word (fd, __stpcpy (procname, "/proc/self/fd/"), 10, 0) = '\0';
+
+  ret = __readlink (procname, buf, buflen - 1);
+  if (ret == -1 && errno == ENOENT)
+    {
+      __set_errno (EBADF);
+      return EBADF;
+    }
+
   if (!__isatty (fd))
     {
       __set_errno (ENOTTY);
       return ENOTTY;
     }
 
-  /* We try using the /proc filesystem.  */
-  *_fitoa_word (fd, __stpcpy (procname, "/proc/self/fd/"), 10, 0) = '\0';
+  if (ret == -1 && errno == ENAMETOOLONG)
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
 
-  ret = __readlink (procname, buf, buflen - 1);
   if (ret != -1 && buf[0] != '[')
     {
       buf[ret] = '\0';
       return 0;
     }
-  if (ret == -1 && errno == ENAMETOOLONG)
-    {
-      __set_errno (ERANGE);
-      return ERANGE;
-    }
 
   if (__fxstat64 (_STAT_VER, fd, &st) < 0)
     return errno;
diff -Nur sysdeps/unix/sysv/linux/usleep.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/usleep.c
--- sysdeps/unix/sysv/linux/usleep.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/usleep.c	2003-06-15 23:15:25.000000000 +0200
@@ -1,5 +1,5 @@
 /* Implementation of the BSD usleep function using nanosleep.
-   Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1996, 1997, 1999, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -24,8 +24,11 @@
 int
 usleep (useconds_t useconds)
 {
-  struct timespec ts = { tv_sec: (long int) (useconds / 1000000),
-			 tv_nsec: (long int) (useconds % 1000000) * 1000ul };
+  struct timespec ts = { .tv_sec = (long int) (useconds / 1000000),
+			 .tv_nsec = (long int) (useconds % 1000000) * 1000ul };
 
+  /* Note the usleep() is a cancellation point.  But since we call
+     nanosleep() which itself is a cancellation point we do not have
+     to do anything here.  */
   return __nanosleep (&ts, NULL);
 }
diff -Nur sysdeps/unix/sysv/linux/ustat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ustat.c
--- sysdeps/unix/sysv/linux/ustat.c	2001-07-07 21:21:32.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/ustat.c	2003-09-27 19:00:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -25,15 +25,18 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_ustat (unsigned short int, struct ustat *__unbounded);
-
 int
 ustat (dev_t dev, struct ustat *ubuf)
 {
-  unsigned short int k_dev;
+  unsigned long long int k_dev;
 
   /* We must convert the value to dev_t type used by the kernel.  */
-  k_dev = ((major (dev) & 0xff) << 8) | (minor (dev) & 0xff);
+  k_dev =  dev & ((1ULL << 32) - 1);
+  if (k_dev != dev)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
 
-  return INLINE_SYSCALL (ustat, 2, k_dev, CHECK_1 (ubuf));
+  return INLINE_SYSCALL (ustat, 2, (unsigned int) k_dev, CHECK_1 (ubuf));
 }
diff -Nur sysdeps/unix/sysv/linux/utimes.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/utimes.c
--- sysdeps/unix/sysv/linux/utimes.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/utimes.c	2003-09-17 11:17:48.000000000 +0200
@@ -0,0 +1,60 @@
+/* Copyright (C) 1995, 1997, 2000, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <utime.h>
+#include <sys/time.h>
+#include <sysdep.h>
+#include "kernel-features.h"
+
+
+/* Change the access time of FILE to TVP[0] and
+   the modification time of FILE to TVP[1].  */
+int
+__utimes (const char *file, const struct timeval tvp[2])
+{
+#ifdef __NR_utimes
+  int result = INLINE_SYSCALL (utimes, 2, file, tvp);
+# ifndef __ASSUME_UTIMES
+  if (result != -1 || errno != ENOSYS)
+# endif
+    return result;
+#endif
+
+  /* The utimes() syscall does not exist or is not available in the
+     used kernel.  Use utime().  For this we have to convert to the
+     data format utime() expects.  */
+#ifndef __ASSUME_UTIMES
+  struct utimbuf buf;
+  struct utimbuf *times;
+
+  if (tvp != NULL)
+    {
+      times = &buf;
+      buf.actime = tvp[0].tv_sec + tvp[0].tv_usec / 1000000;
+      buf.modtime = tvp[1].tv_sec + tvp[1].tv_usec / 1000000;
+    }
+  else
+    times = NULL;
+
+  return INLINE_SYSCALL (utime, 2, file, times);
+#endif
+}
+
+weak_alias (__utimes, utimes)
diff -Nur sysdeps/unix/sysv/linux/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Versions
--- sysdeps/unix/sysv/linux/Versions	2002-08-30 07:20:47.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/Versions	2004-10-22 21:57:45.000000000 +0200
@@ -105,10 +105,17 @@
     #errlist-compat	126
     _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
   }
+  GLIBC_2.3.2 {
+    # New kernel interfaces.
+    epoll_create; epoll_ctl; epoll_wait;
+  }
+  GLIBC_2.3.3 {
+    gnu_dev_major; gnu_dev_minor; gnu_dev_makedev;
+  }
+  GLIBC_2.3.4 {
+    sched_getaffinity; sched_setaffinity;
+  }
   GLIBC_PRIVATE {
-    # needed by libpthread.
-    __libc_sigaction;
-
     # functions used in other libraries
     __syscall_rt_sigqueueinfo;
   }
diff -Nur sysdeps/unix/sysv/linux/wait.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wait.c
--- sysdeps/unix/sysv/linux/wait.c	1996-03-21 01:37:12.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wait.c	2003-06-16 21:02:42.000000000 +0200
@@ -1 +1,45 @@
-#include <sysdeps/unix/bsd/bsd4.4/wait.c>
+/* Copyright (C) 1991,1995,1996,1997,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/wait.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <stddef.h>
+#include <sysdep-cancel.h>
+
+/* Wait for a child to die.  When one does, put its status in *STAT_LOC
+   and return its process ID.  For errors, return (pid_t) -1.  */
+pid_t
+__libc_wait (__WAIT_STATUS_DEFN stat_loc)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (wait4, 4, WAIT_ANY, stat_loc, 0,
+			   (struct rusage *) NULL);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  pid_t result = INLINE_SYSCALL (wait4, 4, WAIT_ANY, stat_loc, 0,
+				 (struct rusage *) NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_wait, __wait)
+weak_alias (__libc_wait, wait)
diff -Nur sysdeps/unix/sysv/linux/waitid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/waitid.c
--- sysdeps/unix/sysv/linux/waitid.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/waitid.c	2004-10-30 20:01:02.000000000 +0200
@@ -0,0 +1,71 @@
+/* Linux implementation of waitid.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <kernel-features.h>
+#include <sysdep.h>
+
+
+#ifdef __NR_waitid
+
+# if __ASSUME_WAITID_SYSCALL > 0
+
+static inline int
+do_waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options)
+{
+  /* The unused fifth argument is a `struct rusage *' that we could
+     pass if we were using waitid to simulate wait3/wait4.  */
+  return INLINE_SYSCALL (waitid, 5, idtype, id, infop, options, NULL);
+}
+# define NO_DO_WAITID
+
+# else
+
+static int do_compat_waitid (idtype_t idtype, id_t id,
+			     siginfo_t *infop, int options);
+# define DO_WAITID do_compat_waitid
+
+static int
+do_waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options)
+{
+  static int waitid_works;
+  if (waitid_works > 0)
+    return INLINE_SYSCALL (waitid, 5, idtype, id, infop, options, NULL);
+  if (waitid_works == 0)
+    {
+      int result = INLINE_SYSCALL (waitid, 5,
+				   idtype, id, infop, options, NULL);
+      if (result < 0 && errno == ENOSYS)
+	waitid_works = -1;
+      else
+	{
+	  waitid_works = 1;
+	  return result;
+	}
+    }
+  return do_compat_waitid (idtype, id, infop, options);
+}
+
+# endif
+
+#endif
+
+#include "sysdeps/posix/waitid.c"
diff -Nur sysdeps/unix/sysv/linux/waitpid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/waitpid.c
--- sysdeps/unix/sysv/linux/waitpid.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/waitpid.c	2003-05-14 01:56:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1991,92,95,96,97,2002 Free Software Foundation, Inc.
+/* Copyright (C) 1991,92,95,96,97,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,14 +16,34 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#include <sysdep.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
 #include <stdlib.h>
 #include <sys/wait.h>
 
 __pid_t
 __libc_waitpid (__pid_t pid, int *stat_loc, int options)
 {
-  return __wait4 (pid, stat_loc, options, NULL);
+  if (SINGLE_THREAD_P)
+    {
+#ifdef __NR_waitpid
+      return INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options);
+#else
+      return INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+#endif
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+#ifdef __NR_waitpid
+  int result = INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options);
+#else
+  int result = INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+#endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 weak_alias (__libc_waitpid, __waitpid)
 libc_hidden_weak (__waitpid)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c
--- sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatfs64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* fstatfs64 is the same as fstatfs. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/fstatvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatvfs64.c
--- sysdeps/unix/sysv/linux/wordsize-64/fstatvfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatvfs64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* fstatvfs64 is the same as fstatvfs. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/fstatvfs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatvfs.c
--- sysdeps/unix/sysv/linux/wordsize-64/fstatvfs.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fstatvfs.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,5 @@
+#define __fstatvfs64(file, buf) __no_fstatvfs64(file, buf)
+#define fstatvfs64(file, buf) no_fstatvfs64(file, buf)
+#include "../fstatvfs.c"
+strong_alias (fstatvfs, __fstatvfs64)
+weak_alias (fstatvfs, fstatvfs64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/ftruncate64.c
--- sysdeps/unix/sysv/linux/wordsize-64/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/ftruncate64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* ftruncate64 is the same as ftruncate. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fxstat64.c
--- sysdeps/unix/sysv/linux/wordsize-64/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fxstat64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* fxstat64 is in fxstat.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
--- sysdeps/unix/sysv/linux/wordsize-64/fxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/fxstat.c	2004-04-18 01:13:34.000000000 +0200
@@ -0,0 +1,48 @@
+/* fxstat using old-style Unix fstat system call.
+   Copyright (C) 1991, 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __fxstat64 __fxstat64_disable
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Get information about the file FD in BUF.  */
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+  if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
+    return INLINE_SYSCALL (fstat, 2, fd, CHECK_1 (buf));
+
+  __set_errno (EINVAL);
+  return -1;
+}
+
+hidden_def (__fxstat)
+weak_alias (__fxstat, _fxstat);
+#undef __fxstat64
+strong_alias (__fxstat, __fxstat64);
+hidden_ver (__fxstat, __fxstat64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/getdents64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getdents64.c
--- sysdeps/unix/sysv/linux/wordsize-64/getdents64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getdents64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* getdents64 is in getdents.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/getdents.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getdents.c
--- sysdeps/unix/sysv/linux/wordsize-64/getdents.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getdents.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,4 @@
+#define __getdents64 __no___getdents64_decl
+#include <sysdeps/unix/sysv/linux/getdents.c>
+#undef __getdents64
+weak_alias(__getdents, __getdents64);
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/getrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getrlimit64.c
--- sysdeps/unix/sysv/linux/wordsize-64/getrlimit64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/getrlimit64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* getrlimit64 is the same as getrlimit. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/glob64.c
--- sysdeps/unix/sysv/linux/wordsize-64/glob64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/glob64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* glob64 is in glob.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/internal_statvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/internal_statvfs64.c
--- sysdeps/unix/sysv/linux/wordsize-64/internal_statvfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/internal_statvfs64.c	2004-04-03 19:33:02.000000000 +0200
@@ -0,0 +1 @@
+/* Nothing.  */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/lxstat64.c
--- sysdeps/unix/sysv/linux/wordsize-64/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/lxstat64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* lxstat64 is in lxstat.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c
--- sysdeps/unix/sysv/linux/wordsize-64/lxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/lxstat.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,48 @@
+/* lxstat using old-style Unix lstat system call.
+   Copyright (C) 1991, 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __lxstat64 __lxstat64_disable
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Get information about the file FD in BUF.  */
+int
+__lxstat (int vers, const char *name, struct stat *buf)
+{
+  if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
+    return INLINE_SYSCALL (lstat, 2, CHECK_STRING (name), CHECK_1 (buf));
+
+  __set_errno (EINVAL);
+  return -1;
+}
+
+hidden_def (__lxstat)
+weak_alias (__lxstat, _lxstat);
+#undef __lxstat64
+strong_alias (__lxstat, __lxstat64);
+hidden_ver (__lxstat, __lxstat64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/mmap64.c
--- sysdeps/unix/sysv/linux/wordsize-64/mmap64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/mmap64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* mmap64 is the same as mmap. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise64.c
--- sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* posix_fadvise64 is in posix_fadvise.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c
--- sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define posix_fadvise64 __no_posix_fadvise64
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#undef posix_fadvise64
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 4, fd, offset, len, advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
+strong_alias (posix_fadvise, posix_fadvise64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/pread64.c
--- sysdeps/unix/sysv/linux/wordsize-64/pread64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/pread64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/pwrite64.c
--- sysdeps/unix/sysv/linux/wordsize-64/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/pwrite64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/readdir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir64.c
--- sysdeps/unix/sysv/linux/wordsize-64/readdir64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* readdir64 is in readdir.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/readdir64_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir64_r.c
--- sysdeps/unix/sysv/linux/wordsize-64/readdir64_r.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir64_r.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* readdir64_r is in readdir_r.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/readdir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir.c
--- sysdeps/unix/sysv/linux/wordsize-64/readdir.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,7 @@
+#define readdir64 __no_readdir64_decl
+#define __readdir64 __no___readdir64_decl
+#include <sysdeps/unix/readdir.c>
+#undef __readdir64
+strong_alias (__readdir, __readdir64)
+#undef readdir64
+weak_alias (__readdir, readdir64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/readdir_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir_r.c
--- sysdeps/unix/sysv/linux/wordsize-64/readdir_r.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/readdir_r.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,4 @@
+#define readdir64_r __no_readdir64_r_decl
+#include <sysdeps/unix/readdir_r.c>
+#undef readdir64_r
+weak_alias (__readdir_r, readdir64_r)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/sendfile64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/sendfile64.c
--- sysdeps/unix/sysv/linux/wordsize-64/sendfile64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/sendfile64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* sendfile64 is alias of sendfile syscall.  */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/setrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/setrlimit64.c
--- sysdeps/unix/sysv/linux/wordsize-64/setrlimit64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/setrlimit64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* setrlimit64 is the same as setrlimit. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/statfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c
--- sysdeps/unix/sysv/linux/wordsize-64/statfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statfs64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* statfs64 is the same as statfs. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/statvfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statvfs64.c
--- sysdeps/unix/sysv/linux/wordsize-64/statvfs64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statvfs64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* statvfs64 is the same as statvfs. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/statvfs.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statvfs.c
--- sysdeps/unix/sysv/linux/wordsize-64/statvfs.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/statvfs.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,5 @@
+#define __statvfs64(file, buf) __no_statvfs64(file, buf)
+#define statvfs64(file, buf) no_statvfs64(file, buf)
+#include "../statvfs.c"
+strong_alias (statvfs, __statvfs64)
+weak_alias (statvfs, statvfs64)
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list
--- sysdeps/unix/sysv/linux/wordsize-64/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/syscalls.list	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,16 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+# Whee! 64-bit systems naturally implement llseek.
+llseek		EXTRA	lseek		Ci:iii	__libc_lseek	__lseek lseek __libc_lseek64 __llseek llseek __lseek64 lseek64
+lseek		llseek	-
+pread		-	pread		Ci:ibni	__libc_pread	__libc_pread64 __pread pread __pread64 pread64
+pwrite		-	pwrite		Ci:ibni	__libc_pwrite	__libc_pwrite64 __pwrite pwrite __pwrite64 pwrite64
+fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs fstatfs64 __fstatfs64
+statfs		-	statfs		i:sp	__statfs	statfs statfs64
+mmap		-	mmap		b:aniiii __mmap		mmap __mmap64 mmap64
+ftruncate	-	ftruncate	i:ii	__ftruncate	ftruncate ftruncate64 __ftruncate64
+truncate	-	truncate	i:si	truncate	truncate64
+getrlimit	-	getrlimit	i:ip	__getrlimit	getrlimit getrlimit64
+setrlimit	-	setrlimit	i:ip	__setrlimit	setrlimit setrlimit64
+readahead	-	readahead	i:iii	__readahead	readahead
+sendfile	-	sendfile	i:iipi	sendfile	sendfile64
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/truncate64.c
--- sysdeps/unix/sysv/linux/wordsize-64/truncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/truncate64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* truncate64 is the same as truncate. */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/xstat64.c
--- sysdeps/unix/sysv/linux/wordsize-64/xstat64.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/xstat64.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1 @@
+/* xstat64 is in xstat.c */
diff -Nur sysdeps/unix/sysv/linux/wordsize-64/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/xstat.c
--- sysdeps/unix/sysv/linux/wordsize-64/xstat.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/wordsize-64/xstat.c	2004-03-24 00:25:53.000000000 +0100
@@ -0,0 +1,47 @@
+/* xstat using old-style Unix stat system call.
+   Copyright (C) 1991, 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Ho hum, since xstat == xstat64 we must get rid of the prototype or gcc
+   will complain since they don't strictly match.  */
+#define __xstat64 __xstat64_disable
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Get information about the file NAME in BUF.  */
+int
+__xstat (int vers, const char *name, struct stat *buf)
+{
+  if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
+    return INLINE_SYSCALL (stat, 2, name, CHECK_1 (buf));
+
+  __set_errno (EINVAL);
+  return -1;
+}
+hidden_def (__xstat)
+weak_alias (__xstat, _xstat);
+#undef __xstat64
+strong_alias (__xstat, __xstat64);
+hidden_ver (__xstat, __xstat64)
diff -Nur sysdeps/unix/sysv/linux/writev.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/writev.c
--- sysdeps/unix/sysv/linux/writev.c	2002-07-18 09:20:49.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/writev.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* writev supports all Linux kernels >= 2.0.
-   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,11 +22,10 @@
 #include <sys/param.h>
 #include <sys/uio.h>
 
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern ssize_t __syscall_writev (int, const struct iovec *__unbounded, int);
 static ssize_t __atomic_writev_replacement (int, const struct iovec *,
 					    int) internal_function;
 
@@ -39,11 +38,8 @@
 
 /* We should deal with kernel which have a smaller UIO_FASTIOV as well
    as a very big count.  */
-ssize_t
-__writev (fd, vector, count)
-     int fd;
-     const struct iovec *vector;
-     int count;
+static ssize_t
+do_writev (int fd, const struct iovec *vector, int count)
 {
   ssize_t bytes_written;
 
@@ -54,7 +50,26 @@
 
   return __atomic_writev_replacement (fd, vector, count);
 }
-weak_alias (__writev, writev)
 
-#define __writev static internal_function __atomic_writev_replacement
+ssize_t
+__libc_writev (fd, vector, count)
+     int fd;
+     const struct iovec *vector;
+     int count;
+{
+  if (SINGLE_THREAD_P)
+    return do_writev (fd, vector, count);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_writev (fd, vector, count);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+strong_alias (__libc_writev, __writev)
+weak_alias (__libc_writev, writev)
+
+#define __libc_writev static internal_function __atomic_writev_replacement
 #include <sysdeps/posix/writev.c>
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/a.out.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
--- sysdeps/unix/sysv/linux/x86_64/bits/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h	2003-07-25 11:04:58.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+
+/* Signal to users of this header that this architecture really doesn't
+   support a.out binary format.  */
+#define __NO_A_OUT_SUPPORT 1
+
+#endif
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/environments.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/environments.h
--- sysdeps/unix/sysv/linux/x86_64/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/environments.h	2004-11-26 09:11:06.000000000 +0100
@@ -0,0 +1,87 @@
+/* Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* Environments with 32-bit wide pointers are optionally provided.
+   Therefore following macros aren't defined:
+   # undef _POSIX_V6_ILP32_OFF32
+   # undef _POSIX_V6_ILP32_OFFBIG
+   # undef _XBS5_ILP32_OFF32
+   # undef _XBS5_ILP32_OFFBIG
+   and users need to check at runtime.  */
+
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* Environments with 64-bit wide pointers can be provided,
+   so these macros aren't defined:
+   # undef _POSIX_V6_LP64_OFF64
+   # undef _POSIX_V6_LPBIG_OFFBIG
+   # undef _XBS5_LP64_OFF64
+   # undef _XBS5_LPBIG_OFFBIG
+   and sysconf tests for it at runtime.  */
+
+#endif /* __WORDSIZE == 32 */
+
+#define __ILP32_OFF32_CFLAGS	"-m32"
+#define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+#define __ILP32_OFF32_LDFLAGS	"-m32"
+#define __ILP32_OFFBIG_LDFLAGS	"-m32"
+#define __LP64_OFF64_CFLAGS	"-m64"
+#define __LP64_OFF64_LDFLAGS	"-m64"
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
--- sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h	2002-03-11 22:08:05.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h	2004-08-23 09:28:46.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux/x86-64.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -46,6 +46,7 @@
 # define O_DIRECT	 040000	/* Direct disk access.	*/
 # define O_DIRECTORY	0200000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_NOATIME     01000000 /* Do not set atime.  */
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
@@ -70,19 +71,30 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-#define F_GETLK		5	/* Get record locking info.  */
-#define F_SETLK		6	/* Set record locking info (non-blocking).  */
-#define F_SETLKW	7	/* Set record locking info (blocking).	*/
 #if __WORDSIZE == 64
-# define F_GETLK64	F_GETLK	/* Get record locking info.  */
-# define F_SETLK64	F_SETLK	/* Set record locking info (non-blocking).  */
-# define F_SETLKW64	F_SETLKW /* Set record locking info (blocking).	*/
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+/* Not necessary, we always have 64-bit offsets.  */
+# define F_GETLK64	5	/* Get record locking info.  */
+# define F_SETLK64	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	7	/* Set record locking info (blocking).	*/
 #else
-#define F_GETLK64	12	/* Get record locking info.  */
-#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
-#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+# ifndef __USE_FILE_OFFSET64
+#  define F_GETLK	5	/* Get record locking info.  */
+#  define F_SETLK	6	/* Set record locking info (non-blocking).  */
+#  define F_SETLKW	7	/* Set record locking info (blocking).	*/
+# else
+#  define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+#  define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+#  define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+# endif
+# define F_GETLK64	12	/* Get record locking info.  */
+# define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	14	/* Set record locking info (blocking).	*/
 #endif
-#if defined __USE_BSD || defined __USE_XOPEN2K
+
+#if defined __USE_BSD || defined __USE_UNIX98
 # define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
 # define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
 #endif
@@ -181,3 +193,11 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+__BEGIN_DECLS
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/mman.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/mman.h
--- sysdeps/unix/sysv/linux/x86_64/bits/mman.h	2001-09-19 12:30:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/mman.h	2003-09-25 18:43:08.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/x86_64 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -34,6 +34,10 @@
 #define PROT_WRITE	0x2		/* Page can be written.  */
 #define PROT_EXEC	0x4		/* Page can be executed.  */
 #define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
 
 /* Sharing types (must choose one and only one of these).  */
 #define MAP_SHARED	0x01		/* Share changes.  */
@@ -53,11 +57,13 @@
 
 /* These are Linux-specific.  */
 #ifdef __USE_MISC
-# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
-# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
-# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
-# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
 #endif
 
 /* Flags to `msync'.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/resource.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/resource.h
--- sysdeps/unix/sysv/linux/x86_64/bits/resource.h	2002-03-04 14:39:58.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* Bit values & structures for resource limits.  Linux/x86-64 version.
-   Copyright (C) 1994,1996,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_RESOURCE_H
-# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Transmute defines to enumerations.  The macro re-definitions are
-   necessary because some programs want to test for operating system
-   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
-   definition is a no-op.  */
-
-/* Kinds of resource limit.  */
-enum __rlimit_resource
-{
-  /* Per-process CPU limit, in seconds.  */
-  RLIMIT_CPU = 0,
-#define RLIMIT_CPU RLIMIT_CPU
-
-  /* Largest file that can be created, in bytes.  */
-  RLIMIT_FSIZE = 1,
-#define	RLIMIT_FSIZE RLIMIT_FSIZE
-
-  /* Maximum size of data segment, in bytes.  */
-  RLIMIT_DATA = 2,
-#define	RLIMIT_DATA RLIMIT_DATA
-
-  /* Maximum size of stack segment, in bytes.  */
-  RLIMIT_STACK = 3,
-#define	RLIMIT_STACK RLIMIT_STACK
-
-  /* Largest core file that can be created, in bytes.  */
-  RLIMIT_CORE = 4,
-#define	RLIMIT_CORE RLIMIT_CORE
-
-  /* Largest resident set size, in bytes.
-     This affects swapping; processes that are exceeding their
-     resident set size will be more likely to have physical memory
-     taken from them.  */
-  RLIMIT_RSS = 5,
-#define	RLIMIT_RSS RLIMIT_RSS
-
-  /* Number of open files.  */
-  RLIMIT_NOFILE = 7,
-  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
-#define RLIMIT_NOFILE RLIMIT_NOFILE
-#define RLIMIT_OFILE RLIMIT_OFILE
-
-  /* Address space limit.  */
-  RLIMIT_AS = 9,
-#define RLIMIT_AS RLIMIT_AS
-
-  /* Number of processes.  */
-  RLIMIT_NPROC = 6,
-#define RLIMIT_NPROC RLIMIT_NPROC
-
-  /* Locked-in-memory address space.  */
-  RLIMIT_MEMLOCK = 8,
-#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
-
-  /* Maximum number of file locks.  */
-  RLIMIT_LOCKS = 10,
-#define RLIMIT_LOCKS RLIMIT_LOCKS
-
-  RLIMIT_NLIMITS = 11,
-  RLIM_NLIMITS = RLIMIT_NLIMITS
-#define RLIMIT_NLIMITS RLIMIT_NLIMITS
-#define RLIM_NLIMITS RLIM_NLIMITS
-};
-
-/* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((unsigned long int)(~0UL))
-#else
-# define RLIM_INFINITY 0xffffffffffffffffuLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0xffffffffffffffffuLL
-#endif
-
-/* We can represent all limits.  */
-#define RLIM_SAVED_MAX	RLIM_INFINITY
-#define RLIM_SAVED_CUR	RLIM_INFINITY
-
-
-/* Type for resource quantity measurement.  */
-#ifndef __USE_FILE_OFFSET64
-typedef __rlim_t rlim_t;
-#else
-typedef __rlim64_t rlim_t;
-#endif
-#ifdef __USE_LARGEFILE64
-typedef __rlim64_t rlim64_t;
-#endif
-
-struct rlimit
-  {
-    /* The current (soft) limit.  */
-    rlim_t rlim_cur;
-    /* The hard limit.  */
-    rlim_t rlim_max;
-  };
-
-#ifdef __USE_LARGEFILE64
-struct rlimit64
-  {
-    /* The current (soft) limit.  */
-    rlim64_t rlim_cur;
-    /* The hard limit.  */
-    rlim64_t rlim_max;
- };
-#endif
-
-/* Whose usage statistics do you want?  */
-enum __rusage_who
-{
-  /* The calling process.  */
-  RUSAGE_SELF = 0,
-#define RUSAGE_SELF RUSAGE_SELF
-
-  /* All of its terminated child processes.  */
-  RUSAGE_CHILDREN = -1,
-#define RUSAGE_CHILDREN RUSAGE_CHILDREN
-
-  /* Both.  */
-  RUSAGE_BOTH = -2
-#define RUSAGE_BOTH RUSAGE_BOTH
-};
-
-#define __need_timeval
-#include <bits/time.h>		/* For `struct timeval'.  */
-
-/* Structure which says how much of each resource has been used.  */
-struct rusage
-  {
-    /* Total amount of user time used.  */
-    struct timeval ru_utime;
-    /* Total amount of system time used.  */
-    struct timeval ru_stime;
-    /* Maximum resident set size (in kilobytes).  */
-    long int ru_maxrss;
-    /* Amount of sharing of text segment memory
-       with other processes (kilobyte-seconds).  */
-    long int ru_ixrss;
-    /* Amount of data segment memory used (kilobyte-seconds).  */
-    long int ru_idrss;
-    /* Amount of stack memory used (kilobyte-seconds).  */
-    long int ru_isrss;
-    /* Number of soft page faults (i.e. those serviced by reclaiming
-       a page from the list of pages awaiting reallocation.  */
-    long int ru_minflt;
-    /* Number of hard page faults (i.e. those that required I/O).  */
-    long int ru_majflt;
-    /* Number of times a process was swapped out of physical memory.  */
-    long int ru_nswap;
-    /* Number of input operations via the file system.  Note: This
-       and `ru_oublock' do not include operations with the cache.  */
-    long int ru_inblock;
-    /* Number of output operations via the file system.  */
-    long int ru_oublock;
-    /* Number of IPC messages sent.  */
-    long int ru_msgsnd;
-    /* Number of IPC messages received.  */
-    long int ru_msgrcv;
-    /* Number of signals delivered.  */
-    long int ru_nsignals;
-    /* Number of voluntary context switches, i.e. because the process
-       gave up the process before it had to (usually to wait for some
-       resource to be available).  */
-    long int ru_nvcsw;
-    /* Number of involuntary context switches, i.e. a higher priority process
-       became runnable or the current process used up its time slice.  */
-    long int ru_nivcsw;
-  };
-
-/* Priority limits.  */
-#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
-#define PRIO_MAX	20	/* Maximum priority a process can have.  */
-
-/* The type of the WHICH argument to `getpriority' and `setpriority',
-   indicating what flavor of entity the WHO argument specifies.  */
-enum __priority_which
-{
-  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
-#define PRIO_PROCESS PRIO_PROCESS
-  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
-#define PRIO_PGRP PRIO_PGRP
-  PRIO_USER = 2			/* WHO is a user ID.  */
-#define PRIO_USER PRIO_USER
-};
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/shm.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
--- sysdeps/unix/sysv/linux/x86_64/bits/shm.h	2002-08-24 00:20:41.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/shm.h	2004-08-12 19:27:21.000000000 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -35,6 +36,8 @@
 #define SHM_LOCK	11		/* lock segment (root only) */
 #define SHM_UNLOCK	12		/* unlock segment (root only) */
 
+__BEGIN_DECLS
+
 /* Segment low boundary address multiple.  */
 #define SHMLBA		(__getpagesize ())
 extern int __getpagesize (void) __THROW __attribute__ ((__const__));
@@ -76,6 +79,7 @@
 /* shm_mode upper byte flags */
 # define SHM_DEST	01000	/* segment will be destroyed on last detach */
 # define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
 
 struct	shminfo
   {
@@ -101,3 +105,5 @@
   };
 
 #endif /* __USE_MISC */
+
+__END_DECLS
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/socket.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/socket.h
--- sysdeps/unix/sysv/linux/x86_64/bits/socket.h	2002-03-04 14:39:58.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,321 +0,0 @@
-/* System-specific socket constants and types.  Linux/x86-64 version.
-   Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef __BITS_SOCKET_H
-#define __BITS_SOCKET_H
-
-#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
-# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
-#endif
-
-#define	__need_size_t
-#define __need_NULL
-#include <stddef.h>
-
-#include <limits.h>
-#include <sys/types.h>
-
-/* Type for length arguments in socket calls.  */
-#ifndef __socklen_t_defined
-typedef __socklen_t socklen_t;
-# define __socklen_t_defined
-#endif
-
-/* Types of sockets.  */
-enum __socket_type
-{
-  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
-				   byte streams.  */
-#define SOCK_STREAM SOCK_STREAM
-  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
-				   of fixed maximum length.  */
-#define SOCK_DGRAM SOCK_DGRAM
-  SOCK_RAW = 3,			/* Raw protocol interface.  */
-#define SOCK_RAW SOCK_RAW
-  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
-#define SOCK_RDM SOCK_RDM
-  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
-				   datagrams of fixed maximum length.  */
-#define SOCK_SEQPACKET SOCK_SEQPACKET
-  SOCK_PACKET = 10		/* Linux specific way of getting packets
-				   at the dev level.  For writing rarp and
-				   other similar things on the user level. */
-#define SOCK_PACKET SOCK_PACKET
-};
-
-/* Protocol families.  */
-#define	PF_UNSPEC	0	/* Unspecified.  */
-#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
-#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
-#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
-#define	PF_INET		2	/* IP protocol family.  */
-#define	PF_AX25		3	/* Amateur Radio AX.25.  */
-#define	PF_IPX		4	/* Novell Internet Protocol.  */
-#define	PF_APPLETALK	5	/* Appletalk DDP.  */
-#define	PF_NETROM	6	/* Amateur radio NetROM.  */
-#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
-#define	PF_ATMPVC	8	/* ATM PVCs.  */
-#define	PF_X25		9	/* Reserved for X.25 project.  */
-#define	PF_INET6	10	/* IP version 6.  */
-#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
-#define	PF_DECnet	12	/* Reserved for DECnet project.  */
-#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
-#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
-#define	PF_KEY		15	/* PF_KEY key management API.  */
-#define	PF_NETLINK	16
-#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
-#define	PF_PACKET	17	/* Packet family.  */
-#define	PF_ASH		18	/* Ash.  */
-#define	PF_ECONET	19	/* Acorn Econet.  */
-#define	PF_ATMSVC	20	/* ATM SVCs.  */
-#define	PF_SNA		22	/* Linux SNA Project */
-#define	PF_IRDA		23	/* IRDA sockets.  */
-#define	PF_PPPOX	24	/* PPPoX sockets.  */
-#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
-#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
-#define	PF_MAX		32	/* For now..  */
-
-/* Address families.  */
-#define	AF_UNSPEC	PF_UNSPEC
-#define	AF_LOCAL	PF_LOCAL
-#define	AF_UNIX		PF_UNIX
-#define	AF_FILE		PF_FILE
-#define	AF_INET		PF_INET
-#define	AF_AX25		PF_AX25
-#define	AF_IPX		PF_IPX
-#define	AF_APPLETALK	PF_APPLETALK
-#define	AF_NETROM	PF_NETROM
-#define	AF_BRIDGE	PF_BRIDGE
-#define	AF_ATMPVC	PF_ATMPVC
-#define	AF_X25		PF_X25
-#define	AF_INET6	PF_INET6
-#define	AF_ROSE		PF_ROSE
-#define	AF_DECnet	PF_DECnet
-#define	AF_NETBEUI	PF_NETBEUI
-#define	AF_SECURITY	PF_SECURITY
-#define	AF_KEY		PF_KEY
-#define	AF_NETLINK	PF_NETLINK
-#define	AF_ROUTE	PF_ROUTE
-#define	AF_PACKET	PF_PACKET
-#define	AF_ASH		PF_ASH
-#define	AF_ECONET	PF_ECONET
-#define	AF_ATMSVC	PF_ATMSVC
-#define	AF_SNA		PF_SNA
-#define	AF_IRDA		PF_IRDA
-#define	AF_PPPOX	PF_PPPOX
-#define	AF_WANPIPE	PF_WANPIPE
-#define	AF_BLUETOOTH	PF_BLUETOOTH
-#define	AF_MAX		PF_MAX
-
-/* Socket level values.  Others are defined in the appropriate headers.
-
-   XXX These definitions also should go into the appropriate headers as
-   far as they are available.  */
-#define SOL_RAW		255
-#define SOL_DECNET      261
-#define SOL_X25         262
-#define SOL_PACKET	263
-#define SOL_ATM		264	/* ATM layer (cell level).  */
-#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
-#define SOL_IRDA	266
-
-/* Maximum queue length specifiable by listen.  */
-#define SOMAXCONN	128
-
-/* Get the definition of the macro to define the common sockaddr members.  */
-#include <bits/sockaddr.h>
-
-/* Structure describing a generic socket address.  */
-struct sockaddr
-  {
-    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
-    char sa_data[14];		/* Address data.  */
-  };
-
-
-/* Structure large enough to hold any socket address (with the historical
-   exception of AF_UNIX).  We reserve 128 bytes.  */
-#if ULONG_MAX > 0xffffffff
-# define __ss_aligntype	__uint64_t
-#else
-# define __ss_aligntype	__uint32_t
-#endif
-#define _SS_SIZE	128
-#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
-
-struct sockaddr_storage
-  {
-    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
-    __ss_aligntype __ss_align;	/* Force desired alignment.  */
-    char __ss_padding[_SS_PADSIZE];
-  };
-
-
-/* Bits in the FLAGS argument to `send', `recv', et al.  */
-enum
-  {
-    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
-#define MSG_OOB		MSG_OOB
-    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
-#define MSG_PEEK	MSG_PEEK
-    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
-#define MSG_DONTROUTE	MSG_DONTROUTE
-#ifdef __USE_GNU
-    /* DECnet uses a different name.  */
-    MSG_TRYHARD		= MSG_DONTROUTE,
-# define MSG_TRYHARD	MSG_DONTROUTE
-#endif
-    MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
-#define MSG_CTRUNC	MSG_CTRUNC
-    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
-#define MSG_PROXY	MSG_PROXY
-    MSG_TRUNC		= 0x20,
-#define	MSG_TRUNC	MSG_TRUNC
-    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
-#define	MSG_DONTWAIT	MSG_DONTWAIT
-    MSG_EOR		= 0x80, /* End of record.  */
-#define	MSG_EOR		MSG_EOR
-    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
-#define	MSG_WAITALL	MSG_WAITALL
-    MSG_FIN		= 0x200,
-#define	MSG_FIN		MSG_FIN
-    MSG_SYN		= 0x400,
-#define	MSG_SYN		MSG_SYN
-    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
-#define	MSG_CONFIRM	MSG_CONFIRM
-    MSG_RST		= 0x1000,
-#define	MSG_RST		MSG_RST
-    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
-#define	MSG_ERRQUEUE	MSG_ERRQUEUE
-    MSG_NOSIGNAL	= 0x4000, /* Do not generate SIGPIPE.  */
-#define	MSG_NOSIGNAL	MSG_NOSIGNAL
-    MSG_MORE		= 0x8000  /* Sender will send more.  */
-#define	MSG_MORE	MSG_MORE
-  };
-
-
-/* Structure describing messages sent by
-   `sendmsg' and received by `recvmsg'.  */
-struct msghdr
-  {
-    void *msg_name;		/* Address to send to/receive from.  */
-    socklen_t msg_namelen;	/* Length of address data.  */
-
-    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
-#if __WORDSIZE == 32
-    int msg_iovlen;		/* Number of elements in the vector.  */
-
-    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
-#else
-    size_t msg_iovlen;		/* Number of elements in the vector.  */
-
-    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    size_t msg_controllen;	/* Ancillary data buffer length.  */
-#endif
-    int msg_flags;		/* Flags on received message.  */
-  };
-
-/* Structure used for storage of ancillary data object information.  */
-struct cmsghdr
-  {
-    size_t cmsg_len;		/* Length of data in cmsg_data plus length
-				   of cmsghdr structure.  */
-    int cmsg_level;		/* Originating protocol.  */
-    int cmsg_type;		/* Protocol specific type.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
-#endif
-  };
-
-/* Ancillary data object manipulation macros.  */
-#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
-# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
-#else
-# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
-#endif
-#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
-#define CMSG_FIRSTHDR(mhdr) \
-  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
-   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
-#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
-			 & (size_t) ~(sizeof (size_t) - 1))
-#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
-			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
-#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
-
-extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
-				      struct cmsghdr *__cmsg) __THROW;
-#ifdef __USE_EXTERN_INLINES
-# ifndef _EXTERN_INLINE
-#  define _EXTERN_INLINE extern __inline
-# endif
-_EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
-{
-  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
-    return 0;
-
-  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
-			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
-					+ __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return 0;
-  return __cmsg;
-}
-#endif	/* Use `extern inline'.  */
-
-/* Socket level message types.  This must match the definitions in
-   <linux/socket.h>.  */
-enum
-  {
-    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
-#define SCM_RIGHTS SCM_RIGHTS
-#ifdef __USE_BSD
-    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
-# define SCM_CREDENTIALS SCM_CREDENTIALS
-#endif
-    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
-  };
-
-/* User visible structure for SCM_CREDENTIALS message */
-
-struct ucred
-{
-  pid_t pid;			/* PID of sending process.  */
-  uid_t uid;			/* UID of sending process.  */
-  gid_t gid;			/* GID of sending process.  */
-};
-
-/* Get socket manipulation related informations from kernel headers.  */
-#include <asm/socket.h>
-
-
-/* Structure used to manipulate the SO_LINGER option.  */
-struct linger
-  {
-    int l_onoff;		/* Nonzero to linger on close.  */
-    int l_linger;		/* Time to linger.  */
-  };
-
-#endif	/* bits/socket.h */
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/statfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h
--- sysdeps/unix/sysv/linux/x86_64/bits/statfs.h	2001-09-19 12:30:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_STATFS_H
-# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
-#endif
-
-#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t. */
-
-struct statfs
-  {
-    long int f_type;
-    long int f_bsize;
-    __fsblkcnt_t f_blocks;
-    __fsblkcnt_t f_bfree;
-    __fsblkcnt_t f_bavail;
-    __fsblkcnt_t f_files;
-    __fsblkcnt_t f_ffree;
-    __fsid_t f_fsid;
-    long int f_namelen;
-    long int f_spare[6];
-  };
-
-#ifdef __USE_LARGEFILE64
-/* We already use 64-bit types in the normal structure,
-   so this is the same as the above.  */
-struct statfs64
-  {
-    long int f_type;
-    long int f_bsize;
-    __fsblkcnt64_t f_blocks;
-    __fsblkcnt64_t f_bfree;
-    __fsblkcnt64_t f_bavail;
-    __fsblkcnt64_t f_files;
-    __fsblkcnt64_t f_ffree;
-    __fsid_t f_fsid;
-    long int f_namelen;
-    long int f_spare[6];
-  };
-#endif
-
-/* Tell code we have this member.  */
-#define _STATFS_F_NAMELEN
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
--- sysdeps/unix/sysv/linux/x86_64/bits/stat.h	2002-03-11 22:08:06.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/stat.h	2003-06-26 19:00:37.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1999,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,8 +22,6 @@
 
 /* Versions of the `struct stat' data structure.  */
 #define _STAT_VER_KERNEL	0
-#define _STAT_VER_LINUX		1
-#define _STAT_VER		_STAT_VER_LINUX
 
 #if __WORDSIZE == 32
 # define _STAT_VER_SVR4		2
@@ -34,10 +32,14 @@
 # define _MKNOD_VER_SVR4	2
 # define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
 #else
+# define _STAT_VER_LINUX	1
+
 /* x86-64 versions of the `xmknod' interface.  */
 # define _MKNOD_VER_LINUX	0
 #endif
 
+#define _STAT_VER		_STAT_VER_LINUX
+
 struct stat
   {
     __dev_t st_dev;		/* Device.  */
@@ -76,12 +78,27 @@
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
 #endif
-    __time_t st_atime;		/* Time of last access.  */
-    long int __reserved0;	/* Reserved for atime.nanoseconds.  */
-    __time_t st_mtime;		/* Time of last modification.  */
-    long int __reserved1;	/* Reserved for mtime.nanoseconds.  */
-    __time_t st_ctime;		/* Time of last status change.  */
-    long int __reserved2;	/* Reserved for ctime.nanoseconds.  */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
 #if __WORDSIZE == 64
     long int __unused[3];
 #else
@@ -122,12 +139,27 @@
 #endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.  */
     __blkcnt64_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
-    __time_t st_atime;		/* Time of last access.  */
-    long int __reserved0;	/* Reserved for atime.nanoseconds.  */
-    __time_t st_mtime;		/* Time of last modification.  */
-    long int __reserved1;	/* Reserved for mtime.nanoseconds.  */
-    __time_t st_ctime;		/* Time of last status change.  */
-    long int __reserved2;	/* Reserved for ctime.nanoseconds.  */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
 #if __WORDSIZE == 64
     long int __unused[3];
 #else
@@ -139,6 +171,8 @@
 /* Tell code we have these members.  */
 #define	_STATBUF_ST_BLKSIZE
 #define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
 
 /* Encoding of the file mode.  */
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/time.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/time.h
--- sysdeps/unix/sysv/linux/x86_64/bits/time.h	2001-09-19 12:30:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/time.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* System-dependent timing definitions.  Linux x86-64 version.
-   Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <time.h> instead.
- */
-
-#ifndef __need_timeval
-# ifndef _BITS_TIME_H
-#  define _BITS_TIME_H	1
-
-/* ISO/IEC 9899:1990 7.12.1: <time.h>
-   The macro `CLOCKS_PER_SEC' is the number per second of the value
-   returned by the `clock' function. */
-/* CAE XSH, Issue 4, Version 2: <time.h>
-   The value of CLOCKS_PER_SEC is required to be 1 million on all
-   XSI-conformant systems. */
-#  define CLOCKS_PER_SEC  1000000l
-
-#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
-/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
-   presents the real value for clock ticks per second for the system.  */
-#   include <bits/types.h>
-extern long int __sysconf (int);
-#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
-#  endif
-
-#  ifdef __USE_POSIX199309
-/* Identifier for system-wide realtime clock.  */
-#   define CLOCK_REALTIME	0
-/* High-resolution timer from the CPU.  */
-#   define CLOCK_PROCESS_CPUTIME_ID	2
-/* Thread-specific CPU-time clock.  */
-#   define CLOCK_THREAD_CPUTIME_ID	3
-
-/* Flag to indicate time is absolute.  */
-#   define TIMER_ABSTIME	1
-#  endif
-
-# endif	/* bits/time.h */
-#endif
-
-#ifdef __need_timeval
-# undef __need_timeval
-# ifndef _STRUCT_TIMEVAL
-#  define _STRUCT_TIMEVAL	1
-#  include <bits/types.h>
-
-/* A time value that is accurate to the nearest
-   microsecond but also has a range of years.  */
-struct timeval
-  {
-    __time_t tv_sec;		/* Seconds.  */
-    __suseconds_t tv_usec;	/* Microseconds.  */
-  };
-# endif	/* struct timeval */
-#endif	/* need timeval */
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/types.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/types.h
--- sysdeps/unix/sysv/linux/x86_64/bits/types.h	2002-03-29 00:41:53.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,185 +0,0 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
- * Never include this file directly; use <sys/types.h> instead.
- */
-
-#ifndef	_BITS_TYPES_H
-#define	_BITS_TYPES_H	1
-
-#include <features.h>
-
-#define __need_size_t
-#include <stddef.h>
-#include <bits/wordsize.h>
-
-/* Convenience types.  */
-typedef unsigned char __u_char;
-typedef unsigned short int __u_short;
-typedef unsigned int __u_int;
-typedef unsigned long int __u_long;
-#if __WORDSIZE == 64
-typedef unsigned long int __u_quad_t;
-typedef long int __quad_t;
-#else
-# ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef unsigned long long int __u_quad_t;
-__extension__ typedef long long int __quad_t;
-# else
-typedef struct
-  {
-    long int __val[2];
-  } __quad_t;
-typedef struct
-  {
-    __u_long __val[2];
-  } __u_quad_t;
-# endif
-#endif
-typedef signed char __int8_t;
-typedef unsigned char __uint8_t;
-typedef signed short int __int16_t;
-typedef unsigned short int __uint16_t;
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#if __WORDSIZE == 64
-typedef signed long int __int64_t;
-typedef unsigned long int __uint64_t;
-#else
-# ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef signed long long int __int64_t;
-__extension__ typedef unsigned long long int __uint64_t;
-# endif
-#endif
-typedef __quad_t *__qaddr_t;
-
-#if __WORDSIZE == 64
-typedef __uint64_t __dev_t;		/* Type of device numbers.  */
-#else
-typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
-#endif
-typedef __uint32_t __uid_t;		/* Type of user identifications.  */
-typedef __uint32_t __gid_t;		/* Type of group identifications.  */
-#if __WORDSIZE == 64
-typedef __uint64_t __ino_t;		/* Type of file serial numbers.  */
-typedef __uint64_t __ino64_t;		/*  "" (LFS) */
-#else
-typedef __u_long __ino_t;		/* Type of file serial numbers.  */
-typedef __u_quad_t __ino64_t;		/*  "" (LFS) */
-#endif
-typedef __uint32_t __mode_t;		/* Type of file attribute bitmasks.  */
-#if __WORDSIZE == 64
-typedef __uint64_t __nlink_t;		/* Type of file link counts.  */
-typedef __int64_t  __off_t;		/* Type of file sizes and offsets.  */
-typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
-typedef __loff_t  __off64_t;		/*  "" (LFS) */
-#else
-typedef __u_int __nlink_t;		/* Type of file link counts.  */
-typedef long int __off_t;		/* Type of file sizes and offsets.  */
-typedef __int64_t  __loff_t;		/* Type of file sizes and offsets.  */
-typedef __int64_t  __off64_t;		/*  "" (LFS) */
-#endif
-typedef __int32_t  __pid_t;		/* Type of process identifications.  */
-#if __WORDSIZE == 64
-typedef __int64_t  __ssize_t;		/* Type of a byte count, or error.  */
-typedef __uint64_t  __rlim_t;		/* Type of resource counts.  */
-typedef __uint64_t  __rlim64_t;		/*  "" (LFS) */
-typedef __int64_t  __blkcnt_t;		/* Type to count nr disk blocks.  */
-typedef __int64_t  __blkcnt64_t;	/*  "" (LFS) */
-typedef __uint64_t __fsblkcnt_t;	/* Type to count file system blocks.  */
-typedef __uint64_t __fsblkcnt64_t;	/*  "" (LFS) */
-typedef __uint64_t __fsfilcnt_t;	/* Type to count file system inodes.  */
-typedef __uint64_t __fsfilcnt64_t;	/*  "" (LFS) */
-typedef __uint32_t __id_t;		/* General type for IDs.  */
-#else
-typedef int __ssize_t;			/* Type of a byte count, or error.  */
-typedef __u_long __rlim_t;		/* Type of resource counts.  */
-typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
-typedef long int  __blkcnt_t;		/* Type to count nr disk blocks.  */
-typedef __quad_t  __blkcnt64_t;		/*  "" (LFS) */
-typedef __u_long __fsblkcnt_t;		/* Type to count file system blocks.  */
-typedef __u_quad_t __fsblkcnt64_t;	/*  "" (LFS) */
-typedef __u_long __fsfilcnt_t;		/* Type to count file system inodes.  */
-typedef __u_quad_t __fsfilcnt64_t;	/*  "" (LFS) */
-typedef __u_int __id_t;			/* General type for ID.  */
-#endif
-
-typedef struct
-  {
-    int __val[2];
-  } __fsid_t;				/* Type of file system IDs.  */
-
-/* Everythin' else.  */
-typedef int __daddr_t;			/* Type of a disk address.  */
-typedef char *__caddr_t;		/* Type of a core address.  */
-typedef long int __time_t;
-typedef unsigned int __useconds_t;
-typedef long int __suseconds_t;
-typedef long int __swblk_t;		/* Type of a swap block maybe?  */
-typedef long int __clock_t;
-typedef int __key_t;			/* Type of a SYSV IPC key. */
-
-/* Clock ID used in clock and timer functions.  */
-typedef int __clockid_t;
-
-/* Timer ID returned by `timer_create'.  */
-typedef int __timer_t;
-
-/* Used in `struct shmid_ds'.  */
-#if __WORDSIZE == 64
-typedef int __ipc_pid_t;
-#else
-typedef unsigned short int __ipc_pid_t;
-#endif
-
-/* type to represent block size. */
-typedef long int __blksize_t;
-
-/* Due to incaution, we may have gotten these from a kernel header file.  */
-#undef __FD_SETSIZE
-#undef __FDMASK
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define __FD_SETSIZE	1024
-
-/* Used in XTI.  */
-#if __WORDSIZE == 64
-typedef int __t_scalar_t;
-typedef unsigned int __t_uscalar_t;
-#else
-typedef long int __t_scalar_t;
-typedef unsigned long int __t_uscalar_t;
-#endif
-
-/* Duplicates info from stdint.h but this is used in unistd.h.  */
-#if __WORDSIZE == 64
-typedef long int __intptr_t;
-#else
-typedef int __intptr_t;
-#endif
-
-/* Duplicate info from sys/socket.h.  */
-typedef unsigned int __socklen_t;
-
-/* Now add the thread types.  */
-#if defined __USE_POSIX199506 || defined __USE_UNIX98
-# include <bits/pthreadtypes.h>
-#endif
-
-#endif /* bits/types.h */
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/utmp.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h
--- sysdeps/unix/sysv/linux/x86_64/bits/utmp.h	2002-10-02 23:15:35.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
-   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002 
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMP_H
-# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
-#endif
-
-#include <paths.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <bits/wordsize.h>
-
-
-#define UT_LINESIZE	32
-#define UT_NAMESIZE	32
-#define UT_HOSTSIZE	256
-
-
-/* The structure describing an entry in the database of
-   previous logins.  */
-struct lastlog
-  {
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-    int32_t ll_time;
-#else
-    __time_t ll_time;
-#endif
-    char ll_line[UT_LINESIZE];
-    char ll_host[UT_HOSTSIZE];
-  };
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmp' below.  */
-struct exit_status
-  {
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmp
-{
-  short int ut_type;		/* Type of login.  */
-  pid_t ut_pid;			/* Process ID of login process.  */
-  char ut_line[UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
-  char ut_user[UT_NAMESIZE];	/* Username.  */
-  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled 
-   32- and 64-bit.  This allows files and shared memory to be shared 
-   between 32/64bit applications.  For example /var/run/utmp.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    int32_t tv_sec;		/* Seconds.  */
-    int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-
-  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-/* Backwards compatibility hacks.  */
-#define ut_name		ut_user
-#ifndef _NO_UT_TIME
-/* We have a problem here: `ut_time' is also used otherwise.  Define
-   _NO_UT_TIME if the compiler complains.  */
-# define ut_time	ut_tv.tv_sec
-#endif
-#define ut_xtime	ut_tv.tv_sec
-#define ut_addr		ut_addr_v6[0]
-
-
-/* Values for the `ut_type' field of a `struct utmp'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#define RUN_LVL		1	/* The system's runlevel.  */
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#define ACCOUNTING	9
-
-/* Old Linux name for the EMPTY type.  */
-#define UT_UNKNOWN	EMPTY
-
-
-/* Tell the user that we have a modern system with UT_HOST, UT_PID,
-   UT_TYPE, UT_ID and UT_TV fields.  */
-#define _HAVE_UT_TYPE	1
-#define _HAVE_UT_PID	1
-#define _HAVE_UT_ID	1
-#define _HAVE_UT_TV	1
-#define _HAVE_UT_HOST	1
diff -Nur sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h
--- sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h	2002-10-02 22:39:00.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,102 +0,0 @@
-/* Structures and definitions for the user accounting database.  GNU version.
-   Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UTMPX_H
-# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
-#endif
-
-#include <bits/types.h>
-#include <sys/time.h>
-
-
-#ifdef __USE_GNU
-# include <paths.h>
-# define _PATH_UTMPX	_PATH_UTMP
-# define _PATH_WTMPX	_PATH_WTMP
-#endif
-
-
-#define __UT_LINESIZE	32
-#define __UT_NAMESIZE	32
-#define __UT_HOSTSIZE	256
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmpx' below.  */
-struct __exit_status
-  {
-#ifdef __USE_GNU
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-#else
-    short int __e_termination;	/* Process termination status.  */
-    short int __e_exit;		/* Process exit status.  */
-#endif
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmpx
-{
-  short int ut_type;		/* Type of login.  */
-  __pid_t ut_pid;		/* Process ID of login process.  */
-  char ut_line[__UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID. */
-  char ut_user[__UT_NAMESIZE];	/* Username.  */
-  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
-  struct __exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-
-/* The fields ut_session and ut_tv must be the same size when compiled
-   32- and 64-bit.  This allows files and shared memory to be shared
-   between 32/64bit applications.  */
-#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
-  __int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    __int32_t tv_sec;		/* Seconds.  */
-    __int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __unused[20];		/* Reserved for future use.  */
-};
-
-
-/* Values for the `ut_type' field of a `struct utmpx'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#ifdef __USE_GNU
-# define RUN_LVL	1	/* The system's runlevel.  */
-#endif
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#ifdef __USE_GNU
-# define ACCOUNTING	9	/* System accounting.  */
-#endif
diff -Nur sysdeps/unix/sysv/linux/x86_64/clone.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/clone.S
--- sysdeps/unix/sysv/linux/x86_64/clone.S	2002-08-04 04:20:07.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/clone.S	2004-12-05 08:49:19.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001,02 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,21 +26,30 @@
 #include <bp-sym.h>
 #include <bp-asm.h>
 
+#define CLONE_VM	0x00000100
+#define CLONE_THREAD	0x00010000
+
 /* The userland implementation is:
    int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),
    the kernel entry is:
    int clone (long flags, void *child_stack).
 
-   The parameters are passed in register from userland:
+   The parameters are passed in register and on the stack from userland:
    rdi: fn
    rsi: child_stack
    rdx:	flags
    rcx: arg
+   r8d:	TID field in parent
+   r9d: thread pointer
+%esp+8:	TID field in child
 
    The kernel expects:
    rax: system call number
    rdi: flags
-   rsi: child_stack  */
+   rsi: child_stack
+   rdx: TID field in parent
+   r10: TID field in child
+   r8:	thread pointer  */
 
 
         .text
@@ -57,22 +66,46 @@
 	movq	%rcx,8(%rsi)
 
 	/* Save the function pointer.  It will be popped off in the
-	child in the ebx frobbing below.  */
+	   child in the ebx frobbing below.  */
 	movq	%rdi,0(%rsi)
 
 	/* Do the system call.  */
 	movq	%rdx, %rdi
+	movq	%r8, %rdx
+	movq	%r9, %r8
+	movq	8(%rsp), %r10
 	movq	$SYS_ify(clone),%rax
+
+	/* End FDE now, because in the child the unwind info will be
+	   wrong.  */
+	cfi_endproc;
 	syscall
 
 	testq	%rax,%rax
 	jl	SYSCALL_ERROR_LABEL
-	jz	thread_start
+	jz	L(thread_start)
 
 L(pseudo_end):
 	ret
 
-thread_start:
+L(thread_start):
+	/* Clear the frame pointer.  The ABI suggests this be done, to mark
+	   the outermost frame obviously.  */
+	xorq	%rbp, %rbp
+
+#ifdef RESET_PID
+	testq	$CLONE_THREAD, %rdi
+	jne	1f
+	testq	$CLONE_VM, %rdi
+	movl	$-1, %eax
+	jne	2f
+	movq	$SYS_ify(getpid), %rax
+	syscall
+2:	movl	%eax, %fs:PID
+	movl	%eax, %fs:TID
+1:
+#endif
+
 	/* Set up arguments for the function call.  */
 	popq	%rax		/* Function to call.  */
 	popq	%rdi		/* Argument.  */
@@ -81,6 +114,7 @@
 	movq	%rax, %rdi
 	call	HIDDEN_JUMPTARGET (_exit)
 
+	cfi_startproc;
 PSEUDO_END (BP_SYM (__clone))
 
 weak_alias (BP_SYM (__clone), BP_SYM (clone))
diff -Nur sysdeps/unix/sysv/linux/x86_64/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Dist
--- sysdeps/unix/sysv/linux/x86_64/Dist	2002-10-03 02:56:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Dist	2003-02-20 23:20:55.000000000 +0100
@@ -1,4 +1,3 @@
-bits/utmpx.h
 clone.S
 ldd-rewrite.sed
 __start_context.S
diff -Nur sysdeps/unix/sysv/linux/x86_64/dl-cache.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
--- sysdeps/unix/sysv/linux/x86_64/dl-cache.h	2002-04-22 13:51:40.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-cache.h	2003-06-25 10:01:37.000000000 +0200
@@ -1,5 +1,5 @@
 /* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
-   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,4 +22,4 @@
 #define _dl_cache_check_flags(flags)			\
   ((flags) == _DL_CACHE_DEFAULT_ID)
 
-#include_next <dl-cache.h>
+#include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>
diff -Nur sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c
--- sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c	2003-09-26 00:00:18.000000000 +0200
@@ -0,0 +1,5 @@
+#ifdef IS_IN_ldconfig
+#include <sysdeps/i386/dl-procinfo.c>
+#else
+#include <sysdeps/generic/dl-procinfo.c>
+#endif
diff -Nur sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h
--- sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h	2003-07-23 00:06:23.000000000 +0200
@@ -0,0 +1,5 @@
+#ifdef IS_IN_ldconfig
+#include <sysdeps/unix/sysv/linux/i386/dl-procinfo.h>
+#else
+#include <sysdeps/generic/dl-procinfo.h>
+#endif
diff -Nur sysdeps/unix/sysv/linux/x86_64/fstatfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fstatfs64.c
--- sysdeps/unix/sysv/linux/x86_64/fstatfs64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fstatfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fstatfs64 is the same as fstatfs. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/ftruncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/ftruncate64.c
--- sysdeps/unix/sysv/linux/x86_64/ftruncate64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* ftruncate64 is the same as ftruncate. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/fxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fxstat64.c
--- sysdeps/unix/sysv/linux/x86_64/fxstat64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* fxstat64 is in fxstat.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/fxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fxstat.c
--- sysdeps/unix/sysv/linux/x86_64/fxstat.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/fxstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/fxstat.c>
diff -Nur sysdeps/unix/sysv/linux/x86_64/get_clockfreq.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/get_clockfreq.c
--- sysdeps/unix/sysv/linux/x86_64/get_clockfreq.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/get_clockfreq.c	2003-05-09 09:52:47.000000000 +0200
@@ -0,0 +1 @@
+#include "../i386/get_clockfreq.c"
diff -Nur sysdeps/unix/sysv/linux/x86_64/getdents64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getdents64.c
--- sysdeps/unix/sysv/linux/x86_64/getdents64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getdents64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getdents64 is in getdents.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/getdents.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getdents.c
--- sysdeps/unix/sysv/linux/x86_64/getdents.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getdents.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/getdents.c>
-
diff -Nur sysdeps/unix/sysv/linux/x86_64/getrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getrlimit64.c
--- sysdeps/unix/sysv/linux/x86_64/getrlimit64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/getrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* getrlimit64 is the same as getrlimit. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/gettimeofday.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/gettimeofday.S
--- sysdeps/unix/sysv/linux/x86_64/gettimeofday.S	2002-04-14 10:58:48.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/gettimeofday.S	2003-05-22 06:03:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -27,6 +27,7 @@
 ENTRY (__gettimeofday)
 	/* Align stack.  */
 	sub	$0x8, %rsp
+	cfi_adjust_cfa_offset(8)
 	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
 	callq	*%rax
 	/* Check error return.  */
@@ -35,6 +36,7 @@
 
 L(pseudo_end):
 	add	$0x8, %rsp
+	cfi_adjust_cfa_offset(-8)
 	ret
 PSEUDO_END(__gettimeofday)
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/glob64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/glob64.c
--- sysdeps/unix/sysv/linux/x86_64/glob64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/glob64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* glob64 is in glob.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Implies
--- sysdeps/unix/sysv/linux/x86_64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Implies	2004-03-24 00:26:25.000000000 +0100
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff -Nur sysdeps/unix/sysv/linux/x86_64/kernel_stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/kernel_stat.h
--- sysdeps/unix/sysv/linux/x86_64/kernel_stat.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/kernel_stat.h	2003-06-12 18:15:48.000000000 +0200
@@ -0,0 +1,21 @@
+/* Definition of `struct stat' used in the kernel.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define STAT_IS_KERNEL_STAT 1
+#define XSTAT_IS_XSTAT64 1
diff -Nur sysdeps/unix/sysv/linux/x86_64/lxstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/lxstat64.c
--- sysdeps/unix/sysv/linux/x86_64/lxstat64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/lxstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* lxstat64 is in lxstat.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/lxstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/lxstat.c
--- sysdeps/unix/sysv/linux/x86_64/lxstat.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/lxstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/lxstat.c>
diff -Nur sysdeps/unix/sysv/linux/x86_64/makecontext.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/makecontext.c
--- sysdeps/unix/sysv/linux/x86_64/makecontext.c	2002-08-31 10:04:45.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/makecontext.c	2004-06-05 09:54:40.000000000 +0200
@@ -1,5 +1,5 @@
 /* Create new context.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 2002.
 
@@ -58,13 +58,11 @@
 
   /* Generate room on stack for parameter if needed and uc_link.  */
   sp = (long *) ((long) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
-  sp -= (argc > 6 ? argc : 0) + 1;
-  /* Align stack.  */
-  sp = (long *) (((long) sp) & -16L);
-  /* Make space for trampoline address.  */
-  sp -= 8;
+  sp -= (argc > 6 ? argc - 6 : 0) + 1;
+  /* Align stack and make space for trampoline address.  */
+  sp = (long *) ((((long) sp) & -16L) - 8);
 
-  idx_uc_link = (argc > 6 ? argc : 0) + 1;
+  idx_uc_link = (argc > 6 ? argc - 6 : 0) + 1;
 
   /* Setup context ucp.  */
   /* Address to jump to.  */
@@ -102,7 +100,7 @@
 	break;
       default:
 	/* Put value on stack.  */
-	sp[8 + (i - 5)] = va_arg (ap, int);
+	sp[(i - 5)] = va_arg (ap, int);
 	break;
       }
   va_end (ap);
diff -Nur sysdeps/unix/sysv/linux/x86_64/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Makefile
--- sysdeps/unix/sysv/linux/x86_64/Makefile	2002-08-31 10:27:53.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Makefile	2002-10-30 19:25:25.000000000 +0100
@@ -1,48 +1,9 @@
+32bit-predefine = __i386__
+64bit-predefine = __x86_64__
+
 ifeq ($(subdir),misc)
 sysdep_routines += ioperm iopl
 sysdep_headers += sys/perm.h sys/reg.h sys/debugreg.h sys/io.h
-
-no_syscall_list_h = 1
-
-# Generate the list of SYS_* macros for the system calls (__NR_* macros).
-$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/sys/syscall.h
-	rm -f $(@:.h=.d)-t
-	{ \
-	 echo '/* Generated at libc build time from kernel syscall list.  */';\
-	 echo ''; \
-	 echo '#ifndef _SYSCALL_H'; \
-	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
-	 echo '#endif'; \
-	 echo ''; \
-	 SUNPRO_DEPENDENCIES='$(@:.h=.d)-t $@' \
-	 $(CC) -E -x c $(sysincludes) $< -U__x86_64__ -D_LIBC -dM | \
-	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
-	 LC_ALL=C sort > $(@:.d=.h).new32; \
-	 SUNPRO_DEPENDENCIES='$(@:.h=.d)-t $@' \
-	 $(CC) -E -x c $(sysincludes) $< -D__x86_64 -D_LIBC -dM | \
-	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
-	 LC_ALL=C sort > $(@:.d=.h).new64; \
-	 if cmp -s $(@:.d=.h).new32 $(@:.d=.h).new64; then \
-	   cat $(@:.d=.h).new32; \
-	 else \
-	   echo '#include <bits/wordsize.h>'; \
-	   echo ''; \
-	   comm -12 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#if __WORDSIZE == 64'; \
-	   comm -13 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#else'; \
-	   comm -23 $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	   echo '#endif'; \
-	 fi; \
-	 rm -f $(@:.d=.h).new32 $(@:.d=.h).new64; \
-	} > $(@:.d=.h).new
-	mv -f $(@:.d=.h).new $(@:.d=.h)
-	sed < $(@:.h=.d)-t > $(@:.h=.d)-t2 \
-	    -e 's,$(subst .,\.,$@),$(patsubst $(objpfx)%,$$(objpfx)%,\
-					      $(@:.d=.h) $(@:.h=.d)),'
-	rm -f $(@:.h=.d)-t
-	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
-
 endif
 
 ifeq ($(subdir),stdlib)
diff -Nur sysdeps/unix/sysv/linux/x86_64/mmap64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/mmap64.c
--- sysdeps/unix/sysv/linux/x86_64/mmap64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/mmap64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* mmap64 is the same as mmap. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/pread64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/pread64.c
--- sysdeps/unix/sysv/linux/x86_64/pread64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/pread64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/profil-counter.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/profil-counter.h
--- sysdeps/unix/sysv/linux/x86_64/profil-counter.h	2001-09-19 12:32:01.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/profil-counter.h	2002-10-14 19:26:14.000000000 +0200
@@ -1,5 +1,5 @@
 /* Low-level statistical profiling support function.  Linux/x86-64 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,4 +24,9 @@
 profil_counter (int signo, SIGCONTEXT scp)
 {
   profil_count ((void *) GET_PC (scp));
+
+  /* This is a hack to prevent the compiler from implementing the
+     above function call as a sibcall.  The sibcall would overwrite
+     the signal context.  */
+  asm volatile ("");
 }
diff -Nur sysdeps/unix/sysv/linux/x86_64/pwrite64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/pwrite64.c
--- sysdeps/unix/sysv/linux/x86_64/pwrite64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* Empty since the pread syscall is equivalent.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/readdir64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir64.c
--- sysdeps/unix/sysv/linux/x86_64/readdir64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64 is in readdir.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/readdir64_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir64_r.c
--- sysdeps/unix/sysv/linux/x86_64/readdir64_r.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir64_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* readdir64_r is in readdir_r.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/readdir.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir.c
--- sysdeps/unix/sysv/linux/x86_64/readdir.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/readdir.c>
-
diff -Nur sysdeps/unix/sysv/linux/x86_64/readdir_r.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir_r.c
--- sysdeps/unix/sysv/linux/x86_64/readdir_r.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/readdir_r.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/readdir_r.c>
diff -Nur sysdeps/unix/sysv/linux/x86_64/recv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/recv.c
--- sysdeps/unix/sysv/linux/x86_64/recv.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/recv.c	2002-12-18 01:52:07.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,7 +18,7 @@
 
 #include <errno.h>
 #include <sys/socket.h>
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 
 /* Read N bytes into BUF from socket FD.
    Returns the number read or -1 for errors.  */
@@ -26,8 +26,16 @@
 ssize_t
 __libc_recv (int fd, void *buf, size_t n, int flags)
 {
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
 
-  return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 
 weak_alias (__libc_recv, __recv)
diff -Nur sysdeps/unix/sysv/linux/x86_64/register-dump.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/register-dump.h
--- sysdeps/unix/sysv/linux/x86_64/register-dump.h	2002-03-29 00:41:52.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/register-dump.h	2003-09-10 01:57:59.000000000 +0200
@@ -1,5 +1,5 @@
 /* Dump registers.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -65,7 +65,7 @@
 }
 
 static void
-register_dump (int fd, struct sigcontext *ctx)
+register_dump (int fd, struct ucontext *ctx)
 {
   char regs[25][16];
   char fpregs[30][8];
@@ -84,33 +84,33 @@
   ++nr
 
   /* Generate strings of register contents.  */
-  hexvalue (ctx->rax, regs[0], 16);
-  hexvalue (ctx->rbx, regs[1], 16);
-  hexvalue (ctx->rcx, regs[2], 16);
-  hexvalue (ctx->rdx, regs[3], 16);
-  hexvalue (ctx->rsi, regs[4], 16);
-  hexvalue (ctx->rdi, regs[5], 16);
-  hexvalue (ctx->rbp, regs[6], 16);
-  hexvalue (ctx->r8, regs[7], 16);
-  hexvalue (ctx->r9, regs[8], 16);
-  hexvalue (ctx->r10, regs[9], 16);
-  hexvalue (ctx->r11, regs[10], 16);
-  hexvalue (ctx->r12, regs[11], 16);
-  hexvalue (ctx->r13, regs[12], 16);
-  hexvalue (ctx->r14, regs[13], 16);
-  hexvalue (ctx->r15, regs[14], 16);
-  hexvalue (ctx->rsp, regs[15], 16);
-  hexvalue (ctx->rip, regs[16], 16);
-
-  hexvalue (ctx->eflags, regs[17], 8);
-  hexvalue (ctx->cs, regs[18], 4);
-  hexvalue (ctx->fs, regs[19], 4);
-  hexvalue (ctx->gs, regs[20], 4);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RAX], regs[0], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RBX], regs[1], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RCX], regs[2], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RDX], regs[3], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RSI], regs[4], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RDI], regs[5], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RBP], regs[6], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R8], regs[7], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R9], regs[8], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R10], regs[9], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R11], regs[10], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R12], regs[11], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R13], regs[12], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R14], regs[13], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_R15], regs[14], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RSP], regs[15], 16);
+  hexvalue (ctx->uc_mcontext.gregs[REG_RIP], regs[16], 16);
+
+  hexvalue (ctx->uc_mcontext.gregs[REG_EFL], regs[17], 8);
+  hexvalue (ctx->uc_mcontext.gregs[REG_CSGSFS] & 0xffff, regs[18], 4);
+  hexvalue ((ctx->uc_mcontext.gregs[REG_CSGSFS] >> 16) & 0xffff, regs[19], 4);
+  hexvalue ((ctx->uc_mcontext.gregs[REG_CSGSFS] >> 32) & 0xffff, regs[20], 4);
   /* hexvalue (ctx->ss, regs[23], 4); */
-  hexvalue (ctx->trapno, regs[21], 8);
-  hexvalue (ctx->err, regs[22], 8);
-  hexvalue (ctx->oldmask, regs[23], 8);
-  hexvalue (ctx->cr2, regs[24], 8);
+  hexvalue (ctx->uc_mcontext.gregs[REG_TRAPNO], regs[21], 8);
+  hexvalue (ctx->uc_mcontext.gregs[REG_ERR], regs[22], 8);
+  hexvalue (ctx->uc_mcontext.gregs[REG_OLDMASK], regs[23], 8);
+  hexvalue (ctx->uc_mcontext.gregs[REG_CR2], regs[24], 8);
 
   /* Generate the output.  */
   ADD_STRING ("Register dump:\n\n RAX: ");
@@ -168,15 +168,15 @@
   ADD_STRING ("   CR2: ");
   ADD_MEM (regs[24], 8);
 
-  if (ctx->fpstate != NULL)
+  if (ctx->uc_mcontext.fpregs != NULL)
     {
 
       /* Generate output for the FPU control/status registers.  */
-      hexvalue (ctx->fpstate->cwd, fpregs[0], 8);
-      hexvalue (ctx->fpstate->swd, fpregs[1], 8);
-      hexvalue (ctx->fpstate->ftw, fpregs[2], 8);
-      hexvalue (ctx->fpstate->rip, fpregs[3], 8);
-      hexvalue (ctx->fpstate->rdp, fpregs[4], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->cwd, fpregs[0], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->swd, fpregs[1], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->ftw, fpregs[2], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->rip, fpregs[3], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->rdp, fpregs[4], 8);
 
       ADD_STRING ("\n\n FPUCW: ");
       ADD_MEM (fpregs[0], 8);
@@ -190,54 +190,71 @@
       ADD_MEM (fpregs[4], 8);
 
       /* Now the real FPU registers.  */
-      hexvalue (ctx->fpstate->_st[0].exponent, fpregs[5], 8);
-      hexvalue (ctx->fpstate->_st[0].significand[3] << 16
-		| ctx->fpstate->_st[0].significand[2], fpregs[6], 8);
-      hexvalue (ctx->fpstate->_st[0].significand[1] << 16
-		| ctx->fpstate->_st[0].significand[0], fpregs[7], 8);
-      hexvalue (ctx->fpstate->_st[1].exponent, fpregs[8], 8);
-      hexvalue (ctx->fpstate->_st[1].significand[3] << 16
-		| ctx->fpstate->_st[1].significand[2], fpregs[9], 8);
-      hexvalue (ctx->fpstate->_st[1].significand[1] << 16
-		| ctx->fpstate->_st[1].significand[0], fpregs[10], 8);
-      hexvalue (ctx->fpstate->_st[2].exponent, fpregs[11], 8);
-      hexvalue (ctx->fpstate->_st[2].significand[3] << 16
-		| ctx->fpstate->_st[2].significand[2], fpregs[12], 8);
-      hexvalue (ctx->fpstate->_st[2].significand[1] << 16
-		| ctx->fpstate->_st[2].significand[0], fpregs[13], 8);
-      hexvalue (ctx->fpstate->_st[3].exponent, fpregs[14], 8);
-      hexvalue (ctx->fpstate->_st[3].significand[3] << 16
-		| ctx->fpstate->_st[3].significand[2], fpregs[15], 8);
-      hexvalue (ctx->fpstate->_st[3].significand[1] << 16
-		| ctx->fpstate->_st[3].significand[0], fpregs[16], 8);
-      hexvalue (ctx->fpstate->_st[4].exponent, fpregs[17], 8);
-      hexvalue (ctx->fpstate->_st[4].significand[3] << 16
-		| ctx->fpstate->_st[4].significand[2], fpregs[18], 8);
-      hexvalue (ctx->fpstate->_st[4].significand[1] << 16
-		| ctx->fpstate->_st[4].significand[0], fpregs[19], 8);
-      hexvalue (ctx->fpstate->_st[5].exponent, fpregs[20], 8);
-      hexvalue (ctx->fpstate->_st[5].significand[3] << 16
-		| ctx->fpstate->_st[5].significand[2], fpregs[21], 8);
-      hexvalue (ctx->fpstate->_st[5].significand[1] << 16
-		| ctx->fpstate->_st[5].significand[0], fpregs[22], 8);
-      hexvalue (ctx->fpstate->_st[6].exponent, fpregs[23], 8);
-      hexvalue (ctx->fpstate->_st[6].significand[3] << 16
-		| ctx->fpstate->_st[6].significand[2], fpregs[24], 8);
-      hexvalue (ctx->fpstate->_st[6].significand[1] << 16
-		| ctx->fpstate->_st[6].significand[0], fpregs[25], 8);
-      hexvalue (ctx->fpstate->_st[7].exponent, fpregs[26], 8);
-      hexvalue (ctx->fpstate->_st[7].significand[3] << 16
-		| ctx->fpstate->_st[7].significand[2], fpregs[27], 8);
-      hexvalue (ctx->fpstate->_st[7].significand[1] << 16
-		| ctx->fpstate->_st[7].significand[0], fpregs[28], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[0].exponent, fpregs[5], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[0].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[0].significand[2], fpregs[6],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[0].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[0].significand[0], fpregs[7],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[1].exponent, fpregs[8], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[1].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[1].significand[2], fpregs[9],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[1].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[1].significand[0], fpregs[10],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[2].exponent, fpregs[11], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[2].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[2].significand[2], fpregs[12],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[2].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[2].significand[0], fpregs[13],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[3].exponent, fpregs[14], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[3].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[3].significand[2], fpregs[15],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[3].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[3].significand[0], fpregs[16],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[4].exponent, fpregs[17], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[4].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[4].significand[2], fpregs[18],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[4].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[4].significand[0], fpregs[19],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[5].exponent, fpregs[20], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[5].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[5].significand[2], fpregs[21],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[5].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[5].significand[0], fpregs[22],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[6].exponent, fpregs[23], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[6].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[6].significand[2], fpregs[24],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[6].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[6].significand[0], fpregs[25],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[7].exponent, fpregs[26], 8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[7].significand[3] << 16
+		| ctx->uc_mcontext.fpregs->_st[7].significand[2], fpregs[27],
+		8);
+      hexvalue (ctx->uc_mcontext.fpregs->_st[7].significand[1] << 16
+		| ctx->uc_mcontext.fpregs->_st[7].significand[0], fpregs[28],
+		8);
 
-      hexvalue (ctx->fpstate->mxcsr, fpregs[29], 4);
+      hexvalue (ctx->uc_mcontext.fpregs->mxcsr, fpregs[29], 4);
 
       for (i = 0; i < 16; i++)
-	hexvalue (ctx->fpstate->_xmm[i].element[3] << 24
-		  | ctx->fpstate->_xmm[i].element[2] << 16
-		  | ctx->fpstate->_xmm[i].element[1] << 8
-		  | ctx->fpstate->_xmm[i].element[0], xmmregs[i], 32);
+	hexvalue (ctx->uc_mcontext.fpregs->_xmm[i].element[3] << 24
+		  | ctx->uc_mcontext.fpregs->_xmm[i].element[2] << 16
+		  | ctx->uc_mcontext.fpregs->_xmm[i].element[1] << 8
+		  | ctx->uc_mcontext.fpregs->_xmm[i].element[0], xmmregs[i],
+		  32);
 
 
       ADD_STRING ("\n\n ST(0) ");
@@ -284,25 +301,25 @@
       ADD_STRING ("\n mxcsr: ");
       ADD_MEM (fpregs[29], 4);
 
-      ADD_STRING ("\n XMM0: ");
+      ADD_STRING ("\n XMM0:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING (" XMM1: ");
+      ADD_STRING (" XMM1:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING ("\n XMM2: ");
+      ADD_STRING ("\n XMM2:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING (" XMM3: ");
+      ADD_STRING (" XMM3:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING ("\n XMM4: ");
+      ADD_STRING ("\n XMM4:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING (" XMM5: ");
+      ADD_STRING (" XMM5:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING ("\n XMM6: ");
+      ADD_STRING ("\n XMM6:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING (" XMM7: ");
+      ADD_STRING (" XMM7:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING ("\n XMM8: ");
+      ADD_STRING ("\n XMM8:  ");
       ADD_MEM (xmmregs[0], 32);
-      ADD_STRING (" XMM9: ");
+      ADD_STRING (" XMM9:  ");
       ADD_MEM (xmmregs[0], 32);
       ADD_STRING ("\n XMM10: ");
       ADD_MEM (xmmregs[0], 32);
@@ -326,4 +343,4 @@
 }
 
 
-#define REGISTER_DUMP register_dump (fd, &ctx)
+#define REGISTER_DUMP register_dump (fd, ctx)
diff -Nur sysdeps/unix/sysv/linux/x86_64/send.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/send.c
--- sysdeps/unix/sysv/linux/x86_64/send.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/send.c	2002-12-18 01:52:37.000000000 +0100
@@ -18,13 +18,22 @@
 
 #include <errno.h>
 #include <sys/socket.h>
-#include <sysdep.h>
+#include <sysdep-cancel.h>
 
 /* Send N bytes of BUF to socket FD.  Returns the number sent or -1.  */
 ssize_t
 __libc_send (int fd, const void *buf, size_t n, int flags)
 {
-  return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, NULL);
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, NULL);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
 }
 
 weak_alias (__libc_send, __send)
diff -Nur sysdeps/unix/sysv/linux/x86_64/sendfile64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sendfile64.c
--- sysdeps/unix/sysv/linux/x86_64/sendfile64.c	2002-06-07 14:33:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sendfile64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* sendfile64 is alias of sendfile syscall.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/setcontext.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/setcontext.S
--- sysdeps/unix/sysv/linux/x86_64/setcontext.S	2002-08-31 10:27:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/setcontext.S	2004-01-22 09:17:42.000000000 +0100
@@ -1,5 +1,5 @@
 /* Install given context.
-   Copyright (C) 2002 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 2002.
 
@@ -35,6 +35,7 @@
 ENTRY(__setcontext)
 	/* Save argument since syscall will destroy it.  */
 	pushq	%rdi
+	cfi_adjust_cfa_offset(8)
 
 	/* Set the signal mask with
 	   rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */
@@ -45,6 +46,7 @@
 	movq	$__NR_rt_sigprocmask, %rax
 	syscall
 	popq	%rdi			/* Reload %rdi, adjust stack.  */
+	cfi_adjust_cfa_offset(-8)
 	cmpq	$-4095, %rax		/* Check %rax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 
@@ -57,6 +59,16 @@
 
 	/* Load the new stack pointer, the preserved registers and
 	   registers used for passing args.  */
+	cfi_def_cfa(%rdi, 0)
+	cfi_offset(%rbx,oRBX)
+	cfi_offset(%rbp,oRBP)
+	cfi_offset(%r12,oR12)
+	cfi_offset(%r13,oR13)
+	cfi_offset(%r14,oR14)
+	cfi_offset(%r15,oR15)
+	cfi_offset(%rsp,oRSP)
+	cfi_offset(%rip,oRIP)
+
 	movq	oRSP(%rdi), %rsp
 	movq	oRBX(%rdi), %rbx
 	movq	oRBP(%rdi), %rbp
@@ -79,6 +91,10 @@
 	/* Setup finally  %rdi.  */
 	movq	oRDI(%rdi), %rdi
 
+	/* End FDE here, we fall into another context.  */
+	cfi_endproc
+	cfi_startproc
+
 	/* Clear rax to indicate success.  */
 	xorq	%rax, %rax
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/setrlimit64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/setrlimit64.c
--- sysdeps/unix/sysv/linux/x86_64/setrlimit64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/setrlimit64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* setrlimit64 is the same as setrlimit. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sigaction.c
--- sysdeps/unix/sysv/linux/x86_64/sigaction.c	2002-09-18 19:59:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sigaction.c	2003-09-03 05:21:28.000000000 +0200
@@ -1,5 +1,5 @@
 /* POSIX.1 `sigaction' call for Linux/x86-64.
-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,10 +36,14 @@
 /* We do not globally define the SA_RESTORER flag so do it here.  */
 #define SA_RESTORER 0x04000000
 
-extern int __syscall_rt_sigaction (int, const struct kernel_sigaction *__unbounded,
-				   struct kernel_sigaction *__unbounded, size_t);
-
+/* Using the hidden attribute here does not change the code but it
+   helps to avoid warnings.  */
+#if defined HAVE_HIDDEN && defined HAVE_VISIBILITY_ATTRIBUTE \
+    && !defined HAVE_BROKEN_VISIBILITY_ATTRIBUTE
+extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
+#else
 static void restore_rt (void) asm ("__restore_rt");
+#endif
 
 
 /* If ACT is not NULL, change the action for SIG to *ACT.
@@ -74,9 +78,12 @@
   return result;
 }
 libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
 weak_alias (__libc_sigaction, sigaction)
+#endif
 
 /* NOTE: Please think twice before making any changes to the bits of
    code below.  GDB needs some intimate knowledge about it to
@@ -87,14 +94,15 @@
    appropriate GDB maintainer.  */
 
 #define RESTORE(name, syscall) RESTORE2 (name, syscall)
-#define RESTORE2(name, syscall) \
+# define RESTORE2(name, syscall) \
 asm						\
   (						\
    ".align 16\n"				\
+   CFI_STARTPROC "\n"				\
    "__" #name ":\n"				\
    "	movq $" #syscall ", %rax\n"		\
    "	syscall\n"				\
+   CFI_ENDPROC "\n"				\
    );
-
 /* The return code for realtime-signals.  */
 RESTORE (restore_rt, __NR_rt_sigreturn)
diff -Nur sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
--- sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h	2002-03-29 00:41:52.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h	2003-09-10 01:58:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,11 +16,11 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#define SIGCONTEXT struct sigcontext
-#define SIGCONTEXT_EXTRA_ARGS
-#define GET_PC(ctx)	((void *) ctx.rip)
-#define GET_FRAME(ctx)	((void *) ctx.rbp)
-#define GET_STACK(ctx)	((void *) ctx.rsp)
+#define SIGCONTEXT siginfo_t *_si, struct ucontext *
+#define SIGCONTEXT_EXTRA_ARGS _si,
+#define GET_PC(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RIP])
+#define GET_FRAME(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RBP])
+#define GET_STACK(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RSP])
 
 #define CALL_SIGHANDLER(handler, signo, ctx) \
   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff -Nur sysdeps/unix/sysv/linux/x86_64/__start_context.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/__start_context.S
--- sysdeps/unix/sysv/linux/x86_64/__start_context.S	2002-08-31 10:05:17.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/__start_context.S	2004-01-10 19:06:16.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 2002.
 
@@ -33,6 +33,7 @@
 	movq	%rbx, %rsp
 
 	popq	%rdi			/* This is the next context.  */
+	cfi_adjust_cfa_offset(-8)
 	testq	%rdi, %rdi
 	je	2f			/* If it is zero exit.  */
 
@@ -41,7 +42,7 @@
 	   exit the program with the return error value (-1).  */
 
 2:	movq	%rax,%rdi
-	call	JUMPTARGET(exit)
+	call	HIDDEN_JUMPTARGET(exit)
 	/* The 'exit' call should never return.  In case it does cause
 	   the process to terminate.  */
 	hlt
diff -Nur sysdeps/unix/sysv/linux/x86_64/statfs64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/statfs64.c
--- sysdeps/unix/sysv/linux/x86_64/statfs64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/statfs64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* statfs64 is the same as statfs. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
--- sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h	2001-11-21 13:21:56.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h	2003-04-30 12:03:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,6 +18,7 @@
 
 #ifndef _SYS_DEBUGREG_H
 #define _SYS_DEBUGREG_H	1
+#include <bits/wordsize.h>
 
 /* Indicate the register numbers for a number of the specific
    debug registers.  Registers 0-3 contain the addresses we wish to trap on */
@@ -73,7 +74,14 @@
 
 /* The second byte to the control register has a few special
    things.  */
-#define DR_CONTROL_RESERVED (0xFC00) /* Reserved */
+
+
+
+#if __WORDSIZE == 64
+# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#else
+# define DR_CONTROL_RESERVED (0x00FC00U) /* Reserved */
+#endif
 #define DR_LOCAL_SLOWDOWN   (0x100)  /* Local slow the pipeline */
 #define DR_GLOBAL_SLOWDOWN  (0x200)  /* Global slow the pipeline */
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/sys/epoll.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/epoll.h
--- sysdeps/unix/sysv/linux/x86_64/sys/epoll.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/epoll.h	2004-01-21 07:19:35.000000000 +0100
@@ -0,0 +1,107 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H	1
+
+#include <stdint.h>
+#include <sys/types.h>
+
+
+enum EPOLL_EVENTS
+  {
+    EPOLLIN = 0x001,
+#define EPOLLIN EPOLLIN
+    EPOLLPRI = 0x002,
+#define EPOLLPRI EPOLLPRI
+    EPOLLOUT = 0x004,
+#define EPOLLOUT EPOLLOUT
+    EPOLLRDNORM = 0x040,
+#define EPOLLRDNORM EPOLLRDNORM
+    EPOLLRDBAND = 0x080,
+#define EPOLLRDBAND EPOLLRDBAND
+    EPOLLWRNORM = 0x100,
+#define EPOLLWRNORM EPOLLWRNORM
+    EPOLLWRBAND = 0x200,
+#define EPOLLWRBAND EPOLLWRBAND
+    EPOLLMSG = 0x400,
+#define EPOLLMSG EPOLLMSG
+    EPOLLERR = 0x008,
+#define EPOLLERR EPOLLERR
+    EPOLLHUP = 0x010,
+#define EPOLLHUP EPOLLHUP
+    EPOLLONESHOT = (1 << 30),
+#define EPOLLONESHOT EPOLLONESHOT
+    EPOLLET = (1 << 31)
+#define EPOLLET EPOLLET
+  };
+
+
+/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */
+#define EPOLL_CTL_ADD 1	/* Add a file decriptor to the interface.  */
+#define EPOLL_CTL_DEL 2	/* Remove a file decriptor from the interface.  */
+#define EPOLL_CTL_MOD 3	/* Change file decriptor epoll_event structure.  */
+
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+} __attribute__ ((__packed__));
+
+
+__BEGIN_DECLS
+
+/* Creates an epoll instance.  Returns an fd for the new instance.
+   The "size" parameter is a hint specifying the number of file
+   descriptors to be associated with the new instance.  The fd
+   returned by epoll_create() should be closed with close().  */
+extern int epoll_create (int __size) __THROW;
+
+
+/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
+   -1 in case of error ( the "errno" variable will contain the
+   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
+   constants defined above. The "fd" parameter is the target of the
+   operation. The "event" parameter describes which events the caller
+   is interested in and any associated user data.  */
+extern int epoll_ctl (int __epfd, int __op, int __fd,
+		      struct epoll_event *__event) __THROW;
+
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).  */
+extern int epoll_wait (int __epfd, struct epoll_event *__events,
+		       int __maxevents, int __timeout) __THROW;
+
+__END_DECLS
+
+#endif /* sys/epoll.h */
diff -Nur sysdeps/unix/sysv/linux/x86_64/sys/procfs.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
--- sysdeps/unix/sysv/linux/x86_64/sys/procfs.h	2001-09-19 12:30:49.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h	2004-11-05 00:37:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,10 +45,20 @@
 #define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
+#if __WORDSIZE == 32
+/* Register set for the floating-point registers.  */
+typedef struct user_fpregs_struct elf_fpregset_t;
+
+/* Register set for the extended floating-point registers.  Includes
+   the Pentium III SSE registers in addition to the classic
+   floating-point stuff.  */
+typedef struct user_fpxregs_struct elf_fpxregset_t;
+#else
 /* Register set for the extended floating-point registers.  Includes
    the Pentium III SSE registers in addition to the classic
    floating-point stuff.  */
 typedef struct user_fpregs_struct elf_fpregset_t;
+#endif
 
 /* Signal info.  */
 struct elf_siginfo
@@ -94,8 +104,13 @@
     char pr_zomb;			/* Zombie.  */
     char pr_nice;			/* Nice val.  */
     unsigned long int pr_flag;		/* Flags.  */
+#if __WORDSIZE == 32
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+#else
     unsigned int pr_uid;
     unsigned int pr_gid;
+#endif
     int pr_pid, pr_ppid, pr_pgrp, pr_sid;
     /* Lots missing */
     char pr_fname[16];			/* Filename of executable.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
--- sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h	2002-03-29 00:41:53.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h	2002-11-10 12:10:26.000000000 +0100
@@ -33,7 +33,7 @@
 typedef long int greg_t;
 
 /* Number of general registers.  */
-#define NGREG	21
+#define NGREG	23
 
 /* Container for all general registers.  */
 typedef greg_t gregset_t[NGREG];
@@ -82,8 +82,12 @@
 # define REG_CSGSFS	REG_CSGSFS
   REG_ERR,
 # define REG_ERR	REG_ERR
-  REG_TRAPNO
+  REG_TRAPNO,
 # define REG_TRAPNO	REG_TRAPNO
+  REG_OLDMASK,
+# define REG_OLDMASK	REG_OLDMASK
+  REG_CR2
+# define REG_CR2	REG_CR2
 };
 #endif
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/sys/user.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/user.h
--- sysdeps/unix/sysv/linux/x86_64/sys/user.h	2002-03-29 00:41:53.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sys/user.h	2004-11-05 00:37:34.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -38,7 +38,7 @@
   __uint32_t		mxcsr;
   __uint32_t		mxcr_mask;
   __uint32_t		st_space[32];   /* 8*16 bytes for each FP-reg = 128 bytes */
-  __uint32_t		xmm_space[64];  /* 16*16 bytes for each XMM-reg = 128 bytes */
+  __uint32_t		xmm_space[64];  /* 16*16 bytes for each XMM-reg = 256 bytes */
   __uint32_t		padding[24];
 };
 
diff -Nur sysdeps/unix/sysv/linux/x86_64/syscall.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/syscall.S
--- sysdeps/unix/sysv/linux/x86_64/syscall.S	2001-09-19 12:31:54.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/syscall.S	2003-12-12 12:02:04.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,20 +21,20 @@
 /* Please consult the file sysdeps/unix/sysv/linux/x86-64/sysdep.h for
    more information about the value -4095 used below.  */
 
-/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5)
+/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
    We need to do some arg shifting, the syscall_number will be in
    rax.  */
 
 
 	.text
 ENTRY (syscall)
-
 	movq %rdi, %rax		/* Syscall number -> rax.  */
 	movq %rsi, %rdi		/* shift arg1 - arg5.  */
 	movq %rdx, %rsi
 	movq %rcx, %rdx
 	movq %r8, %r10
 	movq %r9, %r8
+	movq 8(%rsp),%r9	/* arg6 is on the stack.  */
 	syscall			/* Do the system call.  */
 	cmpq $-4095, %rax	/* Check %rax for error.  */
 	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
diff -Nur sysdeps/unix/sysv/linux/x86_64/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/syscalls.list
--- sysdeps/unix/sysv/linux/x86_64/syscalls.list	2002-08-23 21:47:02.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/syscalls.list	2004-03-24 00:31:17.000000000 +0100
@@ -1,48 +1,35 @@
 # File name	Caller	Syscall name	# args	Strong name	Weak names
 
 arch_prctl	EXTRA	arch_prctl	i:ii	__arch_prctl	arch_prctl
-mmap		-	mmap		b:aniiii __mmap		mmap __mmap64 mmap64
 modify_ldt	EXTRA	modify_ldt	i:ipi	__modify_ldt	modify_ldt
-llseek		EXTRA	lseek		i:iii	__libc_lseek64	__llseek llseek __lseek64 lseek64
-pread		-	pread		i:ibni	__libc_pread	__libc_pread64 __pread pread __pread64 pread64
-pwrite		-	pwrite		i:ibni	__libc_pwrite	__libc_pwrite64 __pwrite pwrite __pwrite64 pwrite64
-fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs __fstatfs64 fstatfs64
-statfs		-	statfs		i:sp	__statfs	statfs statfs64
-getresgid	-	getresgid	i:ppp	getresgid
-getresuid	-	getresuid	i:ppp	getresuid
-getrlimit	-	getrlimit	i:ip	__getrlimit	getrlimit getrlimit64
-setrlimit	-	setrlimit	i:ip	__setrlimit	setrlimit64 setrlimit
-ftruncate	-	ftruncate	i:ii	__ftruncate	ftruncate ftruncate64 __ftruncate64
-truncate	-	truncate	i:si	truncate	truncate64
-readahead	EXTRA	readahead	i:iipi	__readahead	readahead
-sendfile	-	sendfile	i:iip	sendfile	sendfile64
 
 # semaphore and shm system calls
 msgctl		-	msgctl		i:iip	__msgctl	msgctl
 msgget		-	msgget		i:ii	__msgget	msgget
-msgrcv		-	msgrcv		i:ibnii	__msgrcv	msgrcv
-msgsnd		-	msgsnd		i:ibni	__msgsnd	msgsnd
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
 shmat		-	shmat		i:ipi	__shmat		shmat
 shmctl		-	shmctl		i:iip	__shmctl	shmctl
 shmdt		-	shmdt		i:s	__shmdt		shmdt
 shmget		-	shmget		i:iii	__shmget	shmget
 semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
 semget		-	semget		i:iii	__semget	semget
 semctl		-	semctl		i:iiii	__semctl	semctl
 
 
 # proper socket implementations:
-accept		-	accept		i:iBN	__libc_accept	__accept accept
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
 bind		-	bind		i:ipi	__bind		bind
-connect		-	connect		i:ipi	__libc_connect	__connect_internal __connect connect
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
 getpeername	-	getpeername	i:ipp	__getpeername	getpeername
 getsockname	-	getsockname	i:ipp	__getsockname	getsockname
 getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
 listen		-	listen		i:ii	__listen	listen
-recvfrom	-	recvfrom	i:ibniBN	__libc_recvfrom	__recvfrom recvfrom
-recvmsg		-	recvmsg		i:ipi	__libc_recvmsg	__recvmsg recvmsg
-sendmsg		-	sendmsg		i:ipi	__libc_sendmsg	__sendmsg sendmsg
-sendto		-	sendto		i:ibnibn	__libc_sendto	__sendto sendto
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
 setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
 shutdown	-	shutdown	i:ii	__shutdown	shutdown
 socket		-	socket		i:iii	__socket	socket
diff -Nur sysdeps/unix/sysv/linux/x86_64/sysconf.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysconf.c
--- sysdeps/unix/sysv/linux/x86_64/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysconf.c	2004-10-05 11:23:06.000000000 +0200
@@ -0,0 +1,318 @@
+/* Get file-specific information about a file.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+
+static long int linux_sysconf (int name);
+
+
+static const struct intel_02_cache_info
+{
+  unsigned int idx;
+  int name;
+  long int size;
+  long int assoc;
+  long int linesize;
+} intel_02_known[] =
+  {
+    { 0x06, _SC_LEVEL1_ICACHE_SIZE, 8192, 4, 32 },
+    { 0x08, _SC_LEVEL1_ICACHE_SIZE, 16384, 4, 32 },
+    { 0x0a, _SC_LEVEL1_DCACHE_SIZE, 8192, 2, 32 },
+    { 0x0c, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 32 },
+    { 0x22, _SC_LEVEL3_CACHE_SIZE, 524288, 4, 64 },
+    { 0x23, _SC_LEVEL3_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x25, _SC_LEVEL3_CACHE_SIZE, 2097152, 8, 64 },
+    { 0x29, _SC_LEVEL3_CACHE_SIZE, 4194304, 8, 64 },
+    { 0x2c, _SC_LEVEL1_DCACHE_SIZE, 32768, 8, 64 },
+    { 0x30, _SC_LEVEL1_ICACHE_SIZE, 32768, 8, 64 },
+    { 0x41, _SC_LEVEL2_CACHE_SIZE, 131072, 4, 32 },
+    { 0x42, _SC_LEVEL2_CACHE_SIZE, 262144, 4, 32 },
+    { 0x43, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 32 },
+    { 0x44, _SC_LEVEL2_CACHE_SIZE, 1048576, 4, 32 },
+    { 0x45, _SC_LEVEL2_CACHE_SIZE, 2097152, 4, 32 },
+    { 0x60, _SC_LEVEL1_DCACHE_SIZE, 16384, 8, 64 },
+    { 0x66, _SC_LEVEL1_DCACHE_SIZE, 8192, 4, 64 },
+    { 0x67, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 64 },
+    { 0x68, _SC_LEVEL1_DCACHE_SIZE, 32768, 4, 64 },
+    { 0x78, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x79, _SC_LEVEL2_CACHE_SIZE, 131072, 8, 64 },
+    { 0x7a, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 64 },
+    { 0x7b, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 64 },
+    { 0x7c, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+    { 0x7d, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 64 },
+    { 0x82, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 32 },
+    { 0x83, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 32 },
+    { 0x84, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 32 },
+    { 0x85, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 32 },
+    { 0x86, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 64 },
+    { 0x87, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
+  };
+#define nintel_02_known (sizeof (intel_02_known) / sizeof (intel_02_known[0]))
+
+
+static int
+intel_02_known_compare (const void *p1, const void *p2)
+{
+  const struct intel_02_cache_info *i1;
+  const struct intel_02_cache_info *i2;
+
+  i1 = (const struct intel_02_cache_info *) p1;
+  i2 = (const struct intel_02_cache_info *) p2;
+
+  if (i1->idx == i2->idx)
+    return 0;
+
+  return i1->idx < i2->idx ? -1 : 1;
+}
+
+
+static long int
+intel_check_word (int name, unsigned int value, bool *has_level_2,
+		  bool *no_level_2_or_3)
+{
+  if ((value & 0x80000000) != 0)
+    /* The register value is reserved.  */
+    return 0;
+
+  /* Fold the name.  The _SC_ constants are always in the order SIZE,
+     ASSOC, LINESIZE.  */
+  int folded_name = (_SC_LEVEL1_ICACHE_SIZE
+		     + ((name - _SC_LEVEL1_ICACHE_SIZE) / 3) * 3);
+
+  while (value != 0)
+    {
+      unsigned int byte = value & 0xff;
+
+      if (byte == 0x40)
+	{
+	  *no_level_2_or_3 = true;
+
+	  if (folded_name == _SC_LEVEL3_CACHE_SIZE)
+	    /* No need to look further.  */
+	    break;
+	}
+      else
+	{
+	  struct intel_02_cache_info *found;
+	  struct intel_02_cache_info search;
+
+	  search.idx = byte;
+	  found = bsearch (&search, intel_02_known, nintel_02_known,
+			   sizeof (intel_02_known[0]), intel_02_known_compare);
+	  if (found != NULL)
+	    {
+	      if (found->name == folded_name)
+		{
+		  unsigned int offset = name - folded_name;
+
+		  if (offset == 0)
+		    /* Cache size.  */
+		    return found->size;
+		  if (offset == 1)
+		    return found->assoc;
+
+		  assert (offset == 2);
+		  return found->linesize;
+		}
+
+	      if (found->name == _SC_LEVEL2_CACHE_SIZE)
+		*has_level_2 = true;
+	    }
+	}
+
+      /* Next byte for the next round.  */
+      value >>= 8;
+    }
+
+  /* Nothing found.  */
+  return 0;
+}
+
+
+static long int
+handle_intel (int name, unsigned int maxidx)
+{
+  assert (maxidx >= 2);
+
+  /* OK, we can use the CPUID instruction to get all info about the
+     caches.  */
+  unsigned int cnt = 0;
+  unsigned int max = 1;
+  long int result = 0;
+  bool no_level_2_or_3 = false;
+  bool has_level_2 = false;
+  while (cnt++ < max)
+    {
+      unsigned int eax;
+      unsigned int ebx;
+      unsigned int ecx;
+      unsigned int edx;
+      asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		    : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		    : "0" (2));
+
+      /* The low byte of EAX in the first round contain the number of
+	 rounds we have to make.  At least one, the one we are already
+	 doing.  */
+      if (cnt == 1)
+	{
+	  max = eax & 0xff;
+	  eax &= 0xffffff00;
+	}
+
+      /* Process the individual registers' value.  */
+      result = intel_check_word (name, eax, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ebx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ecx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, edx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+    }
+
+  if (name >= _SC_LEVEL2_CACHE_SIZE && name <= _SC_LEVEL3_CACHE_LINESIZE
+      && no_level_2_or_3)
+    return -1;
+
+  return 0;
+}
+
+
+static long int
+handle_amd (int name)
+{
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0x80000000));
+
+  if (name >= _SC_LEVEL3_CACHE_SIZE)
+    return 0;
+
+  unsigned int fn = 0x80000005 + (name >= _SC_LEVEL2_CACHE_SIZE);
+  if (eax < fn)
+    return 0;
+
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (fn));
+
+  if (name < _SC_LEVEL1_DCACHE_SIZE)
+    {
+      name += _SC_LEVEL1_DCACHE_SIZE - _SC_LEVEL1_ICACHE_SIZE;
+      ecx = edx;
+    }
+
+  switch (name)
+    {
+    case _SC_LEVEL1_DCACHE_SIZE:
+      return (ecx >> 14) & 0x3fc00;
+    case _SC_LEVEL1_DCACHE_ASSOC:
+      ecx >>= 16;
+      if ((ecx & 0xff) == 0xff)
+	/* Fully associative.  */
+	return (ecx << 2) & 0x3fc00;
+      return ecx & 0xff;
+    case _SC_LEVEL1_DCACHE_LINESIZE:
+      return ecx & 0xff;
+    case _SC_LEVEL2_CACHE_SIZE:
+      return (ecx & 0xf000) == 0 ? 0 : (ecx >> 6) & 0x3fffc00;
+    case _SC_LEVEL2_CACHE_ASSOC:
+      ecx >>= 12;
+      switch (ecx & 0xf)
+        {
+        case 0:
+        case 1:
+        case 2:
+        case 4:
+	  return ecx & 0xf;
+	case 6:
+	  return 8;
+	case 8:
+	  return 16;
+	case 0xf:
+	  return (ecx << 6) & 0x3fffc00;
+	default:
+	  return 0;
+        }
+    case _SC_LEVEL2_CACHE_LINESIZE:
+      return (ecx & 0xf000) == 0 ? 0 : ecx & 0xff;
+    default:
+      assert (! "cannot happen");
+    }
+  return -1;
+}
+
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  if (name == _SC_CPUTIME || name == _SC_THREAD_CPUTIME)
+    {
+      /* XXX Test whether TSC is usable.  */
+      return 200112L;
+    }
+
+  /* We only handle the cache information here (for now).  */
+  if (name < _SC_LEVEL1_ICACHE_SIZE || name > _SC_LEVEL4_CACHE_LINESIZE)
+    return linux_sysconf (name);
+
+  /* Find out what brand of processor.  */
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
+		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0));
+
+  /* This spells out "GenuineIntel".  */
+  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
+    return handle_intel (name, eax);
+
+  /* This spells out "AuthenticAMD".  */
+  if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
+    return handle_amd (name);
+
+  // XXX Fill in more vendors.
+
+  /* CPU not known, we have no information.  */
+  return 0;
+}
+
+/* Now the generic Linux version.  */
+#undef __sysconf
+#define __sysconf static linux_sysconf
+#include "../sysconf.c"
diff -Nur sysdeps/unix/sysv/linux/x86_64/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysdep.h
--- sysdeps/unix/sysv/linux/x86_64/sysdep.h	2002-10-01 00:03:10.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysdep.h	2004-10-04 22:59:36.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001,02 Free Software Foundation, Inc.
+/* Copyright (C) 2001,02,03,04 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,6 +23,11 @@
 #include <sysdeps/unix/x86_64/sysdep.h>
 #include <bp-sym.h>
 #include <bp-asm.h>
+#include <tls.h>
+
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
 
 /* For Linux we can use the system call table in the header file
 	/usr/include/asm/unistd.h
@@ -41,6 +46,13 @@
 # define __NR_pwrite __NR_pwrite64
 #endif
 
+/* This is to help the old kernel headers where __NR_semtimedop is not
+   available.  */
+#ifndef __NR_semtimedop
+# define __NR_semtimedop 220
+#endif
+
+
 #ifdef __ASSEMBLER__
 
 /* Linux uses a negative return value to indicate syscall errors,
@@ -76,14 +88,56 @@
   SYSCALL_ERROR_HANDLER							      \
   END (name)
 
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    negq %rax
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
 #ifndef PIC
 #define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
-#elif USE_TLS && HAVE___THREAD
+#elif RTLD_PRIVATE_ERRNO
 # define SYSCALL_ERROR_HANDLER			\
-  movq errno@GOTTPOFF(%rip), %rcx;		\
+0:						\
+  leaq rtld_errno(%rip), %rcx;			\
   xorq %rdx, %rdx;				\
   subq %rax, %rdx;				\
-  movl %eax, %fs:0(%rcx)
+  movl %edx, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#elif USE___THREAD
+# ifndef NOT_IN_libc
+#  define SYSCALL_ERROR_ERRNO __libc_errno
+# else
+#  define SYSCALL_ERROR_ERRNO errno
+# endif
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  xorq %rdx, %rdx;				\
+  subq %rax, %rdx;				\
+  movl %edx, %fs:(%rcx);			\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
 #elif defined _LIBC_REENTRANT
 /* Store (- %rax) into errno through the GOT.
    Note that errno occupies only 4 bytes.  */
@@ -91,11 +145,13 @@
 0:						\
   xorq %rdx, %rdx;				\
   subq %rax, %rdx;				\
-  pushq %rdx					\
+  pushq %rdx;					\
+  cfi_adjust_cfa_offset(8);			\
   PUSH_ERRNO_LOCATION_RETURN;			\
   call BP_SYM (__errno_location)@PLT;		\
   POP_ERRNO_LOCATION_RETURN;			\
   popq %rdx;					\
+  cfi_adjust_cfa_offset(-8);			\
   movl %edx, (%rax);				\
   orq $-1, %rax;				\
   jmp L(pseudo_end);
@@ -112,37 +168,42 @@
   jmp L(pseudo_end);
 #endif	/* PIC */
 
-/* Linux/x86-64 takes system call arguments in registers:
+/* The Linux/x86-64 kernel expects the system call parameters in
+   registers according to the following table:
 
-    Register setup:
-    system call number	rax
+    syscall number	rax
     arg 1		rdi
     arg 2		rsi
     arg 3		rdx
-    arg 4		rcx
+    arg 4		r10
     arg 5		r8
     arg 6		r9
 
+    The Linux kernel uses and destroys internally these registers:
     return address from
     syscall		rcx
     additionally clobered: r12-r15,rbx,rbp
     eflags from syscall	r11
 
-    The compiler is going to form a call by coming here, through PSEUDO, with arguments:
+    Normal function call, including calls to the system call stub
+    functions in the libc, get the first six parameters passed in
+    registers and the seventh parameter and later on the stack.  The
+    register use is as follows:
+
+     system call number	in the DO_CALL macro
+     arg 1		rdi
+     arg 2		rsi
+     arg 3		rdx
+     arg 4		rcx
+     arg 5		r8
+     arg 6		r9
+
+    We have to take care that the stack is aligned to 16 bytes.  When
+    called the stack is not aligned since the return address has just
+    been pushed.
 
-	syscall number	in the DO_CALL macro
-	arg 1		rdi
-	arg 2		rsi
-	arg 3		rdx
-	arg 4		r10
-	arg 5		r8
-	arg 6		r9
-
-     We have to take care that the stack is alignedto 16 bytes.	 When
-     called the stack is not aligned since the return address has just
-     been pushed.
 
-     Syscalls of more than 6 arguments are not supported.  */
+    Syscalls of more than 6 arguments are not supported.  */
 
 #undef	DO_CALL
 #define DO_CALL(syscall_name, args)		\
@@ -164,51 +225,88 @@
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) \
   ({									      \
+    unsigned long resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
+      {									      \
+	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
+	resultvar = (unsigned long) -1;					      \
+      }									      \
+    (long) resultvar; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
     unsigned long resultvar;						      \
     LOAD_ARGS_##nr (args)						      \
+    LOAD_REGS_##nr							      \
     asm volatile (							      \
-    "movq %1, %%rax\n\t"						      \
     "syscall\n\t"							      \
     : "=a" (resultvar)							      \
-    : "i" (__NR_##name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");	      \
-    if (resultvar >= (unsigned long) -4095)				      \
-      {									      \
-	__set_errno (-resultvar);					      \
-	resultvar = (unsigned long) -1;					      \
-      }									      \
+    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");		      \
     (long) resultvar; })
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_NCS (__NR_##name, err, nr, ##args)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned long) (val) >= -4095L)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
 #define LOAD_ARGS_0()
+#define LOAD_REGS_0
 #define ASM_ARGS_0
 
 #define LOAD_ARGS_1(a1)					\
-  register long int _a1 asm ("rdi") = (long) (a1);	\
+  long int __arg1 = (long) (a1);			\
   LOAD_ARGS_0 ()
+#define LOAD_REGS_1					\
+  register long int _a1 asm ("rdi") = __arg1;		\
+  LOAD_REGS_0
 #define ASM_ARGS_1	ASM_ARGS_0, "r" (_a1)
 
 #define LOAD_ARGS_2(a1, a2)				\
-  register long int _a2 asm ("rsi") = (long) (a2);	\
+  long int __arg2 = (long) (a2);			\
   LOAD_ARGS_1 (a1)
+#define LOAD_REGS_2					\
+  register long int _a2 asm ("rsi") = __arg2;		\
+  LOAD_REGS_1
 #define ASM_ARGS_2	ASM_ARGS_1, "r" (_a2)
 
 #define LOAD_ARGS_3(a1, a2, a3)				\
-  register long int _a3 asm ("rdx") = (long) (a3);	\
+  long int __arg3 = (long) (a3);			\
   LOAD_ARGS_2 (a1, a2)
+#define LOAD_REGS_3					\
+  register long int _a3 asm ("rdx") = __arg3;		\
+  LOAD_REGS_2
 #define ASM_ARGS_3	ASM_ARGS_2, "r" (_a3)
 
 #define LOAD_ARGS_4(a1, a2, a3, a4)			\
-  register long int _a4 asm ("r10") = (long) (a4);	\
+  long int __arg4 = (long) (a4);			\
   LOAD_ARGS_3 (a1, a2, a3)
+#define LOAD_REGS_4					\
+  register long int _a4 asm ("r10") = __arg4;		\
+  LOAD_REGS_3
 #define ASM_ARGS_4	ASM_ARGS_3, "r" (_a4)
 
 #define LOAD_ARGS_5(a1, a2, a3, a4, a5)			\
-  register long int _a5 asm ("r8") = (long) (a5);	\
+  long int __arg5 = (long) (a5);			\
   LOAD_ARGS_4 (a1, a2, a3, a4)
+#define LOAD_REGS_5					\
+  register long int _a5 asm ("r8") = __arg5;		\
+  LOAD_REGS_4
 #define ASM_ARGS_5	ASM_ARGS_4, "r" (_a5)
 
 #define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
-  register long int _a6 asm ("r9") = (long) (a6);	\
+  long int __arg6 = (long) (a6);			\
   LOAD_ARGS_5 (a1, a2, a3, a4, a5)
+#define LOAD_REGS_6					\
+  register long int _a6 asm ("r9") = __arg6;		\
+  LOAD_REGS_5
 #define ASM_ARGS_6	ASM_ARGS_5, "r" (_a6)
 
 #endif	/* __ASSEMBLER__ */
diff -Nur sysdeps/unix/sysv/linux/x86_64/sysdep.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysdep.S
--- sysdeps/unix/sysv/linux/x86_64/sysdep.S	2002-09-30 02:50:05.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/sysdep.S	2002-10-11 12:51:31.000000000 +0200
@@ -17,30 +17,6 @@
    02111-1307 USA.  */
 
 #include <sysdep.h>
-#include <tls.h>
-
-/* The Linux version is in fact x86-64/ELF and the start.? file for this
-   system (sysdeps/x86_64/elf/start.S) is also used by The Hurd.  This file
-   must not contain the definition of the `errno' variable, we have to
-   define it somewhere else.
-
-   ...and this place is here.  */
-#if USE_TLS && HAVE___THREAD
-	.section .tbss
-#else
-	.bss
-#endif
-	.globl	errno
-	.type errno,@object
-	.size errno,4
-	.globl	_errno
-	.type _errno,@object
-	.size _errno,4
-	.align 4
-errno:
-_errno:
-	.space	4
-
 
 /* The following code is only used in the shared library when we
    compile the reentrant version.  Otherwise each system call defines
diff -Nur sysdeps/unix/sysv/linux/x86_64/time.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/time.S
--- sysdeps/unix/sysv/linux/x86_64/time.S	2002-08-03 18:57:52.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/time.S	2003-07-27 20:54:44.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001,02 Free Software Foundation, Inc.
+/* Copyright (C) 2001,02, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -30,14 +30,13 @@
 ENTRY (time)
 	/* Align stack.  */
 	sub	$0x8, %rsp
+	cfi_adjust_cfa_offset(8)
+
 	movq	$VSYSCALL_ADDR_vtime, %rax
 	callq	*%rax
-	/* Check error return.  */
-	cmpl	$-4095, %eax
-	jae	SYSCALL_ERROR_LABEL
 
-L(pseudo_end):
 	add	$0x8, %rsp
+	cfi_adjust_cfa_offset(-8)
 	ret
-PSEUDO_END(time)
+PSEUDO_END_NOERRNO(time)
 libc_hidden_def (time)
diff -Nur sysdeps/unix/sysv/linux/x86_64/truncate64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/truncate64.c
--- sysdeps/unix/sysv/linux/x86_64/truncate64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/truncate64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* truncate64 is the same as truncate. */
diff -Nur sysdeps/unix/sysv/linux/x86_64/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Versions
--- sysdeps/unix/sysv/linux/x86_64/Versions	2002-08-23 21:47:02.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/Versions	2004-05-03 23:26:23.000000000 +0200
@@ -6,7 +6,4 @@
 
     modify_ldt;
   }
-  GLIBC_PRIVATE {
-    __modify_ldt;
-  }
 }
diff -Nur sysdeps/unix/sysv/linux/x86_64/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/vfork.S
--- sysdeps/unix/sysv/linux/x86_64/vfork.S	2002-04-22 09:46:34.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/vfork.S	2004-03-09 07:29:00.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,25 +29,33 @@
 
 	/* Pop the return PC value into RDI.  We need a register that
 	   is preserved by the syscall and that we're allowed to destroy. */
-	popq %rdi
+	popq	%rdi
+	cfi_adjust_cfa_offset(-8)
+
+#ifdef SAVE_PID
+	SAVE_PID
+#endif
 
 	/* Stuff the syscall number in RAX and enter into the kernel.  */
 	movl	$SYS_ify (vfork), %eax
 	syscall
-	cmpl	$-4095, %eax
-	jae	.Lerror		/* Branch forward if it failed.  */
-
-	/* Jump to the return PC.  */
-	jmp	*%rdi
 
-.Lerror:
 	/* Push back the return PC.  */
 	pushq	%rdi
-	jmp	SYSCALL_ERROR_LABEL
+	cfi_adjust_cfa_offset(8)
+
+#ifdef RESTORE_PID
+	RESTORE_PID
+#endif
+
+	cmpl	$-4095, %eax
+	jae SYSCALL_ERROR_LABEL		/* Branch forward if it failed.  */
 
+	/* Normal return.  */
 .Lpseudo_end:
 	ret
 
 PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
 
 weak_alias (__vfork, vfork)
diff -Nur sysdeps/unix/sysv/linux/x86_64/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/xstat64.c
--- sysdeps/unix/sysv/linux/x86_64/xstat64.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/xstat64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* xstat64 is in xstat.c */
diff -Nur sysdeps/unix/sysv/linux/x86_64/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/xstat.c
--- sysdeps/unix/sysv/linux/x86_64/xstat.c	2001-09-19 12:31:31.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/x86_64/xstat.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/ia64/xstat.c>
diff -Nur sysdeps/unix/sysv/linux/xmknod.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xmknod.c
--- sysdeps/unix/sysv/linux/xmknod.c	2002-08-04 10:22:58.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xmknod.c	2003-09-27 19:00:01.000000000 +0200
@@ -1,5 +1,6 @@
 /* xmknod call using old-style Unix mknod system call.
-   Copyright (C) 1991,93,95,96,97,98,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2002, 2003
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -26,16 +27,13 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-extern int __syscall_mknod (const char *__unbounded, unsigned short int,
-			    unsigned short int);
-
 /* Create a device file named PATH, with permission and special bits MODE
    and device number DEV (which can be constructed from major and minor
    device numbers with the `makedev' macro above).  */
 int
 __xmknod (int vers, const char *path, mode_t mode, dev_t *dev)
 {
-  unsigned short int k_dev;
+  unsigned long long int k_dev;
 
   if (vers != _MKNOD_VER)
     {
@@ -44,9 +42,15 @@
     }
 
   /* We must convert the value to dev_t type used by the kernel.  */
-  k_dev = ((major (*dev) & 0xff) << 8) | (minor (*dev) & 0xff);
+  k_dev =  (*dev) & ((1ULL << 32) - 1);
+  if (k_dev != *dev)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
 
-  return INLINE_SYSCALL (mknod, 3, CHECK_STRING (path), mode, k_dev);
+  return INLINE_SYSCALL (mknod, 3, CHECK_STRING (path), mode,
+			 (unsigned int) k_dev);
 }
 
 weak_alias (__xmknod, _xmknod)
diff -Nur sysdeps/unix/sysv/linux/xstat64.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstat64.c
--- sysdeps/unix/sysv/linux/xstat64.c	2002-08-13 16:29:42.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstat64.c	2003-09-03 05:21:26.000000000 +0200
@@ -1,5 +1,5 @@
 /* xstat64 using old-style Unix stat system call.
-   Copyright (C) 1991,95,96,97,98,99,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1991, 1995-2002, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,15 +29,10 @@
 #include "kernel-features.h"
 
 #if __ASSUME_STAT64_SYSCALL == 0
-# include <xstatconv.c>
+# include <xstatconv.h>
 #endif
 
-extern int __syscall_stat (const char *__unbounded,
-			   struct kernel_stat *__unbounded);
-
 #ifdef __NR_stat64
-extern int __syscall_stat64 (const char *__unbounded,
-			     struct stat64 *__unbounded);
 # if  __ASSUME_STAT64_SYSCALL == 0
 /* The variable is shared between all wrappers around *stat64 calls.
    This is the definition.  */
@@ -82,23 +77,21 @@
 
   result = INLINE_SYSCALL (stat, 2, CHECK_STRING (name), __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat64_conv (vers, &kbuf, buf);
+    result = __xstat64_conv (vers, &kbuf, buf);
 
   return result;
 #endif
 }
 
-#ifndef RTLD_STAT64
-# include <shlib-compat.h>
 
-versioned_symbol (libc, ___xstat64, __xstat64, GLIBC_2_2);
+#include <shlib-compat.h>
 
-# if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
+#if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_2)
+versioned_symbol (libc, ___xstat64, __xstat64, GLIBC_2_2);
 strong_alias (___xstat64, __old__xstat64)
 compat_symbol (libc, __old__xstat64, __xstat64, GLIBC_2_1);
-# endif
-
+hidden_ver (___xstat64, __xstat64)
 #else
-strong_alias (___xstat64, __xstat64);
+strong_alias (___xstat64, __xstat64)
+hidden_def (__xstat64)
 #endif
-hidden_ver (___xstat64, __xstat64)
diff -Nur sysdeps/unix/sysv/linux/xstat.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstat.c
--- sysdeps/unix/sysv/linux/xstat.c	2002-10-02 10:53:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstat.c	2003-06-28 10:10:46.000000000 +0200
@@ -1,6 +1,5 @@
 /* xstat using old-style Unix stat system call.
-   Copyright (C) 1991, 1995, 1996, 1997, 1998, 2000, 2002
-   Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-1998,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -31,10 +30,7 @@
 #include <sys/syscall.h>
 #include <bp-checks.h>
 
-#include <xstatconv.c>
-
-extern int __syscall_stat (const char *__unbounded,
-			   struct kernel_stat *__unbounded);
+#include <xstatconv.h>
 
 /* Get information about the file NAME in BUF.  */
 int
@@ -54,7 +50,7 @@
   result = INLINE_SYSCALL (stat, 2, CHECK_STRING (name),
 			   __ptrvalue (&kbuf));
   if (result == 0)
-    result = xstat_conv (vers, &kbuf, buf);
+    result = __xstat_conv (vers, &kbuf, buf);
 
   return result;
 #endif
diff -Nur sysdeps/unix/sysv/linux/xstatconv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstatconv.c
--- sysdeps/unix/sysv/linux/xstatconv.c	2002-10-02 10:53:20.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstatconv.c	2003-06-16 19:02:55.000000000 +0200
@@ -1,5 +1,5 @@
 /* Convert between the kernel's `struct stat' format, and libc's.
-   Copyright (C) 1991,1995,1996,1997,2000,2002 Free Software Foundation, Inc.
+   Copyright (C) 1991,1995-1997,2000,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,6 +17,10 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <errno.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
 #ifdef STAT_IS_KERNEL_STAT
 
 /* Dummy.  */
@@ -27,8 +31,9 @@
 #include <string.h>
 
 
-static inline int
-xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+#if !defined __ASSUME_STAT64_SYSCALL || defined XSTAT_IS_XSTAT64
+int
+__xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
 {
   switch (vers)
     {
@@ -60,15 +65,24 @@
 	buf->st_size = kbuf->st_size;
 	buf->st_blksize = kbuf->st_blksize;
 	buf->st_blocks = kbuf->st_blocks;
+#ifdef _HAVE_STAT_NSEC
+	buf->st_atim.tv_sec = kbuf->st_atim.tv_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atim.tv_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtim.tv_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtim.tv_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctim.tv_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctim.tv_nsec;
+#else
 	buf->st_atime = kbuf->st_atime;
+	buf->st_mtime = kbuf->st_mtime;
+	buf->st_ctime = kbuf->st_ctime;
+#endif
 #ifdef _HAVE_STAT___UNUSED1
 	buf->__unused1 = 0;
 #endif
-	buf->st_mtime = kbuf->st_mtime;
 #ifdef _HAVE_STAT___UNUSED2
 	buf->__unused2 = 0;
 #endif
-	buf->st_ctime = kbuf->st_ctime;
 #ifdef _HAVE_STAT___UNUSED3
 	buf->__unused3 = 0;
 #endif
@@ -88,12 +102,13 @@
 
   return 0;
 }
+#endif
 
-static inline int
-xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+int
+__xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
 {
 #ifdef XSTAT_IS_XSTAT64
-  return xstat_conv (vers, kbuf, ubuf);
+  return __xstat_conv (vers, kbuf, ubuf);
 #else
   switch (vers)
     {
@@ -121,15 +136,24 @@
 	buf->st_size = kbuf->st_size;
 	buf->st_blksize = kbuf->st_blksize;
 	buf->st_blocks = kbuf->st_blocks;
+#ifdef _HAVE_STAT64_NSEC
+	buf->st_atim.tv_sec = kbuf->st_atim.tv_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atim.tv_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtim.tv_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtim.tv_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctim.tv_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctim.tv_nsec;
+#else
 	buf->st_atime = kbuf->st_atime;
+	buf->st_mtime = kbuf->st_mtime;
+	buf->st_ctime = kbuf->st_ctime;
+#endif
 #ifdef _HAVE_STAT64___UNUSED1
 	buf->__unused1 = 0;
 #endif
-	buf->st_mtime = kbuf->st_mtime;
 #ifdef _HAVE_STAT64___UNUSED2
 	buf->__unused2 = 0;
 #endif
-	buf->st_ctime = kbuf->st_ctime;
 #ifdef _HAVE_STAT64___UNUSED3
 	buf->__unused3 = 0;
 #endif
@@ -154,8 +178,8 @@
 #endif
 }
 
-static inline int
-xstat32_conv (int vers, struct stat64 *kbuf, struct stat *buf)
+int
+__xstat32_conv (int vers, struct stat64 *kbuf, struct stat *buf)
 {
   switch (vers)
     {
@@ -216,15 +240,25 @@
 	    __set_errno (EOVERFLOW);
 	    return -1;
 	  }
+#ifdef _HAVE_STAT_NSEC
+	buf->st_atim.tv_sec = kbuf->st_atim.tv_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atim.tv_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtim.tv_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtim.tv_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctim.tv_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctim.tv_nsec;
+#else
 	buf->st_atime = kbuf->st_atime;
+	buf->st_mtime = kbuf->st_mtime;
+	buf->st_ctime = kbuf->st_ctime;
+#endif
+
 #ifdef _HAVE_STAT___UNUSED1
 	buf->__unused1 = 0;
 #endif
-	buf->st_mtime = kbuf->st_mtime;
 #ifdef _HAVE_STAT___UNUSED2
 	buf->__unused2 = 0;
 #endif
-	buf->st_ctime = kbuf->st_ctime;
 #ifdef _HAVE_STAT___UNUSED3
 	buf->__unused3 = 0;
 #endif
diff -Nur sysdeps/unix/sysv/linux/xstatconv.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstatconv.h
--- sysdeps/unix/sysv/linux/xstatconv.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/linux/xstatconv.h	2003-06-28 10:10:46.000000000 +0200
@@ -0,0 +1,26 @@
+/* Convert between the kernel's `struct stat' format, and libc's.
+   Copyright (C) 1991,1995-1997,2000,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "kernel-features.h"
+
+#ifndef STAT_IS_KERNEL_STAT
+extern int __xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf);
+extern int __xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf);
+#endif
+extern int __xstat32_conv (int vers, struct stat64 *kbuf, struct stat *buf);
diff -Nur sysdeps/unix/sysv/minix/bits/sigaction.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/minix/bits/sigaction.h
--- sysdeps/unix/sysv/minix/bits/sigaction.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/minix/bits/sigaction.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/* Copyright (C) 1992, 1996, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SIGNAL_H
-# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
-#endif
-
-/* Structure describing the action to be taken when a signal arrives.  */
-struct sigaction
-  {
-    /* Signal handler.  */
-    __sighandler_t sa_handler;
-
-    /* Additional set of signals to be blocked.  */
-    __sigset_t sa_mask;
-
-    /* Special flags.  */
-    int sa_flags;
-  };
-
-/* Bits in `sa_flags'.  */
-#ifdef	__USE_MISC
-# define SA_ONSTACK	0x1	/* Take signal on signal stack.  */
-# define SA_RESETHAND	0x2	/* Reset signal handler when signal caught.  */
-# define SA_NODEFER	0x4	/* Don't block signal while catching it.  */
-# define SA_RESTART	0x8	/* Restart syscall on signal return.  */
-# define SA_SIGINFO	0x10	/* Extended signal handling.  */
-# define SA_NOCLDWAIT	0x20	/* Don't create zombies.  */
-# define SA_COMPAT	0x80	/* Internal flag for old signal catchers.  */
-# define SA_DISABLE	0x100	/* Disable alternate signal stack.  */
-#endif
-#define	SA_NOCLDSTOP	0x40	/* Don't send SIGCHLD when children stop.  */
-
-
-/* Values for the HOW argument to `sigprocmask'.  */
-#define	SIG_BLOCK	0	/* Block signals.  */
-#define	SIG_UNBLOCK	1	/* Unblock signals.  */
-#define	SIG_SETMASK	2	/* Set the set of blocked signals.  */
diff -Nur sysdeps/unix/sysv/sco3.2/bits/local_lim.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/bits/local_lim.h
--- sysdeps/unix/sysv/sco3.2/bits/local_lim.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* Copyright (C) 1993, 1996 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _BITS_LOCAL_LIM_H
-#define _BITS_LOCAL_LIM_H 1
-
-#define NGROUPS_MAX 8		/* Maximum number of supplementary groups.  */
-#define ARG_MAX 5120
-#define CHILD_MAX 25
-#define OPEN_MAX 60
-#define LINK_MAX 1000
-#define MAX_CANON 256
-
-/* For SVR3, this is 14.  For SVR4, it is 255, at least on ufs
-   file systems, even though the System V limits.h incorrectly
-   defines it as 14.  Giving it a value which is too large
-   is harmless (it is a maximum).  */
-#define NAME_MAX 255
-
-#define PATH_MAX 1024
-
-#endif	/* bits/local_lim.h */
diff -Nur sysdeps/unix/sysv/sco3.2/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/Dist
--- sysdeps/unix/sysv/sco3.2/Dist	1993-05-06 03:32:29.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-__fltused.c
diff -Nur sysdeps/unix/sysv/sco3.2/__fltused.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/__fltused.c
--- sysdeps/unix/sysv/sco3.2/__fltused.c	1993-05-06 03:31:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/__fltused.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-/* Code compiled by the SCO compiler apparently likes this to be defined.  */
-
-int __fltused = 1;
diff -Nur sysdeps/unix/sysv/sco3.2/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/Makefile
--- sysdeps/unix/sysv/sco3.2/Makefile	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-# Copyright (C) 1993, 1997 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; if not, write to the Free
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-# 02111-1307 USA.
-
-ifeq ($(subdir),misc)
-
-sysdep_routines := $(sysdep_routines) __fltused
-
-endif
diff -Nur sysdeps/unix/sysv/sco3.2.4/bits/confname.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/bits/confname.h
--- sysdeps/unix/sysv/sco3.2.4/bits/confname.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/bits/confname.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
-   Copyright (C) 1993, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _UNISTD_H
-# error "Never use <bits/confname.h> directly; include <unistd.h> instead."
-#endif
-
-/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
-#define _PC_LINK_MAX		0
-#define _PC_MAX_CANON		1
-#define _PC_MAX_INPUT		2
-#define _PC_NAME_MAX		3
-#define _PC_PATH_MAX		4
-#define _PC_PIPE_BUF		5
-#define _PC_CHOWN_RESTRICTED	6
-#define _PC_NO_TRUNC		7
-#define _PC_VDISABLE		8
-
-/* Values for the argument to `sysconf'.  */
-#define _SC_ARG_MAX		0
-#define _SC_CHILD_MAX		1
-#define _SC_CLK_TCK		2
-#define _SC_NGROUPS_MAX		3
-#define _SC_OPEN_MAX		4
-#define _SC_JOB_CONTROL		5
-#define _SC_SAVED_IDS		6
-#define _SC_VERSION		7
-#define _SC_PASS_MAX		8
-#define _SC_XOPEN_VERSION	9
-#define _SC_TZNAME_MAX		666 /* Not handled by SCO's system call.  */
-
-#ifdef __USE_POSIX2
-/* Values for the NAME argument to `confstr'.  */
-enum
-  {
-    _CS_PATH			/* The default search path.  */
-  };
-#endif
diff -Nur sysdeps/unix/sysv/sco3.2.4/bits/sigaction.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/bits/sigaction.h
--- sysdeps/unix/sysv/sco3.2.4/bits/sigaction.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/bits/sigaction.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* The proper definitions for SCO's sigaction.
-   Copyright (C) 1993, 1994, 1996, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SIGNAL_H
-# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
-#endif
-
-/* Structure describing the action to be taken when a signal arrives.  */
-struct sigaction
-  {
-    /* Signal handler.  */
-    __sighandler_t sa_handler;
-
-    /* Additional set of signals to be blocked.  */
-    __sigset_t sa_mask;
-
-    /* Special flags.  */
-    int sa_flags;
-  };
-
-/* Bits in `sa_flags'.  */
-#define	SA_NOCLDSTOP	0x01	/* Don't send SIGCHLD when children stop.  */
-
-/* Values for the HOW argument to `sigprocmask'.  */
-#define	SIG_SETMASK	0	/* Set the set of blocked signals.  */
-#define	SIG_BLOCK	1	/* Block signals.  */
-#define	SIG_UNBLOCK	2	/* Unblock signals.  */
diff -Nur sysdeps/unix/sysv/sco3.2.4/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/Dist
--- sysdeps/unix/sysv/sco3.2.4/Dist	1997-03-19 06:44:31.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-__setpgid.c
diff -Nur sysdeps/unix/sysv/sco3.2.4/getgroups.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/getgroups.c
--- sysdeps/unix/sysv/sco3.2.4/getgroups.c	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/getgroups.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/* Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sys/types.h>
-#include <unistd.h>
-#include <limits.h>
-#include <alloca.h>
-
-extern int __sco_getgroups __P ((int size, unsigned short int *list));
-
-int
-__getgroups (size, list)
-     int size; gid_t *list;
-{
-  int i;
-  unsigned short int *shortlist;
-
-  if (size <= 0)
-    return __sco_getgroups (size, NULL);
-
-  shortlist = __alloca (size * sizeof (*shortlist));
-
-  size = __sco_getgroups (size, shortlist);
-  for (i = 0; i < size; ++i)
-    list[i] = shortlist[i];
-
-  return size;
-}
-
-weak_alias (__getgroups, getgroups)
diff -Nur sysdeps/unix/sysv/sco3.2.4/getpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/getpgid.c
--- sysdeps/unix/sysv/sco3.2.4/getpgid.c	1995-01-26 02:27:55.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/getpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/sysv4/getpgid.c>
diff -Nur sysdeps/unix/sysv/sco3.2.4/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/Makefile
--- sysdeps/unix/sysv/sco3.2.4/Makefile	1995-07-26 17:38:25.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-ifeq (posix,$(subdir))
-sysdep_routines := $(sysdep_routines) pgrpsys sco_getgrp
-endif
-
-ifeq (csu,$(subdir))
-
-# SCO uses crt1.o, and expects that single initializer file to also start
-# the .init and .fini sections as crti.o normally does.
-start-installed-name = crt1.o
-start-installed-name-rule = yes
-
-# Link together start.o and crti.o into the expected crt1.o.
-# Now crt1.o as initializer and crtn.o as finalizer will work.
-$(objpfx)crt1.o: $(objpfx)start.o $(objpfx)crti.o
-	$(CC) -nostdlib -nostartfiles -Wl,-r -o $@ $^
-
-endif
diff -Nur sysdeps/unix/sysv/sco3.2.4/__setpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/__setpgid.c
--- sysdeps/unix/sysv/sco3.2.4/__setpgid.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/__setpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Copyright (C) 1994, 1997, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-
-extern int __pgrpsys __P ((int type, ...));
-
-/* Get the process group ID of process PID.  */
-int
-__setpgid (pid, pgid)
-     pid_t pid;
-     pid_t pgid;
-{
-  return __pgrpsys (2, pid, pgid);
-}
-libc_hidden_def (__setpgid)
diff -Nur sysdeps/unix/sysv/sco3.2.4/setpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/setpgid.c
--- sysdeps/unix/sysv/sco3.2.4/setpgid.c	1995-01-26 02:28:44.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/setpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/sysv4/setpgid.c>
diff -Nur sysdeps/unix/sysv/sco3.2.4/setsid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/setsid.c
--- sysdeps/unix/sysv/sco3.2.4/setsid.c	1995-01-21 16:15:01.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/setsid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/sysv4/setsid.c>
diff -Nur sysdeps/unix/sysv/sco3.2.4/sigaction.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sigaction.S
--- sysdeps/unix/sysv/sco3.2.4/sigaction.S	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sigaction.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 1993, 1994, 1995, 1997, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-.globl C_SYMBOL_NAME(__sigreturn)
-
-ENTRY (__sigaction)
-	movl $C_SYMBOL_NAME(__sigreturn), %ecx
-	DO_CALL (sigaction, 3)
-	jb syscall_error
-	ret
-
-libc_hidden_def (__sigaction)
-weak_alias (__sigaction, sigaction)
diff -Nur sysdeps/unix/sysv/sco3.2.4/sys/syscall.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sys/syscall.h
--- sysdeps/unix/sysv/sco3.2.4/sys/syscall.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sys/syscall.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/* Copyright (C) 1994, 1996 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* From Scott Bartram.  */
-
-#ifndef _SYSCALL_H
-#define _SYSCALL_H
-
-#define SYS_access	33
-#define SYS_acct	51
-#define SYS_advfs	70
-#define SYS_alarm	27
-#define SYS_break	17
-#define SYS_brk		17
-#define SYS_chdir	12
-#define SYS_chmod	15
-#define SYS_chown	16
-#define SYS_chroot	61
-#define SYS_chsize	0x0a28
-#define SYS_close	6
-#define SYS_creat	8
-#define SYS_dup		41
-#define SYS_exec	11
-#define SYS_exece	59
-#define SYS_exit	1
-#define SYS_fcntl	62
-#define SYS_fork	2
-#define SYS_fpathconf	0x2f28
-#define SYS_fstat	28
-#define SYS_fstatfs	38
-#define SYS_ftime	0x0b28
-#define SYS_getdents	81
-#define SYS_getgid	47
-#define SYS_getgroups	0x2b28
-#define SYS_getitimer	0x3728
-#define SYS_getmsg	85
-#define SYS_getpid	20
-#define SYS_getuid	24
-#define SYS_gtty	32
-#define SYS_ioctl	54
-#define SYS_kill	37
-#define SYS_link	9
-#define SYS_lock	45
-#define SYS_lseek	19
-#define SYS_lstat	91
-#define SYS_mkdir	80
-#define SYS_mknod	14
-#define SYS_mount	21
-#define SYS_msgsys	49
-#define SYS_nap		0x0c28
-#define SYS_nice	34
-#define SYS_open	5
-#define SYS_pathconf	0x2e28
-#define SYS_pause	29
-#define SYS_pgrpsys	39
-#define SYS_pipe	42
-#define SYS_plock	45
-#define SYS_poll	87
-#define SYS_prof	44
-#define SYS_ptrace	26
-#define SYS_putmsg	86
-#define SYS_rdebug	76
-#define SYS_read	3
-#define SYS_readlink	92
-#define SYS_rename	0x3028
-#define SYS_rfstart	74
-#define SYS_rfstop	77
-#define SYS_rfsys	78
-#define SYS_rmdir	79
-#define SYS_rmount	72
-#define SYS_rumount	73
-#define SYS_seek	19
-#define SYS_select	0x2428
-#define SYS_semsys	53
-#define SYS_setgid	46
-#define SYS_setgroups	0x2c28
-#define SYS_setitimer	0x3828
-#define SYS_setpgrp	39
-#define SYS_setuid	23
-#define SYS_shmsys	52
-#define SYS_sigaction	0x2728
-#define SYS_signal	48
-#define SYS_sigpending	0x2928
-#define SYS_sigprocmask	0x2828
-#define SYS_sigsuspend	0x2a28
-#define SYS_stat	18
-#define SYS_statfs	35
-#define SYS_stime	25
-#define SYS_stty	31
-#define SYS_symlink	90
-#define SYS_sync	36
-#define SYS_sys3b	50
-#define SYS_sysacct	51
-#define SYS_sysconf	0x2d28
-#define SYS_sysfs	84
-#define SYS_sysi86  	50
-#define SYS_time	13
-#define SYS_times	43
-#define SYS_uadmin	55
-#define SYS_ulimit	63
-#define SYS_umask	60
-#define SYS_umount	22
-#define SYS_unadvfs	71
-#define SYS_unlink	10
-#define SYS_utime	30
-#define SYS_utssys	57
-#define SYS_wait	7
-#define SYS_write	4
-
-#endif
diff -Nur sysdeps/unix/sysv/sco3.2.4/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/syscalls.list
--- sysdeps/unix/sysv/sco3.2.4/syscalls.list	1996-01-19 01:40:58.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/syscalls.list	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-# File name	Caller	Syscall name	# args	Strong name	Weak names
-
-pathconf	-	pathconf	2	__pathconf	pathconf
-pgrpsys		-	pgrpsys		3	__pgrpsys
-sco_getgrp	getgroups getgroups	2	__sco_getgroups
-sigpending	-	sigpending	1	sigpending
-sigprocmask	-	sigprocmask	3	__sigprocmask	sigprocmask
-sigsuspend	-	sigsuspend	1	sigsuspend
diff -Nur sysdeps/unix/sysv/sco3.2.4/sysconf.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sysconf.S
--- sysdeps/unix/sysv/sco3.2.4/sysconf.S	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/sysconf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 1993, 1994, 1995, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#include <bits/confname.h>
-
-.globl	__tzname_max
-ENTRY (__sysconf)
-	cmpl $_SC_TZNAME_MAX, 4(%esp) /* Is the arg _SC_TZNAME_MAX?  */
-	je tzname
-	DO_CALL (sysconf, 1)	/* No; use the SCO system call.  */
-	ret
-tzname:	jmp C_SYMBOL_NAME(__tzname_max) /* Yes; bounce to __tzname_max (). */
-
-weak_alias (__sysconf, sysconf)
diff -Nur sysdeps/unix/sysv/sco3.2.4/system.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/system.c
--- sysdeps/unix/sysv/sco3.2.4/system.c	1994-05-17 00:43:49.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/system.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-/* SCO has a bug where `waitpid' will never return if SIGCHLD is blocked.
-   They have acknowledged that this is a bug but I have not seen nor heard
-   of any forthcoming fix.  */
-
-#define WAITPID_CANNOT_BLOCK_SIGCHLD
-
-/* SCO 3.2v4 does have `waitpid'.
-   Avoid unix/system.c, which says we don't.  */
-
-#include <sysdeps/posix/system.c>
diff -Nur sysdeps/unix/sysv/sco3.2.4/uname.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/uname.S
--- sysdeps/unix/sysv/sco3.2.4/uname.S	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/uname.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* Copyright (C) 1993, 1994, 1997 Free Software Foundation, Inc.
-   Contributed by Scott Bartram.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-/*
-    before lcall, stack contents should be:
-
-	4(%esp) -> name
-	8(%esp) -> unspecified
-	12(%esp) -> 0
- */
-
-ENTRY (uname)
-	pushl $0x0		/* Push the discriminator flag.  */
-	pushl $0x0		/* Push dummy placeholder.  */
-	pushl 12(%esp,1)	/* Push NAME (ptr to struct utsname)  */
-	subl $0x4, %esp		/* Adjust stack pointer.  */
-	DO_CALL (utssys, 3)
-	jb error		/* Test for error.  */
-	addl $0x10, %esp	/* Adjust the stack pointer.  */
-	xorl %eax, %eax		/* Clear return value.  */
-	ret
-error:	addl $0x10, %esp	/* Adjust the stack pointer.  */
-	jmp syscall_error
diff -Nur sysdeps/unix/sysv/sco3.2.4/waitpid.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/waitpid.S
--- sysdeps/unix/sysv/sco3.2.4/waitpid.S	2002-08-13 16:29:44.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sco3.2.4/waitpid.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* Copyright (C) 1993,94,95,97,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-ENTRY (__waitpid)
-	/* The `waitpid' system call is distinguished from plain
-	   `wait' by setting lots of bits in the processor flags.  */
-	pushfl			/* Push the flags word.  */
-	popl %eax		/* Pop it into the accumulator.  */
-	orl $0x8c4, %eax	/* Set lots of bits.  */
-	pushl %eax		/* Push the new flags word.  */
-	popfl			/* Pop it into the flags.  */
-	DO_CALL (wait, 2)
-	movl 8(%esp), scratch	/* Put status pointer in scratch register.  */
-	testl scratch, scratch	/* Is it non-nil?  */
-	je null
-	movl r1, (scratch)	/* Yes; store the status there.  */
-null:	ret
-
-libc_hidden_def (__waitpid)
-weak_alias (__waitpid, waitpid)
diff -Nur sysdeps/unix/sysv/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/syscalls.list
--- sysdeps/unix/sysv/syscalls.list	2000-08-24 17:11:13.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/syscalls.list	2003-07-27 21:01:39.000000000 +0200
@@ -3,14 +3,14 @@
 alarm		-	alarm		i:i	alarm
 ftime		-	ftime		i:p	ftime
 nice		-	nice		i:i	nice
-pause		-	pause		i:	pause
-poll		-	poll		i:pii	poll
+pause		-	pause		Ci:	pause
+poll		-	poll		Ci:pii	poll
 s_getdents	getdents getdents	i:ipi	__getdents
 setrlimit	-	setrlimit	i:ip	__setrlimit	setrlimit
 settimeofday	-	settimeofday	i:PP	__settimeofday	settimeofday
 signal		-	signal		i:ii	signal
 stime		-	stime		i:p	stime
-time		-	time		i:P	time
+time		-	time		Ei:P	time
 times		-	times		i:p	__times	times
 ulimit		-	ulimit		i:ii	ulimit
 utime		-	utime		i:sP	utime
diff -Nur sysdeps/unix/sysv/sysv4/bits/sigaction.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/sigaction.h
--- sysdeps/unix/sysv/sysv4/bits/sigaction.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/sigaction.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/* The proper definitions for SVR4's sigaction.
-   Copyright (C) 1993, 1994, 1996, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SIGNAL_H
-# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
-#endif
-
-/* Structure describing the action to be taken when a signal arrives.  */
-struct sigaction
-  {
-    /* Special flags.  */
-    int sa_flags;
-
-    /* Signal handler.  */
-    __sighandler_t sa_handler;
-
-    /* Additional set of signals to be blocked.  */
-    __sigset_t sa_mask;
-
-    /* Padding.  */
-    int sa_resv[2];
-  };
-
-/* Bits in `sa_flags'.  */
-#ifdef __USE_MISC
-# define SA_ONSTACK	0x1	/* Take signal on signal stack.  */
-# define SA_RESETHAND	0x2	/* Reset to SIG_DFL on entry to handler.  */
-# define SA_RESTART	0x4	/* Restart syscall on signal return.  */
-# define SA_SIGINFO	0x8	/* Provide additional info to the handler.  */
-# define SA_NODEFER	0x10	/* Don't automatically block the signal when
-				   its handler is being executed.  */
-# define SA_NOCLDWAIT	0x10000	/* Don't save zombie processes.  */
-#endif
-#define	SA_NOCLDSTOP	0x20000	/* Don't send SIGCHLD when children stop.  */
-
-/* Values for the HOW argument to `sigprocmask'.  */
-#define	SIG_BLOCK	1	/* Block signals.  */
-#define	SIG_UNBLOCK	2	/* Unblock signals.  */
-#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
diff -Nur sysdeps/unix/sysv/sysv4/bits/signum.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/signum.h
--- sysdeps/unix/sysv/sysv4/bits/signum.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/signum.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/* Signal number definitions.  SVR4 version.
-   Copyright (C) 1994, 1996 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifdef	_SIGNAL_H
-
-/* Fake signal functions.  */
-#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
-#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
-#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
-
-
-/* Signals.  */
-#define	SIGHUP		1	/* Hangup (POSIX).  */
-#define	SIGINT		2	/* Interrupt (ANSI).  */
-#define	SIGQUIT		3	/* Quit (POSIX).  */
-#define	SIGILL		4	/* Illegal instruction (ANSI).  */
-#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
-#define	SIGTRAP		5	/* Trace trap (POSIX).  */
-#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
-#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
-#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
-#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
-#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
-#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
-#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD)*/
-#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
-#define	SIGALRM		14	/* Alarm clock (POSIX).  */
-#define	SIGTERM		15	/* Termination (ANSI).  */
-#define	SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
-#define	SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
-#define	SIGCHLD		18	/* Child status has changed (POSIX).  */
-#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
-#define	SIGPWR		19	/* Power failure restart (System V).  */
-#define	SIGWINCH	20	/* Window size change (4.3 BSD, Sun).  */
-#define	SIGURG		21	/* Urgent condition on socket (4.2 BSD).*/
-#define	SIGPOLL		22	/* Pollable event occurred (System V).  */
-#define	SIGIO		SIGPOLL	/* I/O now possible (4.2 BSD).  */
-#define	SIGSTOP		23	/* Stop, unblockable (POSIX).  */
-#define	SIGTSTP		24	/* Keyboard stop (POSIX).  */
-#define	SIGCONT		25	/* Continue (POSIX).  */
-#define	SIGTTIN		26	/* Background read from tty (POSIX).  */
-#define	SIGTTOU		27	/* Background write to tty (POSIX).  */
-#define	SIGVTALRM	28	/* Virtual alarm clock (4.2 BSD).  */
-#define	SIGPROF		29	/* Profiling alarm clock (4.2 BSD).  */
-#define	SIGXCPU		30	/* CPU limit exceeded (4.2 BSD).  */
-#define	SIGXFSZ		31	/* File size limit exceeded (4.2 BSD).  */
-
-#endif	/* <signal.h> included.  */
-
-#define	_NSIG		32	/* Biggest signal number + 1.  */
diff -Nur sysdeps/unix/sysv/sysv4/bits/sigset.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/sigset.h
--- sysdeps/unix/sysv/sysv4/bits/sigset.h	2002-07-10 22:25:25.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/sigset.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/* __sig_atomic_t, __sigset_t, and related definitions.  SVR4 version.
-   Copyright (C) 1994-1996, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef	_SIGSET_H_types
-#define	_SIGSET_H_types	1
-
-typedef int __sig_atomic_t;
-
-/* A `sigset_t' has a bit for each signal.  */
-typedef struct
-  {
-    unsigned long int __sigbits[4];
-  } __sigset_t;
-
-#endif	/* ! _SIGSET_H_types */
-
-/* We only want to define these functions if <signal.h> was actually
-   included; otherwise we were included just to define the types.  Since we
-   are namespace-clean, it wouldn't hurt to define extra macros.  But
-   trouble can be caused by functions being defined (e.g., any global
-   register vars declared later will cause compilation errors).  */
-
-#if !defined (_SIGSET_H_fns) && defined (_SIGNAL_H)
-#define _SIGSET_H_fns 1
-
-/* Return a mask that includes SIG only.  */
-#define	__sigmask(sig)	(1 << ((sig) - 1))
-
-
-/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
-#define	__NSSBITS	(sizeof (unsigned long int) * 8)
-#define	__SSELT(s)	((s) / __NSSBITS)
-#define	__SSMASK(s)	(1 << ((s) % __NSSBITS))
-
-#ifdef __USE_EXTERN_INLINES
-# ifndef _EXTERN_INLINE
-#  define _EXTERN_INLINE	extern __inline
-# endif
-
-_EXTERN_INLINE int
-__sigemptyset (__sigset_t *__set)
-{
-  __set->__sigbits[0] = __set->__sigbits[1] =
-    __set->__sigbits[2] = __set->__sigbits[3] = 0L;
-  return 0;
-}
-
-_EXTERN_INLINE int
-__sigfillset (__sigset_t *__set)
-{
-  /* SVR4 has a system call for `sigfillset' (!), and it only sets the bits
-     for signals [1,31].  Setting bits for unimplemented signals seems
-     harmless (and we will find out if it really is).  */
-  __set->__sigbits[0] = __set->__sigbits[1] =
-    __set->__sigbits[2] = __set->__sigbits[3] = ~0L;
-  return 0;
-}
-
-_EXTERN_INLINE int
-__sigaddset (__sigset_t *__set, int __sig)
-{
-  __set->__sigbits[__SSELT (__sig)] |= __SSMASK (__sig);
-  return 0;
-}
-
-_EXTERN_INLINE int
-__sigdelset (__sigset_t *__set, int __sig)
-{
-  __set->__sigbits[__SSELT (__sig)] &= ~__SSMASK (__sig);
-  return 0;
-}
-
-_EXTERN_INLINE int
-__sigismember (__const __sigset_t *__set, int __sig)
-{
-  if (__set->__sigbits[__SSELT (__sig)] & __SSMASK (__sig))
-    return 1;
-  return 0;
-}
-#endif	/* use extern inlines.  */
-
-#endif /* ! _SIGSET_H_fns */
diff -Nur sysdeps/unix/sysv/sysv4/bits/utsname.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/utsname.h
--- sysdeps/unix/sysv/sysv4/bits/utsname.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/utsname.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-/* Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_UTSNAME_H
-# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
-#endif
-
-#define _UTSNAME_LENGTH 257
diff -Nur sysdeps/unix/sysv/sysv4/bits/waitflags.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/waitflags.h
--- sysdeps/unix/sysv/sysv4/bits/waitflags.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/bits/waitflags.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/* Definitions of flag bits for `waitpid' et al.
-   Copyright (C) 1993, 1996, 1997, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#if !defined _SYS_WAIT_H && !defined _STDLIB_H
-# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
-#endif
-
-
-/* Bits in the third argument to `waitpid'.  */
-#define	WNOHANG		64	/* Don't block waiting.  */
-#define	WUNTRACED	4	/* Report status of stopped children.  */
-
-#ifdef __USE_SVID
-# define WEXITED	1	/* Look for children that have exited.  */
-# define WTRAPPED	2	/* Look for processes that stopped
-				   while tracing.  */
-#endif
diff -Nur sysdeps/unix/sysv/sysv4/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Dist
--- sysdeps/unix/sysv/sysv4/Dist	1997-03-19 06:45:44.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-__getpgid.c
-__setpgid.c
-sysconfig.h
-siginfo.h
diff -Nur sysdeps/unix/sysv/sysv4/dup2.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/dup2.c
--- sysdeps/unix/sysv/sysv4/dup2.c	1995-02-20 00:43:06.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/dup2.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-/* SVR4 uses the POSIX dup2.  */
-#include <sysdeps/posix/dup2.c>
diff -Nur sysdeps/unix/sysv/sysv4/ftruncate.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/ftruncate.c
--- sysdeps/unix/sysv/sysv4/ftruncate.c	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/ftruncate.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* ftruncate for SVR4 using the fcntl F_FREESP command.
-   Copyright (C) 1995, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sys/types.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-
-/* Truncate the file FD refers to to LENGTH bytes.  */
-int
-ftruncate (fd, length)
-     int fd;
-     off_t length;
-{
-  struct flock fl;
-
-  memset (&fl, 0, sizeof fl);
-  fl.l_type = F_WRLCK;
-  fl.l_start = length;
-  return fcntl (fd, F_FREESP, &fl);
-}
diff -Nur sysdeps/unix/sysv/sysv4/gethostname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/gethostname.c
--- sysdeps/unix/sysv/sysv4/gethostname.c	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/gethostname.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/* Copyright (C) 1994, 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/systeminfo.h>
-
-extern int __sysinfo (int command, char *buf, long int count);
-
-int
-__gethostname (name, namelen)
-     char *name;
-     size_t namelen;
-{
-  return __sysinfo (SI_HOSTNAME, name, namelen);
-}
-
-weak_alias (__gethostname, gethostname)
diff -Nur sysdeps/unix/sysv/sysv4/getpagesize.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/getpagesize.c
--- sysdeps/unix/sysv/sysv4/getpagesize.c	1995-01-21 15:47:46.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/getpagesize.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-/* Solaris uses sysconf ala POSIX.1.  */
-#include <sysdeps/posix/getpagesize.c>
diff -Nur sysdeps/unix/sysv/sysv4/__getpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/__getpgid.c
--- sysdeps/unix/sysv/sysv4/__getpgid.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/__getpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Copyright (C) 1993, 1997, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-
-extern int __pgrpsys __P ((int type, ...));
-
-/* Get the process group ID of process PID.  */
-int
-__getpgid (pid)
-     pid_t pid;
-{
-  return __pgrpsys (4, pid);
-}
-libc_hidden_def (__getpgid)
diff -Nur sysdeps/unix/sysv/sysv4/getpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/getpgid.c
--- sysdeps/unix/sysv/sysv4/getpgid.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/getpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/* Copyright (C) 1993, 1995, 1997, 1999, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <unistd.h>
-#include <sys/types.h>
-
-extern pid_t __pgrpsys __P ((int type, ...));
-
-/* Get the process group ID of process PID.  */
-pid_t
-__getpgid (pid)
-     pid_t pid;
-{
-  return __pgrpsys (4, pid);
-}
-libc_hidden_def (__getpgid)
-weak_alias (__getpgid, getpgid)
diff -Nur sysdeps/unix/sysv/sysv4/i386/bits/stat.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/bits/stat.h
--- sysdeps/unix/sysv/sysv4/i386/bits/stat.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/bits/stat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/* Copyright (C) 1993, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_STAT_H
-# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
-#endif
-
-#include <bits/types.h>
-
-/* Versions of the `struct stat' data structure and
-   the bits of the `xmknod' interface.  */
-#define _STAT_VER	2
-#define _MKNOD_VER	2
-
-/* Structure describing file characteristics.  */
-struct stat
-  {
-    unsigned long itn st_dev;	/* Device.  */
-    long int st_filler1[3];
-    unsigned long int st_ino;	/* File serial number.		*/
-    unsigned long int st_mode;	/* File mode.  */
-    unsigned long int st_nlink;	/* Link count.  */
-    long int st_uid;		/* User ID of the file's owner.	*/
-    long int st_gid;		/* Group ID of the file's group.*/
-    unsigned long int st_rdev;	/* Device number, if device.  */
-    long int st_filler2[2];
-
-    long int st_size;		/* Size of file, in bytes.  */
-    /* SVR4 added this extra long to allow for expansion of off_t.  */
-    long int st_filler3;
-
-    long int st_atime;		/* Time of last access.  */
-    unsigned long int st_atime_usec;
-    long int st_mtime;		/* Time of last modification.  */
-    unsigned long int st_mtime_usec;
-    long int st_ctime;		/* Time of last status change.  */
-    unsigned long int st_ctime_usec;
-
-    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
-#define	_STATBUF_ST_BLKSIZE	/* Tell code we have this member.  */
-
-    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
-    char st_fstype[16];		/* The type of this filesystem.  */
-    int st_aclcnt;
-    unsigned long int st_level;
-    unsigned long int st_flags;
-    unsigned long int st_cmwlevel;
-    long int st_filler4[4];
-  };
-
-/* Encoding of the file mode.  */
-
-#define	__S_IFMT	0170000	/* These bits determine file type.  */
-
-/* File types.  */
-#define	__S_IFDIR	0040000	/* Directory.  */
-#define	__S_IFCHR	0020000	/* Character device.  */
-#define	__S_IFBLK	0060000	/* Block device.  */
-#define	__S_IFREG	0100000	/* Regular file.  */
-#define	__S_IFIFO	0010000	/* FIFO.  */
-
-/* These don't actually exist on System V, but having them doesn't hurt.  */
-#define	__S_IFLNK	0120000	/* Symbolic link.  */
-#define	__S_IFSOCK	0140000	/* Socket.  */
-
-/* POSIX.1b objects.  */
-#define __S_TYPEISMQ(buf) (0)
-#define __S_TYPEISSEM(buf) (0)
-#define __S_TYPEISSHM(buf) (0)
-
-/* Protection bits.  */
-
-#define	__S_ISUID	04000	/* Set user ID on execution.  */
-#define	__S_ISGID	02000	/* Set group ID on execution.  */
-#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
-#define	__S_IREAD	0400	/* Read by owner.  */
-#define	__S_IWRITE	0200	/* Write by owner.  */
-#define	__S_IEXEC	0100	/* Execute by owner.  */
diff -Nur sysdeps/unix/sysv/sysv4/i386/Dist /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/Dist
--- sysdeps/unix/sysv/sysv4/i386/Dist	1994-02-19 23:39:32.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-sys-sig.S
diff -Nur sysdeps/unix/sysv/sysv4/i386/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/Makefile
--- sysdeps/unix/sysv/sysv4/i386/Makefile	1994-02-17 02:57:33.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-ifeq ($(subdir),signal)
-sysdep_routines := $(sysdep_routines) sys-sig
-endif
diff -Nur sysdeps/unix/sysv/sysv4/i386/syscalls.list /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/syscalls.list
--- sysdeps/unix/sysv/sysv4/i386/syscalls.list	1996-01-19 01:41:54.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/syscalls.list	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-# File name	Caller	Syscall name	# args	Strong name	Weak names
-
-xstat		-	xstat		3	__xstat		_xstat
-fxstat		-	fxstat		3	__fxstat	_fxstat
-lxstat		-	lxstat		3	__lxstat	_lxstat
-xmknod		-	xmknod		4	__xmknod	_xmknod
diff -Nur sysdeps/unix/sysv/sysv4/i386/sysdep.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/sysdep.h
--- sysdeps/unix/sysv/sysv4/i386/sysdep.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/sysdep.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdeps/unix/sysv/i386/sysdep.h>
-
-/* In SVR4 some system calls can fail with the error ERESTART,
-   and this means the call should be retried.  */
-
-#ifndef _ERRNO_H
-#define _ERRNO_H
-#endif
-#include <bits/errno.h>
-
-#undef	PSEUDO
-#define	PSEUDO(name, syscall_name, args)				      \
-  .globl syscall_error;							      \
-  ENTRY (name)								      \
-  DO_CALL (syscall_name, args);						      \
-  jae noerror;								      \
-  cmpb $ERESTART, %al;							      \
-  je C_SYMBOL_NAME (name);						      \
-  jmp syscall_error;							      \
-  noerror:
diff -Nur sysdeps/unix/sysv/sysv4/i386/sys-sig.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/sys-sig.S
--- sysdeps/unix/sysv/sysv4/i386/sys-sig.S	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/sys-sig.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-.globl C_SYMBOL_NAME(__sigreturn)
-
-ENTRY (__sigaction_syscall)
-	movl $C_SYMBOL_NAME(__sigreturn), %edx
-	DO_CALL (sigaction, 3)
-	jb syscall_error
-	ret
-
-PSEUDO (__context_syscall, context, 2)
-	ret
diff -Nur sysdeps/unix/sysv/sysv4/i386/vfork.S /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/vfork.S
--- sysdeps/unix/sysv/sysv4/i386/vfork.S	1995-01-21 16:30:36.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/i386/vfork.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/bsd/i386/vfork.S>
diff -Nur sysdeps/unix/sysv/sysv4/Implies /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Implies
--- sysdeps/unix/sysv/sysv4/Implies	1993-02-24 23:25:32.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Implies	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-# The directory unix/common contains things which are common to both BSD
-# and SVR4.
-unix/common
diff -Nur sysdeps/unix/sysv/sysv4/Makefile /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Makefile
--- sysdeps/unix/sysv/sysv4/Makefile	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-# Copyright (C) 1992, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; if not, write to the Free
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-# 02111-1307 USA.
-
-ifeq ($(subdir),posix)
-
-sysdep_routines := $(sysdep_routines) sysconfig pgrpsys __waitid
-
-endif
-
-ifeq ($(subdir),misc)
-
-sysdep_routines := $(sysdep_routines) sysinfo
-
-endif
diff -Nur sysdeps/unix/sysv/sysv4/sethostname.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sethostname.c
--- sysdeps/unix/sysv/sysv4/sethostname.c	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sethostname.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/systeminfo.h>
-
-extern int __sysinfo __P ((int command, const char *buf, long count));
-
-int
-sethostname (name, namelen)
-     const char *name;
-     size_t namelen;
-{
-  return __sysinfo (SI_SET_HOSTNAME, name, namelen);
-}
diff -Nur sysdeps/unix/sysv/sysv4/__setpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/__setpgid.c
--- sysdeps/unix/sysv/sysv4/__setpgid.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/__setpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/* Copyright (C) 1993, 1997, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-
-extern int __pgrpsys __P ((int type, ...));
-
-/* Get the process group ID of process PID.  */
-int
-__setpgid (pid, pgid)
-     pid_t pid;
-     pid_t pgid;
-{
-  return __pgrpsys (5, pid, pgid);
-}
-libc_hidden_def (__setpgid)
diff -Nur sysdeps/unix/sysv/sysv4/setpgid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/setpgid.c
--- sysdeps/unix/sysv/sysv4/setpgid.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/setpgid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/* Copyright (C) 1993,1995,1996,1997,1999,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-extern int __pgrpsys __P ((pid_t type, ...));
-
-/* Set the process group ID of the process matching PID to PGID.
-   If PID is zero, the current process's process group ID is set.
-   If PGID is zero, the process ID of the process is used.  */
-int
-__setpgid (pid, pgid)
-     pid_t pid, pgid;
-{
-  return __pgrpsys (5, pid, pgid);
-}
-libc_hidden_def (__setpgid)
-weak_alias (__setpgid, setpgid)
diff -Nur sysdeps/unix/sysv/sysv4/setsid.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/setsid.c
--- sysdeps/unix/sysv/sysv4/setsid.c	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/setsid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Copyright (C) 1993, 1995, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-extern pid_t __pgrpsys __P ((int type, ...));
-
-/* Create a new session with the calling process as its leader.
-   The process group IDs of the session and the calling process
-   are set to the process ID of the calling process, which is returned.  */
-pid_t
-__setsid ()
-{
-  return __pgrpsys (3);
-}
-
-weak_alias (__setsid, setsid)
diff -Nur sysdeps/unix/sysv/sysv4/sigaction.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sigaction.c
--- sysdeps/unix/sysv/sysv4/sigaction.c	2002-08-02 23:46:59.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sigaction.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-/* Copyright (C) 1994,1995,1996,1997,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <stddef.h>
-
-static __sighandler_t user_handlers[NSIG];
-
-extern int __context_syscall (int, struct sigcontext *);
-extern int __sigaction_syscall (int,
-				const struct sigaction *, struct sigaction *);
-
-static void
-trampoline (int sig, int code, struct sigcontext *context)
-{
-  (*(void (*) (int, int, struct sigcontext *)) user_handlers[sig])
-    (sig, code, context);
-  __context_syscall (1, context);
-}
-
-/* If ACT is not NULL, change the action for SIG to *ACT.
-   If OACT is not NULL, put the old action for SIG in *OACT.  */
-int
-__sigaction (sig, act, oact)
-     int sig;
-     const struct sigaction *act;
-     struct sigaction *oact;
-{
-  struct sigaction myact;
-  __sighandler_t ohandler;
-
-  if (sig <= 0 || sig >= NSIG)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  ohandler = user_handlers[sig];
-
-  if (act != NULL)
-    {
-      user_handlers[sig] = act->sa_handler;
-      if (act->sa_handler != SIG_DFL && act->sa_handler != SIG_IGN)
-	{
-	  myact = *act;
-	  act = &myact;
-	  act->sa_handler = (__sighandler_t) trampoline;
-	}
-    }
-
-  if (__sigaction_syscall (sig, act, oact) < 0)
-    {
-      /* The syscall got an error.  Restore the old handler and return -1.  */
-      user_handlers[sig] = ohandler;
-      return -1;
-    }
-
-  if (oact != NULL && oact->sa_handler == (__sighandler_t) trampoline)
-    oact->sa_handler = ohandler;
-
-  return 0;
-}
-libc_hidden_def (__sigaction)
-weak_alias (__sigaction, sigaction)
diff -Nur sysdeps/unix/sysv/sysv4/siginfo.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/siginfo.h
--- sysdeps/unix/sysv/sysv4/siginfo.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/siginfo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Definitions of the siginfo structure.
-   Copyright (C) 1993, 1994, 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Brendan Kehoe (brendan@zen.org).
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef	_SIGINFO_H
-#define	_SIGINFO_H	1
-
-#ifdef __USE_SVID
-/* SVR4 puts a ton of other stuff in this structure.  For now, we'll just
-   define the two things we really need out of it, and hope for the best.  */
-
-/* These define the different states a child can have on exit.
-   We need these to build the status return for things like waitpid.  */
-#define EXITED 		1
-#define KILLED		2
-#define CORED		3
-#define TRAPPED		4
-#define STOPPED		5
-#define CONTINUED	6
-
-typedef struct __siginfo
-  {
-    int filler1;
-
-    /* Code indicating child's status */
-    int __code;
-
-    int filler2;
-
-    /* The PID of the child.  */
-    long __pid;
-
-    int filler3;
-
-    /* The child's status.  */
-    int __status;
-
-    int filler4[26];
-
-  } __siginfo_t;
-
-#endif  /* __USE_SVID */
-#endif	/* siginfo.h */
diff -Nur sysdeps/unix/sysv/sysv4/sigset-cvt-mask.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sigset-cvt-mask.h
--- sysdeps/unix/sysv/sysv4/sigset-cvt-mask.h	2002-09-05 20:56:51.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/sigset-cvt-mask.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* Convert between lowlevel sigmask and libc representation of sigset_t.
-   SysVr4 version.
-   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Joe Keane <jgk@jgk.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-static inline int __attribute__ ((unused))
-sigset_set_old_mask (sigset_t *set, int mask)
-{
-  set->__sigbits[0] = (unsigned int) mask;
-  set->__sigbits[1] = 0ul;
-  set->__sigbits[2] = 0ul;
-  set->__sigbits[3] = 0ul;
-
-  return 0;
-}
-
-static inline int __attribute__ ((unused))
-sigset_get_old_mask (const sigset_t *set)
-{
-  return (unsigned int) set->__sigbits[0];
-}
diff -Nur sysdeps/unix/sysv/sysv4/solaris2/bits/dirent.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/dirent.h
--- sysdeps/unix/sysv/sysv4/solaris2/bits/dirent.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/dirent.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _DIRENT_H
-# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
-#endif
-
-struct dirent
-  {
-#ifndef __USE_FILE_OFFSET64
-    __ino_t d_ino;
-    __off_t d_off;
-#else
-    __ino64_t d_ino;
-    __off64_t d_off;
-#endif
-    unsigned short int d_reclen;
-    char d_name[256];		/* We must not include limits.h! */
-  };
-
-#ifdef __USE_LARGEFILE64
-struct dirent64
-  {
-    __ino64_t d_ino;
-    __off64_t d_off;
-    unsigned short int d_reclen;
-    char d_name[256];		/* We must not include limits.h! */
-  };
-#endif
-
-#define d_fileno	d_ino	/* Backwards compatibility.  */
-
-#undef  _DIRENT_HAVE_D_NAMLEN
-#define _DIRENT_HAVE_D_RECLEN
-#define _DIRENT_HAVE_D_OFF
diff -Nur sysdeps/unix/sysv/sysv4/solaris2/bits/errno.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/errno.h
--- sysdeps/unix/sysv/sysv4/solaris2/bits/errno.h	2002-07-18 02:18:41.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/errno.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/* Copyright (C) 1991, 1994, 1996, 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This file defines the `errno' constants.  */
-
-#if !defined __Emath_defined && (defined _ERRNO_H || defined __need_Emath)
-#undef	__need_Emath
-#define	__Emath_defined	1
-
-# define EDOM	33	/* Math argument out of domain of function.  */
-# define EILSEQ	88	/* Illegal byte sequence.  */
-# define ERANGE	34	/* Math result not representable.  */
-#endif
-
-#ifdef	_ERRNO_H
-/* All error codes the system knows about.  */
-
-# define EPERM		1	/* Not super-user.  */
-# define ENOENT		2	/* No such file or directory.  */
-# define ESRCH		3	/* No such process.  */
-# define EINTR		4	/* Interrupted system call.  */
-# define EIO		5	/* I/O error.  */
-# define ENXIO		6	/* No such device or address.  */
-# define E2BIG		7	/* Arg list too long.  */
-# define ENOEXEC	8	/* Exec format error.  */
-# define EBADF		9	/* Bad file number.  */
-# define ECHILD		10	/* No children.  */
-# define EAGAIN		11	/* Resource temporarily unavailable.  */
-# define EWOULDBLOCK	EAGAIN
-# define ENOMEM		12	/* Not enough core.  */
-# define EACCES		13	/* Permission denied.  */
-# define EFAULT		14	/* Bad address.  */
-# define ENOTBLK	15	/* Block device required.  */
-# define EBUSY		16	/* Mount device busy.  */
-# define EEXIST		17	/* File exists.  */
-# define EXDEV		18	/* Cross-device link.  */
-# define ENODEV		19	/* No such device.  */
-# define ENOTDIR	20	/* Not a directory.  */
-# define EISDIR		21	/* Is a directory.  */
-# define EINVAL		22	/* Invalid argument.  */
-# define ENFILE		23	/* File table overflow.  */
-# define EMFILE		24	/* Too many open files.  */
-# define ENOTTY		25	/* Inappropriate ioctl for device.  */
-# define ETXTBSY	26	/* Text file busy.  */
-# define EFBIG		27	/* File too large.  */
-# define ENOSPC		28	/* No space left on device.  */
-# define ESPIPE		29	/* Illegal seek.  */
-# define EROFS		30	/* Read only file system.  */
-# define EMLINK		31	/* Too many links.  */
-# define EPIPE		32	/* Broken pipe.  */
-# define ENOMSG		35	/* No message of desired type.  */
-# define EIDRM		36	/* Identifier removed.  */
-# define ECHRNG		37	/* Channel number out of range.  */
-# define EL2NSYNC	38	/* Level 2 not synchronized.  */
-# define EL3HLT		39	/* Level 3 halted.  */
-# define EL3RST		40	/* Level 3 reset.  */
-# define ELNRNG		41	/* Link number out of range.  */
-# define EUNATCH	42	/* Protocol driver not attached.  */
-# define ENOCSI		43	/* No CSI structure available.  */
-# define EL2HLT		44	/* Level 2 halted.  */
-# define EDEADLK	45	/* Deadlock condition.  */
-# define ENOLCK		46	/* No record locks available.  */
-# define ECANCELED	47	/* Operation canceled.  */
-# define ENOTSUP	48	/* Operation not supported.  */
-
-/* Filesystem Quotas.  */
-# define EDQUOT		49	/* Disc quota exceeded.  */
-
-/* Convergent Error Returns.  */
-# define EBADE		50	/* Invalid exchange.  */
-# define EBADR		51	/* Invalid request descriptor.  */
-# define EXFULL		52	/* Exchange full.  */
-# define ENOANO		53	/* No anode.  */
-# define EBADRQC	54	/* Invalid request code.  */
-# define EBADSLT	55	/* Invalid slot.  */
-# define EDEADLOCK	56	/* File locking deadlock error.  */
-
-# define EBFONT		57	/* Bad font file fmt.  */
-
-/* STREAM problems.  */
-# define ENOSTR		60	/* Device not a stream.  */
-# define ENODATA	61	/* No data (for no delay io).  */
-# define ETIME		62	/* Timer expired.  */
-# define ENOSR		63	/* Out of streams resources.  */
-
-# define ENONET		64	/* Machine is not on the network.  */
-# define ENOPKG		65	/* Package not installed.  */
-# define EREMOTE	66	/* The object is remote.  */
-# define ENOLINK	67	/* The link has been severed.  */
-# define EADV		68	/* Advertise error.  */
-# define ESRMNT		69	/* Srmount error.  */
-
-# define ECOMM		70	/* Communication error on send.  */
-# define EPROTO		71	/* Protocol error.  */
-# define EMULTIHOP	74	/* Multihop attempted.  */
-# define EBADMSG	77	/* Trying to read unreadable message.  */
-# define ENAMETOOLONG	78	/* Path name is too long.  */
-# define EOVERFLOW	79	/* Value too large to be stored in data type.*/
-# define ENOTUNIQ	80	/* Given log. name not unique.  */
-# define EBADFD		81	/* F.d. invalid for this operation.  */
-# define EREMCHG	82	/* Remote address changed.  */
-
-/* Shared library problems.  */
-# define ELIBACC	83	/* Can't access a needed shared lib.  */
-# define ELIBBAD	84	/* Accessing a corrupted shared lib.  */
-# define ELIBSCN	85	/* .lib section in a.out corrupted.  */
-# define ELIBMAX	86	/* Attempting to link in too many libs.  */
-# define ELIBEXEC	87	/* Attempting to exec a shared library.  */
-# define ENOSYS		89	/* Unsupported file system operation.  */
-# define ELOOP		90	/* Symbolic link loop.  */
-# define ERESTART	91	/* Restartable system call.  */
-# define ESTRPIPE	92	/* If pipe/FIFO, don't sleep in stream head. */
-# define ENOTEMPTY	93	/* Directory not empty.  */
-# define EUSERS		94	/* Too many users (for UFS).  */
-
-/* BSD Networking Software: argument errors.  */
-# define ENOTSOCK	95	/* Socket operation on non-socket.  */
-# define EDESTADDRREQ	96	/* Destination address required.  */
-# define EMSGSIZE	97	/* Message too long.  */
-# define EPROTOTYPE	98	/* Protocol wrong type for socket.  */
-# define ENOPROTOOPT	99	/* Protocol not available.  */
-# define EPROTONOSUPPORT 120	/* Protocol not supported.  */
-# define ESOCKTNOSUPPORT 121	/* Socket type not supported.  */
-# define EOPNOTSUPP	122	/* Operation not supported on socket.  */
-# define EPFNOSUPPORT	123	/* Protocol family not supported.  */
-# define EAFNOSUPPORT	124	/* Address family not supported by
-				   protocol family.  */
-# define EADDRINUSE	125	/* Address already in use.  */
-# define EADDRNOTAVAIL	126	/* Can't assign requested address.  */
-/* BSD Networking Software: operational errors.  */
-# define ENETDOWN	127	/* Network is down.  */
-# define ENETUNREACH	128	/* Network is unreachable.  */
-# define ENETRESET	129	/* Network dropped connection because
-				   of reset.  */
-# define ECONNABORTED	130	/* Software caused connection abort.  */
-# define ECONNRESET	131	/* Connection reset by peer.  */
-# define ENOBUFS	132	/* No buffer space available.  */
-# define EISCONN	133	/* Socket is already connected.  */
-# define ENOTCONN	134	/* Socket is not connected.  */
-/* XENIX has 135 - 142.  */
-# define ESHUTDOWN	143	/* Can't send after socket shutdown.  */
-# define ETOOMANYREFS	144	/* Too many references: can't splice.  */
-# define ETIMEDOUT	145	/* Connection timed out.  */
-# define ECONNREFUSED	146	/* Connection refused.  */
-# define EHOSTDOWN	147	/* Host is down.  */
-# define EHOSTUNREACH	148	/* No route to host.  */
-# define EALREADY	149	/* operation already in progress.  */
-# define EINPROGRESS	150	/* operation now in progress.  */
-
-/* SUN Network File System.  */
-# define ESTALE		151     /* Stale NFS file handle.  */
-
-#endif
diff -Nur sysdeps/unix/sysv/sysv4/solaris2/bits/signum.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/signum.h
--- sysdeps/unix/sysv/sysv4/solaris2/bits/signum.h	2001-07-07 21:21:39.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/unix/sysv/sysv4/solaris2/bits/signum.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* Signal number definitions.  Solaris 2 version.
-   Copyright (C) 1994, 1996, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifdef	_SIGNAL_H
-
-/* Fake signal functions.  */
-#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
-#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
-#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
-#ifdef __USE_UNIX98
-# define SIG_HOLD ((__sighandler_t) 2) /* Add signal to hold mask.  */
-#endif
-
-
-/* Signals.  */
-#define	SIGHUP		1	/* Hangup (POSIX).  */
-#define	SIGINT		2	/* Interrupt (ANSI).  */
-#define	SIGQUIT		3	/* Quit (POSIX).  */
-#define	SIGILL		4	/* Illegal instruction (ANSI).  */
-#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
-#define	SIGTRAP		5	/* Trace trap (POSIX).  */
-#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
-#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
-#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
-#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
-#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
-#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
-#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD)*/
-#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
-#define	SIGALRM		14	/* Alarm clock (POSIX).  */
-#define	SIGTERM		15	/* Termination (ANSI).  */
-#define	SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
-#define	SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
-#define	SIGCHLD		18	/* Child status has changed (POSIX).  */
-#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
-#define	SIGPWR		19	/* Power failure restart (System V).  */
-#define	SIGWINCH	20	/* Window size change (4.3 BSD, Sun).  */
-#define	SIGURG		21	/* Urgent condition on socket (4.2 BSD).*/
-#define	SIGPOLL		22	/* Pollable event occurred (System V).  */
-#define	SIGIO		SIGPOLL	/* I/O now possible (4.2 BSD).  */
-#define	SIGSTOP		23	/* Stop, unblockable (POSIX).  */
-#define	SIGTSTP		24	/* Keyboard stop (POSIX).  */
-#define	SIGCONT		25	/* Continue (POSIX).  */
-#define	SIGTTIN		26	/* Background read from tty (POSIX).  */
-#define	SIGTTOU		27	/* Background write to tty (POSIX).  */
-#define	SIGVTALRM	28	/* Virtual alarm clock (4.2 BSD).  */
-#define	SIGPROF		29	/* Profiling alarm clock (4.2 BSD).  */
-#define	SIGXCPU		30	/* CPU limit exceeded (4.2 BSD).  */
-#define	SIGXFSZ		31	/* File size limit exceeded (4.2 BSD).  */
-/* The following signals are new in Solaris 2.  */
-#define	SIGWAITING	32	/* Process's lwps are blocked.  */
-#define	SIGLWP		33	/* Special signal used by thread library.  */
-#define	SIGFREEZE	34	/* Special signal used by CPR.  */
-#define	SIGTHAW		35	/* Special signal used by CPR.  */
-#define	_SIGRTMIN	36	/* First (highest-priority) realtime signal. */
-#define	_SIGRTMAX	43	/* Last (lowest-priority) realtime signal.  */
-
-#endif	/* <signal.h> included.  */
-
-#define	_NSIG		44	/* Biggest signal number + 1.  */

diff -Nur sysdeps/wordsize-32/divdi3.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/divdi3.c
--- sysdeps/wordsize-32/divdi3.c	2002-09-19 07:31:26.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/divdi3.c	2004-03-08 22:29:07.000000000 +0100
@@ -1,5 +1,5 @@
 /* 64-bit multiplication and division
-   Copyright (C) 1989, 1992-1999, 2000, 2001, 2002
+   Copyright (C) 1989, 1992-1999, 2000, 2001, 2002, 2003, 2004
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -294,7 +294,7 @@
     w = -w;
   return w;
 }
-INTDEF(__divdi3)
+strong_alias (__divdi3, __divdi3_internal)
 
 DWtype
 __moddi3 (DWtype u, DWtype v)
@@ -314,12 +314,14 @@
     w = -w;
   return w;
 }
+strong_alias (__moddi3, __moddi3_internal)
 
 UDWtype
 __udivdi3 (UDWtype u, UDWtype v)
 {
   return __udivmoddi4 (u, v, NULL);
 }
+strong_alias (__udivdi3, __udivdi3_internal)
 
 UDWtype
 __umoddi3 (UDWtype u, UDWtype v)
@@ -329,3 +331,14 @@
   __udivmoddi4 (u, v, &w);
   return w;
 }
+strong_alias (__umoddi3, __umoddi3_internal)
+
+/* We declare these with compat_symbol so that they are not visible at
+   link time.  Programs must use the functions from libgcc.  */
+#if defined HAVE_ELF && defined SHARED && defined DO_VERSIONING
+# include <shlib-compat.h>
+compat_symbol (libc, __divdi3, __divdi3, GLIBC_2_0);
+compat_symbol (libc, __moddi3, __moddi3, GLIBC_2_0);
+compat_symbol (libc, __udivdi3, __udivdi3, GLIBC_2_0);
+compat_symbol (libc, __umoddi3, __umoddi3, GLIBC_2_0);
+#endif
diff -Nur sysdeps/wordsize-32/lldiv.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/lldiv.c
--- sysdeps/wordsize-32/lldiv.c	2002-07-25 09:55:16.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/lldiv.c	2003-01-27 22:01:40.000000000 +0100
@@ -21,13 +21,6 @@
 
 #include <inttypes.h>
 
-#ifdef SHARED
-/* This is an ugly trick.  We cause the C code generated for the code
-   in lldiv.c to use __divdi3_internal instead of __divdi3 by defining
-   an alias on the assembler level.  */
-asm ("__divdi3 = __divdi3_internal");
-#endif
-
 #include <sysdeps/generic/lldiv.c>
 
 #undef imaxdiv
diff -Nur sysdeps/wordsize-32/symbol-hacks.h /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/symbol-hacks.h
--- sysdeps/wordsize-32/symbol-hacks.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/symbol-hacks.h	2004-03-08 21:59:34.000000000 +0100
@@ -0,0 +1,30 @@
+/* Hacks needed for symbol manipulation.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* A very dirty trick: gcc emits references to __divdi3, __udivdi3,
+   __moddi3, and __umoddi3.  These functions are exported and
+   therefore we get PLTs.  Unnecessarily so.  Changing gcc is a big
+   task which might not be worth it so we play tricks with the
+   assembler.  */
+#if !defined __ASSEMBLER__ && !defined NOT_IN_libc && defined SHARED
+asm ("__divdi3 = __divdi3_internal");
+asm ("__udivdi3 = __udivdi3_internal");
+asm ("__moddi3 = __moddi3_internal");
+asm ("__umoddi3 = __umoddi3_internal");
+#endif
diff -Nur sysdeps/wordsize-32/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/Versions
--- sysdeps/wordsize-32/Versions	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-32/Versions	2003-03-03 10:45:12.000000000 +0100
@@ -0,0 +1,7 @@
+libc {
+  GLIBC_2.3 {
+    # These were erroneously omitted for 64-bit platforms in 2.3
+    # and so we don't put them in locale/Versions.
+    strtoll_l; strtoull_l;
+  }
+}
diff -Nur sysdeps/wordsize-64/strtol_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/strtol_l.c
--- sysdeps/wordsize-64/strtol_l.c	2002-08-05 02:30:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/strtol_l.c	2003-03-03 10:45:12.000000000 +0100
@@ -1,11 +1,14 @@
 /* We have to irritate the compiler a bit.  */
 #define ____strtoll_l_internal ____strtoll_l_internal_XXX
 #define __strtoll_l __strtoll_l_XXX
+#define strtoll_l strtoll_l_XXX
 
 #include <sysdeps/generic/strtol_l.c>
 
 #undef ____strtoll_l_internal
 #undef __strtoll_l
+#undef strtoll_l
 strong_alias (____strtol_l_internal, ____strtoll_l_internal)
 libc_hidden_ver (____strtol_l_internal, ____strtoll_l_internal)
 weak_alias (__strtol_l, __strtoll_l)
+weak_alias (__strtol_l, strtoll_l)
diff -Nur sysdeps/wordsize-64/strtoul_l.c /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/strtoul_l.c
--- sysdeps/wordsize-64/strtoul_l.c	2002-08-05 02:30:03.000000000 +0200
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/strtoul_l.c	2003-03-03 10:45:12.000000000 +0100
@@ -1,11 +1,14 @@
 /* We have to irritate the compiler a bit.  */
 #define ____strtoull_l_internal ____strtoull_l_internal_XXX
 #define __strtoull_l __strtoull_l_XXX
+#define strtoull_l strtoull_l_XXX
 
 #include <sysdeps/generic/strtoul_l.c>
 
 #undef ____strtoull_l_internal
 #undef __strtoull_l
+#undef strtoull_l
 strong_alias (____strtoul_l_internal, ____strtoull_l_internal)
 libc_hidden_ver (____strtoul_l_internal, ____strtoull_l_internal)
 weak_alias (__strtoul_l, __strtoull_l)
+weak_alias (__strtoul_l, strtoull_l)
diff -Nur sysdeps/wordsize-64/Versions /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/Versions
--- sysdeps/wordsize-64/Versions	1970-01-01 01:00:00.000000000 +0100
+++ /home/aurel32/debian/ports/glibc/new/glibc-2.3.5/build-tree/glibc-2.3.5/sysdeps/wordsize-64/Versions	2003-03-03 10:45:12.000000000 +0100
@@ -0,0 +1,6 @@
+libc {
+  GLIBC_2.3.3 {
+    # These were erroneously omitted for 64-bit platforms in 2.3.
+    strtoll_l; strtoull_l;
+  }
+}

