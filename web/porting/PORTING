Common practices and problems found when porting to GNU/k*BSD
===============================================================

GNUAB archive upload policy
---------------------------

When you're going to upload your fixes to the GNUAB repository, check
this first:

  <http://archive.gnuab.org/upload-policy.txt>


Config scripts (config.guess and config.sub)
--------------------------------------------

You must have the latest config.guess and config.sub. Copy them from
"/usr/share/misc/config.*".


Add our system name to checks here and there
--------------------------------------------

When the check doesn't concern kernel, but userland stuff (notably, libc),
we want to match the same checks that match Linux.  Make sure the definitions
are not simply duplicated from Linux' because that will eventualy result in
out-of-sync definitions that break for us.

Example of triplet check:	linux*-gnu | gnu* | k*bsd*-gnu)
Example of uname check:		Linux|GNU|GNU/*)
Example of C macro check:	defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
				[note: GNU/Hurd defines __GNU__, and GNU/k*BSD define __GLIBC__ as hardcoded macro]

When the check concerns kernel, we obviously want to match with FreeBSD's or
NetBSD's.

Example of triplet check:	freebsd* | kfreebsd*-gnu)
Example of uname check:		*FreeBSD)
Example of C macro check:	defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
				[note: see below for more details on this one]


Libraries, your beloved enemy
-----------------------------

Here are some guidelines for building and porting libraries. Many libraries
need porting work because they have to detect the system in order to decide
how their shared object support works.

When building a library make sure it generates the shared object (.so.*)
files.  Most of them will FTBFS if this fails, but a few will still build
succesfuly, being the cause of horrible bugs in unrelated packages that are
sometimes difficult to trace and can easily be avoided.

First of all, check if your library uses libtool.  A quick and reliable check
is:

  grep 'Linux ELF' *

If it reports matches in aclocal.m4 and configure, it means we're using
libtool.  Now check wether the installed libtool supports us:

  grep kfreebsd aclocal.m4

If no match is found, we need to re-libtoolize. Generaly, this involves:

  Check the 'configure' header for the version of autoconf that generated it.
  If that version is 2.13, give up. Your attempt at relibtoolising failed.
  (read the notes below for a method to work around the problem).

  Run 'libtoolize -c -f'.  If everything is ok, this command should be a
  no-op.  However, make sure it doesn't say you need to add the contents of
  'libtool.m4' here or there.  If it does, it means the package is keeping an
  old copy of libtool.m4 hidden somewhere (sigh).  Sometimes it's just renamed,
  sometimes it's embedded in acinclude.m4.  In whichever case, _don't_ update
  it manualy.  Instead, remove the libtool.m4 bits from whereever they are.

  Check the 'aclocal.m4' header for the version of aclocal that generated it,
  and use the same major version (aclocal-1.x) to regenerate it.  If the
  package includes an 'm4' directory you might need to pass '-I m4' to aclocal.

  Regenerate configure using autoconf 2.5x.  Now make sure everything went as
  expected:

    grep kfreebsd configure

This should do it.  If you failed to update libtool due to broken autotools
templates or some other weird reason, there's a workaround solution you can
use.  Since the gnu system (GNU/Hurd) is already supported by old versions
of libtool, and since the definitions are actualy not kernel-specific but
specific to things like libc, ld.so, or binary format, we can cloak
k*bsd-gnu as if it were gnu and this will work fine for us.

  *PLEASE* make sure the package doesn't use any kernel-specific interfaces
  that are supported by kfreebsd. If it does, the kfreebsd-gnu triplet needs
  to be used to match with freebsd in the corresponding test, and using this
  hack will break it.  Don't use this hack unless you know what you're doing.
  Don't encourage package maintainers who are not aware of this porting issue
  to use this hack without checking the package properly. If in doubt, ask.

  I generaly do it like this.  In debian/rules:

  DEB_BUILD_GNU_TYPE	?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
  DEB_BUILD_GNU_CPU	?= $(shell dpkg-architecture -qDEB_BUILD_GNU_CPU)
  DEB_BUILD_GNU_SYSTEM	?= $(shell dpkg-architecture -qDEB_BUILD_GNU_SYSTEM)

  ifneq (, $(filter $(DEB_BUILD_GNU_SYSTEM), kfreebsd-gnu knetbsd-gnu))
  DEB_BUILD_GNU_TYPE = $(DEB_BUILD_GNU_CPU)-gnu
  endif

  [...]
  ./configure [...] $(DEB_BUILD_GNU_TYPE)

When you submit the bug, please point the maintainer to bug #242950, it
contains some useful info for maintainers.


Finaly, if the library doesn't use libtool, expect a hardcoded check for
Linux somewhere.  This is how badly-portable libraries generaly handle the
shared object definitions.  Just find the check for Linux and add our triplet
or uname output where it belongs.


Non portable mount(2) calls
---------------------------

Use pmount() instead, from libpmount:

  <http://packages.debian.org/libpmount-dev>


Preprocessor Variables
----------------------

How to check for system based on kernel of FreeBSD (i.e. either FreeBSD or
GNU/kFreeBSD), the Right Way [tm].

#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
[...]
#endif

Alternatively, when there are lots of checks, this might be prefered:

#if defined(__FreeBSD__) && ! defined(__FreeBSD_kernel__)
# define __FreeBSD_kernel__ __FreeBSD__
#endif
[...]
#ifdef __FreeBSD_kernel__
[...]
#endif

Some notes on version checking stuff. You _may_ assume __FreeBSD__ contains
major version information, but you must _not_ assume the same for
__FreeBSD_kernel__. On GNU/kFreeBSD, __FreeBSD_kernel__ will only contain
major version number after including <osreldate.h>. E.g:

#if defined(__FreeBSD__) && ! defined(__FreeBSD_kernel__)
# define __FreeBSD_kernel__ __FreeBSD__
#endif
#ifdef __FreeBSD_kernel__
# include <osreldate.h>
#endif
[...]
#if __FreeBSD_kernel__ >= 5
[...]
#else
[...]
#endif

There are also __FreeBSD_version and __FreeBSD_kernel_version, which work
similarly:

#if defined(__FreeBSD__) && ! defined(__FreeBSD_kernel__)
# define __FreeBSD_kernel__ __FreeBSD__
#endif
#ifdef __FreeBSD_kernel__
# include <osreldate.h>
# ifndef __FreeBSD_kernel_version
# define __FreeBSD_kernel_version __FreeBSD_version
# endif
#endif
[...]
#if __FreeBSD_kernel_version >= 502010
[...]
#else
[...]
#endif

For possible values of __FreeBSD_*version variables, see:

  <http://www.freebsd.org/doc/en/books/porters-handbook/freebsd-versions.html>


Important note on __FreeBSD_*version. Unlike FreeBSD, we ship packages that
are not part of base _always_ providing binaries. Sometimes it's not important
for a FreeBSD porter to maintain compatibility with different kernel ABIs
in runtime, and per might opt for doing it in build time. However, we are
going to ship two major kernel versions (4.x and 5.x) and our binaries should
run on both. This is why we need to implement runtime detection whenever
possible. An example, based on the previous one:

#if defined(__FreeBSD__) && ! defined(__FreeBSD_kernel__)
# define __FreeBSD_kernel__ __FreeBSD__
#endif
#ifdef __FreeBSD_kernel__
# include <osreldate.h>
# ifndef __FreeBSD_kernel_version
# define __FreeBSD_kernel_version __FreeBSD_version
# endif
int
get_kfreebsd_version ()
  {
[...]
  }
#endif
[...]
#if __FreeBSD_kernel_version >= 502010
  if (get_kfreebsd_version () >= 502010)
    {
[...]
    }
  else
#else
  {
[...]
  }
#endif

get_kfreebsd_version () returns the latest version of kFreeBSD that uname ()
can garantee us, and converts it in a 6-digit format compatible with
__FreeBSD_*version. I have put get_kfreebsd_version () in
get_kfreebsd_version.c in this directory. You can copy and use it whereever
you like.

There are usage examples of all the above examples in [grub]/lib/device.c,
so I suggest you have a look at it.


Writing to devfs (kFreeBSD)
---------------------------

On kFreeBSD's devfs it's only possible to create block/char devices and
symlinks. So if you need to create some thing in /dev, like a named pipe
create it in another place, then symlink from /dev.

Note that the symlink you put in /dev will be removed on next reboot, so
make sure the proper init.d script restores it.

Generaly, you should use /var/run for your named pipe.  The only exception
is sysvinit, which can't assume /var is mounted and hence uses /etc. All
other daemons can assume /var is mounted, so this shouldn't be an issue.


gcc attempting to link C programs with C++ libraries
----------------------------------------------------

If you see an error like this:

gcc -o foo foo.o -lbar ...
/usr/lib/libbar.so: undefined reference to `operator new[](unsigned)'
/usr/lib/libbar.so: undefined reference to `vtable for __cxxabiv1::__si_class_type_info'
/usr/lib/libbar.so: undefined reference to `operator delete(void*)'
/usr/lib/libbar.so: undefined reference to `__gxx_personality_v0'
/usr/lib/libbar.so: undefined reference to `__cxa_pure_virtual'

It means you should be using g++ instead of gcc to link.  In some
systems/situations, adding -lstdc++ works around the problem, but it might
result in even more weird errors too.  In particular, if you see something
really weird like this:

/usr/bin/ld: foo: hidden symbol `__umoddi3' in /usr/lib/gcc-lib/[...]/libgcc.a(_umoddi3.oS) is referenced by DSO

it most likely means upstream hardcoded -lstdc++ which only seems to break
for us.

Replacing gcc with g++ when linking non-c++ programs with autotools is a bit
tricky:

  - Make sure configure.ac has AC_PROG_CXX
  - Create an empty empty.cc file and edit Makefile.am.  Make the foo_SOURCES
    line look like "foo_SOURCES = foo.c empty.cc".  This will fool automake
    into thinking foo is a C++ program.  If you know a better way to do this,
    please let us know.



RT signals
----------

kFreeBSD doesn't support POSIX RT (realtime) signals.  I hope that this
functionality is added someday but for now it's a porting issue for us.

You can detect wether RT signals are available in the system via the SIGRTMIN
and SIGRTMAX macros (which are not defined on kfreebsd-gnu).

The lack of this feature is more annoying that it might seem, as it produces
breakage in programs that don't use LinuxThreads properly.  From the
LinuxThreads FAQ:

  "On ``old'' kernels (2.0 and early 2.1 kernels), there are only 32 signals
  available and the kernel reserves all of them but two: SIGUSR1 and SIGUSR2.
  So, LinuxThreads has no choice but use those two signals."

  "On recent kernels (2.2 and up), more than 32 signals are provided in the
  form of realtime signals. When run on one of those kernels, LinuxThreads
  uses two reserved realtime signals for its internal operation, thus leaving
  SIGUSR1 and SIGUSR2 free for user code."

Since we don't support RT signals, kFreeBSD counts as a "Linux 2.0" kernel,
and we use SIGUSR1 and SIGUSR2.  Programs with custom use of SIGUSR1 and
SIGUSR2 will interfere with the pthread implementation and cause trouble
(this happens with Linux 2.0 too).
