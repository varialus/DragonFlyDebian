diff -Nur src.old/lib/libkvm/Makefile src/lib/libkvm/Makefile
--- src.old/lib/libkvm/Makefile	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/Makefile	2004-08-11 00:07:51.000000000 +0200
@@ -5,7 +5,7 @@
 SHLIBDIR?= /lib
 CFLAGS+=-DLIBC_SCCS -I${.CURDIR}
 SRCS=	kvm.c kvm_${MACHINE_ARCH}.c kvm_file.c kvm_getloadavg.c \
-	kvm_getswapinfo.c kvm_proc.c
+	kvm_getswapinfo.c kvm_proc.c strlcpy.c
 INCS=	kvm.h
 
 MAN=	kvm.3 kvm_geterr.3 kvm_getfiles.3 kvm_getloadavg.3 kvm_getprocs.3 \
diff -Nur src.old/lib/libkvm/kvm.c src/lib/libkvm/kvm.c
--- src.old/lib/libkvm/kvm.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm.c	2004-08-11 00:07:51.000000000 +0200
@@ -36,7 +36,8 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm.c,v 1.25 2003/10/29 14:02:16 simokawa Exp $");
+#ifdef __FreeBSD__
+#endif
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
@@ -61,7 +62,6 @@
 #include <fcntl.h>
 #include <kvm.h>
 #include <limits.h>
-#include <nlist.h>
 #include <paths.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -70,9 +70,6 @@
 
 #include "kvm_private.h"
 
-/* from src/lib/libc/gen/nlist.c */
-int __fdnlist(int, struct nlist *);
-
 char *
 kvm_geterr(kd)
 	kvm_t *kd;
@@ -159,7 +156,7 @@
 	kd->argv = 0;
 
 	if (uf == 0)
-		uf = getbootfile();
+		uf = _PATH_UNIX; /* should query 'kern.bootfile' via sysctl */
 	else if (strlen(uf) >= MAXPATHLEN) {
 		_kvm_err(kd, kd->program, "exec file name too long");
 		goto failed;
@@ -235,7 +232,7 @@
 kvm_openfiles(uf, mf, sf, flag, errout)
 	const char *uf;
 	const char *mf;
-	const char *sf __unused;
+	const char *sf;
 	int flag;
 	char *errout;
 {
@@ -254,7 +251,7 @@
 kvm_open(uf, mf, sf, flag, errstr)
 	const char *uf;
 	const char *mf;
-	const char *sf __unused;
+	const char *sf;
 	int flag;
 	const char *errstr;
 {
@@ -304,11 +301,10 @@
 	struct kld_sym_lookup lookup;
 
 	/*
-	 * If we can't use the kld symbol lookup, revert to the
-	 * slow library call.
+	 * If we can't use the kld symbol lookup, eat flaming hell.
 	 */
 	if (!ISALIVE(kd))
-		return (__fdnlist(kd->nlfd, nl));
+		return -1;
 
 	/*
 	 * We can use the kld lookup syscall.  Go through each nlist entry
diff -Nur src.old/lib/libkvm/kvm.h src/lib/libkvm/kvm.h
--- src.old/lib/libkvm/kvm.h	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm.h	2004-08-11 00:07:51.000000000 +0200
@@ -38,8 +38,15 @@
 #define	_KVM_H_
 
 #include <sys/cdefs.h>
+#ifdef __FreeBSD__
 #include <sys/_types.h>
 #include <nlist.h>
+#else
+#include <sys/types.h>
+#include "/usr/src/kfreebsd5-headers/sys/nlist_aout.h"
+#define _SIZE_T_DECLARED
+#define _SSIZE_T_DECLARED
+#endif
 
 /* Default version symbol. */
 #define	VRS_SYM		"_version"
diff -Nur src.old/lib/libkvm/kvm_alpha.c src/lib/libkvm/kvm_alpha.c
--- src.old/lib/libkvm/kvm_alpha.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_alpha.c	2004-08-11 00:07:51.000000000 +0200
@@ -28,7 +28,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_alpha.c,v 1.7 2001/10/13 04:38:46 bde Exp $");
 
 #include <sys/param.h>
 #include <sys/user.h>
diff -Nur src.old/lib/libkvm/kvm_amd64.c src/lib/libkvm/kvm_amd64.c
--- src.old/lib/libkvm/kvm_amd64.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_amd64.c	2004-08-11 00:07:51.000000000 +0200
@@ -36,7 +36,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_amd64.c,v 1.16 2003/04/30 21:05:33 peter Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
diff -Nur src.old/lib/libkvm/kvm_file.c src/lib/libkvm/kvm_file.c
--- src.old/lib/libkvm/kvm_file.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_file.c	2004-08-11 00:07:51.000000000 +0200
@@ -32,7 +32,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_file.c,v 1.17 2003/07/31 21:44:31 phk Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
@@ -55,7 +54,6 @@
 #undef _KERNEL
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <nlist.h>
 #include <kvm.h>
 
 #include <vm/vm.h>
@@ -64,8 +62,9 @@
 #include <sys/sysctl.h>
 
 #include <limits.h>
-#include <ndbm.h>
+#include <gdbm-ndbm.h>
 #include <paths.h>
+#include <stdio.h> /* NULL */
 
 #include "kvm_private.h"
 
@@ -81,43 +80,7 @@
 	int op, arg, nfiles;
 	long filehead_o;
 {
-	int buflen = kd->arglen, n = 0;
-	struct file *fp;
-	char *where = kd->argspc;
-	struct filelist filehead;
-
-	/*
-	 * first copyout filehead
-	 */
-	if (buflen > sizeof (filehead)) {
-		if (KREAD(kd, filehead_o, &filehead)) {
-			_kvm_err(kd, kd->program, "can't read filehead");
-			return (0);
-		}
-		buflen -= sizeof (filehead);
-		where += sizeof (filehead);
-		*(struct filelist *)kd->argspc = filehead;
-	}
-	/*
-	 * followed by an array of file structures
-	 */
-	LIST_FOREACH(fp, &filehead, f_list) {
-		if (buflen > sizeof (struct file)) {
-			if (KREAD(kd, (long)fp, ((struct file *)where))) {
-				_kvm_err(kd, kd->program, "can't read kfp");
-				return (0);
-			}
-			buflen -= sizeof (struct file);
-			fp = (struct file *)where;
-			where += sizeof (struct file);
-			n++;
-		}
-	}
-	if (n != nfiles) {
-		_kvm_err(kd, kd->program, "inconsistant nfiles");
-		return (0);
-	}
-	return (nfiles);
+	return 0;
 }
 
 char *
@@ -126,67 +89,5 @@
 	int op, arg;
 	int *cnt;
 {
-	int mib[2], st, nfiles;
-	size_t size;
-	struct file *fp, *fplim;
-	struct filelist filehead;
-
-	if (ISALIVE(kd)) {
-		size = 0;
-		mib[0] = CTL_KERN;
-		mib[1] = KERN_FILE;
-		st = sysctl(mib, 2, NULL, &size, NULL, 0);
-		if (st == -1) {
-			_kvm_syserr(kd, kd->program, "kvm_getfiles");
-			return (0);
-		}
-		if (kd->argspc == 0)
-			kd->argspc = (char *)_kvm_malloc(kd, size);
-		else if (kd->arglen < size)
-			kd->argspc = (char *)_kvm_realloc(kd, kd->argspc, size);
-		if (kd->argspc == 0)
-			return (0);
-		kd->arglen = size;
-		st = sysctl(mib, 2, kd->argspc, &size, NULL, 0);
-		if (st == -1 || size < sizeof(filehead)) {
-			_kvm_syserr(kd, kd->program, "kvm_getfiles");
-			return (0);
-		}
-		filehead = *(struct filelist *)kd->argspc;
-		fp = (struct file *)(kd->argspc + sizeof (filehead));
-		fplim = (struct file *)(kd->argspc + size);
-		for (nfiles = 0; LIST_FIRST(&filehead) && (fp < fplim); nfiles++, fp++)
-			LIST_FIRST(&filehead) = LIST_NEXT(fp, f_list);
-	} else {
-		struct nlist nl[3], *p;
-
-		nl[0].n_name = "_filehead";
-		nl[1].n_name = "_nfiles";
-		nl[2].n_name = 0;
-
-		if (kvm_nlist(kd, nl) != 0) {
-			for (p = nl; p->n_type != 0; ++p)
-				;
-			_kvm_err(kd, kd->program,
-				 "%s: no such symbol", p->n_name);
-			return (0);
-		}
-		if (KREAD(kd, nl[0].n_value, &nfiles)) {
-			_kvm_err(kd, kd->program, "can't read nfiles");
-			return (0);
-		}
-		size = sizeof(filehead) + (nfiles + 10) * sizeof(struct file);
-		if (kd->argspc == 0)
-			kd->argspc = (char *)_kvm_malloc(kd, size);
-		else if (kd->arglen < size)
-			kd->argspc = (char *)_kvm_realloc(kd, kd->argspc, size);
-		if (kd->argspc == 0)
-			return (0);
-		kd->arglen = size;
-		nfiles = kvm_deadfiles(kd, op, arg, nl[1].n_value, nfiles);
-		if (nfiles == 0)
-			return (0);
-	}
-	*cnt = nfiles;
-	return (kd->argspc);
+	return 0;
 }
diff -Nur src.old/lib/libkvm/kvm_getloadavg.c src/lib/libkvm/kvm_getloadavg.c
--- src.old/lib/libkvm/kvm_getloadavg.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_getloadavg.c	2004-08-11 00:07:51.000000000 +0200
@@ -32,7 +32,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_getloadavg.c,v 1.9 2001/11/20 08:26:37 jhb Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
@@ -46,19 +45,10 @@
 
 #include <stdlib.h>
 #include <limits.h>
-#include <nlist.h>
 #include <kvm.h>
 
 #include "kvm_private.h"
 
-static struct nlist nl[] = {
-	{ "_averunnable" },
-#define	X_AVERUNNABLE	0
-	{ "_fscale" },
-#define	X_FSCALE	1
-	{ "" },
-};
-
 /*
  * kvm_getloadavg() -- Get system load averages, from live or dead kernels.
  *
@@ -71,36 +61,10 @@
 	double loadavg[];
 	int nelem;
 {
-	struct loadavg loadinfo;
-	struct nlist *p;
 	int fscale, i;
 
 	if (ISALIVE(kd))
 		return (getloadavg(loadavg, nelem));
 
-	if (kvm_nlist(kd, nl) != 0) {
-		for (p = nl; p->n_type != 0; ++p);
-		_kvm_err(kd, kd->program,
-		    "%s: no such symbol", p->n_name);
-		return (-1);
-	}
-
-#define KREAD(kd, addr, obj) \
-	(kvm_read(kd, addr, (char *)(obj), sizeof(*obj)) != sizeof(*obj))
-	if (KREAD(kd, nl[X_AVERUNNABLE].n_value, &loadinfo)) {
-		_kvm_err(kd, kd->program, "can't read averunnable");
-		return (-1);
-	}
-
-	/*
-	 * Old kernels have fscale separately; if not found assume
-	 * running new format.
-	 */
-	if (!KREAD(kd, nl[X_FSCALE].n_value, &fscale))
-		loadinfo.fscale = fscale;
-
-	nelem = MIN(nelem, sizeof(loadinfo.ldavg) / sizeof(fixpt_t));
-	for (i = 0; i < nelem; i++)
-		loadavg[i] = (double) loadinfo.ldavg[i] / loadinfo.fscale;
 	return (nelem);
 }
diff -Nur src.old/lib/libkvm/kvm_getswapinfo.c src/lib/libkvm/kvm_getswapinfo.c
--- src.old/lib/libkvm/kvm_getswapinfo.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_getswapinfo.c	2004-08-11 00:09:28.000000000 +0200
@@ -7,22 +7,23 @@
  * Copyright as found in /usr/src/COPYRIGHT in the FreeBSD source tree.
  */
 
+#define _BSD_SOURCE 1
+
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_getswapinfo.c,v 1.25 2003/07/31 21:42:12 phk Exp $");
 
+#include <sys/types.h> /* u_daddr_t */
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/stat.h>
 #include <sys/blist.h>
 #include <sys/sysctl.h>
 
-#include <vm/vm_param.h>
+#include "/usr/src/kfreebsd5-headers/vm/vm_param.h"
 
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <kvm.h>
-#include <nlist.h>
 #include <paths.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -101,11 +102,6 @@
 		return -1;
 
 	mibi = SWI_MAXMIB - 1;
-	if (sysctlnametomib("vm.swap_info", soid, &mibi) == -1) {
-		_kvm_err(kd, kd->program, "sysctlnametomib failed: %s",
-		    strerror(errno));
-		return -1;
-	}
 	bzero(&tot, sizeof(tot));
 	for (unswdev = 0;; unswdev++) {
 		soid[mibi] = unswdev;
@@ -134,8 +130,6 @@
 			swap_ary[unswdev].ksw_total = ttl;
 			swap_ary[unswdev].ksw_used = xsd.xsw_used;
 			swap_ary[unswdev].ksw_flags = xsd.xsw_flags;
-			GETSWDEVNAME(xsd.xsw_dev, swap_ary[unswdev].ksw_devname,
-			     flags);
 		}
 		tot.ksw_total += ttl;
 		tot.ksw_used += xsd.xsw_used;
diff -Nur src.old/lib/libkvm/kvm_i386.c src/lib/libkvm/kvm_i386.c
--- src.old/lib/libkvm/kvm_i386.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_i386.c	2004-08-11 00:07:51.000000000 +0200
@@ -36,7 +36,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_i386.c,v 1.15 2001/10/10 17:48:43 bde Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
@@ -55,7 +54,6 @@
 #include <sys/stat.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <nlist.h>
 #include <kvm.h>
 
 #include <vm/vm.h>
diff -Nur src.old/lib/libkvm/kvm_powerpc.c src/lib/libkvm/kvm_powerpc.c
--- src.old/lib/libkvm/kvm_powerpc.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_powerpc.c	2004-08-11 00:07:51.000000000 +0200
@@ -36,7 +36,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_powerpc.c,v 1.2 2002/05/15 09:56:40 obrien Exp $");
 
 #include <sys/param.h>
 
diff -Nur src.old/lib/libkvm/kvm_private.h src/lib/libkvm/kvm_private.h
--- src.old/lib/libkvm/kvm_private.h	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_private.h	2004-08-11 00:07:51.000000000 +0200
@@ -70,14 +70,12 @@
 /*
  * Functions used internally by kvm, but across kvm modules.
  */
-void	 _kvm_err(kvm_t *kd, const char *program, const char *fmt, ...)
-	    __printflike(3, 4);
+void	 _kvm_err(kvm_t *kd, const char *program, const char *fmt, ...);
 void	 _kvm_freeprocs(kvm_t *kd);
 void	 _kvm_freevtop(kvm_t *);
 int	 _kvm_initvtop(kvm_t *);
 int	 _kvm_kvatop(kvm_t *, u_long, u_long *);
 void	*_kvm_malloc(kvm_t *kd, size_t);
 void	*_kvm_realloc(kvm_t *kd, void *, size_t);
-void	 _kvm_syserr (kvm_t *kd, const char *program, const char *fmt, ...)
-	    __printflike(3, 4);
+void	 _kvm_syserr (kvm_t *kd, const char *program, const char *fmt, ...);
 int	 _kvm_uvatop(kvm_t *, const struct proc *, u_long, u_long *);
diff -Nur src.old/lib/libkvm/kvm_proc.c src/lib/libkvm/kvm_proc.c
--- src.old/lib/libkvm/kvm_proc.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_proc.c	2004-08-11 00:07:51.000000000 +0200
@@ -42,7 +42,6 @@
 #endif
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_proc.c,v 1.71 2003/09/27 08:12:41 tjr Exp $");
 
 /*
  * Proc traversal interface for kvm.  ps and w are (probably) the exclusive
@@ -54,7 +53,7 @@
 #include <sys/param.h>
 #define _WANT_UCRED	/* make ucred.h give us 'struct ucred' */
 #include <sys/ucred.h>
-#include <sys/user.h>
+#include "/usr/src/kfreebsd5-headers/sys/user.h"
 #include <sys/proc.h>
 #include <sys/exec.h>
 #include <sys/stat.h>
@@ -64,13 +63,12 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <nlist.h>
 #include <kvm.h>
 
 #include <vm/vm.h>
 #include <vm/vm_param.h>
 
-#include <sys/sysctl.h>
+#include "/usr/src/kfreebsd5-headers/sys/sysctl.h"
 
 #include <limits.h>
 #include <memory.h>
@@ -93,301 +91,7 @@
 	struct kinfo_proc *bp;
 	int maxcnt;
 {
-	int cnt = 0;
-	struct kinfo_proc kinfo_proc, *kp;
-	struct pgrp pgrp;
-	struct session sess;
-	struct tty tty;
-	struct vmspace vmspace;
-	struct sigacts sigacts;
-	struct pstats pstats;
-	struct ucred ucred;
-	struct thread mtd;
-	struct kse mke;
-	struct ksegrp mkg;
-	struct proc proc;
-	struct proc pproc;
-	struct timeval tv;
-
-	kp = &kinfo_proc;
-	kp->ki_structsize = sizeof(kinfo_proc);
-	for (; cnt < maxcnt && p != NULL; p = LIST_NEXT(&proc, p_list)) {
-		memset(kp, 0, sizeof *kp);
-		if (KREAD(kd, (u_long)p, &proc)) {
-			_kvm_err(kd, kd->program, "can't read proc at %x", p);
-			return (-1);
-		}
-		if (proc.p_state != PRS_ZOMBIE) {
-			if (KREAD(kd, (u_long)TAILQ_FIRST(&proc.p_threads),
-			    &mtd)) {
-				_kvm_err(kd, kd->program,
-				    "can't read thread at %x",
-				    TAILQ_FIRST(&proc.p_threads));
-				return (-1);
-			}
-			if (proc.p_flag & P_SA == 0) {
-				if (KREAD(kd,
-				    (u_long)TAILQ_FIRST(&proc.p_ksegrps),
-				    &mkg)) {
-					_kvm_err(kd, kd->program,
-					    "can't read ksegrp at %x",
-					    TAILQ_FIRST(&proc.p_ksegrps));
-					return (-1);
-				}
-				if (KREAD(kd,
-				    (u_long)TAILQ_FIRST(&mkg.kg_kseq), &mke)) {
-					_kvm_err(kd, kd->program,
-					    "can't read kse at %x",
-					    TAILQ_FIRST(&mkg.kg_kseq));
-					return (-1);
-				}
-			}
-		}
-		if (KREAD(kd, (u_long)proc.p_ucred, &ucred) == 0) {
-			kp->ki_ruid = ucred.cr_ruid;
-			kp->ki_svuid = ucred.cr_svuid;
-			kp->ki_rgid = ucred.cr_rgid;
-			kp->ki_svgid = ucred.cr_svgid;
-			kp->ki_ngroups = ucred.cr_ngroups;
-			bcopy(ucred.cr_groups, kp->ki_groups,
-			    NGROUPS * sizeof(gid_t));
-			kp->ki_uid = ucred.cr_uid;
-		}
-
-		switch(what) {
-
-		case KERN_PROC_PID:
-			if (proc.p_pid != (pid_t)arg)
-				continue;
-			break;
-
-		case KERN_PROC_UID:
-			if (kp->ki_uid != (uid_t)arg)
-				continue;
-			break;
-
-		case KERN_PROC_RUID:
-			if (kp->ki_ruid != (uid_t)arg)
-				continue;
-			break;
-		}
-		/*
-		 * We're going to add another proc to the set.  If this
-		 * will overflow the buffer, assume the reason is because
-		 * nprocs (or the proc list) is corrupt and declare an error.
-		 */
-		if (cnt >= maxcnt) {
-			_kvm_err(kd, kd->program, "nprocs corrupt");
-			return (-1);
-		}
-		/*
-		 * gather kinfo_proc
-		 */
-		kp->ki_paddr = p;
-		kp->ki_addr = proc.p_uarea;
-		/* kp->ki_kstack = proc.p_thread.td_kstack; XXXKSE */
-		kp->ki_args = proc.p_args;
-		kp->ki_tracep = proc.p_tracevp;
-		kp->ki_textvp = proc.p_textvp;
-		kp->ki_fd = proc.p_fd;
-		kp->ki_vmspace = proc.p_vmspace;
-		if (proc.p_sigacts != NULL) {
-			if (KREAD(kd, (u_long)proc.p_sigacts, &sigacts)) {
-				_kvm_err(kd, kd->program,
-				    "can't read sigacts at %x", proc.p_sigacts);
-				return (-1);
-			}
-			kp->ki_sigignore = sigacts.ps_sigignore;
-			kp->ki_sigcatch = sigacts.ps_sigcatch;
-		}
-		if ((proc.p_sflag & PS_INMEM) && proc.p_stats != NULL) {
-			if (KREAD(kd, (u_long)proc.p_stats, &pstats)) {
-				_kvm_err(kd, kd->program,
-				    "can't read stats at %x", proc.p_stats);
-				return (-1);
-			}
-			kp->ki_start = pstats.p_start;
-			kp->ki_rusage = pstats.p_ru;
-			kp->ki_childtime.tv_sec = pstats.p_cru.ru_utime.tv_sec +
-			    pstats.p_cru.ru_stime.tv_sec;
-			kp->ki_childtime.tv_usec =
-			    pstats.p_cru.ru_utime.tv_usec +
-			    pstats.p_cru.ru_stime.tv_usec;
-		}
-		if (proc.p_oppid)
-			kp->ki_ppid = proc.p_oppid;
-		else if (proc.p_pptr) {
-			if (KREAD(kd, (u_long)proc.p_pptr, &pproc)) {
-				_kvm_err(kd, kd->program,
-				    "can't read pproc at %x", proc.p_pptr);
-				return (-1);
-			}
-			kp->ki_ppid = pproc.p_pid;
-		} else 
-			kp->ki_ppid = 0;
-		if (proc.p_pgrp == NULL)
-			goto nopgrp;
-		if (KREAD(kd, (u_long)proc.p_pgrp, &pgrp)) {
-			_kvm_err(kd, kd->program, "can't read pgrp at %x",
-				 proc.p_pgrp);
-			return (-1);
-		}
-		kp->ki_pgid = pgrp.pg_id;
-		kp->ki_jobc = pgrp.pg_jobc;
-		if (KREAD(kd, (u_long)pgrp.pg_session, &sess)) {
-			_kvm_err(kd, kd->program, "can't read session at %x",
-				pgrp.pg_session);
-			return (-1);
-		}
-		kp->ki_sid = sess.s_sid;
-		(void)memcpy(kp->ki_login, sess.s_login,
-						sizeof(kp->ki_login));
-		kp->ki_kiflag = sess.s_ttyvp ? KI_CTTY : 0;
-		if (sess.s_leader == p)
-			kp->ki_kiflag |= KI_SLEADER;
-		if ((proc.p_flag & P_CONTROLT) && sess.s_ttyp != NULL) {
-			if (KREAD(kd, (u_long)sess.s_ttyp, &tty)) {
-				_kvm_err(kd, kd->program,
-					 "can't read tty at %x", sess.s_ttyp);
-				return (-1);
-			}
-			kp->ki_tdev = tty.t_dev;
-			if (tty.t_pgrp != NULL) {
-				if (KREAD(kd, (u_long)tty.t_pgrp, &pgrp)) {
-					_kvm_err(kd, kd->program,
-						 "can't read tpgrp at %x",
-						tty.t_pgrp);
-					return (-1);
-				}
-				kp->ki_tpgid = pgrp.pg_id;
-			} else
-				kp->ki_tpgid = -1;
-			if (tty.t_session != NULL) {
-				if (KREAD(kd, (u_long)tty.t_session, &sess)) {
-					_kvm_err(kd, kd->program,
-					    "can't read session at %x",
-					    tty.t_session);
-					return (-1);
-				}
-				kp->ki_tsid = sess.s_sid;
-			}
-		} else {
-nopgrp:
-			kp->ki_tdev = NODEV;
-		}
-		if ((proc.p_state != PRS_ZOMBIE) && mtd.td_wmesg)
-			(void)kvm_read(kd, (u_long)mtd.td_wmesg,
-			    kp->ki_wmesg, WMESGLEN);
-
-#ifdef sparc
-		(void)kvm_read(kd, (u_long)&proc.p_vmspace->vm_rssize,
-		    (char *)&kp->ki_rssize,
-		    sizeof(kp->ki_rssize));
-		(void)kvm_read(kd, (u_long)&proc.p_vmspace->vm_tsize,
-		    (char *)&kp->ki_tsize,
-		    3 * sizeof(kp->ki_rssize));	/* XXX */
-#else
-		(void)kvm_read(kd, (u_long)proc.p_vmspace,
-		    (char *)&vmspace, sizeof(vmspace));
-		kp->ki_size = vmspace.vm_map.size;
-		kp->ki_rssize = vmspace.vm_swrss; /* XXX */
-		kp->ki_swrss = vmspace.vm_swrss;
-		kp->ki_tsize = vmspace.vm_tsize;
-		kp->ki_dsize = vmspace.vm_dsize;
-		kp->ki_ssize = vmspace.vm_ssize;
-#endif
-
-		switch (what) {
-
-		case KERN_PROC_PGRP:
-			if (kp->ki_pgid != (pid_t)arg)
-				continue;
-			break;
-
-		case KERN_PROC_TTY:
-			if ((proc.p_flag & P_CONTROLT) == 0 ||
-			     kp->ki_tdev != (dev_t)arg)
-				continue;
-			break;
-		}
-		if (proc.p_comm[0] != 0) {
-			strncpy(kp->ki_comm, proc.p_comm, MAXCOMLEN);
-			kp->ki_comm[MAXCOMLEN] = 0;
-		}
-		if ((proc.p_state != PRS_ZOMBIE) &&
-		    (mtd.td_blocked != 0)) {
-			kp->ki_kiflag |= KI_LOCKBLOCK;
-			if (mtd.td_lockname)
-				(void)kvm_read(kd,
-				    (u_long)mtd.td_lockname,
-				    kp->ki_lockname, LOCKNAMELEN);
-			kp->ki_lockname[LOCKNAMELEN] = 0;
-		}
-		bintime2timeval(&proc.p_runtime, &tv);
-		kp->ki_runtime = (u_int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
-		kp->ki_pid = proc.p_pid;
-		kp->ki_siglist = proc.p_siglist;
-		SIGSETOR(kp->ki_siglist, mtd.td_siglist);
-		kp->ki_sigmask = mtd.td_sigmask;
-		kp->ki_xstat = proc.p_xstat;
-		kp->ki_acflag = proc.p_acflag;
-		kp->ki_lock = proc.p_lock;
-		if (proc.p_state != PRS_ZOMBIE) {
-			kp->ki_swtime = proc.p_swtime;
-			kp->ki_flag = proc.p_flag;
-			kp->ki_sflag = proc.p_sflag;
-			kp->ki_traceflag = proc.p_traceflag;
-			if (proc.p_state == PRS_NORMAL) { 
-				if (TD_ON_RUNQ(&mtd) ||
-				    TD_CAN_RUN(&mtd) ||
-				    TD_IS_RUNNING(&mtd)) {
-					kp->ki_stat = SRUN;
-				} else if (mtd.td_state == 
-				    TDS_INHIBITED) {
-					if (P_SHOULDSTOP(&proc)) {
-						kp->ki_stat = SSTOP;
-					} else if (
-					    TD_IS_SLEEPING(&mtd)) {
-						kp->ki_stat = SSLEEP;
-					} else if (TD_ON_LOCK(&mtd)) {
-						kp->ki_stat = SLOCK;
-					} else {
-						kp->ki_stat = SWAIT;
-					}
-				}
-			} else {
-				kp->ki_stat = SIDL;
-			}
-			/* Stuff from the thread */
-			kp->ki_pri.pri_level = mtd.td_priority;
-			kp->ki_pri.pri_native = mtd.td_base_pri;
-			kp->ki_lastcpu = mtd.td_lastcpu;
-			kp->ki_wchan = mtd.td_wchan;
-			kp->ki_oncpu = mtd.td_oncpu;
-
-			if (!(proc.p_flag & P_SA)) {
-				/* stuff from the ksegrp */
-				kp->ki_slptime = mkg.kg_slptime;
-				kp->ki_pri.pri_class = mkg.kg_pri_class;
-				kp->ki_pri.pri_user = mkg.kg_user_pri;
-				kp->ki_nice = mkg.kg_nice;
-				kp->ki_estcpu = mkg.kg_estcpu;
-
-				/* Stuff from the kse */
-				kp->ki_pctcpu = mke.ke_pctcpu;
-				kp->ki_rqindex = mke.ke_rqindex;
-			} else {
-				kp->ki_tdflags = -1;
-				/* All the rest are 0 for now */
-			}
-		} else {
-			kp->ki_stat = SZOMB;
-		}
-		bcopy(&kinfo_proc, bp, sizeof(kinfo_proc));
-		++bp;
-		++cnt;
-	}
-	return (cnt);
+	return -1;
 }
 
 /*
@@ -503,36 +207,6 @@
 		}
 liveout:
 		nprocs = size == 0 ? 0 : size / kd->procbase->ki_structsize;
-	} else {
-		struct nlist nl[4], *p;
-
-		nl[0].n_name = "_nprocs";
-		nl[1].n_name = "_allproc";
-		nl[2].n_name = "_zombproc";
-		nl[3].n_name = 0;
-
-		if (kvm_nlist(kd, nl) != 0) {
-			for (p = nl; p->n_type != 0; ++p)
-				;
-			_kvm_err(kd, kd->program,
-				 "%s: no such symbol", p->n_name);
-			return (0);
-		}
-		if (KREAD(kd, nl[0].n_value, &nprocs)) {
-			_kvm_err(kd, kd->program, "can't read nprocs");
-			return (0);
-		}
-		size = nprocs * sizeof(struct kinfo_proc);
-		kd->procbase = (struct kinfo_proc *)_kvm_malloc(kd, size);
-		if (kd->procbase == 0)
-			return (0);
-
-		nprocs = kvm_deadprocs(kd, op, arg, nl[1].n_value,
-				      nl[2].n_value, nprocs);
-#ifdef notdef
-		size = nprocs * sizeof(struct kinfo_proc);
-		(void)realloc(kd->procbase, size);
-#endif
 	}
 	*cnt = nprocs;
 	return (kd->procbase);
diff -Nur src.old/lib/libkvm/kvm_sparc.c src/lib/libkvm/kvm_sparc.c
--- src.old/lib/libkvm/kvm_sparc.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_sparc.c	2004-08-11 00:07:51.000000000 +0200
@@ -36,7 +36,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_sparc.c,v 1.5 2002/03/21 23:38:09 obrien Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
diff -Nur src.old/lib/libkvm/kvm_sparc64.c src/lib/libkvm/kvm_sparc64.c
--- src.old/lib/libkvm/kvm_sparc64.c	2004-08-11 00:07:46.000000000 +0200
+++ src/lib/libkvm/kvm_sparc64.c	2004-08-11 00:07:51.000000000 +0200
@@ -38,7 +38,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libkvm/kvm_sparc64.c,v 1.6 2002/12/27 01:45:05 jake Exp $");
 
 #if defined(LIBC_SCCS) && !defined(lint)
 #if 0
diff -Nur src.old/lib/libkvm/strlcpy.c src/lib/libkvm/strlcpy.c
--- src.old/lib/libkvm/strlcpy.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/libkvm/strlcpy.c	2004-08-11 00:07:51.000000000 +0200
@@ -0,0 +1,66 @@
+/*	$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <string.h>
+
+/*
+ * Copy src to string dst of size siz.  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns strlen(src); if retval >= siz, truncation occurred.
+ */
+size_t strlcpy(dst, src, siz)
+	char *dst;
+	const char *src;
+	size_t siz;
+{
+	char *d = dst;
+	const char *s = src;
+	size_t n = siz;
+
+	/* Copy as many bytes as will fit */
+	if (n != 0 && --n != 0) {
+		do {
+			if ((*d++ = *s++) == 0)
+				break;
+		} while (--n != 0);
+	}
+
+	/* Not enough room in dst, add NUL and traverse rest of src */
+	if (n == 0) {
+		if (siz != 0)
+			*d = '\0';		/* NUL-terminate dst */
+		while (*s++)
+			;
+	}
+
+	return(s - src - 1);	/* count does not include NUL */
+}
