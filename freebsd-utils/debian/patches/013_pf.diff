---
 contrib/pf/authpf/authpf.c        |   31 +-
 contrib/pf/ftp-proxy/ftp-proxy.c  |   12 
 contrib/pf/libevent/kqueue.c      |    2 
 contrib/pf/pfctl/parse.y          |   15 -
 contrib/pf/pfctl/pf_print_state.c |   18 +
 contrib/pf/pfctl/pfctl.c          |    8 
 contrib/pf/pfctl/pfctl.h          |    8 
 contrib/pf/pfctl/pfctl_altq.c     |   12 
 contrib/pf/pfctl/pfctl_optimize.c |    2 
 contrib/pf/pfctl/pfctl_parser.c   |   29 +-
 contrib/pf/pfctl/pfctl_parser.h   |    2 
 contrib/pf/pfctl/pfctl_qstats.c   |   10 
 contrib/pf/pflogd/pflogd.c        |   25 -
 contrib/pf/pflogd/pidfile.c       |    2 
 contrib/pf/pflogd/privsep.c       |    6 
 contrib/pf/tftp-proxy/filter.c    |    2 
 sbin/pfctl/Makefile               |    2 
 sbin/pfctl/pf_ruleset.c           |  512 ++++++++++++++++++++++++++++++++++++++
 usr.sbin/authpf/Makefile          |    2 
 19 files changed, 628 insertions(+), 72 deletions(-)

--- a/contrib/pf/authpf/authpf.c
+++ b/contrib/pf/authpf/authpf.c
@@ -33,10 +33,11 @@ __FBSDID("$FreeBSD$");
 
 #include <err.h>
 #include <errno.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <inttypes.h>
 #endif
-#include <login_cap.h>
+//#include <login_cap.h>
+#include <bsd/string.h>
 #include <pwd.h>
 #include <signal.h>
 #include <stdio.h>
@@ -70,10 +71,10 @@ struct timeval	Tstart, Tend;	/* start an
 
 volatile sig_atomic_t	want_death;
 static void		need_death(int signo);
-#ifdef __FreeBSD__
-static __dead2 void	do_death(int);
+#ifdef __FreeBSD_kernel__
+static void	do_death(int);
 #else
-static __dead void	do_death(int);
+static void	do_death(int);
 #endif
 
 /*
@@ -93,8 +94,9 @@ main(int argc, char *argv[])
 	gid_t		 gid;
 	uid_t		 uid;
 	char		*shell;
+#if 0
 	login_cap_t	*lc;
-
+#endif
 	config = fopen(PATH_CONFFILE, "r");
 	if (config == NULL) {
 		syslog(LOG_ERR, "can not open %s (%m)", PATH_CONFFILE);
@@ -140,15 +142,16 @@ main(int argc, char *argv[])
 		syslog(LOG_ERR, "cannot find user for uid %u", uid);
 		goto die;
 	}
-
+#if 0
 	if ((lc = login_getclass(pw->pw_class)) != NULL)
 		shell = (char *)login_getcapstr(lc, "shell", pw->pw_shell,
 		    pw->pw_shell);
 	else
+#endif
 		shell = pw->pw_shell;
-
+#if 0
 	login_close(lc);
-
+#endif
 	if (strcmp(shell, PATH_AUTHPF_SHELL)) {
 		syslog(LOG_ERR, "wrong shell for user %s, uid %u",
 		    pw->pw_name, pw->pw_uid);
@@ -318,7 +321,9 @@ main(int argc, char *argv[])
 	while (1) {
 		printf("\r\nHello %s. ", luser);
 		printf("You are authenticated from host \"%s\"\r\n", ipsrc);
+#if 0
 		setproctitle("%s@%s", luser, ipsrc);
+#endif
 		print_message(PATH_MESSAGE);
 		while (1) {
 			sleep(10);
@@ -716,7 +721,7 @@ change_filter(int add, const char *luser
 		syslog(LOG_INFO, "allowing %s, user %s", ipsrc, luser);
 	} else {
 		gettimeofday(&Tend, NULL);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		syslog(LOG_INFO, "removed %s, user %s - duration %jd seconds",
 		    ipsrc, luser, (intmax_t)(Tend.tv_sec - Tstart.tv_sec));
 #else
@@ -829,10 +834,10 @@ need_death(int signo)
 /*
  * function that removes our stuff when we go away.
  */
-#ifdef __FreeBSD__
-static __dead2 void
+#ifdef __FreeBSD_kernel__
+static void
 #else
-static __dead void
+static void
 #endif
 do_death(int active)
 {
--- a/contrib/pf/ftp-proxy/ftp-proxy.c
+++ b/contrib/pf/ftp-proxy/ftp-proxy.c
@@ -95,7 +95,7 @@ void	client_read(struct bufferevent *, v
 int	drop_privs(void);
 void	end_session(struct session *);
 int	exit_daemon(void);
-int	getline(char *, size_t *);
+int	bsd_getline(char *, size_t *);
 void	handle_connection(const int, short, void *);
 void	handle_signal(int, short, void *);
 struct session * init_session(void);
@@ -229,7 +229,7 @@ client_read(struct bufferevent *bufev, v
 		    buf_avail);
 		s->cbuf_valid += read;
 
-		while ((n = getline(s->cbuf, &s->cbuf_valid)) > 0) {
+		while ((n = bsd_getline(s->cbuf, &s->cbuf_valid)) > 0) {
 			logmsg(LOG_DEBUG, "#%d client: %s", s->id, linebuf);
 			if (!client_parse(s)) {
 				end_session(s);
@@ -305,7 +305,7 @@ exit_daemon(void)
 {
 	struct session *s, *next;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	LIST_FOREACH_SAFE(s, &sessions, entry, next) {
 #else
 	for (s = LIST_FIRST(&sessions); s != LIST_END(&sessions); s = next) {
@@ -324,7 +324,7 @@ exit_daemon(void)
 }
 
 int
-getline(char *buf, size_t *valid)
+bsd_getline(char *buf, size_t *valid)
 {
 	size_t i;
 
@@ -566,7 +566,7 @@ logmsg(int pri, const char *message, ...
 
 		/* We don't care about truncation. */
 		vsnprintf(buf, sizeof buf, message, ap);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/* XXX: strnvis might be nice to have */
 		strvisx(visbuf, buf,
 		    MIN((sizeof(visbuf) / 4) - 1, strlen(buf)),
@@ -1053,7 +1053,7 @@ server_read(struct bufferevent *bufev, v
 		    buf_avail);
 		s->sbuf_valid += read;
 
-		while ((n = getline(s->sbuf, &s->sbuf_valid)) > 0) {
+		while ((n = bsd_getline(s->sbuf, &s->sbuf_valid)) > 0) {
 			logmsg(LOG_DEBUG, "#%d server: %s", s->id, linebuf);
 			if (!server_parse(s)) {
 				end_session(s);
--- a/contrib/pf/libevent/kqueue.c
+++ b/contrib/pf/libevent/kqueue.c
@@ -48,7 +48,7 @@
 #include <inttypes.h>
 #endif
 
-#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD_kernel__)
 #define INTPTR(x)	(intptr_t)x
 #else
 #define INTPTR(x)	x
--- a/contrib/pf/pfctl/parse.y
+++ b/contrib/pf/pfctl/parse.y
@@ -57,12 +57,12 @@ __FBSDID("$FreeBSD$");
 #include <limits.h>
 #include <pwd.h>
 #include <grp.h>
-#include <md5.h>
+#include <bsd/md5.h>
 
 #include "pfctl_parser.h"
 #include "pfctl.h"
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	HTONL(x)	(x) = htonl((__uint32_t)(x))
 #endif
 
@@ -402,6 +402,7 @@ typedef struct {
 	} v;
 	int lineno;
 } YYSTYPE;
+#define YYSTYPE_IS_DECLARED 1
 
 #define DYNIF_MULTIADDR(addr) ((addr).type == PF_ADDR_DYNIFTL && \
 	(!((addr).iflags & PFI_AFLAG_NOALIAS) ||		 \
@@ -1027,7 +1028,7 @@ scrub_opt	: NODF	{
 			scrub_opts.randomid = 1;
 		}
 		| RTABLE number				{
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 			if ($2 > RT_TABLEID_MAX || $2 < 0) {
 				yyerror("invalid rtable id");
 				YYERROR;
@@ -1172,7 +1173,7 @@ antispoof_opt	: label	{
 			antispoof_opts.label = $1;
 		}
 		| RTABLE number				{
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 			if ($2 > RT_TABLEID_MAX || $2 < 0) {
 				yyerror("invalid rtable id");
 				YYERROR;
@@ -2155,7 +2156,7 @@ filter_opt	: USER uids {
 			free($2);
 		}
 		| RTABLE number				{
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 			if ($2 > RT_TABLEID_MAX || $2 < 0) {
 				yyerror("invalid rtable id");
 				YYERROR;
@@ -3468,7 +3469,7 @@ redirection	: /* empty */			{ $$ = NULL;
 		}
 		;
 
-/* ifdef __FreeBSD__ */
+/* ifdef __FreeBSD_kernel__ */
 natpass		: /* empty */	{ $$.b1 = $$.b2 = 0; $$.w2 = 0; }
 		| PASS		{ $$.b1 = 1; $$.b2 = 0; $$.w2 = 0; }
 /* else 
@@ -3842,7 +3843,7 @@ tagged		: /* empty */		{ $$.neg = 0; $$.
 
 rtable		: /* empty */		{ $$ = -1; }
 		| RTABLE number		{
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			yyerror("rtable id not supported in FreeBSD, yet");
 			YYERROR;
 #else
--- a/contrib/pf/pfctl/pfctl_altq.c
+++ b/contrib/pf/pfctl/pfctl_altq.c
@@ -77,7 +77,7 @@ static int		 gsc_add_seg(struct gen_sc *
 			     double);
 static double		 sc_x2y(struct service_curve *, double);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 u_int32_t	 getifspeed(int, char *);
 #else
 u_int32_t	 getifspeed(char *);
@@ -153,7 +153,7 @@ print_altq(const struct pf_altq *a, unsi
 		return;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->local_flags & PFALTQ_FLAG_IF_REMOVED)
 		printf("INACTIVE ");
 #endif
@@ -191,7 +191,7 @@ print_queue(const struct pf_altq *a, uns
 {
 	unsigned	i;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->local_flags & PFALTQ_FLAG_IF_REMOVED)
 		printf("INACTIVE ");
 #endif
@@ -237,7 +237,7 @@ eval_pfaltq(struct pfctl *pf, struct pf_
 	if (bw->bw_absolute > 0)
 		pa->ifbandwidth = bw->bw_absolute;
 	else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((rate = getifspeed(pf->dev, pa->ifname)) == 0) {
 #else
 		if ((rate = getifspeed(pa->ifname)) == 0) {
@@ -1096,7 +1096,7 @@ rate2str(double rate)
 	return (buf);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /*
  * XXX
  * FreeBSD does not have SIOCGIFDATA.
@@ -1153,7 +1153,7 @@ getifmtu(char *ifname)
 	    sizeof(ifr.ifr_name))
 		errx(1, "getifmtu: strlcpy");
 	if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == -1)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		ifr.ifr_mtu = 1500;
 #else
 		err(1, "SIOCGIFMTU");
--- a/contrib/pf/pfctl/pfctl.c
+++ b/contrib/pf/pfctl/pfctl.c
@@ -59,7 +59,7 @@ __FBSDID("$FreeBSD$");
 #include "pfctl_parser.h"
 #include "pfctl.h"
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define HTONL(x)	(x) = htonl((__uint32_t)(x))
 #endif
 
@@ -250,7 +250,7 @@ pfctl_enable(int dev, int opts)
 	if (ioctl(dev, DIOCSTART)) {
 		if (errno == EEXIST)
 			errx(1, "pf already enabled");
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (errno == ESRCH)
 			errx(1, "pfil registeration failed");
 #endif
@@ -1895,7 +1895,7 @@ pfctl_debug(int dev, u_int32_t level, in
 int
 pfctl_test_altqsupport(int dev, int opts)
 {
-#if defined(__FreeBSD__) && !defined(ENABLE_ALTQ)
+#if defined(__FreeBSD_kernel__) && !defined(ENABLE_ALTQ)
 	return (0);
 #else
 	struct pfioc_altq pa;
@@ -2171,7 +2171,7 @@ main(int argc, char *argv[])
 		/* turn off options */
 		opts &= ~ (PF_OPT_DISABLE | PF_OPT_ENABLE);
 		clearopt = showopt = debugopt = NULL;
-#if defined(__FreeBSD__) && !defined(ENABLE_ALTQ)
+#if defined(__FreeBSD_kernel__) && !defined(ENABLE_ALTQ)
 		altqsupport = 0;
 #else
 		altqsupport = 1;
--- a/contrib/pf/pfctl/pfctl.h
+++ b/contrib/pf/pfctl/pfctl.h
@@ -36,6 +36,12 @@
 
 enum pfctl_show { PFCTL_SHOW_RULES, PFCTL_SHOW_LABELS, PFCTL_SHOW_NOTHING };
 
+#include <bsd/string.h>
+#include <bsd/stdlib.h>
+#define __BSD_VISIBLE 1
+#define __XSI_VISIBLE 1
+#include <sys/limits.h>
+
 enum {	PFRB_TABLES = 1, PFRB_TSTATS, PFRB_ADDRS, PFRB_ASTATS,
 	PFRB_IFACES, PFRB_TRANS, PFRB_MAX };
 struct pfr_buffer {
@@ -89,7 +95,7 @@ void	 warn_namespace_collision(const cha
 int	 pfctl_show_ifaces(const char *, int);
 FILE	*pfctl_fopen(const char *, const char *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 extern int altqsupport;
 #endif
 
--- a/contrib/pf/pfctl/pfctl_optimize.c
+++ b/contrib/pf/pfctl/pfctl_optimize.c
@@ -860,7 +860,7 @@ block_feedback(struct pfctl *pf, struct
 				break;
 			}
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (por2 == NULL)
 #else
 		if (por2 == TAILQ_END(&block->sb_rules))
--- a/contrib/pf/pfctl/pfctl_parser.c
+++ b/contrib/pf/pfctl/pfctl_parser.c
@@ -43,7 +43,7 @@ __FBSDID("$FreeBSD$");
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
-#include <netinet/ip_icmp.h>
+//#include <netinet/ip_icmp.h>
 #include <netinet/icmp6.h>
 #include <net/pfvar.h>
 #include <arpa/inet.h>
@@ -60,6 +60,29 @@ __FBSDID("$FreeBSD$");
 #include <ifaddrs.h>
 #include <unistd.h>
 
+#include <bsd/ip_icmp.h>
+#include <bsd/bsd.h>
+
+/* RFC2292 decls */
+#define ICMP6_MEMBERSHIP_QUERY          130     /* group membership query */
+#define ICMP6_MEMBERSHIP_REPORT         131     /* group membership report */
+#define ICMP6_MEMBERSHIP_REDUCTION      132     /* group membership termination */
+#define ICMP6_DST_UNREACH_NOTNEIGHBOR 2 /* not a neighbor(obsolete) */
+#define MLD_LISTENER_QUERY              130     /* multicast listener query */
+#define MLD_LISTENER_REPORT             131     /* multicast listener report */
+#define MLD_LISTENER_DONE               132     /* multicast listener done */
+#define ICMP6_ROUTER_RENUMBERING        138     /* router renumbering */
+#define ICMP6_WRUREQUEST                139     /* who are you request */
+#define ICMP6_WRUREPLY                  140     /* who are you reply */
+#define ICMP6_FQDN_QUERY                139     /* FQDN query */
+#define ICMP6_FQDN_REPLY                140     /* FQDN reply */
+#define ICMP6_NI_QUERY                  139     /* node information request */
+#define ICMP6_NI_REPLY                  140     /* node information reply */
+#define MLD_MTRACE_RESP                 200     /* mtrace resp (to sender) */
+#define MLD_MTRACE                      201     /* mtrace messages */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE   2       /* beyond scope of source address */
+#define ND_REDIRECT_ONLINK      0       /* redirect to an on-link node */
+#define ND_REDIRECT_ROUTER      1       /* redirect to a better router */
 #include "pfctl_parser.h"
 #include "pfctl.h"
 
@@ -598,7 +621,7 @@ print_status(struct pf_status *s, int op
 		printf("Limit Counters\n");
 		for (i = 0; i < LCNT_MAX; i++) {
 			printf("  %-25s %14lld ", pf_lcounters[i],
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    (unsigned long long)s->lcounters[i]);
 #else
 				    s->lcounters[i]);
@@ -647,7 +670,7 @@ print_src_node(struct pf_src_node *sn, i
 			    sn->expire, min, sec);
 		}
 		printf(", %llu pkts, %llu bytes",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)(sn->packets[0] + sn->packets[1]),
 		    (unsigned long long)(sn->bytes[0] + sn->bytes[1]));
 #else
--- a/contrib/pf/pfctl/pfctl_parser.h
+++ b/contrib/pf/pfctl/pfctl_parser.h
@@ -158,7 +158,7 @@ struct node_queue_opt {
 	}			 data;
 };
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /*
  * XXX
  * Absolutely this is not correct location to define this.
--- a/contrib/pf/pfctl/pfctl_qstats.c
+++ b/contrib/pf/pfctl/pfctl_qstats.c
@@ -89,7 +89,7 @@ pfctl_show_altq(int dev, const char *ifa
 	struct pf_altq_node	*root = NULL, *node;
 	int			 nodes, dotitle = (opts & PF_OPT_SHOWALL);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!altqsupport)
 		return (-1);
 #endif
@@ -118,7 +118,7 @@ pfctl_show_altq(int dev, const char *ifa
 		for (node = root; node != NULL; node = node->next) {
 			if (iface != NULL && strcmp(node->altq.ifname, iface))
 				continue;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (node->altq.local_flags & PFALTQ_FLAG_IF_REMOVED)
 				continue;
 #endif
@@ -161,7 +161,7 @@ pfctl_update_qstats(int dev, struct pf_a
 			warn("DIOCGETALTQ");
 			return (-1);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pa.altq.qid > 0 &&
 		    !(pa.altq.local_flags & PFALTQ_FLAG_IF_REMOVED)) {
 #else
@@ -184,7 +184,7 @@ pfctl_update_qstats(int dev, struct pf_a
 				pfctl_insert_altq_node(root, pa.altq, qstats);
 			}
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		  else if (pa.altq.local_flags & PFALTQ_FLAG_IF_REMOVED) {
 		  	memset(&qstats.data, 0, sizeof(qstats.data));
 			if ((node = pfctl_find_altq_node(*root, pa.altq.qname,
@@ -302,7 +302,7 @@ pfctl_print_altq_nodestat(int dev, const
 {
 	if (a->altq.qid == 0)
 		return;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->altq.local_flags & PFALTQ_FLAG_IF_REMOVED)
 		return;
 #endif
--- a/contrib/pf/pfctl/pf_print_state.c
+++ b/contrib/pf/pfctl/pf_print_state.c
@@ -35,7 +35,21 @@ __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
 #include <sys/socket.h>
+
+#ifdef __GLIBC__
+#include <stdint.h>
+#include <endian.h>
+#include <byteswap.h>
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+# define be64toh(x) bswap_64(x)
+# elif __BYTE_ORDER == __BIG_ENDIAN
+# define be64toh(x) ((uint64_t)(x))
+# else
+# error Unknown endian
+# endif
+#else
 #include <sys/endian.h>
+#endif
 #include <net/if.h>
 #define TCPSTATES
 #include <netinet/tcp_fsm.h>
@@ -282,7 +296,7 @@ print_state(struct pf_state *s, int opts
 		s->expire /= 60;
 		printf(", expires in %.2u:%.2u:%.2u", s->expire, min, sec);
 		printf(", %llu:%llu pkts, %llu:%llu bytes",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)s->packets[0],
 		    (unsigned long long)s->packets[1],
 		    (unsigned long long)s->bytes[0],
@@ -304,7 +318,7 @@ print_state(struct pf_state *s, int opts
 	}
 	if (opts & PF_OPT_VERBOSE2) {
 		printf("   id: %016llx creatorid: %08x%s\n",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)be64toh(s->id), ntohl(s->creatorid),
 #else
 		    betoh64(s->id), ntohl(s->creatorid),
--- a/contrib/pf/pflogd/pflogd.c
+++ b/contrib/pf/pflogd/pflogd.c
@@ -37,7 +37,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/ioctl.h>
 #include <sys/file.h>
 #include <sys/stat.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/bpf.h>	/* BIOCLOCK */
 #endif
 #include <stdio.h>
@@ -51,7 +51,7 @@ __FBSDID("$FreeBSD$");
 #include <errno.h>
 #include <stdarg.h>
 #include <fcntl.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "pidfile.h"
 #else
 #include <util.h>
@@ -158,11 +158,6 @@ logmsg(int pri, const char *message, ...
 	va_end(ap);
 }
 
-#ifdef __FreeBSD__
-__dead2 void
-#else
-__dead void
-#endif
 usage(void)
 {
 	fprintf(stderr, "usage: pflogd [-Dx] [-d delay] [-f filename]");
@@ -352,7 +347,7 @@ int
 scan_dump(FILE *fp, off_t size)
 {
 	struct pcap_file_header hdr;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr ph;
 #else
 	struct pcap_pkthdr ph;
@@ -425,7 +420,7 @@ void
 dump_packet_nobuf(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 {
 	FILE *f = (FILE *)user;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr sh;
 #endif
 
@@ -434,7 +429,7 @@ dump_packet_nobuf(u_char *user, const st
 		return;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sh.ts.tv_sec = (bpf_int32)h->ts.tv_sec;
 	sh.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
 	sh.caplen = h->caplen;
@@ -447,7 +442,7 @@ dump_packet_nobuf(u_char *user, const st
 		off_t pos = ftello(f);
 
 		/* try to undo header to prevent corruption */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pos < sizeof(sh) ||
 		    ftruncate(fileno(f), pos - sizeof(sh))) {
 #else
@@ -522,7 +517,7 @@ void
 dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 {
 	FILE *f = (FILE *)user;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr sh;
 	size_t len = sizeof(sh) + h->caplen;
 #else
@@ -555,7 +550,7 @@ dump_packet(u_char *user, const struct p
 	}
 
  append:	
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
  	sh.ts.tv_sec = (bpf_int32)h->ts.tv_sec;
  	sh.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
 	sh.caplen = h->caplen;
@@ -583,7 +578,7 @@ main(int argc, char **argv)
 	pcap_handler phandler = dump_packet;
 	const char *errstr = NULL;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* another ?paranoid? safety measure we do not have */
 #else
 	closefrom(STDERR_FILENO + 1);
@@ -690,7 +685,7 @@ main(int argc, char **argv)
 		np = pcap_dispatch(hpcap, PCAP_NUM_PKTS,
 		    phandler, (u_char *)dpcap);
 		if (np < 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (errno == ENXIO) {
 				logmsg(LOG_ERR,
 				    "Device not/no longer configured");
--- a/contrib/pf/pflogd/pidfile.c
+++ b/contrib/pf/pflogd/pidfile.c
@@ -48,7 +48,7 @@ static const char rcsid[] = "$OpenBSD: p
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "pidfile.h"
 #else
 #include <util.h>
--- a/contrib/pf/pflogd/privsep.c
+++ b/contrib/pf/pflogd/privsep.c
@@ -31,7 +31,7 @@ __FBSDID("$FreeBSD$");
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <pcap.h>
 #include <pcap-int.h>
 #endif
@@ -40,7 +40,7 @@ __FBSDID("$FreeBSD$");
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /* XXX: pcap pollutes namespace with strlcpy if not present previously */
 #include <pcap.h>
 #include <pcap-int.h>
@@ -79,7 +79,7 @@ priv_init(void)
 	int snaplen, ret, olderrno;
 	struct passwd *pw;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	for (i = 1; i < NSIG; i++)
 #else
 	for (i = 1; i < _NSIG; i++)
--- a/contrib/pf/tftp-proxy/filter.c
+++ b/contrib/pf/tftp-proxy/filter.c
@@ -298,7 +298,7 @@ prepare_rule(u_int32_t id, int rs_num, s
 		pfr.rule.quick = 1;
 		pfr.rule.log = rule_log;
 		pfr.rule.keep_state = 1;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pfr.rule.flags = (proto == IPPROTO_TCP ? TH_SYN : 0);
 		pfr.rule.flagset = (proto == IPPROTO_TCP ?
 		    (TH_SYN|TH_ACK|TH_FIN|TH_RST) : 0);
--- /dev/null
+++ b/sbin/pfctl/pf_ruleset.c
@@ -0,0 +1,512 @@
+
+/*  This is a (temp) hack,
+
+    this file is concatenation of file
+
+    src/lib/libc/stdlib/strtonum.c
+    src/sys/contrib/pf/net/pf_ruleset.c
+
+ */
+
+
+/*-
+ * Copyright (c) 2004 Ted Unangst and Todd Miller
+ * All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *      $OpenBSD: strtonum.c,v 1.6 2004/08/03 19:38:01 millert Exp $
+ */
+
+#include <sys/cdefs.h>
+/* __FBSDID("$FreeBSD: src/lib/libc/stdlib/strtonum.c,v 1.2 2006/03/14 19:53:03 ache Exp $"); */
+
+
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#define INVALID         1
+#define TOOSMALL        2
+#define TOOLARGE        3
+
+long long
+strtonum(const char *numstr, long long minval, long long maxval,
+    const char **errstrp)
+{
+        long long ll = 0;
+        char *ep;
+        int error = 0;
+        struct errval {
+                const char *errstr;
+                int err;
+        } ev[4] = {
+                { NULL,         0 },
+                { "invalid",    EINVAL },
+                { "too small",  ERANGE },
+                { "too large",  ERANGE },
+        };
+
+        ev[0].err = errno;
+        errno = 0;
+        if (minval > maxval)
+                error = INVALID;
+        else {
+                ll = strtoll(numstr, &ep, 10);
+                if (errno == EINVAL || numstr == ep || *ep != '\0')
+                        error = INVALID;
+                else if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)
+                        error = TOOSMALL;
+                else if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)
+                        error = TOOLARGE;
+        }
+        if (errstrp != NULL)
+                *errstrp = ev[error].errstr;
+        errno = ev[error].err;
+        if (error)
+                ll = 0;
+
+        return (ll);
+}
+
+
+
+
+/*	$OpenBSD: pf_ruleset.c,v 1.1 2006/10/27 13:56:51 mcbride Exp $ */
+
+/*
+ * Copyright (c) 2001 Daniel Hartmeier
+ * Copyright (c) 2002,2003 Henning Brauer
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *    - Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    - Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Effort sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F30602-01-2-0537.
+ *
+ */
+
+
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <bsd/string.h>
+#ifdef _KERNEL
+# include <sys/systm.h>
+#endif /* _KERNEL */
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/tcp.h>
+
+#include <net/if.h>
+#include <net/pfvar.h>
+
+#ifdef INET6
+#include <netinet/ip6.h>
+#endif /* INET6 */
+
+
+#ifdef _KERNEL
+# define DPFPRINTF(format, x...)		\
+	if (pf_status.debug >= PF_DEBUG_NOISY)	\
+		printf(format , ##x)
+#ifdef __FreeBSD_kernel__
+#define rs_malloc(x)		malloc(x, M_TEMP, M_NOWAIT)
+#else
+#define rs_malloc(x)		malloc(x, M_TEMP, M_WAITOK)
+#endif
+#define rs_free(x)		free(x, M_TEMP)
+
+#else
+/* Userland equivalents so we can lend code to pfctl et al. */
+
+# include <arpa/inet.h>
+# include <errno.h>
+# include <stdio.h>
+# include <stdlib.h>
+# include <string.h>
+# define rs_malloc(x)		 malloc(x)
+# define rs_free(x)		 free(x)
+
+# ifdef PFDEBUG
+#  include <sys/stdarg.h>
+#  define DPFPRINTF(format, x...)	fprintf(stderr, format , ##x)
+# else
+#  define DPFPRINTF(format, x...)	((void)0)
+# endif /* PFDEBUG */
+#endif /* _KERNEL */
+
+
+struct pf_anchor_global	 pf_anchors;
+struct pf_anchor	 pf_main_anchor;
+
+#ifndef __FreeBSD_kernel__
+/* XXX: hum? */
+int			 pf_get_ruleset_number(u_int8_t);
+void			 pf_init_ruleset(struct pf_ruleset *);
+int			 pf_anchor_setup(struct pf_rule *,
+			    const struct pf_ruleset *, const char *);
+int			 pf_anchor_copyout(const struct pf_ruleset *,
+			    const struct pf_rule *, struct pfioc_rule *);
+void			 pf_anchor_remove(struct pf_rule *);
+#endif
+
+static __inline int pf_anchor_compare(struct pf_anchor *, struct pf_anchor *);
+
+RB_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
+RB_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
+
+static __inline int
+pf_anchor_compare(struct pf_anchor *a, struct pf_anchor *b)
+{
+	int c = strcmp(a->path, b->path);
+
+	return (c ? (c < 0 ? -1 : 1) : 0);
+}
+
+int
+pf_get_ruleset_number(u_int8_t action)
+{
+	switch (action) {
+	case PF_SCRUB:
+	case PF_NOSCRUB:
+		return (PF_RULESET_SCRUB);
+		break;
+	case PF_PASS:
+	case PF_DROP:
+		return (PF_RULESET_FILTER);
+		break;
+	case PF_NAT:
+	case PF_NONAT:
+		return (PF_RULESET_NAT);
+		break;
+	case PF_BINAT:
+	case PF_NOBINAT:
+		return (PF_RULESET_BINAT);
+		break;
+	case PF_RDR:
+	case PF_NORDR:
+		return (PF_RULESET_RDR);
+		break;
+	default:
+		return (PF_RULESET_MAX);
+		break;
+	}
+}
+
+void
+pf_init_ruleset(struct pf_ruleset *ruleset)
+{
+	int	i;
+
+	memset(ruleset, 0, sizeof(struct pf_ruleset));
+	for (i = 0; i < PF_RULESET_MAX; i++) {
+		TAILQ_INIT(&ruleset->rules[i].queues[0]);
+		TAILQ_INIT(&ruleset->rules[i].queues[1]);
+		ruleset->rules[i].active.ptr = &ruleset->rules[i].queues[0];
+		ruleset->rules[i].inactive.ptr = &ruleset->rules[i].queues[1];
+	}
+}
+
+struct pf_anchor *
+pf_find_anchor(const char *path)
+{
+	struct pf_anchor	*key, *found;
+
+	key = (struct pf_anchor *)rs_malloc(sizeof(*key));
+	memset(key, 0, sizeof(*key));
+	strlcpy(key->path, path, sizeof(key->path));
+	found = RB_FIND(pf_anchor_global, &pf_anchors, key);
+	rs_free(key);
+	return (found);
+}
+
+struct pf_ruleset *
+pf_find_ruleset(const char *path)
+{
+	struct pf_anchor	*anchor;
+
+	while (*path == '/')
+		path++;
+	if (!*path)
+		return (&pf_main_ruleset);
+	anchor = pf_find_anchor(path);
+	if (anchor == NULL)
+		return (NULL);
+	else
+		return (&anchor->ruleset);
+}
+
+struct pf_ruleset *
+pf_find_or_create_ruleset(const char *path)
+{
+	char			*p, *q, *r;
+	struct pf_ruleset	*ruleset;
+#ifdef __FreeBSD_kernel__
+	struct pf_anchor	*anchor = NULL, *dup, *parent = NULL;
+#else
+	struct pf_anchor	*anchor, *dup, *parent = NULL;
+#endif
+
+	if (path[0] == 0)
+		return (&pf_main_ruleset);
+	while (*path == '/')
+		path++;
+	ruleset = pf_find_ruleset(path);
+	if (ruleset != NULL)
+		return (ruleset);
+	p = (char *)rs_malloc(MAXPATHLEN);
+	bzero(p, MAXPATHLEN);
+	strlcpy(p, path, MAXPATHLEN);
+	while (parent == NULL && (q = strrchr(p, '/')) != NULL) {
+		*q = 0;
+		if ((ruleset = pf_find_ruleset(p)) != NULL) {
+			parent = ruleset->anchor;
+			break;
+		}
+	}
+	if (q == NULL)
+		q = p;
+	else
+		q++;
+	strlcpy(p, path, MAXPATHLEN);
+	if (!*q) {
+		rs_free(p);
+		return (NULL);
+	}
+	while ((r = strchr(q, '/')) != NULL || *q) {
+		if (r != NULL)
+			*r = 0;
+		if (!*q || strlen(q) >= PF_ANCHOR_NAME_SIZE ||
+		    (parent != NULL && strlen(parent->path) >=
+		    MAXPATHLEN - PF_ANCHOR_NAME_SIZE - 1)) {
+			rs_free(p);
+			return (NULL);
+		}
+		anchor = (struct pf_anchor *)rs_malloc(sizeof(*anchor));
+		if (anchor == NULL) {
+			rs_free(p);
+			return (NULL);
+		}
+		memset(anchor, 0, sizeof(*anchor));
+		RB_INIT(&anchor->children);
+		strlcpy(anchor->name, q, sizeof(anchor->name));
+		if (parent != NULL) {
+			strlcpy(anchor->path, parent->path,
+			    sizeof(anchor->path));
+			strlcat(anchor->path, "/", sizeof(anchor->path));
+		}
+		strlcat(anchor->path, anchor->name, sizeof(anchor->path));
+		if ((dup = RB_INSERT(pf_anchor_global, &pf_anchors, anchor)) !=
+		    NULL) {
+			printf("pf_find_or_create_ruleset: RB_INSERT1 "
+			    "'%s' '%s' collides with '%s' '%s'\n",
+			    anchor->path, anchor->name, dup->path, dup->name);
+			rs_free(anchor);
+			rs_free(p);
+			return (NULL);
+		}
+		if (parent != NULL) {
+			anchor->parent = parent;
+			if ((dup = RB_INSERT(pf_anchor_node, &parent->children,
+			    anchor)) != NULL) {
+				printf("pf_find_or_create_ruleset: "
+				    "RB_INSERT2 '%s' '%s' collides with "
+				    "'%s' '%s'\n", anchor->path, anchor->name,
+				    dup->path, dup->name);
+				RB_REMOVE(pf_anchor_global, &pf_anchors,
+				    anchor);
+				rs_free(anchor);
+				rs_free(p);
+				return (NULL);
+			}
+		}
+		pf_init_ruleset(&anchor->ruleset);
+		anchor->ruleset.anchor = anchor;
+		parent = anchor;
+		if (r != NULL)
+			q = r + 1;
+		else
+			*q = 0;
+	}
+	rs_free(p);
+	return (&anchor->ruleset);
+}
+
+void
+pf_remove_if_empty_ruleset(struct pf_ruleset *ruleset)
+{
+	struct pf_anchor	*parent;
+	int			 i;
+
+	while (ruleset != NULL) {
+		if (ruleset == &pf_main_ruleset || ruleset->anchor == NULL ||
+		    !RB_EMPTY(&ruleset->anchor->children) ||
+		    ruleset->anchor->refcnt > 0 || ruleset->tables > 0 ||
+		    ruleset->topen)
+			return;
+		for (i = 0; i < PF_RULESET_MAX; ++i)
+			if (!TAILQ_EMPTY(ruleset->rules[i].active.ptr) ||
+			    !TAILQ_EMPTY(ruleset->rules[i].inactive.ptr) ||
+			    ruleset->rules[i].inactive.open)
+				return;
+		RB_REMOVE(pf_anchor_global, &pf_anchors, ruleset->anchor);
+		if ((parent = ruleset->anchor->parent) != NULL)
+			RB_REMOVE(pf_anchor_node, &parent->children,
+			    ruleset->anchor);
+		rs_free(ruleset->anchor);
+		if (parent == NULL)
+			return;
+		ruleset = &parent->ruleset;
+	}
+}
+
+int
+pf_anchor_setup(struct pf_rule *r, const struct pf_ruleset *s,
+    const char *name)
+{
+	char			*p, *path;
+	struct pf_ruleset	*ruleset;
+
+	r->anchor = NULL;
+	r->anchor_relative = 0;
+	r->anchor_wildcard = 0;
+	if (!name[0])
+		return (0);
+	path = (char *)rs_malloc(MAXPATHLEN);
+	bzero(path, MAXPATHLEN);
+	if (name[0] == '/')
+		strlcpy(path, name + 1, MAXPATHLEN);
+	else {
+		/* relative path */
+		r->anchor_relative = 1;
+		if (s->anchor == NULL || !s->anchor->path[0])
+			path[0] = 0;
+		else
+			strlcpy(path, s->anchor->path, MAXPATHLEN);
+		while (name[0] == '.' && name[1] == '.' && name[2] == '/') {
+			if (!path[0]) {
+				printf("pf_anchor_setup: .. beyond root\n");
+				rs_free(path);
+				return (1);
+			}
+			if ((p = strrchr(path, '/')) != NULL)
+				*p = 0;
+			else
+				path[0] = 0;
+			r->anchor_relative++;
+			name += 3;
+		}
+		if (path[0])
+			strlcat(path, "/", MAXPATHLEN);
+		strlcat(path, name, MAXPATHLEN);
+	}
+	if ((p = strrchr(path, '/')) != NULL && !strcmp(p, "/*")) {
+		r->anchor_wildcard = 1;
+		*p = 0;
+	}
+	ruleset = pf_find_or_create_ruleset(path);
+	rs_free(path);
+	if (ruleset == NULL || ruleset->anchor == NULL) {
+		printf("pf_anchor_setup: ruleset\n");
+		return (1);
+	}
+	r->anchor = ruleset->anchor;
+	r->anchor->refcnt++;
+	return (0);
+}
+
+int
+pf_anchor_copyout(const struct pf_ruleset *rs, const struct pf_rule *r,
+    struct pfioc_rule *pr)
+{
+	pr->anchor_call[0] = 0;
+	if (r->anchor == NULL)
+		return (0);
+	if (!r->anchor_relative) {
+		strlcpy(pr->anchor_call, "/", sizeof(pr->anchor_call));
+		strlcat(pr->anchor_call, r->anchor->path,
+		    sizeof(pr->anchor_call));
+	} else {
+		char	*a, *p;
+		int	 i;
+
+		a = (char *)rs_malloc(MAXPATHLEN);
+		bzero(a, MAXPATHLEN);
+		if (rs->anchor == NULL)
+			a[0] = 0;
+		else
+			strlcpy(a, rs->anchor->path, MAXPATHLEN);
+		for (i = 1; i < r->anchor_relative; ++i) {
+			if ((p = strrchr(a, '/')) == NULL)
+				p = a;
+			*p = 0;
+			strlcat(pr->anchor_call, "../",
+			    sizeof(pr->anchor_call));
+		}
+		if (strncmp(a, r->anchor->path, strlen(a))) {
+			printf("pf_anchor_copyout: '%s' '%s'\n", a,
+			    r->anchor->path);
+			rs_free(a);
+			return (1);
+		}
+		if (strlen(r->anchor->path) > strlen(a))
+			strlcat(pr->anchor_call, r->anchor->path + (a[0] ?
+			    strlen(a) + 1 : 0), sizeof(pr->anchor_call));
+		rs_free(a);
+	}
+	if (r->anchor_wildcard)
+		strlcat(pr->anchor_call, pr->anchor_call[0] ? "/*" : "*",
+		    sizeof(pr->anchor_call));
+	return (0);
+}
+
+void
+pf_anchor_remove(struct pf_rule *r)
+{
+	if (r->anchor == NULL)
+		return;
+	if (r->anchor->refcnt <= 0) {
+		printf("pf_anchor_remove: broken refcount\n");
+		r->anchor = NULL;
+		return;
+	}
+	if (!--r->anchor->refcnt)
+		pf_remove_if_empty_ruleset(&r->anchor->ruleset);
+	r->anchor = NULL;
+}
+
--- a/sbin/pfctl/Makefile
+++ b/sbin/pfctl/Makefile
@@ -21,7 +21,7 @@ CFLAGS+= -DENABLE_ALTQ
 
 YFLAGS=
 
-LDADD+=	-lm -lmd
+LDADD+=	-lm -lbsd
 DPADD+=	${LIBM} ${LIBMD}
 
 .include <bsd.prog.mk>
--- a/usr.sbin/authpf/Makefile
+++ b/usr.sbin/authpf/Makefile
@@ -16,7 +16,7 @@ CFLAGS+= -I${.CURDIR}/../../contrib/pf/p
 # XXX ALTQ:
 CFLAGS+= -DENABLE_ALTQ
 
-LDADD+= -lm -lmd -lutil
+LDADD+= -lm -lutil -lbsd
 DPADD+= ${LIBM} ${LIBMD} ${LIBUTIL}
 
 .include <bsd.prog.mk>
