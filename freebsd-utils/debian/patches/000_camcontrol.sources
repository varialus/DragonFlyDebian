--- a/sbin/camcontrol/camcontrol.8
+++ b/sbin/camcontrol/camcontrol.8
@@ -0,0 +1,994 @@
+.\"
+.\" Copyright (c) 1998, 1999, 2000, 2002, 2005, 2006, 2007 Kenneth D. Merry.
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. The name of the author may not be used to endorse or promote products
+.\"    derived from this software without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd September 4, 2009
+.Dt CAMCONTROL 8
+.Os
+.Sh NAME
+.Nm camcontrol
+.Nd CAM control program
+.Sh SYNOPSIS
+.Nm
+.Aq Ar command
+.Op device id
+.Op generic args
+.Op command args
+.Nm
+.Ic devlist
+.Op Fl v
+.Nm
+.Ic periphlist
+.Op device id
+.Op Fl n Ar dev_name
+.Op Fl u Ar unit_number
+.Nm
+.Ic tur
+.Op device id
+.Op generic args
+.Nm
+.Ic inquiry
+.Op device id
+.Op generic args
+.Op Fl D
+.Op Fl S
+.Op Fl R
+.Nm
+.Ic identify
+.Op device id
+.Op generic args
+.Nm
+.Ic reportluns
+.Op device id
+.Op generic args
+.Op Fl c
+.Op Fl l
+.Op Fl r Ar reporttype
+.Nm
+.Ic readcap
+.Op device id
+.Op generic args
+.Op Fl b
+.Op Fl h
+.Op Fl H
+.Op Fl N
+.Op Fl q
+.Op Fl s
+.Nm
+.Ic start
+.Op device id
+.Op generic args
+.Nm
+.Ic stop
+.Op device id
+.Op generic args
+.Nm
+.Ic load
+.Op device id
+.Op generic args
+.Nm
+.Ic eject
+.Op device id
+.Op generic args
+.Nm
+.Ic rescan
+.Aq all | bus Ns Op :target:lun
+.Nm
+.Ic reset
+.Aq all | bus Ns Op :target:lun
+.Nm
+.Ic defects
+.Op device id
+.Op generic args
+.Aq Fl f Ar format
+.Op Fl P
+.Op Fl G
+.Nm
+.Ic modepage
+.Op device id
+.Op generic args
+.Aq Fl m Ar page | Fl l
+.Op Fl P Ar pgctl
+.Op Fl b | Fl e
+.Op Fl d
+.Nm
+.Ic cmd
+.Op device id
+.Op generic args
+.Aq Fl a Ar cmd Op args
+.Aq Fl c Ar cmd Op args
+.Op Fl i Ar len Ar fmt
+.Bk -words
+.Op Fl o Ar len Ar fmt Op args
+.Op Fl r Ar fmt
+.Ek
+.Nm
+.Ic debug
+.Op Fl I
+.Op Fl P
+.Op Fl T
+.Op Fl S
+.Op Fl X
+.Op Fl c
+.Aq all|off|bus Ns Op :target Ns Op :lun
+.Nm
+.Ic tags
+.Op device id
+.Op generic args
+.Op Fl N Ar tags
+.Op Fl q
+.Op Fl v
+.Nm
+.Ic negotiate
+.Op device id
+.Op generic args
+.Op Fl c
+.Op Fl D Ar enable|disable
+.Op Fl O Ar offset
+.Op Fl q
+.Op Fl R Ar syncrate
+.Op Fl T Ar enable|disable
+.Op Fl U
+.Op Fl W Ar bus_width
+.Op Fl v
+.Nm
+.Ic format
+.Op device id
+.Op generic args
+.Op Fl q
+.Op Fl r
+.Op Fl w
+.Op Fl y
+.Nm
+.Ic help
+.Sh DESCRIPTION
+The
+.Nm
+utility is designed to provide a way for users to access and control the
+.Fx
+CAM subsystem.
+.Pp
+The
+.Nm
+utility
+can cause a loss of data and/or system crashes if used improperly.
+Even
+expert users are encouraged to exercise caution when using this command.
+Novice users should stay away from this utility.
+.Pp
+The
+.Nm
+utility has a number of primary functions, many of which support an optional
+device identifier.
+A device identifier can take one of three forms:
+.Bl -tag -width 14n
+.It deviceUNIT
+Specify a device name and unit number combination, like "da5" or "cd3".
+Note that character device node names (e.g.\& /dev/da0) are
+.Em not
+allowed here.
+.It bus:target
+Specify a bus number and target id.
+The bus number can be determined from
+the output of
+.Dq camcontrol devlist .
+The lun defaults to 0.
+.It bus:target:lun
+Specify the bus, target and lun for a device.
+(e.g.\& 1:2:0)
+.El
+.Pp
+The device identifier, if it is specified,
+.Em must
+come immediately after the function name, and before any generic or
+function-specific arguments.
+Note that the
+.Fl n
+and
+.Fl u
+arguments described below will override any device name or unit number
+specified beforehand.
+The
+.Fl n
+and
+.Fl u
+arguments will
+.Em not
+override a specified bus:target or bus:target:lun, however.
+.Pp
+Most of the
+.Nm
+primary functions support these generic arguments:
+.Bl -tag -width 14n
+.It Fl C Ar count
+SCSI command retry count.
+In order for this to work, error recovery
+.Pq Fl E
+must be turned on.
+.It Fl E
+Instruct the kernel to perform generic SCSI error recovery for the given
+command.
+This is needed in order for the retry count
+.Pq Fl C
+to be honored.
+Other than retrying commands, the generic error recovery in
+the code will generally attempt to spin up drives that are not spinning.
+It may take some other actions, depending upon the sense code returned from
+the command.
+.It Fl n Ar dev_name
+Specify the device type to operate on, e.g.\& "da", "cd".
+.It Fl t Ar timeout
+SCSI command timeout in seconds.
+This overrides the default timeout for
+any given command.
+.It Fl u Ar unit_number
+Specify the device unit number, e.g.\& "1", "5".
+.It Fl v
+Be verbose, print out sense information for failed SCSI commands.
+.El
+.Pp
+Primary command functions:
+.Bl -tag -width periphlist
+.It Ic devlist
+List all physical devices (logical units) attached to the CAM subsystem.
+This also includes a list of peripheral drivers attached to each device.
+With the
+.Fl v
+argument, SCSI bus number, adapter name and unit numbers are printed as
+well.
+.It Ic periphlist
+List all peripheral drivers attached to a given physical device (logical
+unit).
+.It Ic tur
+Send the SCSI test unit ready (0x00) command to the given device.
+The
+.Nm
+utility will report whether the device is ready or not.
+.It Ic inquiry
+Send a SCSI inquiry command (0x12) to a device.
+By default,
+.Nm
+will print out the standard inquiry data, device serial number, and
+transfer rate information.
+The user can specify that only certain types of
+inquiry data be printed:
+.Bl -tag -width 4n
+.It Fl D
+Get the standard inquiry data.
+.It Fl S
+Print out the serial number.
+If this flag is the only one specified,
+.Nm
+will not print out "Serial Number" before the value returned by the drive.
+This is to aid in script writing.
+.It Fl R
+Print out transfer rate information.
+.El
+.It Ic identify
+Send a ATA identify command (0xec) to a device.
+.It Ic reportluns
+Send the SCSI REPORT LUNS (0xA0) command to the given device.
+By default,
+.Nm
+will print out the list of logical units (LUNs) supported by the target device.
+There are a couple of options to modify the output:
+.Bl -tag -width 14n
+.It Fl c
+Just print out a count of LUNs, not the actual LUN numbers.
+.It Fl l
+Just print out the LUNs, and don't print out the count.
+.It Fl r Ar reporttype
+Specify the type of report to request from the target:
+.Bl -tag -width 012345678
+.It default
+Return the default report.
+This is the
+.Nm
+default.
+Most targets will support this report if they support the REPORT LUNS
+command.
+.It wellknown
+Return only well known LUNs.
+.It all
+Return all available LUNs.
+.El
+.El
+.Pp
+.Nm
+will try to print out LUN numbers in a reasonable format.
+It can understand the peripheral, flat, LUN and extended LUN formats.
+.It Ic readcap
+Send the SCSI READ CAPACITY command to the given device and display
+the results.
+If the device is larger than 2TB, the SCSI READ CAPACITY (16) service
+action will be sent to obtain the full size of the device.
+By default,
+.Nm
+will print out the last logical block of the device, and the blocksize of
+the device in bytes.
+To modify the output format, use the following options:
+.Bl -tag -width 5n
+.It Fl b
+Just print out the blocksize, not the last block or device size.
+This cannot be used with
+.Fl N
+or
+.Fl s .
+.It Fl h
+Print out the device size in human readable (base 2, 1K == 1024) format.
+This implies
+.Fl N
+and cannot be used with
+.Fl q
+or
+.Fl b .
+.It Fl H
+Print out the device size in human readable (base 10, 1K == 1000) format.
+.It Fl N
+Print out the number of blocks in the device instead of the last logical
+block.
+.It Fl q
+Quiet, print out the numbers only (separated by a comma if
+.Fl b
+or
+.Fl s
+are not specified).
+.It Fl s
+Print out the last logical block or the size of the device only, and omit
+the blocksize.
+.El
+.It Ic start
+Send the SCSI Start/Stop Unit (0x1B) command to the given device with the
+start bit set.
+.It Ic stop
+Send the SCSI Start/Stop Unit (0x1B) command to the given device with the
+start bit cleared.
+.It Ic load
+Send the SCSI Start/Stop Unit (0x1B) command to the given device with the
+start bit set and the load/eject bit set.
+.It Ic eject
+Send the SCSI Start/Stop Unit (0x1B) command to the given device with the
+start bit cleared and the load/eject bit set.
+.It Ic rescan
+Tell the kernel to scan all busses in the system (with the
+.Ar all
+argument), the given bus (XPT_SCAN_BUS), or bus:target:lun
+(XPT_SCAN_LUN) for new devices or devices that have gone away.
+The user
+may specify a scan of all busses, a single bus, or a lun.
+Scanning all luns
+on a target is not supported.
+.It Ic reset
+Tell the kernel to reset all busses in the system (with the
+.Ar all
+argument) or the given bus (XPT_RESET_BUS) by issuing a SCSI bus
+reset for that bus, or to reset the given bus:target:lun
+(XPT_RESET_DEV), typically by issuing a BUS DEVICE RESET message after
+connecting to that device.
+Note that this can have a destructive impact
+on the system.
+.It Ic defects
+Send the SCSI READ DEFECT DATA (10) command (0x37) to the given device, and
+print out any combination of: the total number of defects, the primary
+defect list (PLIST), and the grown defect list (GLIST).
+.Bl -tag -width 11n
+.It Fl f Ar format
+The three format options are:
+.Em block ,
+to print out the list as logical blocks,
+.Em bfi ,
+to print out the list in bytes from index format, and
+.Em phys ,
+to print out the list in physical sector format.
+The format argument is
+required.
+Most drives support the physical sector format.
+Some drives
+support the logical block format.
+Many drives, if they do not support the
+requested format, return the data in an alternate format, along with sense
+information indicating that the requested data format is not supported.
+The
+.Nm
+utility
+attempts to detect this, and print out whatever format the drive returns.
+If the drive uses a non-standard sense code to report that it does not
+support the requested format,
+.Nm
+will probably see the error as a failure to complete the request.
+.It Fl G
+Print out the grown defect list.
+This is a list of bad blocks that have
+been remapped since the disk left the factory.
+.It Fl P
+Print out the primary defect list.
+.El
+.Pp
+If neither
+.Fl P
+nor
+.Fl G
+is specified,
+.Nm
+will print out the number of defects given in the READ DEFECT DATA header
+returned from the drive.
+.It Ic modepage
+Allows the user to display and optionally edit a SCSI mode page.
+The mode
+page formats are located in
+.Pa /usr/share/misc/scsi_modes .
+This can be overridden by specifying a different file in the
+.Ev SCSI_MODES
+environment variable.
+The
+.Ic modepage
+command takes several arguments:
+.Bl -tag -width 12n
+.It Fl d
+Disable block descriptors for mode sense.
+.It Fl b
+Displays mode page data in binary format.
+.It Fl e
+This flag allows the user to edit values in the mode page.
+The user may
+either edit mode page values with the text editor pointed to by his
+.Ev EDITOR
+environment variable, or supply mode page values via standard input, using
+the same format that
+.Nm
+uses to display mode page values.
+The editor will be invoked if
+.Nm
+detects that standard input is terminal.
+.It Fl l
+Lists all available mode pages.
+.It Fl m Ar mode_page
+This specifies the number of the mode page the user would like to view
+and/or edit.
+This argument is mandatory unless
+.Fl l
+is specified.
+.It Fl P Ar pgctl
+This allows the user to specify the page control field.
+Possible values are:
+.Bl -tag -width xxx -compact
+.It 0
+Current values
+.It 1
+Changeable values
+.It 2
+Default values
+.It 3
+Saved values
+.El
+.El
+.It Ic cmd
+Allows the user to send an arbitrary ATA or SCSI CDB to any device.
+The
+.Ic cmd
+function requires the
+.Fl c
+argument to specify SCSI CDB or the
+.Fl a
+argument to specify ATA Command Block registers values.
+Other arguments are optional, depending on
+the command type.
+The command and data specification syntax is documented
+in
+.Xr cam_cdbparse 3 .
+NOTE: If the CDB specified causes data to be transfered to or from the
+SCSI device in question, you MUST specify either
+.Fl i
+or
+.Fl o .
+.Bl -tag -width 17n
+.It Fl a Ar cmd Op args
+This specifies the content of 12 ATA Command Block registers (command,
+features, lba_low, lba_mid, lba_high, device, lba_low_exp, lba_mid_exp.
+lba_high_exp, features_exp, sector_count, sector_count_exp).
+.It Fl c Ar cmd Op args
+This specifies the SCSI CDB.
+SCSI CDBs may be 6, 10, 12 or 16 bytes.
+.It Fl i Ar len Ar fmt
+This specifies the amount of data to read, and how it should be displayed.
+If the format is
+.Sq - ,
+.Ar len
+bytes of data will be read from the device and written to standard output.
+.It Fl o Ar len Ar fmt Op args
+This specifies the amount of data to be written to a device, and the data
+that is to be written.
+If the format is
+.Sq - ,
+.Ar len
+bytes of data will be read from standard input and written to the device.
+.It Fl r Ar fmt
+This specifies that 11 result ATA Command Block registers should be displayed
+(status, error, lba_low, lba_mid, lba_high, device, lba_low_exp, lba_mid_exp,
+lba_high_exp, sector_count, sector_count_exp), and how.
+If the format is
+.Sq - ,
+11 result registers will be written to standard output in hex.
+.El
+.It Ic debug
+Turn on CAM debugging printfs in the kernel.
+This requires options CAMDEBUG
+in your kernel config file.
+WARNING: enabling debugging printfs currently
+causes an EXTREME number of kernel printfs.
+You may have difficulty
+turning off the debugging printfs once they start, since the kernel will be
+busy printing messages and unable to service other requests quickly.
+The
+.Ic debug
+function takes a number of arguments:
+.Bl -tag -width 18n
+.It Fl I
+Enable CAM_DEBUG_INFO printfs.
+.It Fl P
+Enable CAM_DEBUG_PERIPH printfs.
+.It Fl T
+Enable CAM_DEBUG_TRACE printfs.
+.It Fl S
+Enable CAM_DEBUG_SUBTRACE printfs.
+.It Fl X
+Enable CAM_DEBUG_XPT printfs.
+.It Fl c
+Enable CAM_DEBUG_CDB printfs.
+This will cause the kernel to print out the
+SCSI CDBs sent to the specified device(s).
+.It all
+Enable debugging for all devices.
+.It off
+Turn off debugging for all devices
+.It bus Ns Op :target Ns Op :lun
+Turn on debugging for the given bus, target or lun.
+If the lun or target
+and lun are not specified, they are wildcarded.
+(i.e., just specifying a
+bus turns on debugging printfs for all devices on that bus.)
+.El
+.It Ic tags
+Show or set the number of "tagged openings" or simultaneous transactions
+we attempt to queue to a particular device.
+By default, the
+.Ic tags
+command, with no command-specific arguments (i.e., only generic arguments)
+prints out the "soft" maximum number of transactions that can be queued to
+the device in question.
+For more detailed information, use the
+.Fl v
+argument described below.
+.Bl -tag -width 7n
+.It Fl N Ar tags
+Set the number of tags for the given device.
+This must be between the
+minimum and maximum number set in the kernel quirk table.
+The default for
+most devices that support tagged queueing is a minimum of 2 and a maximum
+of 255.
+The minimum and maximum values for a given device may be
+determined by using the
+.Fl v
+switch.
+The meaning of the
+.Fl v
+switch for this
+.Nm
+subcommand is described below.
+.It Fl q
+Be quiet, and do not report the number of tags.
+This is generally used when
+setting the number of tags.
+.It Fl v
+The verbose flag has special functionality for the
+.Em tags
+argument.
+It causes
+.Nm
+to print out the tagged queueing related fields of the XPT_GDEV_TYPE CCB:
+.Bl -tag -width 13n
+.It dev_openings
+This is the amount of capacity for transactions queued to a given device.
+.It dev_active
+This is the number of transactions currently queued to a device.
+.It devq_openings
+This is the kernel queue space for transactions.
+This count usually mirrors
+dev_openings except during error recovery operations when
+the device queue is frozen (device is not allowed to receive
+commands), the number of dev_openings is reduced, or transaction
+replay is occurring.
+.It devq_queued
+This is the number of transactions waiting in the kernel queue for capacity
+on the device.
+This number is usually zero unless error recovery is in
+progress.
+.It held
+The held count is the number of CCBs held by peripheral drivers that have
+either just been completed or are about to be released to the transport
+layer for service by a device.
+Held CCBs reserve capacity on a given
+device.
+.It mintags
+This is the current "hard" minimum number of transactions that can be
+queued to a device at once.
+The
+.Ar dev_openings
+value above cannot go below this number.
+The default value for
+.Ar mintags
+is 2, although it may be set higher or lower for various devices.
+.It maxtags
+This is the "hard" maximum number of transactions that can be queued to a
+device at one time.
+The
+.Ar dev_openings
+value cannot go above this number.
+The default value for
+.Ar maxtags
+is 255, although it may be set higher or lower for various devices.
+.El
+.El
+.It Ic negotiate
+Show or negotiate various communication parameters.
+Some controllers may
+not support setting or changing some of these values.
+For instance, the
+Adaptec 174x controllers do not support changing a device's sync rate or
+offset.
+The
+.Nm
+utility
+will not attempt to set the parameter if the controller indicates that it
+does not support setting the parameter.
+To find out what the controller
+supports, use the
+.Fl v
+flag.
+The meaning of the
+.Fl v
+flag for the
+.Ic negotiate
+command is described below.
+Also, some controller drivers do not support
+setting negotiation parameters, even if the underlying controller supports
+negotiation changes.
+Some controllers, such as the Advansys wide
+controllers, support enabling and disabling synchronous negotiation for
+a device, but do not support setting the synchronous negotiation rate.
+.Bl -tag -width 17n
+.It Fl a
+Attempt to make the negotiation settings take effect immediately by sending
+a Test Unit Ready command to the device.
+.It Fl c
+Show or set current negotiation settings.
+This is the default.
+.It Fl D Ar enable|disable
+Enable or disable disconnection.
+.It Fl O Ar offset
+Set the command delay offset.
+.It Fl q
+Be quiet, do not print anything.
+This is generally useful when you want to
+set a parameter, but do not want any status information.
+.It Fl R Ar syncrate
+Change the synchronization rate for a device.
+The sync rate is a floating
+point value specified in MHz.
+So, for instance,
+.Sq 20.000
+is a legal value, as is
+.Sq 20 .
+.It Fl T Ar enable|disable
+Enable or disable tagged queueing for a device.
+.It Fl U
+Show or set user negotiation settings.
+The default is to show or set
+current negotiation settings.
+.It Fl v
+The verbose switch has special meaning for the
+.Ic negotiate
+subcommand.
+It causes
+.Nm
+to print out the contents of a Path Inquiry (XPT_PATH_INQ) CCB sent to the
+controller driver.
+.It Fl W Ar bus_width
+Specify the bus width to negotiate with a device.
+The bus width is
+specified in bits.
+The only useful values to specify are 8, 16, and 32
+bits.
+The controller must support the bus width in question in order for
+the setting to take effect.
+.El
+.Pp
+In general, sync rate and offset settings will not take effect for a
+device until a command has been sent to the device.
+The
+.Fl a
+switch above will automatically send a Test Unit Ready to the device so
+negotiation parameters will take effect.
+.It Ic format
+Issue the
+.Tn SCSI
+FORMAT UNIT command to the named device.
+.Pp
+.Em WARNING! WARNING! WARNING!
+.Pp
+Low level formatting a disk will destroy ALL data on the disk.
+Use
+extreme caution when issuing this command.
+Many users low-level format
+disks that do not really need to be low-level formatted.
+There are
+relatively few scenarios that call for low-level formatting a disk.
+One reason for
+low-level formatting a disk is to initialize the disk after changing
+its physical sector size.
+Another reason for low-level formatting a disk
+is to revive the disk if you are getting "medium format corrupted" errors
+from the disk in response to read and write requests.
+.Pp
+Some disks take longer than others to format.
+Users should specify a
+timeout long enough to allow the format to complete.
+The default format
+timeout is 3 hours, which should be long enough for most disks.
+Some hard
+disks will complete a format operation in a very short period of time
+(on the order of 5 minutes or less).
+This is often because the drive
+does not really support the FORMAT UNIT command -- it just accepts the
+command, waits a few minutes and then returns it.
+.Pp
+The
+.Sq format
+subcommand takes several arguments that modify its default behavior.
+The
+.Fl q
+and
+.Fl y
+arguments can be useful for scripts.
+.Pp
+.Bl -tag -width 6n
+.It Fl q
+Be quiet, do not print any status messages.
+This option will not disable
+the questions, however.
+To disable questions, use the
+.Fl y
+argument, below.
+.It Fl r
+Run in
+.Dq report only
+mode.
+This will report status on a format that is already running on the drive.
+.It Fl w
+Issue a non-immediate format command.
+By default,
+.Nm
+issues the FORMAT UNIT command with the immediate bit set.
+This tells the
+device to immediately return the format command, before the format has
+actually completed.
+Then,
+.Nm
+gathers
+.Tn SCSI
+sense information from the device every second to determine how far along
+in the format process it is.
+If the
+.Fl w
+argument is specified,
+.Nm
+will issue a non-immediate format command, and will be unable to print any
+information to let the user know what percentage of the disk has been
+formatted.
+.It Fl y
+Do not ask any questions.
+By default,
+.Nm
+will ask the user if he/she really wants to format the disk in question,
+and also if the default format command timeout is acceptable.
+The user
+will not be asked about the timeout if a timeout is specified on the
+command line.
+.El
+.It Ic help
+Print out verbose usage information.
+.El
+.Sh ENVIRONMENT
+The
+.Ev SCSI_MODES
+variable allows the user to specify an alternate mode page format file.
+.Pp
+The
+.Ev EDITOR
+variable determines which text editor
+.Nm
+starts when editing mode pages.
+.Sh FILES
+.Bl -tag -width /usr/share/misc/scsi_modes -compact
+.It Pa /usr/share/misc/scsi_modes
+is the SCSI mode format database.
+.It Pa /dev/xpt0
+is the transport layer device.
+.It Pa /dev/pass*
+are the CAM application passthrough devices.
+.El
+.Sh EXAMPLES
+.Dl camcontrol eject -n cd -u 1 -v
+.Pp
+Eject the CD from cd1, and print SCSI sense information if the command
+fails.
+.Pp
+.Dl camcontrol tur da0
+.Pp
+Send the SCSI test unit ready command to da0.
+The
+.Nm
+utility will report whether the disk is ready, but will not display sense
+information if the command fails since the
+.Fl v
+switch was not specified.
+.Pp
+.Bd -literal -offset indent
+camcontrol tur da1 -E -C 4 -t 50 -v
+.Ed
+.Pp
+Send a test unit ready command to da1.
+Enable kernel error recovery.
+Specify a retry count of 4, and a timeout of 50 seconds.
+Enable sense
+printing (with the
+.Fl v
+flag) if the command fails.
+Since error recovery is turned on, the
+disk will be spun up if it is not currently spinning.
+The
+.Nm
+utility will report whether the disk is ready.
+.Bd -literal -offset indent
+camcontrol cmd -n cd -u 1 -v -c "3C 00 00 00 00 00 00 00 0e 00" \e
+	-i 0xe "s1 i3 i1 i1 i1 i1 i1 i1 i1 i1 i1 i1"
+.Ed
+.Pp
+Issue a READ BUFFER command (0x3C) to cd1.
+Display the buffer size of cd1,
+and display the first 10 bytes from the cache on cd1.
+Display SCSI sense
+information if the command fails.
+.Pp
+.Bd -literal -offset indent
+camcontrol cmd -n cd -u 1 -v -c "3B 00 00 00 00 00 00 00 0e 00" \e
+	-o 14 "00 00 00 00 1 2 3 4 5 6 v v v v" 7 8 9 8
+.Ed
+.Pp
+Issue a WRITE BUFFER (0x3B) command to cd1.
+Write out 10 bytes of data,
+not including the (reserved) 4 byte header.
+Print out sense information if
+the command fails.
+Be very careful with this command, improper use may
+cause data corruption.
+.Pp
+.Bd -literal -offset indent
+camcontrol modepage da3 -m 1 -e -P 3
+.Ed
+.Pp
+Edit mode page 1 (the Read-Write Error Recover page) for da3, and save the
+settings on the drive.
+Mode page 1 contains a disk drive's auto read and
+write reallocation settings, among other things.
+.Pp
+.Dl camcontrol rescan all
+.Pp
+Rescan all SCSI busses in the system for devices that have been added,
+removed or changed.
+.Pp
+.Dl camcontrol rescan 0
+.Pp
+Rescan SCSI bus 0 for devices that have been added, removed or changed.
+.Pp
+.Dl camcontrol rescan 0:1:0
+.Pp
+Rescan SCSI bus 0, target 1, lun 0 to see if it has been added, removed, or
+changed.
+.Pp
+.Dl camcontrol tags da5 -N 24
+.Pp
+Set the number of concurrent transactions for da5 to 24.
+.Pp
+.Bd -literal -offset indent
+camcontrol negotiate -n da -u 4 -T disable
+.Ed
+.Pp
+Disable tagged queueing for da4.
+.Pp
+.Bd -literal -offset indent
+camcontrol negotiate -n da -u 3 -R 20.000 -O 15 -a
+.Ed
+.Pp
+Negotiate a sync rate of 20MHz and an offset of 15 with da3.
+Then send a
+Test Unit Ready command to make the settings take effect.
+.Sh SEE ALSO
+.Xr cam 3 ,
+.Xr cam_cdbparse 3 ,
+.Xr cam 4 ,
+.Xr pass 4 ,
+.Xr xpt 4
+.Sh HISTORY
+The
+.Nm
+utility first appeared in
+.Fx 3.0 .
+.Pp
+The mode page editing code and arbitrary SCSI command code are based upon
+code in the old
+.Xr scsi 8
+utility and
+.Xr scsi 3
+library, written by Julian Elischer and Peter Dufault.
+The
+.Xr scsi 8
+program first appeared in
+.Bx 386 0.1.2.4 ,
+and first appeared in
+.Fx
+in
+.Fx 2.0.5 .
+.Sh AUTHORS
+.An Kenneth Merry Aq ken@FreeBSD.org
+.Sh BUGS
+The code that parses the generic command line arguments does not know that
+some of the subcommands take multiple arguments.
+So if, for instance, you
+tried something like this:
+.Bd -literal -offset indent
+camcontrol cmd -n da -u 1 -c "00 00 00 00 00 v" 0x00 -v
+.Ed
+.Pp
+The sense information from the test unit ready command would not get
+printed out, since the first
+.Xr getopt 3
+call in
+.Nm
+bails out when it sees the second argument to
+.Fl c
+(0x00),
+above.
+Fixing this behavior would take some gross code, or changes to the
+.Xr getopt 3
+interface.
+The best way to circumvent this problem is to always make sure
+to specify generic
+.Nm
+arguments before any command-specific arguments.
--- a/sbin/camcontrol/camcontrol.c	
+++ b/sbin/camcontrol/camcontrol.c	
@@ -0,0 +1,4519 @@
+/*
+ * Copyright (c) 1997-2007 Kenneth D. Merry
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/ioctl.h>
+#include <sys/stdint.h>
+#include <sys/types.h>
+#include <sys/endian.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <err.h>
+#include <libutil.h>
+
+#include <cam/cam.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_ccb.h>
+#include <cam/scsi/scsi_all.h>
+#include <cam/scsi/scsi_da.h>
+#include <cam/scsi/scsi_pass.h>
+#include <cam/scsi/scsi_message.h>
+#include <cam/ata/ata_all.h>
+#include <camlib.h>
+#include "camcontrol.h"
+
+typedef enum {
+	CAM_CMD_NONE		= 0x00000000,
+	CAM_CMD_DEVLIST		= 0x00000001,
+	CAM_CMD_TUR		= 0x00000002,
+	CAM_CMD_INQUIRY		= 0x00000003,
+	CAM_CMD_STARTSTOP	= 0x00000004,
+	CAM_CMD_RESCAN		= 0x00000005,
+	CAM_CMD_READ_DEFECTS	= 0x00000006,
+	CAM_CMD_MODE_PAGE	= 0x00000007,
+	CAM_CMD_SCSI_CMD	= 0x00000008,
+	CAM_CMD_DEVTREE		= 0x00000009,
+	CAM_CMD_USAGE		= 0x0000000a,
+	CAM_CMD_DEBUG		= 0x0000000b,
+	CAM_CMD_RESET		= 0x0000000c,
+	CAM_CMD_FORMAT		= 0x0000000d,
+	CAM_CMD_TAG		= 0x0000000e,
+	CAM_CMD_RATE		= 0x0000000f,
+	CAM_CMD_DETACH		= 0x00000010,
+	CAM_CMD_REPORTLUNS	= 0x00000011,
+	CAM_CMD_READCAP		= 0x00000012,
+	CAM_CMD_IDENTIFY	= 0x00000013
+} cam_cmdmask;
+
+typedef enum {
+	CAM_ARG_NONE		= 0x00000000,
+	CAM_ARG_VERBOSE		= 0x00000001,
+	CAM_ARG_DEVICE		= 0x00000002,
+	CAM_ARG_BUS		= 0x00000004,
+	CAM_ARG_TARGET		= 0x00000008,
+	CAM_ARG_LUN		= 0x00000010,
+	CAM_ARG_EJECT		= 0x00000020,
+	CAM_ARG_UNIT		= 0x00000040,
+	CAM_ARG_FORMAT_BLOCK	= 0x00000080,
+	CAM_ARG_FORMAT_BFI	= 0x00000100,
+	CAM_ARG_FORMAT_PHYS	= 0x00000200,
+	CAM_ARG_PLIST		= 0x00000400,
+	CAM_ARG_GLIST		= 0x00000800,
+	CAM_ARG_GET_SERIAL	= 0x00001000,
+	CAM_ARG_GET_STDINQ	= 0x00002000,
+	CAM_ARG_GET_XFERRATE	= 0x00004000,
+	CAM_ARG_INQ_MASK	= 0x00007000,
+	CAM_ARG_MODE_EDIT	= 0x00008000,
+	CAM_ARG_PAGE_CNTL	= 0x00010000,
+	CAM_ARG_TIMEOUT		= 0x00020000,
+	CAM_ARG_CMD_IN		= 0x00040000,
+	CAM_ARG_CMD_OUT		= 0x00080000,
+	CAM_ARG_DBD		= 0x00100000,
+	CAM_ARG_ERR_RECOVER	= 0x00200000,
+	CAM_ARG_RETRIES		= 0x00400000,
+	CAM_ARG_START_UNIT	= 0x00800000,
+	CAM_ARG_DEBUG_INFO	= 0x01000000,
+	CAM_ARG_DEBUG_TRACE	= 0x02000000,
+	CAM_ARG_DEBUG_SUBTRACE	= 0x04000000,
+	CAM_ARG_DEBUG_CDB	= 0x08000000,
+	CAM_ARG_DEBUG_XPT	= 0x10000000,
+	CAM_ARG_DEBUG_PERIPH	= 0x20000000,
+} cam_argmask;
+
+struct camcontrol_opts {
+	const char	*optname;	
+	cam_cmdmask	cmdnum;
+	cam_argmask	argnum;
+	const char	*subopt;
+};
+
+#ifndef MINIMALISTIC
+static const char scsicmd_opts[] = "a:c:i:o:r";
+static const char readdefect_opts[] = "f:GP";
+static const char negotiate_opts[] = "acD:O:qR:T:UW:";
+#endif
+
+struct camcontrol_opts option_table[] = {
+#ifndef MINIMALISTIC
+	{"tur", CAM_CMD_TUR, CAM_ARG_NONE, NULL},
+	{"inquiry", CAM_CMD_INQUIRY, CAM_ARG_NONE, "DSR"},
+	{"identify", CAM_CMD_IDENTIFY, CAM_ARG_NONE, NULL},
+	{"start", CAM_CMD_STARTSTOP, CAM_ARG_START_UNIT, NULL},
+	{"stop", CAM_CMD_STARTSTOP, CAM_ARG_NONE, NULL},
+	{"load", CAM_CMD_STARTSTOP, CAM_ARG_START_UNIT | CAM_ARG_EJECT, NULL},
+	{"eject", CAM_CMD_STARTSTOP, CAM_ARG_EJECT, NULL},
+	{"reportluns", CAM_CMD_REPORTLUNS, CAM_ARG_NONE, "clr:"},
+	{"readcapacity", CAM_CMD_READCAP, CAM_ARG_NONE, "bhHNqs"},
+#endif /* MINIMALISTIC */
+	{"rescan", CAM_CMD_RESCAN, CAM_ARG_NONE, NULL},
+	{"reset", CAM_CMD_RESET, CAM_ARG_NONE, NULL},
+#ifndef MINIMALISTIC
+	{"cmd", CAM_CMD_SCSI_CMD, CAM_ARG_NONE, scsicmd_opts},
+	{"command", CAM_CMD_SCSI_CMD, CAM_ARG_NONE, scsicmd_opts},
+	{"defects", CAM_CMD_READ_DEFECTS, CAM_ARG_NONE, readdefect_opts},
+	{"defectlist", CAM_CMD_READ_DEFECTS, CAM_ARG_NONE, readdefect_opts},
+#endif /* MINIMALISTIC */
+	{"devlist", CAM_CMD_DEVTREE, CAM_ARG_NONE, NULL},
+#ifndef MINIMALISTIC
+	{"periphlist", CAM_CMD_DEVLIST, CAM_ARG_NONE, NULL},
+	{"modepage", CAM_CMD_MODE_PAGE, CAM_ARG_NONE, "bdelm:P:"},
+	{"tags", CAM_CMD_TAG, CAM_ARG_NONE, "N:q"},
+	{"negotiate", CAM_CMD_RATE, CAM_ARG_NONE, negotiate_opts},
+	{"rate", CAM_CMD_RATE, CAM_ARG_NONE, negotiate_opts},
+	{"debug", CAM_CMD_DEBUG, CAM_ARG_NONE, "IPTSXc"},
+	{"format", CAM_CMD_FORMAT, CAM_ARG_NONE, "qrwy"},
+#endif /* MINIMALISTIC */
+	{"help", CAM_CMD_USAGE, CAM_ARG_NONE, NULL},
+	{"-?", CAM_CMD_USAGE, CAM_ARG_NONE, NULL},
+	{"-h", CAM_CMD_USAGE, CAM_ARG_NONE, NULL},
+	{NULL, 0, 0, NULL}
+};
+
+typedef enum {
+	CC_OR_NOT_FOUND,
+	CC_OR_AMBIGUOUS,
+	CC_OR_FOUND
+} camcontrol_optret;
+
+cam_cmdmask cmdlist;
+cam_argmask arglist;
+
+
+camcontrol_optret getoption(char *arg, cam_cmdmask *cmdnum, cam_argmask *argnum,
+			    const char **subopt);
+#ifndef MINIMALISTIC
+static int getdevlist(struct cam_device *device);
+#endif /* MINIMALISTIC */
+static int getdevtree(void);
+#ifndef MINIMALISTIC
+static int testunitready(struct cam_device *device, int retry_count,
+			 int timeout, int quiet);
+static int scsistart(struct cam_device *device, int startstop, int loadeject,
+		     int retry_count, int timeout);
+static int scsidoinquiry(struct cam_device *device, int argc, char **argv,
+			 char *combinedopt, int retry_count, int timeout);
+static int scsiinquiry(struct cam_device *device, int retry_count, int timeout);
+static int scsiserial(struct cam_device *device, int retry_count, int timeout);
+static int scsixferrate(struct cam_device *device);
+#endif /* MINIMALISTIC */
+static int parse_btl(char *tstr, int *bus, int *target, int *lun,
+		     cam_argmask *arglst);
+static int dorescan_or_reset(int argc, char **argv, int rescan);
+static int rescan_or_reset_bus(int bus, int rescan);
+static int scanlun_or_reset_dev(int bus, int target, int lun, int scan);
+#ifndef MINIMALISTIC
+static int readdefects(struct cam_device *device, int argc, char **argv,
+		       char *combinedopt, int retry_count, int timeout);
+static void modepage(struct cam_device *device, int argc, char **argv,
+		     char *combinedopt, int retry_count, int timeout);
+static int scsicmd(struct cam_device *device, int argc, char **argv, 
+		   char *combinedopt, int retry_count, int timeout);
+static int tagcontrol(struct cam_device *device, int argc, char **argv,
+		      char *combinedopt);
+static void cts_print(struct cam_device *device,
+		      struct ccb_trans_settings *cts);
+static void cpi_print(struct ccb_pathinq *cpi);
+static int get_cpi(struct cam_device *device, struct ccb_pathinq *cpi);
+static int get_cgd(struct cam_device *device, struct ccb_getdev *cgd);
+static int get_print_cts(struct cam_device *device, int user_settings,
+			 int quiet, struct ccb_trans_settings *cts);
+static int ratecontrol(struct cam_device *device, int retry_count,
+		       int timeout, int argc, char **argv, char *combinedopt);
+static int scsiformat(struct cam_device *device, int argc, char **argv,
+		      char *combinedopt, int retry_count, int timeout);
+static int scsireportluns(struct cam_device *device, int argc, char **argv,
+			  char *combinedopt, int retry_count, int timeout);
+static int scsireadcapacity(struct cam_device *device, int argc, char **argv,
+			    char *combinedopt, int retry_count, int timeout);
+#endif /* MINIMALISTIC */
+
+camcontrol_optret
+getoption(char *arg, cam_cmdmask *cmdnum, cam_argmask *argnum, 
+	  const char **subopt)
+{
+	struct camcontrol_opts *opts;
+	int num_matches = 0;
+
+	for (opts = option_table; (opts != NULL) && (opts->optname != NULL);
+	     opts++) {
+		if (strncmp(opts->optname, arg, strlen(arg)) == 0) {
+			*cmdnum = opts->cmdnum;
+			*argnum = opts->argnum;
+			*subopt = opts->subopt;
+			if (++num_matches > 1)
+				return(CC_OR_AMBIGUOUS);
+		}
+	}
+
+	if (num_matches > 0)
+		return(CC_OR_FOUND);
+	else
+		return(CC_OR_NOT_FOUND);
+}
+
+#ifndef MINIMALISTIC
+static int
+getdevlist(struct cam_device *device)
+{
+	union ccb *ccb;
+	char status[32];
+	int error = 0;
+
+	ccb = cam_getccb(device);
+
+	ccb->ccb_h.func_code = XPT_GDEVLIST;
+	ccb->ccb_h.flags = CAM_DIR_NONE;
+	ccb->ccb_h.retry_count = 1;
+	ccb->cgdl.index = 0;
+	ccb->cgdl.status = CAM_GDEVLIST_MORE_DEVS;
+	while (ccb->cgdl.status == CAM_GDEVLIST_MORE_DEVS) {
+		if (cam_send_ccb(device, ccb) < 0) {
+			perror("error getting device list");
+			cam_freeccb(ccb);
+			return(1);
+		}
+
+		status[0] = '\0';
+
+		switch (ccb->cgdl.status) {
+			case CAM_GDEVLIST_MORE_DEVS:
+				strcpy(status, "MORE");
+				break;
+			case CAM_GDEVLIST_LAST_DEVICE:
+				strcpy(status, "LAST");
+				break;
+			case CAM_GDEVLIST_LIST_CHANGED:
+				strcpy(status, "CHANGED");
+				break;
+			case CAM_GDEVLIST_ERROR:
+				strcpy(status, "ERROR");
+				error = 1;
+				break;
+		}
+
+		fprintf(stdout, "%s%d:  generation: %d index: %d status: %s\n",
+			ccb->cgdl.periph_name,
+			ccb->cgdl.unit_number,
+			ccb->cgdl.generation,
+			ccb->cgdl.index,
+			status);
+
+		/*
+		 * If the list has changed, we need to start over from the
+		 * beginning.
+		 */
+		if (ccb->cgdl.status == CAM_GDEVLIST_LIST_CHANGED)
+			ccb->cgdl.index = 0;
+	}
+
+	cam_freeccb(ccb);
+
+	return(error);
+}
+#endif /* MINIMALISTIC */
+
+static int
+getdevtree(void)
+{
+	union ccb ccb;
+	int bufsize, fd;
+	unsigned int i;
+	int need_close = 0;
+	int error = 0;
+	int skip_device = 0;
+
+	if ((fd = open(XPT_DEVICE, O_RDWR)) == -1) {
+		warn("couldn't open %s", XPT_DEVICE);
+		return(1);
+	}
+
+	bzero(&ccb, sizeof(union ccb));
+
+	ccb.ccb_h.path_id = CAM_XPT_PATH_ID;
+	ccb.ccb_h.target_id = CAM_TARGET_WILDCARD;
+	ccb.ccb_h.target_lun = CAM_LUN_WILDCARD;
+
+	ccb.ccb_h.func_code = XPT_DEV_MATCH;
+	bufsize = sizeof(struct dev_match_result) * 100;
+	ccb.cdm.match_buf_len = bufsize;
+	ccb.cdm.matches = (struct dev_match_result *)malloc(bufsize);
+	if (ccb.cdm.matches == NULL) {
+		warnx("can't malloc memory for matches");
+		close(fd);
+		return(1);
+	}
+	ccb.cdm.num_matches = 0;
+
+	/*
+	 * We fetch all nodes, since we display most of them in the default
+	 * case, and all in the verbose case.
+	 */
+	ccb.cdm.num_patterns = 0;
+	ccb.cdm.pattern_buf_len = 0;
+
+	/*
+	 * We do the ioctl multiple times if necessary, in case there are
+	 * more than 100 nodes in the EDT.
+	 */
+	do {
+		if (ioctl(fd, CAMIOCOMMAND, &ccb) == -1) {
+			warn("error sending CAMIOCOMMAND ioctl");
+			error = 1;
+			break;
+		}
+
+		if ((ccb.ccb_h.status != CAM_REQ_CMP)
+		 || ((ccb.cdm.status != CAM_DEV_MATCH_LAST)
+		    && (ccb.cdm.status != CAM_DEV_MATCH_MORE))) {
+			warnx("got CAM error %#x, CDM error %d\n",
+			      ccb.ccb_h.status, ccb.cdm.status);
+			error = 1;
+			break;
+		}
+
+		for (i = 0; i < ccb.cdm.num_matches; i++) {
+			switch (ccb.cdm.matches[i].type) {
+			case DEV_MATCH_BUS: {
+				struct bus_match_result *bus_result;
+
+				/*
+				 * Only print the bus information if the
+				 * user turns on the verbose flag.
+				 */
+				if ((arglist & CAM_ARG_VERBOSE) == 0)
+					break;
+
+				bus_result =
+					&ccb.cdm.matches[i].result.bus_result;
+
+				if (need_close) {
+					fprintf(stdout, ")\n");
+					need_close = 0;
+				}
+
+				fprintf(stdout, "scbus%d on %s%d bus %d:\n",
+					bus_result->path_id,
+					bus_result->dev_name,
+					bus_result->unit_number,
+					bus_result->bus_id);
+				break;
+			}
+			case DEV_MATCH_DEVICE: {
+				struct device_match_result *dev_result;
+				char vendor[16], product[48], revision[16];
+				char tmpstr[256];
+
+				dev_result =
+				     &ccb.cdm.matches[i].result.device_result;
+
+				if ((dev_result->flags
+				     & DEV_RESULT_UNCONFIGURED)
+				 && ((arglist & CAM_ARG_VERBOSE) == 0)) {
+					skip_device = 1;
+					break;
+				} else
+					skip_device = 0;
+
+				if (dev_result->protocol == PROTO_SCSI) {
+				    cam_strvis(vendor, dev_result->inq_data.vendor,
+					   sizeof(dev_result->inq_data.vendor),
+					   sizeof(vendor));
+				    cam_strvis(product,
+					   dev_result->inq_data.product,
+					   sizeof(dev_result->inq_data.product),
+					   sizeof(product));
+				    cam_strvis(revision,
+					   dev_result->inq_data.revision,
+					  sizeof(dev_result->inq_data.revision),
+					   sizeof(revision));
+				    sprintf(tmpstr, "<%s %s %s>", vendor, product,
+					revision);
+				} else if (dev_result->protocol == PROTO_ATA ||
+				    dev_result->protocol == PROTO_SATAPM) {
+				    cam_strvis(product,
+					   dev_result->ident_data.model,
+					   sizeof(dev_result->ident_data.model),
+					   sizeof(product));
+				    cam_strvis(revision,
+					   dev_result->ident_data.revision,
+					  sizeof(dev_result->ident_data.revision),
+					   sizeof(revision));
+				    sprintf(tmpstr, "<%s %s>", product,
+					revision);
+				} else {
+				    sprintf(tmpstr, "<>");
+				}
+				if (need_close) {
+					fprintf(stdout, ")\n");
+					need_close = 0;
+				}
+
+				fprintf(stdout, "%-33s  at scbus%d "
+					"target %d lun %d (",
+					tmpstr,
+					dev_result->path_id,
+					dev_result->target_id,
+					dev_result->target_lun);
+
+				need_close = 1;
+
+				break;
+			}
+			case DEV_MATCH_PERIPH: {
+				struct periph_match_result *periph_result;
+
+				periph_result =
+				      &ccb.cdm.matches[i].result.periph_result;
+
+				if (skip_device != 0)
+					break;
+
+				if (need_close > 1)
+					fprintf(stdout, ",");
+
+				fprintf(stdout, "%s%d",
+					periph_result->periph_name,
+					periph_result->unit_number);
+
+				need_close++;
+				break;
+			}
+			default:
+				fprintf(stdout, "unknown match type\n");
+				break;
+			}
+		}
+
+	} while ((ccb.ccb_h.status == CAM_REQ_CMP)
+		&& (ccb.cdm.status == CAM_DEV_MATCH_MORE));
+
+	if (need_close)
+		fprintf(stdout, ")\n");
+
+	close(fd);
+
+	return(error);
+}
+
+#ifndef MINIMALISTIC
+static int
+testunitready(struct cam_device *device, int retry_count, int timeout,
+	      int quiet)
+{
+	int error = 0;
+	union ccb *ccb;
+
+	ccb = cam_getccb(device);
+
+	scsi_test_unit_ready(&ccb->csio,
+			     /* retries */ retry_count,
+			     /* cbfcnp */ NULL,
+			     /* tag_action */ MSG_SIMPLE_Q_TAG,
+			     /* sense_len */ SSD_FULL_SIZE,
+			     /* timeout */ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		if (quiet == 0)
+			perror("error sending test unit ready");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		cam_freeccb(ccb);
+		return(1);
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP) {
+		if (quiet == 0)
+			fprintf(stdout, "Unit is ready\n");
+	} else {
+		if (quiet == 0)
+			fprintf(stdout, "Unit is not ready\n");
+		error = 1;
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+	}
+
+	cam_freeccb(ccb);
+
+	return(error);
+}
+
+static int
+scsistart(struct cam_device *device, int startstop, int loadeject,
+	  int retry_count, int timeout)
+{
+	union ccb *ccb;
+	int error = 0;
+
+	ccb = cam_getccb(device);
+
+	/*
+	 * If we're stopping, send an ordered tag so the drive in question
+	 * will finish any previously queued writes before stopping.  If
+	 * the device isn't capable of tagged queueing, or if tagged
+	 * queueing is turned off, the tag action is a no-op.
+	 */
+	scsi_start_stop(&ccb->csio,
+			/* retries */ retry_count,
+			/* cbfcnp */ NULL,
+			/* tag_action */ startstop ? MSG_SIMPLE_Q_TAG :
+						     MSG_ORDERED_Q_TAG,
+			/* start/stop */ startstop,
+			/* load_eject */ loadeject,
+			/* immediate */ 0,
+			/* sense_len */ SSD_FULL_SIZE,
+			/* timeout */ timeout ? timeout : 120000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending start unit");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		cam_freeccb(ccb);
+		return(1);
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)
+		if (startstop) {
+			fprintf(stdout, "Unit started successfully");
+			if (loadeject)
+				fprintf(stdout,", Media loaded\n");
+			else
+				fprintf(stdout,"\n");
+		} else {
+			fprintf(stdout, "Unit stopped successfully");
+			if (loadeject)
+				fprintf(stdout, ", Media ejected\n");
+			else
+				fprintf(stdout, "\n");
+		}
+	else {
+		error = 1;
+		if (startstop)
+			fprintf(stdout,
+				"Error received from start unit command\n");
+		else
+			fprintf(stdout,
+				"Error received from stop unit command\n");
+			
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+	}
+
+	cam_freeccb(ccb);
+
+	return(error);
+}
+
+static int
+scsidoinquiry(struct cam_device *device, int argc, char **argv,
+	      char *combinedopt, int retry_count, int timeout)
+{
+	int c;
+	int error = 0;
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'D':
+			arglist |= CAM_ARG_GET_STDINQ;
+			break;
+		case 'R':
+			arglist |= CAM_ARG_GET_XFERRATE;
+			break;
+		case 'S':
+			arglist |= CAM_ARG_GET_SERIAL;
+			break;
+		default:
+			break;
+		}
+	}
+
+	/*
+	 * If the user didn't specify any inquiry options, he wants all of
+	 * them.
+	 */
+	if ((arglist & CAM_ARG_INQ_MASK) == 0)
+		arglist |= CAM_ARG_INQ_MASK;
+
+	if (arglist & CAM_ARG_GET_STDINQ)
+		error = scsiinquiry(device, retry_count, timeout);
+
+	if (error != 0)
+		return(error);
+
+	if (arglist & CAM_ARG_GET_SERIAL)
+		scsiserial(device, retry_count, timeout);
+
+	if (error != 0)
+		return(error);
+
+	if (arglist & CAM_ARG_GET_XFERRATE)
+		error = scsixferrate(device);
+
+	return(error);
+}
+
+static int
+scsiinquiry(struct cam_device *device, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	struct scsi_inquiry_data *inq_buf;
+	int error = 0;
+	
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("couldn't allocate CCB");
+		return(1);
+	}
+
+	/* cam_getccb cleans up the header, caller has to zero the payload */
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	inq_buf = (struct scsi_inquiry_data *)malloc(
+		sizeof(struct scsi_inquiry_data));
+
+	if (inq_buf == NULL) {
+		cam_freeccb(ccb);
+		warnx("can't malloc memory for inquiry\n");
+		return(1);
+	}
+	bzero(inq_buf, sizeof(*inq_buf));
+
+	/*
+	 * Note that although the size of the inquiry buffer is the full
+	 * 256 bytes specified in the SCSI spec, we only tell the device
+	 * that we have allocated SHORT_INQUIRY_LENGTH bytes.  There are
+	 * two reasons for this:
+	 *
+	 *  - The SCSI spec says that when a length field is only 1 byte,
+	 *    a value of 0 will be interpreted as 256.  Therefore
+	 *    scsi_inquiry() will convert an inq_len (which is passed in as
+	 *    a u_int32_t, but the field in the CDB is only 1 byte) of 256
+	 *    to 0.  Evidently, very few devices meet the spec in that
+	 *    regard.  Some devices, like many Seagate disks, take the 0 as 
+	 *    0, and don't return any data.  One Pioneer DVD-R drive
+	 *    returns more data than the command asked for.
+	 *
+	 *    So, since there are numerous devices that just don't work
+	 *    right with the full inquiry size, we don't send the full size.
+	 * 
+	 *  - The second reason not to use the full inquiry data length is
+	 *    that we don't need it here.  The only reason we issue a
+	 *    standard inquiry is to get the vendor name, device name,
+	 *    and revision so scsi_print_inquiry() can print them.
+	 *
+	 * If, at some point in the future, more inquiry data is needed for
+	 * some reason, this code should use a procedure similar to the
+	 * probe code.  i.e., issue a short inquiry, and determine from
+	 * the additional length passed back from the device how much
+	 * inquiry data the device supports.  Once the amount the device
+	 * supports is determined, issue an inquiry for that amount and no
+	 * more.
+	 *
+	 * KDM, 2/18/2000
+	 */
+	scsi_inquiry(&ccb->csio,
+		     /* retries */ retry_count,
+		     /* cbfcnp */ NULL,
+		     /* tag_action */ MSG_SIMPLE_Q_TAG,
+		     /* inq_buf */ (u_int8_t *)inq_buf,
+		     /* inq_len */ SHORT_INQUIRY_LENGTH,
+		     /* evpd */ 0,
+		     /* page_code */ 0,
+		     /* sense_len */ SSD_FULL_SIZE,
+		     /* timeout */ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending SCSI inquiry");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		cam_freeccb(ccb);
+		return(1);
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		error = 1;
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+	}
+
+	cam_freeccb(ccb);
+
+	if (error != 0) {
+		free(inq_buf);
+		return(error);
+	}
+
+	fprintf(stdout, "%s%d: ", device->device_name,
+		device->dev_unit_num);
+	scsi_print_inquiry(inq_buf);
+
+	free(inq_buf);
+
+	return(0);
+}
+
+static int
+scsiserial(struct cam_device *device, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	struct scsi_vpd_unit_serial_number *serial_buf;
+	char serial_num[SVPD_SERIAL_NUM_SIZE + 1];
+	int error = 0;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("couldn't allocate CCB");
+		return(1);
+	}
+
+	/* cam_getccb cleans up the header, caller has to zero the payload */
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	serial_buf = (struct scsi_vpd_unit_serial_number *)
+		malloc(sizeof(*serial_buf));
+
+	if (serial_buf == NULL) {
+		cam_freeccb(ccb);
+		warnx("can't malloc memory for serial number");
+		return(1);
+	}
+
+	scsi_inquiry(&ccb->csio,
+		     /*retries*/ retry_count,
+		     /*cbfcnp*/ NULL,
+		     /* tag_action */ MSG_SIMPLE_Q_TAG,
+		     /* inq_buf */ (u_int8_t *)serial_buf,
+		     /* inq_len */ sizeof(*serial_buf),
+		     /* evpd */ 1,
+		     /* page_code */ SVPD_UNIT_SERIAL_NUMBER,
+		     /* sense_len */ SSD_FULL_SIZE,
+		     /* timeout */ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("error getting serial number");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		cam_freeccb(ccb);
+		free(serial_buf);
+		return(1);
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		error = 1;
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+	}
+
+	cam_freeccb(ccb);
+
+	if (error != 0) {
+		free(serial_buf);
+		return(error);
+	}
+
+	bcopy(serial_buf->serial_num, serial_num, serial_buf->length);
+	serial_num[serial_buf->length] = '\0';
+
+	if ((arglist & CAM_ARG_GET_STDINQ)
+	 || (arglist & CAM_ARG_GET_XFERRATE))
+		fprintf(stdout, "%s%d: Serial Number ",
+			device->device_name, device->dev_unit_num);
+
+	fprintf(stdout, "%.60s\n", serial_num);
+
+	free(serial_buf);
+
+	return(0);
+}
+
+static int
+scsixferrate(struct cam_device *device)
+{
+	u_int32_t freq = 0;
+	u_int32_t speed = 0;
+	union ccb *ccb;
+	u_int mb;
+	int retval = 0;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("couldn't allocate CCB");
+		return(1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_trans_settings) - sizeof(struct ccb_hdr));
+
+	ccb->ccb_h.func_code = XPT_GET_TRAN_SETTINGS;
+	ccb->cts.type = CTS_TYPE_CURRENT_SETTINGS;
+
+	if (((retval = cam_send_ccb(device, ccb)) < 0)
+	 || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		const char error_string[] = "error getting transfer settings";
+
+		if (retval < 0)
+			warn(error_string);
+		else
+			warnx(error_string);
+
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+
+		retval = 1;
+
+		goto xferrate_bailout;
+
+	}
+
+	if (ccb->cts.transport == XPORT_SPI) {
+		struct ccb_trans_settings_spi *spi =
+		    &ccb->cts.xport_specific.spi;
+
+		if ((spi->valid & CTS_SPI_VALID_SYNC_RATE) != 0) {
+			freq = scsi_calc_syncsrate(spi->sync_period);
+			speed = freq;
+		} else {
+			struct ccb_pathinq cpi;
+
+			retval = get_cpi(device, &cpi);
+			if (retval == 0) {
+				speed = cpi.base_transfer_speed;
+				freq = 0;
+			}
+		}
+
+		fprintf(stdout, "%s%d: ", device->device_name,
+			device->dev_unit_num);
+
+		if ((spi->valid & CTS_SPI_VALID_BUS_WIDTH) != 0) {
+			speed *= (0x01 << spi->bus_width);
+		}
+
+		mb = speed / 1000;
+
+		if (mb > 0) 
+			fprintf(stdout, "%d.%03dMB/s transfers ",
+				mb, speed % 1000);
+		else
+			fprintf(stdout, "%dKB/s transfers ",
+				speed);
+
+		if (((spi->valid & CTS_SPI_VALID_SYNC_OFFSET) != 0)
+		 && (spi->sync_offset != 0))
+			fprintf(stdout, "(%d.%03dMHz, offset %d", freq / 1000,
+				freq % 1000, spi->sync_offset);
+
+		if (((spi->valid & CTS_SPI_VALID_BUS_WIDTH) != 0)
+		 && (spi->bus_width > 0)) {
+			if (((spi->valid & CTS_SPI_VALID_SYNC_OFFSET) != 0)
+			 && (spi->sync_offset != 0)) {
+				fprintf(stdout, ", ");
+			} else {
+				fprintf(stdout, " (");
+			}
+			fprintf(stdout, "%dbit)", 8 * (0x01 << spi->bus_width));
+		} else if (((spi->valid & CTS_SPI_VALID_SYNC_OFFSET) != 0)
+		 && (spi->sync_offset != 0)) {
+			fprintf(stdout, ")");
+		}
+	} else {
+		struct ccb_pathinq cpi;
+
+		retval = get_cpi(device, &cpi);
+
+		if (retval != 0)
+			goto xferrate_bailout;
+
+		speed = cpi.base_transfer_speed;
+		freq = 0;
+
+		mb = speed / 1000;
+
+		if (mb > 0) 
+			fprintf(stdout, "%d.%03dMB/s transfers ",
+				mb, speed % 1000);
+		else
+			fprintf(stdout, "%dKB/s transfers ",
+				speed);
+	}
+
+	if (ccb->cts.protocol == PROTO_SCSI) {
+		struct ccb_trans_settings_scsi *scsi =
+		    &ccb->cts.proto_specific.scsi;
+		if (scsi->valid & CTS_SCSI_VALID_TQ) {
+			if (scsi->flags & CTS_SCSI_FLAGS_TAG_ENB) {
+				fprintf(stdout, ", Command Queueing Enabled");
+			}
+		}
+	}
+
+        fprintf(stdout, "\n");
+
+xferrate_bailout:
+
+	cam_freeccb(ccb);
+
+	return(retval);
+}
+
+static void
+atacapprint(struct ata_params *parm)
+{
+	u_int32_t lbasize = (u_int32_t)parm->lba_size_1 |
+				((u_int32_t)parm->lba_size_2 << 16);
+
+	u_int64_t lbasize48 = ((u_int64_t)parm->lba_size48_1) |
+				((u_int64_t)parm->lba_size48_2 << 16) |
+				((u_int64_t)parm->lba_size48_3 << 32) |
+				((u_int64_t)parm->lba_size48_4 << 48);
+
+	printf("\n");
+	printf("protocol              ");
+	printf("ATA/ATAPI-%d", ata_version(parm->version_major));
+	if (parm->satacapabilities && parm->satacapabilities != 0xffff) {
+		if (parm->satacapabilities & ATA_SATA_GEN2)
+			printf(" SATA 2.x\n");
+		else if (parm->satacapabilities & ATA_SATA_GEN1)
+			printf(" SATA 1.x\n");
+		else
+			printf(" SATA x.x\n");
+	}
+	else
+		printf("\n");
+	printf("device model          %.40s\n", parm->model);
+	printf("serial number         %.20s\n", parm->serial);
+	printf("firmware revision     %.8s\n", parm->revision);
+
+	printf("cylinders             %d\n", parm->cylinders);
+	printf("heads                 %d\n", parm->heads);
+	printf("sectors/track         %d\n", parm->sectors);
+
+	if (parm->config == ATA_PROTO_CFA ||
+	    (parm->support.command2 & ATA_SUPPORT_CFA))
+		printf("CFA supported\n");
+
+	printf("LBA%ssupported         ",
+		parm->capabilities1 & ATA_SUPPORT_LBA ? " " : " not ");
+	if (lbasize)
+		printf("%d sectors\n", lbasize);
+	else
+		printf("\n");
+
+	printf("LBA48%ssupported       ",
+		parm->support.command2 & ATA_SUPPORT_ADDRESS48 ? " " : " not ");
+	if (lbasize48)
+		printf("%ju sectors\n", (uintmax_t)lbasize48);
+	else
+		printf("\n");
+
+	printf("PIO supported         PIO");
+	if (parm->atavalid & ATA_FLAG_64_70) {
+		if (parm->apiomodes & 0x02)
+			printf("4");
+		else if (parm->apiomodes & 0x01)
+			printf("3");
+	} else if (parm->mwdmamodes & 0x04)
+		printf("4");
+	else if (parm->mwdmamodes & 0x02)
+		printf("3");
+	else if (parm->mwdmamodes & 0x01)
+		printf("2");
+	else if ((parm->retired_piomode & ATA_RETIRED_PIO_MASK) == 0x200)
+		printf("2");
+	else if ((parm->retired_piomode & ATA_RETIRED_PIO_MASK) == 0x100)
+		printf("1");
+	else
+		printf("0");
+	printf("\n");
+
+	printf("DMA%ssupported         ",
+		parm->capabilities1 & ATA_SUPPORT_DMA ? " " : " not ");
+	if (parm->capabilities1 & ATA_SUPPORT_DMA) {
+		if (parm->mwdmamodes & 0xff) {
+			printf("WDMA");
+			if (parm->mwdmamodes & 0x04)
+				printf("2");
+			else if (parm->mwdmamodes & 0x02)
+				printf("1");
+			else if (parm->mwdmamodes & 0x01)
+				printf("0");
+			printf(" ");
+		}
+		if ((parm->atavalid & ATA_FLAG_88) &&
+		    (parm->udmamodes & 0xff)) {
+			printf("UDMA");
+			if (parm->udmamodes & 0x40)
+				printf("6");
+			else if (parm->udmamodes & 0x20)
+				printf("5");
+			else if (parm->udmamodes & 0x10)
+				printf("4");
+			else if (parm->udmamodes & 0x08)
+				printf("3");
+			else if (parm->udmamodes & 0x04)
+				printf("2");
+			else if (parm->udmamodes & 0x02)
+				printf("1");
+			else if (parm->udmamodes & 0x01)
+				printf("0");
+			printf(" ");
+		}
+	}
+	printf("\n");
+
+	printf("overlap%ssupported\n",
+		parm->capabilities1 & ATA_SUPPORT_OVERLAP ? " " : " not ");
+
+	printf("\nFeature                      "
+		"Support  Enable    Value           Vendor\n");
+
+	printf("write cache                    %s	%s\n",
+		parm->support.command1 & ATA_SUPPORT_WRITECACHE ? "yes" : "no",
+		parm->enabled.command1 & ATA_SUPPORT_WRITECACHE ? "yes" : "no");
+
+	printf("read ahead                     %s	%s\n",
+		parm->support.command1 & ATA_SUPPORT_LOOKAHEAD ? "yes" : "no",
+		parm->enabled.command1 & ATA_SUPPORT_LOOKAHEAD ? "yes" : "no");
+
+	if (parm->satacapabilities && parm->satacapabilities != 0xffff) {
+		printf("Native Command Queuing (NCQ)   %s	"
+			"	%d/0x%02X\n",
+			parm->satacapabilities & ATA_SUPPORT_NCQ ?
+				"yes" : "no",
+			(parm->satacapabilities & ATA_SUPPORT_NCQ) ?
+				ATA_QUEUE_LEN(parm->queue) : 0,
+			(parm->satacapabilities & ATA_SUPPORT_NCQ) ?
+				ATA_QUEUE_LEN(parm->queue) : 0);
+	}
+	printf("Tagged Command Queuing (TCQ)   %s	%s	%d/0x%02X\n",
+		parm->support.command2 & ATA_SUPPORT_QUEUED ? "yes" : "no",
+		parm->enabled.command2 & ATA_SUPPORT_QUEUED ? "yes" : "no",
+		ATA_QUEUE_LEN(parm->queue), ATA_QUEUE_LEN(parm->queue));
+
+	printf("SMART                          %s	%s\n",
+		parm->support.command1 & ATA_SUPPORT_SMART ? "yes" : "no",
+		parm->enabled.command1 & ATA_SUPPORT_SMART ? "yes" : "no");
+
+	printf("microcode download             %s	%s\n",
+		parm->support.command2 & ATA_SUPPORT_MICROCODE ? "yes" : "no",
+		parm->enabled.command2 & ATA_SUPPORT_MICROCODE ? "yes" : "no");
+
+	printf("security                       %s	%s\n",
+		parm->support.command1 & ATA_SUPPORT_SECURITY ? "yes" : "no",
+		parm->enabled.command1 & ATA_SUPPORT_SECURITY ? "yes" : "no");
+
+	printf("power management               %s	%s\n",
+		parm->support.command1 & ATA_SUPPORT_POWERMGT ? "yes" : "no",
+		parm->enabled.command1 & ATA_SUPPORT_POWERMGT ? "yes" : "no");
+
+	printf("advanced power management      %s	%s	%d/0x%02X\n",
+		parm->support.command2 & ATA_SUPPORT_APM ? "yes" : "no",
+		parm->enabled.command2 & ATA_SUPPORT_APM ? "yes" : "no",
+		parm->apm_value, parm->apm_value);
+
+	printf("automatic acoustic management  %s	%s	"
+		"%d/0x%02X	%d/0x%02X\n",
+		parm->support.command2 & ATA_SUPPORT_AUTOACOUSTIC ? "yes" :"no",
+		parm->enabled.command2 & ATA_SUPPORT_AUTOACOUSTIC ? "yes" :"no",
+		ATA_ACOUSTIC_CURRENT(parm->acoustic),
+		ATA_ACOUSTIC_CURRENT(parm->acoustic),
+		ATA_ACOUSTIC_VENDOR(parm->acoustic),
+		ATA_ACOUSTIC_VENDOR(parm->acoustic));
+}
+
+
+static int
+ataidentify(struct cam_device *device, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	struct ata_params *ident_buf;
+	struct ccb_getdev cgd;
+	u_int i, error = 0;
+	int16_t *ptr;
+
+	if (get_cgd(device, &cgd) != 0) {
+		warnx("couldn't get CGD");
+		return(1);
+	}
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("couldn't allocate CCB");
+		return(1);
+	}
+
+	/* cam_getccb cleans up the header, caller has to zero the payload */
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_ataio) - sizeof(struct ccb_hdr));
+
+	ptr = (uint16_t *)malloc(sizeof(struct ata_params));
+
+	if (ptr == NULL) {
+		cam_freeccb(ccb);
+		warnx("can't malloc memory for identify\n");
+		return(1);
+	}
+	bzero(ptr, sizeof(struct ata_params));
+
+	cam_fill_ataio(&ccb->ataio,
+		      retry_count,
+		      NULL,
+		      /*flags*/CAM_DIR_IN,
+		      MSG_SIMPLE_Q_TAG,
+		      /*data_ptr*/(u_int8_t *)ptr,
+		      /*dxfer_len*/sizeof(struct ata_params),
+		      timeout ? timeout : 30 * 1000);
+	if (cgd.protocol == PROTO_ATA)
+		ata_28bit_cmd(&ccb->ataio, ATA_ATA_IDENTIFY, 0, 0, 0);
+	else
+		ata_28bit_cmd(&ccb->ataio, ATA_ATAPI_IDENTIFY, 0, 0, 0);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending ATA identify");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		free(ptr);
+		cam_freeccb(ccb);
+		return(1);
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		error = 1;
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+	}
+
+	cam_freeccb(ccb);
+
+	if (error != 0) {
+		free(ptr);
+		return(error);
+	}
+
+	for (i = 0; i < sizeof(struct ata_params) / 2; i++)
+		ptr[i] = le16toh(ptr[i]);
+	ident_buf = (struct ata_params *)ptr;
+
+	if (strncmp(ident_buf->model, "FX", 2) &&
+	    strncmp(ident_buf->model, "NEC", 3) &&
+	    strncmp(ident_buf->model, "Pioneer", 7) &&
+	    strncmp(ident_buf->model, "SHARP", 5)) {
+		ata_bswap(ident_buf->model, sizeof(ident_buf->model));
+		ata_bswap(ident_buf->revision, sizeof(ident_buf->revision));
+		ata_bswap(ident_buf->serial, sizeof(ident_buf->serial));
+	}
+	ata_btrim(ident_buf->model, sizeof(ident_buf->model));
+	ata_bpack(ident_buf->model, ident_buf->model, sizeof(ident_buf->model));
+	ata_btrim(ident_buf->revision, sizeof(ident_buf->revision));
+	ata_bpack(ident_buf->revision, ident_buf->revision, sizeof(ident_buf->revision));
+	ata_btrim(ident_buf->serial, sizeof(ident_buf->serial));
+	ata_bpack(ident_buf->serial, ident_buf->serial, sizeof(ident_buf->serial));
+
+	fprintf(stdout, "%s%d: ", device->device_name,
+		device->dev_unit_num);
+	ata_print_ident(ident_buf);
+	atacapprint(ident_buf);
+
+	free(ident_buf);
+
+	return(0);
+}
+#endif /* MINIMALISTIC */
+
+/*
+ * Parse out a bus, or a bus, target and lun in the following
+ * format:
+ * bus
+ * bus:target
+ * bus:target:lun
+ *
+ * Returns the number of parsed components, or 0.
+ */
+static int
+parse_btl(char *tstr, int *bus, int *target, int *lun, cam_argmask *arglst)
+{
+	char *tmpstr;
+	int convs = 0;
+
+	while (isspace(*tstr) && (*tstr != '\0'))
+		tstr++;
+
+	tmpstr = (char *)strtok(tstr, ":");
+	if ((tmpstr != NULL) && (*tmpstr != '\0')) {
+		*bus = strtol(tmpstr, NULL, 0);
+		*arglst |= CAM_ARG_BUS;
+		convs++;
+		tmpstr = (char *)strtok(NULL, ":");
+		if ((tmpstr != NULL) && (*tmpstr != '\0')) {
+			*target = strtol(tmpstr, NULL, 0);
+			*arglst |= CAM_ARG_TARGET;
+			convs++;
+			tmpstr = (char *)strtok(NULL, ":");
+			if ((tmpstr != NULL) && (*tmpstr != '\0')) {
+				*lun = strtol(tmpstr, NULL, 0);
+				*arglst |= CAM_ARG_LUN;
+				convs++;
+			}
+		}
+	}
+
+	return convs;
+}
+
+static int
+dorescan_or_reset(int argc, char **argv, int rescan)
+{
+	static const char must[] =
+		"you must specify \"all\", a bus, or a bus:target:lun to %s";
+	int rv, error = 0;
+	int bus = -1, target = -1, lun = -1;
+	char *tstr;
+
+	if (argc < 3) {
+		warnx(must, rescan? "rescan" : "reset");
+		return(1);
+	}
+
+	tstr = argv[optind];
+	while (isspace(*tstr) && (*tstr != '\0'))
+		tstr++;
+	if (strncasecmp(tstr, "all", strlen("all")) == 0)
+		arglist |= CAM_ARG_BUS;
+	else {
+		rv = parse_btl(argv[optind], &bus, &target, &lun, &arglist);
+		if (rv != 1 && rv != 3) {
+			warnx(must, rescan? "rescan" : "reset");
+			return(1);
+		}
+	}
+
+	if ((arglist & CAM_ARG_BUS)
+	    && (arglist & CAM_ARG_TARGET)
+	    && (arglist & CAM_ARG_LUN))
+		error = scanlun_or_reset_dev(bus, target, lun, rescan);
+	else
+		error = rescan_or_reset_bus(bus, rescan);
+
+	return(error);
+}
+
+static int
+rescan_or_reset_bus(int bus, int rescan)
+{
+	union ccb ccb, matchccb;
+	int fd, retval;
+	int bufsize;
+
+	retval = 0;
+
+	if ((fd = open(XPT_DEVICE, O_RDWR)) < 0) {
+		warnx("error opening transport layer device %s", XPT_DEVICE);
+		warn("%s", XPT_DEVICE);
+		return(1);
+	}
+
+	if (bus != -1) {
+		ccb.ccb_h.func_code = rescan ? XPT_SCAN_BUS : XPT_RESET_BUS;
+		ccb.ccb_h.path_id = bus;
+		ccb.ccb_h.target_id = CAM_TARGET_WILDCARD;
+		ccb.ccb_h.target_lun = CAM_LUN_WILDCARD;
+		ccb.crcn.flags = CAM_FLAG_NONE;
+
+		/* run this at a low priority */
+		ccb.ccb_h.pinfo.priority = 5;
+
+		if (ioctl(fd, CAMIOCOMMAND, &ccb) == -1) {
+			warn("CAMIOCOMMAND ioctl failed");
+			close(fd);
+			return(1);
+		}
+
+		if ((ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP) {
+			fprintf(stdout, "%s of bus %d was successful\n",
+			    rescan ? "Re-scan" : "Reset", bus);
+		} else {
+			fprintf(stdout, "%s of bus %d returned error %#x\n",
+				rescan ? "Re-scan" : "Reset", bus,
+				ccb.ccb_h.status & CAM_STATUS_MASK);
+			retval = 1;
+		}
+
+		close(fd);
+		return(retval);
+
+	}
+
+
+	/*
+	 * The right way to handle this is to modify the xpt so that it can
+	 * handle a wildcarded bus in a rescan or reset CCB.  At the moment
+	 * that isn't implemented, so instead we enumerate the busses and
+	 * send the rescan or reset to those busses in the case where the
+	 * given bus is -1 (wildcard).  We don't send a rescan or reset
+	 * to the xpt bus; sending a rescan to the xpt bus is effectively a
+	 * no-op, sending a rescan to the xpt bus would result in a status of
+	 * CAM_REQ_INVALID.
+	 */
+	bzero(&(&matchccb.ccb_h)[1],
+	      sizeof(struct ccb_dev_match) - sizeof(struct ccb_hdr));
+	matchccb.ccb_h.func_code = XPT_DEV_MATCH;
+	bufsize = sizeof(struct dev_match_result) * 20;
+	matchccb.cdm.match_buf_len = bufsize;
+	matchccb.cdm.matches=(struct dev_match_result *)malloc(bufsize);
+	if (matchccb.cdm.matches == NULL) {
+		warnx("can't malloc memory for matches");
+		retval = 1;
+		goto bailout;
+	}
+	matchccb.cdm.num_matches = 0;
+
+	matchccb.cdm.num_patterns = 1;
+	matchccb.cdm.pattern_buf_len = sizeof(struct dev_match_pattern);
+
+	matchccb.cdm.patterns = (struct dev_match_pattern *)malloc(
+		matchccb.cdm.pattern_buf_len);
+	if (matchccb.cdm.patterns == NULL) {
+		warnx("can't malloc memory for patterns");
+		retval = 1;
+		goto bailout;
+	}
+	matchccb.cdm.patterns[0].type = DEV_MATCH_BUS;
+	matchccb.cdm.patterns[0].pattern.bus_pattern.flags = BUS_MATCH_ANY;
+
+	do {
+		unsigned int i;
+
+		if (ioctl(fd, CAMIOCOMMAND, &matchccb) == -1) {
+			warn("CAMIOCOMMAND ioctl failed");
+			retval = 1;
+			goto bailout;
+		}
+
+		if ((matchccb.ccb_h.status != CAM_REQ_CMP)
+		 || ((matchccb.cdm.status != CAM_DEV_MATCH_LAST)
+		   && (matchccb.cdm.status != CAM_DEV_MATCH_MORE))) {
+			warnx("got CAM error %#x, CDM error %d\n",
+			      matchccb.ccb_h.status, matchccb.cdm.status);
+			retval = 1;
+			goto bailout;
+		}
+
+		for (i = 0; i < matchccb.cdm.num_matches; i++) {
+			struct bus_match_result *bus_result;
+
+			/* This shouldn't happen. */
+			if (matchccb.cdm.matches[i].type != DEV_MATCH_BUS)
+				continue;
+
+			bus_result = &matchccb.cdm.matches[i].result.bus_result;
+
+			/*
+			 * We don't want to rescan or reset the xpt bus.
+			 * See above.
+			 */
+			if ((int)bus_result->path_id == -1)
+				continue;
+
+			ccb.ccb_h.func_code = rescan ? XPT_SCAN_BUS :
+						       XPT_RESET_BUS;
+			ccb.ccb_h.path_id = bus_result->path_id;
+			ccb.ccb_h.target_id = CAM_TARGET_WILDCARD;
+			ccb.ccb_h.target_lun = CAM_LUN_WILDCARD;
+			ccb.crcn.flags = CAM_FLAG_NONE;
+
+			/* run this at a low priority */
+			ccb.ccb_h.pinfo.priority = 5;
+
+			if (ioctl(fd, CAMIOCOMMAND, &ccb) == -1) {
+				warn("CAMIOCOMMAND ioctl failed");
+				retval = 1;
+				goto bailout;
+			}
+
+			if ((ccb.ccb_h.status & CAM_STATUS_MASK) ==CAM_REQ_CMP){
+				fprintf(stdout, "%s of bus %d was successful\n",
+					rescan? "Re-scan" : "Reset",
+					bus_result->path_id);
+			} else {
+				/*
+				 * Don't bail out just yet, maybe the other
+				 * rescan or reset commands will complete
+				 * successfully.
+				 */
+				fprintf(stderr, "%s of bus %d returned error "
+					"%#x\n", rescan? "Re-scan" : "Reset",
+					bus_result->path_id,
+					ccb.ccb_h.status & CAM_STATUS_MASK);
+				retval = 1;
+			}
+		}
+	} while ((matchccb.ccb_h.status == CAM_REQ_CMP)
+		 && (matchccb.cdm.status == CAM_DEV_MATCH_MORE));
+
+bailout:
+
+	if (fd != -1)
+		close(fd);
+
+	if (matchccb.cdm.patterns != NULL)
+		free(matchccb.cdm.patterns);
+	if (matchccb.cdm.matches != NULL)
+		free(matchccb.cdm.matches);
+
+	return(retval);
+}
+
+static int
+scanlun_or_reset_dev(int bus, int target, int lun, int scan)
+{
+	union ccb ccb;
+	struct cam_device *device;
+	int fd;
+
+	device = NULL;
+
+	if (bus < 0) {
+		warnx("invalid bus number %d", bus);
+		return(1);
+	}
+
+	if (target < 0) {
+		warnx("invalid target number %d", target);
+		return(1);
+	}
+
+	if (lun < 0) {
+		warnx("invalid lun number %d", lun);
+		return(1);
+	}
+
+	fd = -1;
+
+	bzero(&ccb, sizeof(union ccb));
+
+	if (scan) {
+		if ((fd = open(XPT_DEVICE, O_RDWR)) < 0) {
+			warnx("error opening transport layer device %s\n",
+			    XPT_DEVICE);
+			warn("%s", XPT_DEVICE);
+			return(1);
+		}
+	} else {
+		device = cam_open_btl(bus, target, lun, O_RDWR, NULL);
+		if (device == NULL) {
+			warnx("%s", cam_errbuf);
+			return(1);
+		}
+	}
+
+	ccb.ccb_h.func_code = (scan)? XPT_SCAN_LUN : XPT_RESET_DEV;
+	ccb.ccb_h.path_id = bus;
+	ccb.ccb_h.target_id = target;
+	ccb.ccb_h.target_lun = lun;
+	ccb.ccb_h.timeout = 5000;
+	ccb.crcn.flags = CAM_FLAG_NONE;
+
+	/* run this at a low priority */
+	ccb.ccb_h.pinfo.priority = 5;
+
+	if (scan) {
+		if (ioctl(fd, CAMIOCOMMAND, &ccb) < 0) {
+			warn("CAMIOCOMMAND ioctl failed");
+			close(fd);
+			return(1);
+		}
+	} else {
+		if (cam_send_ccb(device, &ccb) < 0) {
+			warn("error sending XPT_RESET_DEV CCB");
+			cam_close_device(device);
+			return(1);
+		}
+	}
+
+	if (scan)
+		close(fd);
+	else
+		cam_close_device(device);
+
+	/*
+	 * An error code of CAM_BDR_SENT is normal for a BDR request.
+	 */
+	if (((ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)
+	 || ((!scan)
+	  && ((ccb.ccb_h.status & CAM_STATUS_MASK) == CAM_BDR_SENT))) {
+		fprintf(stdout, "%s of %d:%d:%d was successful\n",
+		    scan? "Re-scan" : "Reset", bus, target, lun);
+		return(0);
+	} else {
+		fprintf(stdout, "%s of %d:%d:%d returned error %#x\n",
+		    scan? "Re-scan" : "Reset", bus, target, lun,
+		    ccb.ccb_h.status & CAM_STATUS_MASK);
+		return(1);
+	}
+}
+
+#ifndef MINIMALISTIC
+static int
+readdefects(struct cam_device *device, int argc, char **argv,
+	    char *combinedopt, int retry_count, int timeout)
+{
+	union ccb *ccb = NULL;
+	struct scsi_read_defect_data_10 *rdd_cdb;
+	u_int8_t *defect_list = NULL;
+	u_int32_t dlist_length = 65000;
+	u_int32_t returned_length = 0;
+	u_int32_t num_returned = 0;
+	u_int8_t returned_format;
+	unsigned int i;
+	int c, error = 0;
+	int lists_specified = 0;
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c){
+		case 'f':
+		{
+			char *tstr;
+			tstr = optarg;
+			while (isspace(*tstr) && (*tstr != '\0'))
+				tstr++;
+			if (strcmp(tstr, "block") == 0)
+				arglist |= CAM_ARG_FORMAT_BLOCK;
+			else if (strcmp(tstr, "bfi") == 0)
+				arglist |= CAM_ARG_FORMAT_BFI;
+			else if (strcmp(tstr, "phys") == 0)
+				arglist |= CAM_ARG_FORMAT_PHYS;
+			else {
+				error = 1;
+				warnx("invalid defect format %s", tstr);
+				goto defect_bailout;
+			}
+			break;
+		}
+		case 'G':
+			arglist |= CAM_ARG_GLIST;
+			break;
+		case 'P':
+			arglist |= CAM_ARG_PLIST;
+			break;
+		default:
+			break;
+		}
+	}
+
+	ccb = cam_getccb(device);
+
+	/*
+	 * Hopefully 65000 bytes is enough to hold the defect list.  If it
+	 * isn't, the disk is probably dead already.  We'd have to go with
+	 * 12 byte command (i.e. alloc_length is 32 bits instead of 16)
+	 * to hold them all.
+	 */
+	defect_list = malloc(dlist_length);
+	if (defect_list == NULL) {
+		warnx("can't malloc memory for defect list");
+		error = 1;
+		goto defect_bailout;
+	}
+
+	rdd_cdb =(struct scsi_read_defect_data_10 *)&ccb->csio.cdb_io.cdb_bytes;
+
+	/*
+	 * cam_getccb() zeros the CCB header only.  So we need to zero the
+	 * payload portion of the ccb.
+	 */
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	cam_fill_csio(&ccb->csio,
+		      /*retries*/ retry_count,
+		      /*cbfcnp*/ NULL,
+		      /*flags*/ CAM_DIR_IN | ((arglist & CAM_ARG_ERR_RECOVER) ?
+					      CAM_PASS_ERR_RECOVER : 0),
+		      /*tag_action*/ MSG_SIMPLE_Q_TAG,
+		      /*data_ptr*/ defect_list,
+		      /*dxfer_len*/ dlist_length,
+		      /*sense_len*/ SSD_FULL_SIZE,
+		      /*cdb_len*/ sizeof(struct scsi_read_defect_data_10),
+		      /*timeout*/ timeout ? timeout : 5000);
+
+	rdd_cdb->opcode = READ_DEFECT_DATA_10;
+	if (arglist & CAM_ARG_FORMAT_BLOCK)
+		rdd_cdb->format = SRDD10_BLOCK_FORMAT;
+	else if (arglist & CAM_ARG_FORMAT_BFI)
+		rdd_cdb->format = SRDD10_BYTES_FROM_INDEX_FORMAT;
+	else if (arglist & CAM_ARG_FORMAT_PHYS)
+		rdd_cdb->format = SRDD10_PHYSICAL_SECTOR_FORMAT;
+	else {
+		error = 1;
+		warnx("no defect list format specified");
+		goto defect_bailout;
+	}
+	if (arglist & CAM_ARG_PLIST) {
+		rdd_cdb->format |= SRDD10_PLIST;
+		lists_specified++;
+	}
+
+	if (arglist & CAM_ARG_GLIST) {
+		rdd_cdb->format |= SRDD10_GLIST;
+		lists_specified++;
+	}
+
+	scsi_ulto2b(dlist_length, rdd_cdb->alloc_length);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error reading defect list");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		error = 1;
+		goto defect_bailout;
+	}
+
+	returned_length = scsi_2btoul(((struct
+		scsi_read_defect_data_hdr_10 *)defect_list)->length);
+
+	returned_format = ((struct scsi_read_defect_data_hdr_10 *)
+			defect_list)->format;
+
+	if (((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_SCSI_STATUS_ERROR)
+	 && (ccb->csio.scsi_status == SCSI_STATUS_CHECK_COND)
+	 && ((ccb->ccb_h.status & CAM_AUTOSNS_VALID) != 0)) {
+		struct scsi_sense_data *sense;
+		int error_code, sense_key, asc, ascq;
+
+		sense = &ccb->csio.sense_data;
+		scsi_extract_sense(sense, &error_code, &sense_key, &asc, &ascq);
+
+		/*
+		 * According to the SCSI spec, if the disk doesn't support
+		 * the requested format, it will generally return a sense
+		 * key of RECOVERED ERROR, and an additional sense code
+		 * of "DEFECT LIST NOT FOUND".  So, we check for that, and
+		 * also check to make sure that the returned length is
+		 * greater than 0, and then print out whatever format the
+		 * disk gave us.
+		 */
+		if ((sense_key == SSD_KEY_RECOVERED_ERROR)
+		 && (asc == 0x1c) && (ascq == 0x00)
+		 && (returned_length > 0)) {
+			warnx("requested defect format not available");
+			switch(returned_format & SRDDH10_DLIST_FORMAT_MASK) {
+			case SRDD10_BLOCK_FORMAT:
+				warnx("Device returned block format");
+				break;
+			case SRDD10_BYTES_FROM_INDEX_FORMAT:
+				warnx("Device returned bytes from index"
+				      " format");
+				break;
+			case SRDD10_PHYSICAL_SECTOR_FORMAT:
+				warnx("Device returned physical sector format");
+				break;
+			default:
+				error = 1;
+				warnx("Device returned unknown defect"
+				     " data format %#x", returned_format);
+				goto defect_bailout;
+				break; /* NOTREACHED */
+			}
+		} else {
+			error = 1;
+			warnx("Error returned from read defect data command");
+			if (arglist & CAM_ARG_VERBOSE)
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+			goto defect_bailout;
+		}
+	} else if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		error = 1;
+		warnx("Error returned from read defect data command");
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		goto defect_bailout;
+	}
+
+	/*
+	 * XXX KDM  I should probably clean up the printout format for the
+	 * disk defects. 
+	 */
+	switch (returned_format & SRDDH10_DLIST_FORMAT_MASK){
+		case SRDDH10_PHYSICAL_SECTOR_FORMAT:
+		{
+			struct scsi_defect_desc_phys_sector *dlist;
+
+			dlist = (struct scsi_defect_desc_phys_sector *)
+				(defect_list +
+				sizeof(struct scsi_read_defect_data_hdr_10));
+
+			num_returned = returned_length /
+				sizeof(struct scsi_defect_desc_phys_sector);
+
+			fprintf(stderr, "Got %d defect", num_returned);
+
+			if ((lists_specified == 0) || (num_returned == 0)) {
+				fprintf(stderr, "s.\n");
+				break;
+			} else if (num_returned == 1)
+				fprintf(stderr, ":\n");
+			else
+				fprintf(stderr, "s:\n");
+
+			for (i = 0; i < num_returned; i++) {
+				fprintf(stdout, "%d:%d:%d\n",
+					scsi_3btoul(dlist[i].cylinder),
+					dlist[i].head,
+					scsi_4btoul(dlist[i].sector));
+			}
+			break;
+		}
+		case SRDDH10_BYTES_FROM_INDEX_FORMAT:
+		{
+			struct scsi_defect_desc_bytes_from_index *dlist;
+
+			dlist = (struct scsi_defect_desc_bytes_from_index *)
+				(defect_list +
+				sizeof(struct scsi_read_defect_data_hdr_10));
+
+			num_returned = returned_length /
+			      sizeof(struct scsi_defect_desc_bytes_from_index);
+
+			fprintf(stderr, "Got %d defect", num_returned);
+
+			if ((lists_specified == 0) || (num_returned == 0)) {
+				fprintf(stderr, "s.\n");
+				break;
+			} else if (num_returned == 1)
+				fprintf(stderr, ":\n");
+			else
+				fprintf(stderr, "s:\n");
+
+			for (i = 0; i < num_returned; i++) {
+				fprintf(stdout, "%d:%d:%d\n",
+					scsi_3btoul(dlist[i].cylinder),
+					dlist[i].head,
+					scsi_4btoul(dlist[i].bytes_from_index));
+			}
+			break;
+		}
+		case SRDDH10_BLOCK_FORMAT:
+		{
+			struct scsi_defect_desc_block *dlist;
+
+			dlist = (struct scsi_defect_desc_block *)(defect_list +
+				sizeof(struct scsi_read_defect_data_hdr_10));
+
+			num_returned = returned_length /
+			      sizeof(struct scsi_defect_desc_block);
+
+			fprintf(stderr, "Got %d defect", num_returned);
+
+			if ((lists_specified == 0) || (num_returned == 0)) {
+				fprintf(stderr, "s.\n");
+				break;
+			} else if (num_returned == 1)
+				fprintf(stderr, ":\n");
+			else
+				fprintf(stderr, "s:\n");
+
+			for (i = 0; i < num_returned; i++)
+				fprintf(stdout, "%u\n",
+					scsi_4btoul(dlist[i].address));
+			break;
+		}
+		default:
+			fprintf(stderr, "Unknown defect format %d\n",
+				returned_format & SRDDH10_DLIST_FORMAT_MASK);
+			error = 1;
+			break;
+	}
+defect_bailout:
+
+	if (defect_list != NULL)
+		free(defect_list);
+
+	if (ccb != NULL)
+		cam_freeccb(ccb);
+
+	return(error);
+}
+#endif /* MINIMALISTIC */
+
+#if 0
+void
+reassignblocks(struct cam_device *device, u_int32_t *blocks, int num_blocks)
+{
+	union ccb *ccb;
+	
+	ccb = cam_getccb(device);
+
+	cam_freeccb(ccb);
+}
+#endif
+
+#ifndef MINIMALISTIC
+void
+mode_sense(struct cam_device *device, int mode_page, int page_control,
+	   int dbd, int retry_count, int timeout, u_int8_t *data, int datalen)
+{
+	union ccb *ccb;
+	int retval;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL)
+		errx(1, "mode_sense: couldn't allocate CCB");
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	scsi_mode_sense(&ccb->csio,
+			/* retries */ retry_count,
+			/* cbfcnp */ NULL,
+			/* tag_action */ MSG_SIMPLE_Q_TAG,
+			/* dbd */ dbd,
+			/* page_code */ page_control << 6,
+			/* page */ mode_page,
+			/* param_buf */ data,
+			/* param_len */ datalen,
+			/* sense_len */ SSD_FULL_SIZE,
+			/* timeout */ timeout ? timeout : 5000);
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (((retval = cam_send_ccb(device, ccb)) < 0)
+	 || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+		cam_freeccb(ccb);
+		cam_close_device(device);
+		if (retval < 0)
+			err(1, "error sending mode sense command");
+		else
+			errx(1, "error sending mode sense command");
+	}
+
+	cam_freeccb(ccb);
+}
+
+void
+mode_select(struct cam_device *device, int save_pages, int retry_count,
+	   int timeout, u_int8_t *data, int datalen)
+{
+	union ccb *ccb;
+	int retval;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL)
+		errx(1, "mode_select: couldn't allocate CCB");
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	scsi_mode_select(&ccb->csio,
+			 /* retries */ retry_count,
+			 /* cbfcnp */ NULL,
+			 /* tag_action */ MSG_SIMPLE_Q_TAG,
+			 /* scsi_page_fmt */ 1,
+			 /* save_pages */ save_pages,
+			 /* param_buf */ data,
+			 /* param_len */ datalen,
+			 /* sense_len */ SSD_FULL_SIZE,
+			 /* timeout */ timeout ? timeout : 5000);
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (((retval = cam_send_ccb(device, ccb)) < 0)
+	 || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+		cam_freeccb(ccb);
+		cam_close_device(device);
+
+		if (retval < 0)
+			err(1, "error sending mode select command");
+		else
+			errx(1, "error sending mode select command");
+		
+	}
+
+	cam_freeccb(ccb);
+}
+
+void
+modepage(struct cam_device *device, int argc, char **argv, char *combinedopt,
+	 int retry_count, int timeout)
+{
+	int c, mode_page = -1, page_control = 0;
+	int binary = 0, list = 0;
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'b':
+			binary = 1;
+			break;
+		case 'd':
+			arglist |= CAM_ARG_DBD;
+			break;
+		case 'e':
+			arglist |= CAM_ARG_MODE_EDIT;
+			break;
+		case 'l':
+			list = 1;
+			break;
+		case 'm':
+			mode_page = strtol(optarg, NULL, 0);
+			if (mode_page < 0)
+				errx(1, "invalid mode page %d", mode_page);
+			break;
+		case 'P':
+			page_control = strtol(optarg, NULL, 0);
+			if ((page_control < 0) || (page_control > 3))
+				errx(1, "invalid page control field %d",
+				     page_control);
+			arglist |= CAM_ARG_PAGE_CNTL;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (mode_page == -1 && list == 0)
+		errx(1, "you must specify a mode page!");
+
+	if (list) {
+		mode_list(device, page_control, arglist & CAM_ARG_DBD,
+		    retry_count, timeout);
+	} else {
+		mode_edit(device, mode_page, page_control,
+		    arglist & CAM_ARG_DBD, arglist & CAM_ARG_MODE_EDIT, binary,
+		    retry_count, timeout);
+	}
+}
+
+static int
+scsicmd(struct cam_device *device, int argc, char **argv, char *combinedopt,
+	int retry_count, int timeout)
+{
+	union ccb *ccb;
+	u_int32_t flags = CAM_DIR_NONE;
+	u_int8_t *data_ptr = NULL;
+	u_int8_t cdb[20];
+	u_int8_t atacmd[12];
+	struct get_hook hook;
+	int c, data_bytes = 0;
+	int cdb_len = 0;
+	int atacmd_len = 0;
+	int need_res = 0;
+	char *datastr = NULL, *tstr, *resstr = NULL;
+	int error = 0;
+	int fd_data = 0, fd_res = 0;
+	int retval;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("scsicmd: error allocating ccb");
+		return(1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(union ccb) - sizeof(struct ccb_hdr));
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'a':
+			tstr = optarg;
+			while (isspace(*tstr) && (*tstr != '\0'))
+				tstr++;
+			hook.argc = argc - optind;
+			hook.argv = argv + optind;
+			hook.got = 0;
+			atacmd_len = buff_encode_visit(atacmd, sizeof(atacmd), tstr,
+						    iget, &hook);
+			/*
+			 * Increment optind by the number of arguments the
+			 * encoding routine processed.  After each call to
+			 * getopt(3), optind points to the argument that
+			 * getopt should process _next_.  In this case,
+			 * that means it points to the first command string
+			 * argument, if there is one.  Once we increment
+			 * this, it should point to either the next command
+			 * line argument, or it should be past the end of
+			 * the list.
+			 */
+			optind += hook.got;
+			break;
+		case 'c':
+			tstr = optarg;
+			while (isspace(*tstr) && (*tstr != '\0'))
+				tstr++;
+			hook.argc = argc - optind;
+			hook.argv = argv + optind;
+			hook.got = 0;
+			cdb_len = buff_encode_visit(cdb, sizeof(cdb), tstr,
+						    iget, &hook);
+			/*
+			 * Increment optind by the number of arguments the
+			 * encoding routine processed.  After each call to
+			 * getopt(3), optind points to the argument that
+			 * getopt should process _next_.  In this case,
+			 * that means it points to the first command string
+			 * argument, if there is one.  Once we increment
+			 * this, it should point to either the next command
+			 * line argument, or it should be past the end of
+			 * the list.
+			 */
+			optind += hook.got;
+			break;
+		case 'i':
+			if (arglist & CAM_ARG_CMD_OUT) {
+				warnx("command must either be "
+				      "read or write, not both");
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			arglist |= CAM_ARG_CMD_IN;
+			flags = CAM_DIR_IN;
+			data_bytes = strtol(optarg, NULL, 0);
+			if (data_bytes <= 0) {
+				warnx("invalid number of input bytes %d",
+				      data_bytes);
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			hook.argc = argc - optind;
+			hook.argv = argv + optind;
+			hook.got = 0;
+			optind++;
+			datastr = cget(&hook, NULL);
+			/*
+			 * If the user supplied "-" instead of a format, he
+			 * wants the data to be written to stdout.
+			 */
+			if ((datastr != NULL)
+			 && (datastr[0] == '-'))
+				fd_data = 1;
+
+			data_ptr = (u_int8_t *)malloc(data_bytes);
+			if (data_ptr == NULL) {
+				warnx("can't malloc memory for data_ptr");
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			break;
+		case 'o':
+			if (arglist & CAM_ARG_CMD_IN) {
+				warnx("command must either be "
+				      "read or write, not both");
+				error = 1;	
+				goto scsicmd_bailout;
+			}
+			arglist |= CAM_ARG_CMD_OUT;
+			flags = CAM_DIR_OUT;
+			data_bytes = strtol(optarg, NULL, 0);
+			if (data_bytes <= 0) {
+				warnx("invalid number of output bytes %d",
+				      data_bytes);
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			hook.argc = argc - optind;
+			hook.argv = argv + optind;
+			hook.got = 0;
+			datastr = cget(&hook, NULL);
+			data_ptr = (u_int8_t *)malloc(data_bytes);
+			if (data_ptr == NULL) {
+				warnx("can't malloc memory for data_ptr");
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			/*
+			 * If the user supplied "-" instead of a format, he
+			 * wants the data to be read from stdin.
+			 */
+			if ((datastr != NULL)
+			 && (datastr[0] == '-'))
+				fd_data = 1;
+			else
+				buff_encode_visit(data_ptr, data_bytes, datastr,
+						  iget, &hook);
+			optind += hook.got;
+			break;
+		case 'r':
+			need_res = 1;
+			hook.argc = argc - optind;
+			hook.argv = argv + optind;
+			hook.got = 0;
+			resstr = cget(&hook, NULL);
+			if ((resstr != NULL) && (resstr[0] == '-'))
+				fd_res = 1;
+			optind += hook.got;
+			break;
+		default:
+			break;
+		}
+	}
+
+	/*
+	 * If fd_data is set, and we're writing to the device, we need to
+	 * read the data the user wants written from stdin.
+	 */
+	if ((fd_data == 1) && (arglist & CAM_ARG_CMD_OUT)) {
+		ssize_t amt_read;
+		int amt_to_read = data_bytes;
+		u_int8_t *buf_ptr = data_ptr;
+
+		for (amt_read = 0; amt_to_read > 0;
+		     amt_read = read(STDIN_FILENO, buf_ptr, amt_to_read)) {
+			if (amt_read == -1) {
+				warn("error reading data from stdin");
+				error = 1;
+				goto scsicmd_bailout;
+			}
+			amt_to_read -= amt_read;
+			buf_ptr += amt_read;
+		}
+	}
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		flags |= CAM_PASS_ERR_RECOVER;
+
+	/* Disable freezing the device queue */
+	flags |= CAM_DEV_QFRZDIS;
+
+	if (cdb_len) {
+		/*
+		 * This is taken from the SCSI-3 draft spec.
+		 * (T10/1157D revision 0.3)
+		 * The top 3 bits of an opcode are the group code.
+		 * The next 5 bits are the command code.
+		 * Group 0:  six byte commands
+		 * Group 1:  ten byte commands
+		 * Group 2:  ten byte commands
+		 * Group 3:  reserved
+		 * Group 4:  sixteen byte commands
+		 * Group 5:  twelve byte commands
+		 * Group 6:  vendor specific
+		 * Group 7:  vendor specific
+		 */
+		switch((cdb[0] >> 5) & 0x7) {
+			case 0:
+				cdb_len = 6;
+				break;
+			case 1:
+			case 2:
+				cdb_len = 10;
+				break;
+			case 3:
+			case 6:
+			case 7:
+			        /* computed by buff_encode_visit */
+				break;
+			case 4:
+				cdb_len = 16;
+				break;
+			case 5:
+				cdb_len = 12;
+				break;
+		}
+
+		/*
+		 * We should probably use csio_build_visit or something like that
+		 * here, but it's easier to encode arguments as you go.  The
+		 * alternative would be skipping the CDB argument and then encoding
+		 * it here, since we've got the data buffer argument by now.
+		 */
+		bcopy(cdb, &ccb->csio.cdb_io.cdb_bytes, cdb_len);
+
+		cam_fill_csio(&ccb->csio,
+		      /*retries*/ retry_count,
+		      /*cbfcnp*/ NULL,
+		      /*flags*/ flags,
+		      /*tag_action*/ MSG_SIMPLE_Q_TAG,
+		      /*data_ptr*/ data_ptr,
+		      /*dxfer_len*/ data_bytes,
+		      /*sense_len*/ SSD_FULL_SIZE,
+		      /*cdb_len*/ cdb_len,
+		      /*timeout*/ timeout ? timeout : 5000);
+	} else {
+		atacmd_len = 12;
+		bcopy(atacmd, &ccb->ataio.cmd.command, atacmd_len);
+		if (need_res)
+			ccb->ataio.cmd.flags |= CAM_ATAIO_NEEDRESULT;
+
+		cam_fill_ataio(&ccb->ataio,
+		      /*retries*/ retry_count,
+		      /*cbfcnp*/ NULL,
+		      /*flags*/ flags,
+		      /*tag_action*/ 0,
+		      /*data_ptr*/ data_ptr,
+		      /*dxfer_len*/ data_bytes,
+		      /*timeout*/ timeout ? timeout : 5000);
+	}
+
+	if (((retval = cam_send_ccb(device, ccb)) < 0)
+	 || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		if (retval < 0)
+			warn("error sending command");
+		else
+			warnx("error sending command");
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+
+		error = 1;
+		goto scsicmd_bailout;
+	}
+
+	if (atacmd_len && need_res) {
+		if (fd_res == 0) {
+			buff_decode_visit(&ccb->ataio.res.status, 11, resstr,
+					  arg_put, NULL);
+			fprintf(stdout, "\n");
+		} else {
+			fprintf(stdout,
+			    "%02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			    ccb->ataio.res.status,
+			    ccb->ataio.res.error,
+			    ccb->ataio.res.lba_low,
+			    ccb->ataio.res.lba_mid,
+			    ccb->ataio.res.lba_high,
+			    ccb->ataio.res.device,
+			    ccb->ataio.res.lba_low_exp,
+			    ccb->ataio.res.lba_mid_exp,
+			    ccb->ataio.res.lba_high_exp,
+			    ccb->ataio.res.sector_count,
+			    ccb->ataio.res.sector_count_exp);
+			fflush(stdout);
+		}
+	}
+
+	if (((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)
+	 && (arglist & CAM_ARG_CMD_IN)
+	 && (data_bytes > 0)) {
+		if (fd_data == 0) {
+			buff_decode_visit(data_ptr, data_bytes, datastr,
+					  arg_put, NULL);
+			fprintf(stdout, "\n");
+		} else {
+			ssize_t amt_written;
+			int amt_to_write = data_bytes;
+			u_int8_t *buf_ptr = data_ptr;
+
+			for (amt_written = 0; (amt_to_write > 0) &&
+			     (amt_written =write(1, buf_ptr,amt_to_write))> 0;){
+				amt_to_write -= amt_written;
+				buf_ptr += amt_written;
+			}
+			if (amt_written == -1) {
+				warn("error writing data to stdout");
+				error = 1;
+				goto scsicmd_bailout;
+			} else if ((amt_written == 0)
+				&& (amt_to_write > 0)) {
+				warnx("only wrote %u bytes out of %u",
+				      data_bytes - amt_to_write, data_bytes);
+			}
+		}
+	}
+
+scsicmd_bailout:
+
+	if ((data_bytes > 0) && (data_ptr != NULL))
+		free(data_ptr);
+
+	cam_freeccb(ccb);
+
+	return(error);
+}
+
+static int
+camdebug(int argc, char **argv, char *combinedopt)
+{
+	int c, fd;
+	int bus = -1, target = -1, lun = -1;
+	char *tstr, *tmpstr = NULL;
+	union ccb ccb;
+	int error = 0;
+
+	bzero(&ccb, sizeof(union ccb));
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'I':
+			arglist |= CAM_ARG_DEBUG_INFO;
+			ccb.cdbg.flags |= CAM_DEBUG_INFO;
+			break;
+		case 'P':
+			arglist |= CAM_ARG_DEBUG_PERIPH;
+			ccb.cdbg.flags |= CAM_DEBUG_PERIPH;
+			break;
+		case 'S':
+			arglist |= CAM_ARG_DEBUG_SUBTRACE;
+			ccb.cdbg.flags |= CAM_DEBUG_SUBTRACE;
+			break;
+		case 'T':
+			arglist |= CAM_ARG_DEBUG_TRACE;
+			ccb.cdbg.flags |= CAM_DEBUG_TRACE;
+			break;
+		case 'X':
+			arglist |= CAM_ARG_DEBUG_XPT;
+			ccb.cdbg.flags |= CAM_DEBUG_XPT;
+			break;
+		case 'c':
+			arglist |= CAM_ARG_DEBUG_CDB;
+			ccb.cdbg.flags |= CAM_DEBUG_CDB;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if ((fd = open(XPT_DEVICE, O_RDWR)) < 0) {
+		warnx("error opening transport layer device %s", XPT_DEVICE);
+		warn("%s", XPT_DEVICE);
+		return(1);
+	}
+	argc -= optind;
+	argv += optind;
+
+	if (argc <= 0) {
+		warnx("you must specify \"off\", \"all\" or a bus,");
+		warnx("bus:target, or bus:target:lun");
+		close(fd);
+		return(1);
+	}
+
+	tstr = *argv;
+
+	while (isspace(*tstr) && (*tstr != '\0'))
+		tstr++;
+
+	if (strncmp(tstr, "off", 3) == 0) {
+		ccb.cdbg.flags = CAM_DEBUG_NONE;
+		arglist &= ~(CAM_ARG_DEBUG_INFO|CAM_ARG_DEBUG_PERIPH|
+			     CAM_ARG_DEBUG_TRACE|CAM_ARG_DEBUG_SUBTRACE|
+			     CAM_ARG_DEBUG_XPT);
+	} else if (strncmp(tstr, "all", 3) != 0) {
+		tmpstr = (char *)strtok(tstr, ":");
+		if ((tmpstr != NULL) && (*tmpstr != '\0')){
+			bus = strtol(tmpstr, NULL, 0);
+			arglist |= CAM_ARG_BUS;
+			tmpstr = (char *)strtok(NULL, ":");
+			if ((tmpstr != NULL) && (*tmpstr != '\0')){
+				target = strtol(tmpstr, NULL, 0);
+				arglist |= CAM_ARG_TARGET;
+				tmpstr = (char *)strtok(NULL, ":");
+				if ((tmpstr != NULL) && (*tmpstr != '\0')){
+					lun = strtol(tmpstr, NULL, 0);
+					arglist |= CAM_ARG_LUN;
+				}
+			}
+		} else {
+			error = 1;
+			warnx("you must specify \"all\", \"off\", or a bus,");
+			warnx("bus:target, or bus:target:lun to debug");
+		}
+	}
+	
+	if (error == 0) {
+
+		ccb.ccb_h.func_code = XPT_DEBUG;
+		ccb.ccb_h.path_id = bus;
+		ccb.ccb_h.target_id = target;
+		ccb.ccb_h.target_lun = lun;
+
+		if (ioctl(fd, CAMIOCOMMAND, &ccb) == -1) {
+			warn("CAMIOCOMMAND ioctl failed");
+			error = 1;
+		}
+
+		if (error == 0) {
+			if ((ccb.ccb_h.status & CAM_STATUS_MASK) ==
+			     CAM_FUNC_NOTAVAIL) {
+				warnx("CAM debugging not available");
+				warnx("you need to put options CAMDEBUG in"
+				      " your kernel config file!");
+				error = 1;
+			} else if ((ccb.ccb_h.status & CAM_STATUS_MASK) !=
+				    CAM_REQ_CMP) {
+				warnx("XPT_DEBUG CCB failed with status %#x",
+				      ccb.ccb_h.status);
+				error = 1;
+			} else {
+				if (ccb.cdbg.flags == CAM_DEBUG_NONE) {
+					fprintf(stderr,
+						"Debugging turned off\n");
+				} else {
+					fprintf(stderr,
+						"Debugging enabled for "
+						"%d:%d:%d\n",
+						bus, target, lun);
+				}
+			}
+		}
+		close(fd);
+	}
+
+	return(error);
+}
+
+static int
+tagcontrol(struct cam_device *device, int argc, char **argv,
+	   char *combinedopt)
+{
+	int c;
+	union ccb *ccb;
+	int numtags = -1;
+	int retval = 0;
+	int quiet = 0;
+	char pathstr[1024];
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("tagcontrol: error allocating ccb");
+		return(1);
+	}
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'N':
+			numtags = strtol(optarg, NULL, 0);
+			if (numtags < 0) {
+				warnx("tag count %d is < 0", numtags);
+				retval = 1;
+				goto tagcontrol_bailout;
+			}
+			break;
+		case 'q':
+			quiet++;
+			break;
+		default:
+			break;
+		}
+	}
+
+	cam_path_string(device, pathstr, sizeof(pathstr));
+
+	if (numtags >= 0) {
+		bzero(&(&ccb->ccb_h)[1],
+		      sizeof(struct ccb_relsim) - sizeof(struct ccb_hdr));
+		ccb->ccb_h.func_code = XPT_REL_SIMQ;
+		ccb->crs.release_flags = RELSIM_ADJUST_OPENINGS;
+		ccb->crs.openings = numtags;
+
+
+		if (cam_send_ccb(device, ccb) < 0) {
+			perror("error sending XPT_REL_SIMQ CCB");
+			retval = 1;
+			goto tagcontrol_bailout;
+		}
+
+		if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+			warnx("XPT_REL_SIMQ CCB failed");
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+			retval = 1;
+			goto tagcontrol_bailout;
+		}
+
+
+		if (quiet == 0)
+			fprintf(stdout, "%stagged openings now %d\n",
+				pathstr, ccb->crs.openings);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_getdevstats) - sizeof(struct ccb_hdr));
+
+	ccb->ccb_h.func_code = XPT_GDEV_STATS;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending XPT_GDEV_STATS CCB");
+		retval = 1;
+		goto tagcontrol_bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		warnx("XPT_GDEV_STATS CCB failed");
+		cam_error_print(device, ccb, CAM_ESF_ALL,
+				CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto tagcontrol_bailout;
+	}
+
+	if (arglist & CAM_ARG_VERBOSE) {
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "dev_openings  %d\n", ccb->cgds.dev_openings);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "dev_active    %d\n", ccb->cgds.dev_active);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "devq_openings %d\n", ccb->cgds.devq_openings);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "devq_queued   %d\n", ccb->cgds.devq_queued);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "held          %d\n", ccb->cgds.held);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "mintags       %d\n", ccb->cgds.mintags);
+		fprintf(stdout, "%s", pathstr);
+		fprintf(stdout, "maxtags       %d\n", ccb->cgds.maxtags);
+	} else {
+		if (quiet == 0) {
+			fprintf(stdout, "%s", pathstr);
+			fprintf(stdout, "device openings: ");
+		}
+		fprintf(stdout, "%d\n", ccb->cgds.dev_openings +
+			ccb->cgds.dev_active);
+	}
+
+tagcontrol_bailout:
+
+	cam_freeccb(ccb);
+	return(retval);
+}
+
+static void
+cts_print(struct cam_device *device, struct ccb_trans_settings *cts)
+{
+	char pathstr[1024];
+
+	cam_path_string(device, pathstr, sizeof(pathstr));
+
+	if (cts->transport == XPORT_SPI) {
+		struct ccb_trans_settings_spi *spi =
+		    &cts->xport_specific.spi;
+
+		if ((spi->valid & CTS_SPI_VALID_SYNC_RATE) != 0) {
+
+			fprintf(stdout, "%ssync parameter: %d\n", pathstr,
+				spi->sync_period);
+
+			if (spi->sync_offset != 0) {
+				u_int freq;
+
+				freq = scsi_calc_syncsrate(spi->sync_period);
+				fprintf(stdout, "%sfrequency: %d.%03dMHz\n",
+					pathstr, freq / 1000, freq % 1000);
+			}
+		}
+
+		if (spi->valid & CTS_SPI_VALID_SYNC_OFFSET) {
+			fprintf(stdout, "%soffset: %d\n", pathstr,
+			    spi->sync_offset);
+		}
+
+		if (spi->valid & CTS_SPI_VALID_BUS_WIDTH) {
+			fprintf(stdout, "%sbus width: %d bits\n", pathstr,
+				(0x01 << spi->bus_width) * 8);
+		}
+
+		if (spi->valid & CTS_SPI_VALID_DISC) {
+			fprintf(stdout, "%sdisconnection is %s\n", pathstr,
+				(spi->flags & CTS_SPI_FLAGS_DISC_ENB) ?
+				"enabled" : "disabled");
+		}
+	}
+
+	if (cts->protocol == PROTO_SCSI) {
+		struct ccb_trans_settings_scsi *scsi=
+		    &cts->proto_specific.scsi;
+
+		if (scsi->valid & CTS_SCSI_VALID_TQ) {
+			fprintf(stdout, "%stagged queueing is %s\n", pathstr,
+				(scsi->flags & CTS_SCSI_FLAGS_TAG_ENB) ?
+				"enabled" : "disabled");
+		}
+	}
+
+}
+
+/*
+ * Get a path inquiry CCB for the specified device.  
+ */
+static int
+get_cpi(struct cam_device *device, struct ccb_pathinq *cpi)
+{
+	union ccb *ccb;
+	int retval = 0;
+
+	ccb = cam_getccb(device);
+	if (ccb == NULL) {
+		warnx("get_cpi: couldn't allocate CCB");
+		return(1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_pathinq) - sizeof(struct ccb_hdr));
+	ccb->ccb_h.func_code = XPT_PATH_INQ;
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("get_cpi: error sending Path Inquiry CCB");
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_cpi_bailout;
+	}
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_cpi_bailout;
+	}
+	bcopy(&ccb->cpi, cpi, sizeof(struct ccb_pathinq));
+
+get_cpi_bailout:
+	cam_freeccb(ccb);
+	return(retval);
+}
+
+/*
+ * Get a get device CCB for the specified device.  
+ */
+static int
+get_cgd(struct cam_device *device, struct ccb_getdev *cgd)
+{
+	union ccb *ccb;
+	int retval = 0;
+
+	ccb = cam_getccb(device);
+	if (ccb == NULL) {
+		warnx("get_cgd: couldn't allocate CCB");
+		return(1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_pathinq) - sizeof(struct ccb_hdr));
+	ccb->ccb_h.func_code = XPT_GDEV_TYPE;
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("get_cgd: error sending Path Inquiry CCB");
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_cgd_bailout;
+	}
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_cgd_bailout;
+	}
+	bcopy(&ccb->cgd, cgd, sizeof(struct ccb_getdev));
+
+get_cgd_bailout:
+	cam_freeccb(ccb);
+	return(retval);
+}
+
+static void
+cpi_print(struct ccb_pathinq *cpi)
+{
+	char adapter_str[1024];
+	int i;
+
+	snprintf(adapter_str, sizeof(adapter_str),
+		 "%s%d:", cpi->dev_name, cpi->unit_number);
+
+	fprintf(stdout, "%s SIM/HBA version: %d\n", adapter_str,
+		cpi->version_num);
+
+	for (i = 1; i < 0xff; i = i << 1) {
+		const char *str;
+
+		if ((i & cpi->hba_inquiry) == 0)
+			continue;
+
+		fprintf(stdout, "%s supports ", adapter_str);
+
+		switch(i) {
+		case PI_MDP_ABLE:
+			str = "MDP message";
+			break;
+		case PI_WIDE_32:
+			str = "32 bit wide SCSI";
+			break;
+		case PI_WIDE_16:
+			str = "16 bit wide SCSI";
+			break;
+		case PI_SDTR_ABLE:
+			str = "SDTR message";
+			break;
+		case PI_LINKED_CDB:
+			str = "linked CDBs";
+			break;
+		case PI_TAG_ABLE:
+			str = "tag queue messages";
+			break;
+		case PI_SOFT_RST:
+			str = "soft reset alternative";
+			break;
+		case PI_SATAPM:
+			str = "SATA Port Multiplier";
+			break;
+		default:
+			str = "unknown PI bit set";
+			break;
+		}
+		fprintf(stdout, "%s\n", str);
+	}
+
+	for (i = 1; i < 0xff; i = i << 1) {
+		const char *str;
+
+		if ((i & cpi->hba_misc) == 0)
+			continue;
+
+		fprintf(stdout, "%s ", adapter_str);
+
+		switch(i) {
+		case PIM_SCANHILO:
+			str = "bus scans from high ID to low ID";
+			break;
+		case PIM_NOREMOVE:
+			str = "removable devices not included in scan";
+			break;
+		case PIM_NOINITIATOR:
+			str = "initiator role not supported";
+			break;
+		case PIM_NOBUSRESET:
+			str = "user has disabled initial BUS RESET or"
+			      " controller is in target/mixed mode";
+			break;
+		case PIM_NO_6_BYTE:
+			str = "do not send 6-byte commands";
+			break;
+		case PIM_SEQSCAN:
+			str = "scan bus sequentially";
+			break;
+		default:
+			str = "unknown PIM bit set";
+			break;
+		}
+		fprintf(stdout, "%s\n", str);
+	}
+
+	for (i = 1; i < 0xff; i = i << 1) {
+		const char *str;
+
+		if ((i & cpi->target_sprt) == 0)
+			continue;
+
+		fprintf(stdout, "%s supports ", adapter_str);
+		switch(i) {
+		case PIT_PROCESSOR:
+			str = "target mode processor mode";
+			break;
+		case PIT_PHASE:
+			str = "target mode phase cog. mode";
+			break;
+		case PIT_DISCONNECT:
+			str = "disconnects in target mode";
+			break;
+		case PIT_TERM_IO:
+			str = "terminate I/O message in target mode";
+			break;
+		case PIT_GRP_6:
+			str = "group 6 commands in target mode";
+			break;
+		case PIT_GRP_7:
+			str = "group 7 commands in target mode";
+			break;
+		default:
+			str = "unknown PIT bit set";
+			break;
+		}
+
+		fprintf(stdout, "%s\n", str);
+	}
+	fprintf(stdout, "%s HBA engine count: %d\n", adapter_str,
+		cpi->hba_eng_cnt);
+	fprintf(stdout, "%s maximum target: %d\n", adapter_str,
+		cpi->max_target);
+	fprintf(stdout, "%s maximum LUN: %d\n", adapter_str,
+		cpi->max_lun);
+	fprintf(stdout, "%s highest path ID in subsystem: %d\n",
+		adapter_str, cpi->hpath_id);
+	fprintf(stdout, "%s initiator ID: %d\n", adapter_str,
+		cpi->initiator_id);
+	fprintf(stdout, "%s SIM vendor: %s\n", adapter_str, cpi->sim_vid);
+	fprintf(stdout, "%s HBA vendor: %s\n", adapter_str, cpi->hba_vid);
+	fprintf(stdout, "%s bus ID: %d\n", adapter_str, cpi->bus_id);
+	fprintf(stdout, "%s base transfer speed: ", adapter_str);
+	if (cpi->base_transfer_speed > 1000)
+		fprintf(stdout, "%d.%03dMB/sec\n",
+			cpi->base_transfer_speed / 1000,
+			cpi->base_transfer_speed % 1000);
+	else
+		fprintf(stdout, "%dKB/sec\n",
+			(cpi->base_transfer_speed % 1000) * 1000);
+}
+
+static int
+get_print_cts(struct cam_device *device, int user_settings, int quiet,
+	      struct ccb_trans_settings *cts)
+{
+	int retval;
+	union ccb *ccb;
+
+	retval = 0;
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("get_print_cts: error allocating ccb");
+		return(1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_trans_settings) - sizeof(struct ccb_hdr));
+
+	ccb->ccb_h.func_code = XPT_GET_TRAN_SETTINGS;
+
+	if (user_settings == 0)
+		ccb->cts.type = CTS_TYPE_CURRENT_SETTINGS;
+	else
+		ccb->cts.type = CTS_TYPE_USER_SETTINGS;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending XPT_GET_TRAN_SETTINGS CCB");
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_print_cts_bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		warnx("XPT_GET_TRANS_SETTINGS CCB failed");
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto get_print_cts_bailout;
+	}
+
+	if (quiet == 0)
+		cts_print(device, &ccb->cts);
+
+	if (cts != NULL)
+		bcopy(&ccb->cts, cts, sizeof(struct ccb_trans_settings));
+
+get_print_cts_bailout:
+
+	cam_freeccb(ccb);
+
+	return(retval);
+}
+
+static int
+ratecontrol(struct cam_device *device, int retry_count, int timeout,
+	    int argc, char **argv, char *combinedopt)
+{
+	int c;
+	union ccb *ccb;
+	int user_settings = 0;
+	int retval = 0;
+	int disc_enable = -1, tag_enable = -1;
+	int offset = -1;
+	double syncrate = -1;
+	int bus_width = -1;
+	int quiet = 0;
+	int change_settings = 0, send_tur = 0;
+	struct ccb_pathinq cpi;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("ratecontrol: error allocating ccb");
+		return(1);
+	}
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c){
+		case 'a':
+			send_tur = 1;
+			break;
+		case 'c':
+			user_settings = 0;
+			break;
+		case 'D':
+			if (strncasecmp(optarg, "enable", 6) == 0)
+				disc_enable = 1;
+			else if (strncasecmp(optarg, "disable", 7) == 0)
+				disc_enable = 0;
+			else {
+				warnx("-D argument \"%s\" is unknown", optarg);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			change_settings = 1;
+			break;
+		case 'O':
+			offset = strtol(optarg, NULL, 0);
+			if (offset < 0) {
+				warnx("offset value %d is < 0", offset);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			change_settings = 1;
+			break;
+		case 'q':
+			quiet++;
+			break;
+		case 'R':
+			syncrate = atof(optarg);
+
+			if (syncrate < 0) {
+				warnx("sync rate %f is < 0", syncrate);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			change_settings = 1;
+			break;
+		case 'T':
+			if (strncasecmp(optarg, "enable", 6) == 0)
+				tag_enable = 1;
+			else if (strncasecmp(optarg, "disable", 7) == 0)
+				tag_enable = 0;
+			else {
+				warnx("-T argument \"%s\" is unknown", optarg);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			change_settings = 1;
+			break;
+		case 'U':
+			user_settings = 1;
+			break;
+		case 'W':
+			bus_width = strtol(optarg, NULL, 0);
+			if (bus_width < 0) {
+				warnx("bus width %d is < 0", bus_width);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			change_settings = 1;
+			break;
+		default:
+			break;
+		}
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_pathinq) - sizeof(struct ccb_hdr));
+
+	/*
+	 * Grab path inquiry information, so we can determine whether
+	 * or not the initiator is capable of the things that the user
+	 * requests.
+	 */
+	ccb->ccb_h.func_code = XPT_PATH_INQ;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		perror("error sending XPT_PATH_INQ CCB");
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+		retval = 1;
+		goto ratecontrol_bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		warnx("XPT_PATH_INQ CCB failed");
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+		retval = 1;
+		goto ratecontrol_bailout;
+	}
+
+	bcopy(&ccb->cpi, &cpi, sizeof(struct ccb_pathinq));
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_trans_settings) - sizeof(struct ccb_hdr));
+
+	if (quiet == 0)
+		fprintf(stdout, "Current Parameters:\n");
+
+	retval = get_print_cts(device, user_settings, quiet, &ccb->cts);
+
+	if (retval != 0)
+		goto ratecontrol_bailout;
+
+	if (arglist & CAM_ARG_VERBOSE)
+		cpi_print(&cpi);
+
+	if (change_settings) {
+		int didsettings = 0;
+		struct ccb_trans_settings_spi *spi = NULL;
+		struct ccb_trans_settings_scsi *scsi = NULL;
+
+		if (ccb->cts.transport == XPORT_SPI) {
+			spi = &ccb->cts.xport_specific.spi;
+			spi->valid = 0;
+		}
+		if (ccb->cts.protocol == PROTO_SCSI) {
+			scsi = &ccb->cts.proto_specific.scsi;
+			scsi->valid = 0;
+		}
+		if (spi && disc_enable != -1) {
+			spi->valid |= CTS_SPI_VALID_DISC;
+			if (disc_enable == 0)
+				spi->flags &= ~CTS_SPI_FLAGS_DISC_ENB;
+			else
+				spi->flags |= CTS_SPI_FLAGS_DISC_ENB;
+		}
+
+		if (scsi && tag_enable != -1) {
+			if ((cpi.hba_inquiry & PI_TAG_ABLE) == 0) {
+				warnx("HBA does not support tagged queueing, "
+				      "so you cannot modify tag settings");
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+
+			scsi->valid |= CTS_SCSI_VALID_TQ;
+
+			if (tag_enable == 0)
+				scsi->flags &= ~CTS_SCSI_FLAGS_TAG_ENB;
+			else
+				scsi->flags |= CTS_SCSI_FLAGS_TAG_ENB;
+			didsettings++;
+		}
+
+		if (spi && offset != -1) {
+			if ((cpi.hba_inquiry & PI_SDTR_ABLE) == 0) {
+				warnx("HBA at %s%d is not cable of changing "
+				      "offset", cpi.dev_name,
+				      cpi.unit_number);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+			spi->valid |= CTS_SPI_VALID_SYNC_OFFSET;
+			spi->sync_offset = offset;
+			didsettings++;
+		}
+
+		if (spi && syncrate != -1) {
+			int prelim_sync_period;
+			u_int freq;
+
+			if ((cpi.hba_inquiry & PI_SDTR_ABLE) == 0) {
+				warnx("HBA at %s%d is not cable of changing "
+				      "transfer rates", cpi.dev_name,
+				      cpi.unit_number);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+
+			spi->valid |= CTS_SPI_VALID_SYNC_RATE;
+
+			/*
+			 * The sync rate the user gives us is in MHz.
+			 * We need to translate it into KHz for this
+			 * calculation.
+			 */
+			syncrate *= 1000;
+
+			/*
+			 * Next, we calculate a "preliminary" sync period
+			 * in tenths of a nanosecond.
+			 */
+			if (syncrate == 0)
+				prelim_sync_period = 0;
+			else
+				prelim_sync_period = 10000000 / syncrate;
+
+			spi->sync_period =
+				scsi_calc_syncparam(prelim_sync_period);
+
+			freq = scsi_calc_syncsrate(spi->sync_period);
+			didsettings++;
+		}
+
+		/*
+		 * The bus_width argument goes like this:
+		 * 0 == 8 bit
+		 * 1 == 16 bit
+		 * 2 == 32 bit
+		 * Therefore, if you shift the number of bits given on the
+		 * command line right by 4, you should get the correct
+		 * number.
+		 */
+		if (spi && bus_width != -1) {
+
+			/*
+			 * We might as well validate things here with a
+			 * decipherable error message, rather than what
+			 * will probably be an indecipherable error message
+			 * by the time it gets back to us.
+			 */
+			if ((bus_width == 16)
+			 && ((cpi.hba_inquiry & PI_WIDE_16) == 0)) {
+				warnx("HBA does not support 16 bit bus width");
+				retval = 1;
+				goto ratecontrol_bailout;
+			} else if ((bus_width == 32)
+				&& ((cpi.hba_inquiry & PI_WIDE_32) == 0)) {
+				warnx("HBA does not support 32 bit bus width");
+				retval = 1;
+				goto ratecontrol_bailout;
+			} else if ((bus_width != 8)
+				&& (bus_width != 16)
+				&& (bus_width != 32)) {
+				warnx("Invalid bus width %d", bus_width);
+				retval = 1;
+				goto ratecontrol_bailout;
+			}
+
+			spi->valid |= CTS_SPI_VALID_BUS_WIDTH;
+			spi->bus_width = bus_width >> 4;
+			didsettings++;
+		}
+
+		if  (didsettings == 0) {
+			goto ratecontrol_bailout;
+		}
+		ccb->ccb_h.func_code = XPT_SET_TRAN_SETTINGS;
+
+		if (cam_send_ccb(device, ccb) < 0) {
+			perror("error sending XPT_SET_TRAN_SETTINGS CCB");
+			if (arglist & CAM_ARG_VERBOSE) {
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+			}
+			retval = 1;
+			goto ratecontrol_bailout;
+		}
+
+		if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+			warnx("XPT_SET_TRANS_SETTINGS CCB failed");
+			if (arglist & CAM_ARG_VERBOSE) {
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+			}
+			retval = 1;
+			goto ratecontrol_bailout;
+		}
+	}
+
+	if (send_tur) {
+		retval = testunitready(device, retry_count, timeout,
+				       (arglist & CAM_ARG_VERBOSE) ? 0 : 1);
+
+		/*
+		 * If the TUR didn't succeed, just bail.
+		 */
+		if (retval != 0) {
+			if (quiet == 0)
+				fprintf(stderr, "Test Unit Ready failed\n");
+			goto ratecontrol_bailout;
+		}
+
+		/*
+		 * If the user wants things quiet, there's no sense in
+		 * getting the transfer settings, if we're not going
+		 * to print them.
+		 */
+		if (quiet != 0)
+			goto ratecontrol_bailout;
+
+		fprintf(stdout, "New Parameters:\n");
+		retval = get_print_cts(device, user_settings, 0, NULL);
+	}
+
+ratecontrol_bailout:
+
+	cam_freeccb(ccb);
+	return(retval);
+}
+
+static int
+scsiformat(struct cam_device *device, int argc, char **argv,
+	   char *combinedopt, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	int c;
+	int ycount = 0, quiet = 0;
+	int error = 0, response = 0, retval = 0;
+	int use_timeout = 10800 * 1000;
+	int immediate = 1;
+	struct format_defect_list_header fh;
+	u_int8_t *data_ptr = NULL;
+	u_int32_t dxfer_len = 0;
+	u_int8_t byte2 = 0;
+	int num_warnings = 0;
+	int reportonly = 0;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("scsiformat: error allocating ccb");
+		return(1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch(c) {
+		case 'q':
+			quiet++;
+			break;
+		case 'r':
+			reportonly = 1;
+			break;
+		case 'w':
+			immediate = 0;
+			break;
+		case 'y':
+			ycount++;
+			break;
+		}
+	}
+
+	if (reportonly)
+		goto doreport;
+
+	if (quiet == 0) {
+		fprintf(stdout, "You are about to REMOVE ALL DATA from the "
+			"following device:\n");
+
+		error = scsidoinquiry(device, argc, argv, combinedopt,
+				      retry_count, timeout);
+
+		if (error != 0) {
+			warnx("scsiformat: error sending inquiry");
+			goto scsiformat_bailout;
+		}
+	}
+
+	if (ycount == 0) {
+
+		do {
+			char str[1024];
+
+			fprintf(stdout, "Are you SURE you want to do "
+				"this? (yes/no) ");
+
+			if (fgets(str, sizeof(str), stdin) != NULL) {
+
+				if (strncasecmp(str, "yes", 3) == 0)
+					response = 1;
+				else if (strncasecmp(str, "no", 2) == 0)
+					response = -1;
+				else {
+					fprintf(stdout, "Please answer"
+						" \"yes\" or \"no\"\n");
+				}
+			}
+		} while (response == 0);
+
+		if (response == -1) {
+			error = 1;
+			goto scsiformat_bailout;
+		}
+	}
+
+	if (timeout != 0)
+		use_timeout = timeout;
+
+	if (quiet == 0) {
+		fprintf(stdout, "Current format timeout is %d seconds\n",
+			use_timeout / 1000);
+	}
+
+	/*
+	 * If the user hasn't disabled questions and didn't specify a
+	 * timeout on the command line, ask them if they want the current
+	 * timeout.
+	 */
+	if ((ycount == 0)
+	 && (timeout == 0)) {
+		char str[1024];
+		int new_timeout = 0;
+
+		fprintf(stdout, "Enter new timeout in seconds or press\n"
+			"return to keep the current timeout [%d] ",
+			use_timeout / 1000);
+
+		if (fgets(str, sizeof(str), stdin) != NULL) {
+			if (str[0] != '\0')
+				new_timeout = atoi(str);
+		}
+
+		if (new_timeout != 0) {
+			use_timeout = new_timeout * 1000;
+			fprintf(stdout, "Using new timeout value %d\n",
+				use_timeout / 1000);
+		}
+	}
+
+	/*
+	 * Keep this outside the if block below to silence any unused
+	 * variable warnings.
+	 */
+	bzero(&fh, sizeof(fh));
+
+	/*
+	 * If we're in immediate mode, we've got to include the format
+	 * header
+	 */
+	if (immediate != 0) {
+		fh.byte2 = FU_DLH_IMMED;
+		data_ptr = (u_int8_t *)&fh;
+		dxfer_len = sizeof(fh);
+		byte2 = FU_FMT_DATA;
+	} else if (quiet == 0) {
+		fprintf(stdout, "Formatting...");
+		fflush(stdout);
+	}
+
+	scsi_format_unit(&ccb->csio,
+			 /* retries */ retry_count,
+			 /* cbfcnp */ NULL,
+			 /* tag_action */ MSG_SIMPLE_Q_TAG,
+			 /* byte2 */ byte2,
+			 /* ileave */ 0,
+			 /* data_ptr */ data_ptr,
+			 /* dxfer_len */ dxfer_len,
+			 /* sense_len */ SSD_FULL_SIZE,
+			 /* timeout */ use_timeout);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (((retval = cam_send_ccb(device, ccb)) < 0)
+	 || ((immediate == 0)
+	   && ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP))) {
+		const char errstr[] = "error sending format command";
+
+		if (retval < 0)
+			warn(errstr);
+		else
+			warnx(errstr);
+
+		if (arglist & CAM_ARG_VERBOSE) {
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+		}
+		error = 1;
+		goto scsiformat_bailout;
+	}
+
+	/*
+	 * If we ran in non-immediate mode, we already checked for errors
+	 * above and printed out any necessary information.  If we're in
+	 * immediate mode, we need to loop through and get status
+	 * information periodically.
+	 */
+	if (immediate == 0) {
+		if (quiet == 0) {
+			fprintf(stdout, "Format Complete\n");
+		}
+		goto scsiformat_bailout;
+	}
+
+doreport:
+	do {
+		cam_status status;
+
+		bzero(&(&ccb->ccb_h)[1],
+		      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+		/*
+		 * There's really no need to do error recovery or
+		 * retries here, since we're just going to sit in a
+		 * loop and wait for the device to finish formatting.
+		 */
+		scsi_test_unit_ready(&ccb->csio,
+				     /* retries */ 0,
+				     /* cbfcnp */ NULL,
+				     /* tag_action */ MSG_SIMPLE_Q_TAG,
+				     /* sense_len */ SSD_FULL_SIZE,
+				     /* timeout */ 5000);
+
+		/* Disable freezing the device queue */
+		ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+		retval = cam_send_ccb(device, ccb);
+
+		/*
+		 * If we get an error from the ioctl, bail out.  SCSI
+		 * errors are expected.
+		 */
+		if (retval < 0) {
+			warn("error sending CAMIOCOMMAND ioctl");
+			if (arglist & CAM_ARG_VERBOSE) {
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+			}
+			error = 1;
+			goto scsiformat_bailout;
+		}
+
+		status = ccb->ccb_h.status & CAM_STATUS_MASK;
+
+		if ((status != CAM_REQ_CMP)
+		 && (status == CAM_SCSI_STATUS_ERROR)
+		 && ((ccb->ccb_h.status & CAM_AUTOSNS_VALID) != 0)) {
+			struct scsi_sense_data *sense;
+			int error_code, sense_key, asc, ascq;
+
+			sense = &ccb->csio.sense_data;
+			scsi_extract_sense(sense, &error_code, &sense_key,
+					   &asc, &ascq);
+
+			/*
+			 * According to the SCSI-2 and SCSI-3 specs, a
+			 * drive that is in the middle of a format should
+			 * return NOT READY with an ASC of "logical unit
+			 * not ready, format in progress".  The sense key
+			 * specific bytes will then be a progress indicator.
+			 */
+			if ((sense_key == SSD_KEY_NOT_READY)
+			 && (asc == 0x04) && (ascq == 0x04)) {
+				if ((sense->extra_len >= 10)
+				 && ((sense->sense_key_spec[0] &
+				      SSD_SCS_VALID) != 0)
+				 && (quiet == 0)) {
+					int val;
+					u_int64_t percentage;
+
+					val = scsi_2btoul(
+						&sense->sense_key_spec[1]);
+					percentage = 10000 * val;
+
+					fprintf(stdout,
+						"\rFormatting:  %ju.%02u %% "
+						"(%d/%d) done",
+						(uintmax_t)(percentage / 
+						(0x10000 * 100)),
+						(unsigned)((percentage / 
+						0x10000) % 100),
+						val, 0x10000);
+					fflush(stdout);
+				} else if ((quiet == 0)
+					&& (++num_warnings <= 1)) {
+					warnx("Unexpected SCSI Sense Key "
+					      "Specific value returned "
+					      "during format:");
+					scsi_sense_print(device, &ccb->csio,
+							 stderr);
+					warnx("Unable to print status "
+					      "information, but format will "
+					      "proceed.");
+					warnx("will exit when format is "
+					      "complete");
+				}
+				sleep(1);
+			} else {
+				warnx("Unexpected SCSI error during format");
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+				error = 1;
+				goto scsiformat_bailout;
+			}
+
+		} else if (status != CAM_REQ_CMP) {
+			warnx("Unexpected CAM status %#x", status);
+			if (arglist & CAM_ARG_VERBOSE)
+				cam_error_print(device, ccb, CAM_ESF_ALL,
+						CAM_EPF_ALL, stderr);
+			error = 1;
+			goto scsiformat_bailout;
+		}
+
+	} while((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP);
+
+	if (quiet == 0)
+		fprintf(stdout, "\nFormat Complete\n");
+
+scsiformat_bailout:
+
+	cam_freeccb(ccb);
+
+	return(error);
+}
+
+static int
+scsireportluns(struct cam_device *device, int argc, char **argv,
+	       char *combinedopt, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	int c, countonly, lunsonly;
+	struct scsi_report_luns_data *lundata;
+	int alloc_len;
+	uint8_t report_type;
+	uint32_t list_len, i, j;
+	int retval;
+
+	retval = 0;
+	lundata = NULL;
+	report_type = RPL_REPORT_DEFAULT;
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("%s: error allocating ccb", __func__);
+		return (1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	countonly = 0;
+	lunsonly = 0;
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch (c) {
+		case 'c':
+			countonly++;
+			break;
+		case 'l':
+			lunsonly++;
+			break;
+		case 'r':
+			if (strcasecmp(optarg, "default") == 0)
+				report_type = RPL_REPORT_DEFAULT;
+			else if (strcasecmp(optarg, "wellknown") == 0)
+				report_type = RPL_REPORT_WELLKNOWN;
+			else if (strcasecmp(optarg, "all") == 0)
+				report_type = RPL_REPORT_ALL;
+			else {
+				warnx("%s: invalid report type \"%s\"",
+				      __func__, optarg);
+				retval = 1;
+				goto bailout;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	if ((countonly != 0)
+	 && (lunsonly != 0)) {
+		warnx("%s: you can only specify one of -c or -l", __func__);
+		retval = 1;
+		goto bailout;
+	}
+	/*
+	 * According to SPC-4, the allocation length must be at least 16
+	 * bytes -- enough for the header and one LUN.
+	 */
+	alloc_len = sizeof(*lundata) + 8;
+
+retry:
+
+	lundata = malloc(alloc_len);
+
+	if (lundata == NULL) {
+		warn("%s: error mallocing %d bytes", __func__, alloc_len);
+		retval = 1;
+		goto bailout;
+	}
+
+	scsi_report_luns(&ccb->csio,
+			 /*retries*/ retry_count,
+			 /*cbfcnp*/ NULL,
+			 /*tag_action*/ MSG_SIMPLE_Q_TAG,
+			 /*select_report*/ report_type,
+			 /*rpl_buf*/ lundata,
+			 /*alloc_len*/ alloc_len,
+			 /*sense_len*/ SSD_FULL_SIZE,
+			 /*timeout*/ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("error sending REPORT LUNS command");
+
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		cam_error_print(device, ccb, CAM_ESF_ALL, CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto bailout;
+	}
+
+
+	list_len = scsi_4btoul(lundata->length);
+
+	/*
+	 * If we need to list the LUNs, and our allocation
+	 * length was too short, reallocate and retry.
+	 */
+	if ((countonly == 0)
+	 && (list_len > (alloc_len - sizeof(*lundata)))) {
+		alloc_len = list_len + sizeof(*lundata);
+		free(lundata);
+		goto retry;
+	}
+
+	if (lunsonly == 0)
+		fprintf(stdout, "%u LUN%s found\n", list_len / 8,
+			((list_len / 8) > 1) ? "s" : "");
+
+	if (countonly != 0)
+		goto bailout;
+
+	for (i = 0; i < (list_len / 8); i++) {
+		int no_more;
+
+		no_more = 0;
+		for (j = 0; j < sizeof(lundata->luns[i].lundata); j += 2) {
+			if (j != 0)
+				fprintf(stdout, ",");
+			switch (lundata->luns[i].lundata[j] &
+				RPL_LUNDATA_ATYP_MASK) {
+			case RPL_LUNDATA_ATYP_PERIPH:
+				if ((lundata->luns[i].lundata[j] &
+				    RPL_LUNDATA_PERIPH_BUS_MASK) != 0)
+					fprintf(stdout, "%d:", 
+						lundata->luns[i].lundata[j] &
+						RPL_LUNDATA_PERIPH_BUS_MASK);
+				else if ((j == 0)
+				      && ((lundata->luns[i].lundata[j+2] &
+					  RPL_LUNDATA_PERIPH_BUS_MASK) == 0))
+					no_more = 1;
+
+				fprintf(stdout, "%d",
+					lundata->luns[i].lundata[j+1]);
+				break;
+			case RPL_LUNDATA_ATYP_FLAT: {
+				uint8_t tmplun[2];
+				tmplun[0] = lundata->luns[i].lundata[j] &
+					RPL_LUNDATA_FLAT_LUN_MASK;
+				tmplun[1] = lundata->luns[i].lundata[j+1];
+
+				fprintf(stdout, "%d", scsi_2btoul(tmplun));
+				no_more = 1;
+				break;
+			}
+			case RPL_LUNDATA_ATYP_LUN:
+				fprintf(stdout, "%d:%d:%d",
+					(lundata->luns[i].lundata[j+1] &
+					RPL_LUNDATA_LUN_BUS_MASK) >> 5,
+					lundata->luns[i].lundata[j] &
+					RPL_LUNDATA_LUN_TARG_MASK,
+					lundata->luns[i].lundata[j+1] &
+					RPL_LUNDATA_LUN_LUN_MASK);
+				break;
+			case RPL_LUNDATA_ATYP_EXTLUN: {
+				int field_len, field_len_code, eam_code;
+
+				eam_code = lundata->luns[i].lundata[j] &
+					RPL_LUNDATA_EXT_EAM_MASK;
+				field_len_code = (lundata->luns[i].lundata[j] &
+					RPL_LUNDATA_EXT_LEN_MASK) >> 4;
+				field_len = field_len_code * 2;
+		
+				if ((eam_code == RPL_LUNDATA_EXT_EAM_WK)
+				 && (field_len_code == 0x00)) {
+					fprintf(stdout, "%d",
+						lundata->luns[i].lundata[j+1]);
+				} else if ((eam_code ==
+					    RPL_LUNDATA_EXT_EAM_NOT_SPEC)
+					&& (field_len_code == 0x03)) {
+					uint8_t tmp_lun[8];
+
+					/*
+					 * This format takes up all 8 bytes.
+					 * If we aren't starting at offset 0,
+					 * that's a bug.
+					 */
+					if (j != 0) {
+						fprintf(stdout, "Invalid "
+							"offset %d for "
+							"Extended LUN not "
+							"specified format", j);
+						no_more = 1;
+						break;
+					}
+					bzero(tmp_lun, sizeof(tmp_lun));
+					bcopy(&lundata->luns[i].lundata[j+1],
+					      &tmp_lun[1], sizeof(tmp_lun) - 1);
+					fprintf(stdout, "%#jx",
+					       (intmax_t)scsi_8btou64(tmp_lun));
+					no_more = 1;
+				} else {
+					fprintf(stderr, "Unknown Extended LUN"
+						"Address method %#x, length "
+						"code %#x", eam_code,
+						field_len_code);
+					no_more = 1;
+				}
+				break;
+			}
+			default:
+				fprintf(stderr, "Unknown LUN address method "
+					"%#x\n", lundata->luns[i].lundata[0] &
+					RPL_LUNDATA_ATYP_MASK);
+				break;
+			}
+			/*
+			 * For the flat addressing method, there are no
+			 * other levels after it.
+			 */
+			if (no_more != 0)
+				break;
+		}
+		fprintf(stdout, "\n");
+	}
+
+bailout:
+
+	cam_freeccb(ccb);
+
+	free(lundata);
+
+	return (retval);
+}
+
+static int
+scsireadcapacity(struct cam_device *device, int argc, char **argv,
+		 char *combinedopt, int retry_count, int timeout)
+{
+	union ccb *ccb;
+	int blocksizeonly, humanize, numblocks, quiet, sizeonly, baseten;
+	struct scsi_read_capacity_data rcap;
+	struct scsi_read_capacity_data_long rcaplong;
+	uint64_t maxsector;
+	uint32_t block_len;
+	int retval;
+	int c;
+
+	blocksizeonly = 0;
+	humanize = 0;
+	numblocks = 0;
+	quiet = 0;
+	sizeonly = 0;
+	baseten = 0;
+	retval = 0;
+
+	ccb = cam_getccb(device);
+
+	if (ccb == NULL) {
+		warnx("%s: error allocating ccb", __func__);
+		return (1);
+	}
+
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(struct ccb_scsiio) - sizeof(struct ccb_hdr));
+
+	while ((c = getopt(argc, argv, combinedopt)) != -1) {
+		switch (c) {
+		case 'b':
+			blocksizeonly++;
+			break;
+		case 'h':
+			humanize++;
+			baseten = 0;
+			break;
+		case 'H':
+			humanize++;
+			baseten++;
+			break;
+		case 'N':
+			numblocks++;
+			break;
+		case 'q':
+			quiet++;
+			break;
+		case 's':
+			sizeonly++;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if ((blocksizeonly != 0)
+	 && (numblocks != 0)) {
+		warnx("%s: you can only specify one of -b or -N", __func__);
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((blocksizeonly != 0)
+	 && (sizeonly != 0)) {
+		warnx("%s: you can only specify one of -b or -s", __func__);
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((humanize != 0)
+	 && (quiet != 0)) {
+		warnx("%s: you can only specify one of -h/-H or -q", __func__);
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((humanize != 0)
+	 && (blocksizeonly != 0)) {
+		warnx("%s: you can only specify one of -h/-H or -b", __func__);
+		retval = 1;
+		goto bailout;
+	}
+
+	scsi_read_capacity(&ccb->csio,
+			   /*retries*/ retry_count,
+			   /*cbfcnp*/ NULL,
+			   /*tag_action*/ MSG_SIMPLE_Q_TAG,
+			   &rcap,
+			   SSD_FULL_SIZE,
+			   /*timeout*/ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("error sending READ CAPACITY command");
+
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		cam_error_print(device, ccb, CAM_ESF_ALL, CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto bailout;
+	}
+
+	maxsector = scsi_4btoul(rcap.addr);
+	block_len = scsi_4btoul(rcap.length);
+
+	/*
+	 * A last block of 2^32-1 means that the true capacity is over 2TB,
+	 * and we need to issue the long READ CAPACITY to get the real
+	 * capacity.  Otherwise, we're all set.
+	 */
+	if (maxsector != 0xffffffff)
+		goto do_print;
+
+	scsi_read_capacity_16(&ccb->csio,
+			      /*retries*/ retry_count,
+			      /*cbfcnp*/ NULL,
+			      /*tag_action*/ MSG_SIMPLE_Q_TAG,
+			      /*lba*/ 0,
+			      /*reladdr*/ 0,
+			      /*pmi*/ 0,
+			      &rcaplong,
+			      /*sense_len*/ SSD_FULL_SIZE,
+			      /*timeout*/ timeout ? timeout : 5000);
+
+	/* Disable freezing the device queue */
+	ccb->ccb_h.flags |= CAM_DEV_QFRZDIS;
+
+	if (arglist & CAM_ARG_ERR_RECOVER)
+		ccb->ccb_h.flags |= CAM_PASS_ERR_RECOVER;
+
+	if (cam_send_ccb(device, ccb) < 0) {
+		warn("error sending READ CAPACITY (16) command");
+
+		if (arglist & CAM_ARG_VERBOSE)
+			cam_error_print(device, ccb, CAM_ESF_ALL,
+					CAM_EPF_ALL, stderr);
+
+		retval = 1;
+		goto bailout;
+	}
+
+	if ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		cam_error_print(device, ccb, CAM_ESF_ALL, CAM_EPF_ALL, stderr);
+		retval = 1;
+		goto bailout;
+	}
+
+	maxsector = scsi_8btou64(rcaplong.addr);
+	block_len = scsi_4btoul(rcaplong.length);
+
+do_print:
+	if (blocksizeonly == 0) {
+		/*
+		 * Humanize implies !quiet, and also implies numblocks.
+		 */
+		if (humanize != 0) {
+			char tmpstr[6];
+			int64_t tmpbytes;
+			int ret;
+
+			tmpbytes = (maxsector + 1) * block_len;
+			ret = humanize_number(tmpstr, sizeof(tmpstr),
+					      tmpbytes, "", HN_AUTOSCALE,
+					      HN_B | HN_DECIMAL |
+					      ((baseten != 0) ?
+					      HN_DIVISOR_1000 : 0));
+			if (ret == -1) {
+				warnx("%s: humanize_number failed!", __func__);
+				retval = 1;
+				goto bailout;
+			}
+			fprintf(stdout, "Device Size: %s%s", tmpstr,
+				(sizeonly == 0) ?  ", " : "\n");
+		} else if (numblocks != 0) {
+			fprintf(stdout, "%s%ju%s", (quiet == 0) ?
+				"Blocks: " : "", (uintmax_t)maxsector + 1,
+				(sizeonly == 0) ? ", " : "\n");
+		} else {
+			fprintf(stdout, "%s%ju%s", (quiet == 0) ?
+				"Last Block: " : "", (uintmax_t)maxsector,
+				(sizeonly == 0) ? ", " : "\n");
+		}
+	}
+	if (sizeonly == 0)
+		fprintf(stdout, "%s%u%s\n", (quiet == 0) ?
+			"Block Length: " : "", block_len, (quiet == 0) ?
+			" bytes" : "");
+bailout:
+	cam_freeccb(ccb);
+
+	return (retval);
+}
+
+#endif /* MINIMALISTIC */
+
+void 
+usage(int verbose)
+{
+	fprintf(verbose ? stdout : stderr,
+"usage:  camcontrol <command>  [device id][generic args][command args]\n"
+"        camcontrol devlist    [-v]\n"
+#ifndef MINIMALISTIC
+"        camcontrol periphlist [dev_id][-n dev_name] [-u unit]\n"
+"        camcontrol tur        [dev_id][generic args]\n"
+"        camcontrol inquiry    [dev_id][generic args] [-D] [-S] [-R]\n"
+"        camcontrol identify   [dev_id][generic args]\n"
+"        camcontrol reportluns [dev_id][generic args] [-c] [-l] [-r report]\n"
+"        camcontrol readcap    [dev_id][generic args] [-b] [-h] [-H] [-N]\n"
+"                              [-q] [-s]\n"
+"        camcontrol start      [dev_id][generic args]\n"
+"        camcontrol stop       [dev_id][generic args]\n"
+"        camcontrol load       [dev_id][generic args]\n"
+"        camcontrol eject      [dev_id][generic args]\n"
+#endif /* MINIMALISTIC */
+"        camcontrol rescan     <all | bus[:target:lun]>\n"
+"        camcontrol reset      <all | bus[:target:lun]>\n"
+#ifndef MINIMALISTIC
+"        camcontrol defects    [dev_id][generic args] <-f format> [-P][-G]\n"
+"        camcontrol modepage   [dev_id][generic args] <-m page | -l>\n"
+"                              [-P pagectl][-e | -b][-d]\n"
+"        camcontrol cmd        [dev_id][generic args]\n"
+"                              <-a cmd [args] | -c cmd [args]>\n"
+"                              [-i len fmt|-o len fmt [args]] [-r fmt]\n"
+"        camcontrol debug      [-I][-P][-T][-S][-X][-c]\n"
+"                              <all|bus[:target[:lun]]|off>\n"
+"        camcontrol tags       [dev_id][generic args] [-N tags] [-q] [-v]\n"
+"        camcontrol negotiate  [dev_id][generic args] [-a][-c]\n"
+"                              [-D <enable|disable>][-O offset][-q]\n"
+"                              [-R syncrate][-v][-T <enable|disable>]\n"
+"                              [-U][-W bus_width]\n"
+"        camcontrol format     [dev_id][generic args][-q][-r][-w][-y]\n"
+#endif /* MINIMALISTIC */
+"        camcontrol help\n");
+	if (!verbose)
+		return;
+#ifndef MINIMALISTIC
+	fprintf(stdout,
+"Specify one of the following options:\n"
+"devlist     list all CAM devices\n"
+"periphlist  list all CAM peripheral drivers attached to a device\n"
+"tur         send a test unit ready to the named device\n"
+"inquiry     send a SCSI inquiry command to the named device\n"
+"identify    send a ATA identify command to the named device\n"
+"reportluns  send a SCSI report luns command to the device\n"
+"readcap     send a SCSI read capacity command to the device\n"
+"start       send a Start Unit command to the device\n"
+"stop        send a Stop Unit command to the device\n"
+"load        send a Start Unit command to the device with the load bit set\n"
+"eject       send a Stop Unit command to the device with the eject bit set\n"
+"rescan      rescan all busses, the given bus, or bus:target:lun\n"
+"reset       reset all busses, the given bus, or bus:target:lun\n"
+"defects     read the defect list of the specified device\n"
+"modepage    display or edit (-e) the given mode page\n"
+"cmd         send the given scsi command, may need -i or -o as well\n"
+"debug       turn debugging on/off for a bus, target, or lun, or all devices\n"
+"tags        report or set the number of transaction slots for a device\n"
+"negotiate   report or set device negotiation parameters\n"
+"format      send the SCSI FORMAT UNIT command to the named device\n"
+"help        this message\n"
+"Device Identifiers:\n"
+"bus:target        specify the bus and target, lun defaults to 0\n"
+"bus:target:lun    specify the bus, target and lun\n"
+"deviceUNIT        specify the device name, like \"da4\" or \"cd2\"\n"
+"Generic arguments:\n"
+"-v                be verbose, print out sense information\n"
+"-t timeout        command timeout in seconds, overrides default timeout\n"
+"-n dev_name       specify device name, e.g. \"da\", \"cd\"\n"
+"-u unit           specify unit number, e.g. \"0\", \"5\"\n"
+"-E                have the kernel attempt to perform SCSI error recovery\n"
+"-C count          specify the SCSI command retry count (needs -E to work)\n"
+"modepage arguments:\n"
+"-l                list all available mode pages\n"
+"-m page           specify the mode page to view or edit\n"
+"-e                edit the specified mode page\n"
+"-b                force view to binary mode\n"
+"-d                disable block descriptors for mode sense\n"
+"-P pgctl          page control field 0-3\n"
+"defects arguments:\n"
+"-f format         specify defect list format (block, bfi or phys)\n"
+"-G                get the grown defect list\n"
+"-P                get the permanant defect list\n"
+"inquiry arguments:\n"
+"-D                get the standard inquiry data\n"
+"-S                get the serial number\n"
+"-R                get the transfer rate, etc.\n"
+"reportluns arguments:\n"
+"-c                only report a count of available LUNs\n"
+"-l                only print out luns, and not a count\n"
+"-r <reporttype>   specify \"default\", \"wellknown\" or \"all\"\n"
+"readcap arguments\n"
+"-b                only report the blocksize\n"
+"-h                human readable device size, base 2\n"
+"-H                human readable device size, base 10\n"
+"-N                print the number of blocks instead of last block\n"
+"-q                quiet, print numbers only\n"
+"-s                only report the last block/device size\n"
+"cmd arguments:\n"
+"-c cdb [args]     specify the SCSI CDB\n"
+"-i len fmt        specify input data and input data format\n"
+"-o len fmt [args] specify output data and output data fmt\n"
+"debug arguments:\n"
+"-I                CAM_DEBUG_INFO -- scsi commands, errors, data\n"
+"-T                CAM_DEBUG_TRACE -- routine flow tracking\n"
+"-S                CAM_DEBUG_SUBTRACE -- internal routine command flow\n"
+"-c                CAM_DEBUG_CDB -- print out SCSI CDBs only\n"
+"tags arguments:\n"
+"-N tags           specify the number of tags to use for this device\n"
+"-q                be quiet, don't report the number of tags\n"
+"-v                report a number of tag-related parameters\n"
+"negotiate arguments:\n"
+"-a                send a test unit ready after negotiation\n"
+"-c                report/set current negotiation settings\n"
+"-D <arg>          \"enable\" or \"disable\" disconnection\n"
+"-O offset         set command delay offset\n"
+"-q                be quiet, don't report anything\n"
+"-R syncrate       synchronization rate in MHz\n"
+"-T <arg>          \"enable\" or \"disable\" tagged queueing\n"
+"-U                report/set user negotiation settings\n"
+"-W bus_width      set the bus width in bits (8, 16 or 32)\n"
+"-v                also print a Path Inquiry CCB for the controller\n"
+"format arguments:\n"
+"-q                be quiet, don't print status messages\n"
+"-r                run in report only mode\n"
+"-w                don't send immediate format command\n"
+"-y                don't ask any questions\n");
+#endif /* MINIMALISTIC */
+}
+
+int 
+main(int argc, char **argv)
+{
+	int c;
+	char *device = NULL;
+	int unit = 0;
+	struct cam_device *cam_dev = NULL;
+	int timeout = 0, retry_count = 1;
+	camcontrol_optret optreturn;
+	char *tstr;
+	const char *mainopt = "C:En:t:u:v";
+	const char *subopt = NULL;
+	char combinedopt[256];
+	int error = 0, optstart = 2;
+	int devopen = 1;
+#ifndef MINIMALISTIC
+	int bus, target, lun;
+#endif /* MINIMALISTIC */
+
+	cmdlist = CAM_CMD_NONE;
+	arglist = CAM_ARG_NONE;
+
+	if (argc < 2) {
+		usage(0);
+		exit(1);
+	}
+
+	/*
+	 * Get the base option.
+	 */
+	optreturn = getoption(argv[1], &cmdlist, &arglist, &subopt);
+
+	if (optreturn == CC_OR_AMBIGUOUS) {
+		warnx("ambiguous option %s", argv[1]);
+		usage(0);
+		exit(1);
+	} else if (optreturn == CC_OR_NOT_FOUND) {
+		warnx("option %s not found", argv[1]);
+		usage(0);
+		exit(1);
+	}
+
+	/*
+	 * Ahh, getopt(3) is a pain.
+	 *
+	 * This is a gross hack.  There really aren't many other good
+	 * options (excuse the pun) for parsing options in a situation like
+	 * this.  getopt is kinda braindead, so you end up having to run
+	 * through the options twice, and give each invocation of getopt
+	 * the option string for the other invocation.
+	 * 
+	 * You would think that you could just have two groups of options.
+	 * The first group would get parsed by the first invocation of
+	 * getopt, and the second group would get parsed by the second
+	 * invocation of getopt.  It doesn't quite work out that way.  When
+	 * the first invocation of getopt finishes, it leaves optind pointing
+	 * to the argument _after_ the first argument in the second group.
+	 * So when the second invocation of getopt comes around, it doesn't
+	 * recognize the first argument it gets and then bails out.
+	 * 
+	 * A nice alternative would be to have a flag for getopt that says
+	 * "just keep parsing arguments even when you encounter an unknown
+	 * argument", but there isn't one.  So there's no real clean way to
+	 * easily parse two sets of arguments without having one invocation
+	 * of getopt know about the other.
+	 * 
+	 * Without this hack, the first invocation of getopt would work as
+	 * long as the generic arguments are first, but the second invocation
+	 * (in the subfunction) would fail in one of two ways.  In the case
+	 * where you don't set optreset, it would fail because optind may be
+	 * pointing to the argument after the one it should be pointing at.
+	 * In the case where you do set optreset, and reset optind, it would
+	 * fail because getopt would run into the first set of options, which
+	 * it doesn't understand.
+	 *
+	 * All of this would "sort of" work if you could somehow figure out
+	 * whether optind had been incremented one option too far.  The
+	 * mechanics of that, however, are more daunting than just giving
+	 * both invocations all of the expect options for either invocation.
+	 * 
+	 * Needless to say, I wouldn't mind if someone invented a better
+	 * (non-GPL!) command line parsing interface than getopt.  I
+	 * wouldn't mind if someone added more knobs to getopt to make it
+	 * work better.  Who knows, I may talk myself into doing it someday,
+	 * if the standards weenies let me.  As it is, it just leads to
+	 * hackery like this and causes people to avoid it in some cases.
+	 * 
+	 * KDM, September 8th, 1998
+	 */
+	if (subopt != NULL)
+		sprintf(combinedopt, "%s%s", mainopt, subopt);
+	else
+		sprintf(combinedopt, "%s", mainopt);
+
+	/*
+	 * For these options we do not parse optional device arguments and
+	 * we do not open a passthrough device.
+	 */
+	if ((cmdlist == CAM_CMD_RESCAN)
+	 || (cmdlist == CAM_CMD_RESET)
+	 || (cmdlist == CAM_CMD_DEVTREE)
+	 || (cmdlist == CAM_CMD_USAGE)
+	 || (cmdlist == CAM_CMD_DEBUG))
+		devopen = 0;
+
+#ifndef MINIMALISTIC
+	if ((devopen == 1)
+	 && (argc > 2 && argv[2][0] != '-')) {
+		char name[30];
+		int rv;
+
+		/*
+		 * First catch people who try to do things like:
+		 * camcontrol tur /dev/da0 
+		 * camcontrol doesn't take device nodes as arguments.
+		 */
+		if (argv[2][0] == '/') {
+			warnx("%s is not a valid device identifier", argv[2]);
+			errx(1, "please read the camcontrol(8) man page");
+		} else if (isdigit(argv[2][0])) {
+			/* device specified as bus:target[:lun] */
+			rv = parse_btl(argv[2], &bus, &target, &lun, &arglist);
+			if (rv < 2)
+				errx(1, "numeric device specification must "
+				     "be either bus:target, or "
+				     "bus:target:lun");
+			/* default to 0 if lun was not specified */
+			if ((arglist & CAM_ARG_LUN) == 0) {
+				lun = 0;
+				arglist |= CAM_ARG_LUN;
+			}
+			optstart++;
+		} else {
+			if (cam_get_device(argv[2], name, sizeof name, &unit)
+			    == -1)
+				errx(1, "%s", cam_errbuf);
+			device = strdup(name);
+			arglist |= CAM_ARG_DEVICE | CAM_ARG_UNIT;
+			optstart++;
+		}
+	}
+#endif /* MINIMALISTIC */
+	/*
+	 * Start getopt processing at argv[2/3], since we've already
+	 * accepted argv[1..2] as the command name, and as a possible
+	 * device name.
+	 */
+	optind = optstart;
+
+	/*
+	 * Now we run through the argument list looking for generic
+	 * options, and ignoring options that possibly belong to
+	 * subfunctions.
+	 */
+	while ((c = getopt(argc, argv, combinedopt))!= -1){
+		switch(c) {
+			case 'C':
+				retry_count = strtol(optarg, NULL, 0);
+				if (retry_count < 0)
+					errx(1, "retry count %d is < 0",
+					     retry_count);
+				arglist |= CAM_ARG_RETRIES;
+				break;
+			case 'E':
+				arglist |= CAM_ARG_ERR_RECOVER;
+				break;
+			case 'n':
+				arglist |= CAM_ARG_DEVICE;
+				tstr = optarg;
+				while (isspace(*tstr) && (*tstr != '\0'))
+					tstr++;
+				device = (char *)strdup(tstr);
+				break;
+			case 't':
+				timeout = strtol(optarg, NULL, 0);
+				if (timeout < 0)
+					errx(1, "invalid timeout %d", timeout);
+				/* Convert the timeout from seconds to ms */
+				timeout *= 1000;
+				arglist |= CAM_ARG_TIMEOUT;
+				break;
+			case 'u':
+				arglist |= CAM_ARG_UNIT;
+				unit = strtol(optarg, NULL, 0);
+				break;
+			case 'v':
+				arglist |= CAM_ARG_VERBOSE;
+				break;
+			default:
+				break;
+		}
+	}
+
+#ifndef MINIMALISTIC
+	/*
+	 * For most commands we'll want to open the passthrough device
+	 * associated with the specified device.  In the case of the rescan
+	 * commands, we don't use a passthrough device at all, just the
+	 * transport layer device.
+	 */
+	if (devopen == 1) {
+		if (((arglist & (CAM_ARG_BUS|CAM_ARG_TARGET)) == 0)
+		 && (((arglist & CAM_ARG_DEVICE) == 0)
+		  || ((arglist & CAM_ARG_UNIT) == 0))) {
+			errx(1, "subcommand \"%s\" requires a valid device "
+			     "identifier", argv[1]);
+		}
+
+		if ((cam_dev = ((arglist & (CAM_ARG_BUS | CAM_ARG_TARGET))?
+				cam_open_btl(bus, target, lun, O_RDWR, NULL) :
+				cam_open_spec_device(device,unit,O_RDWR,NULL)))
+		     == NULL)
+			errx(1,"%s", cam_errbuf);
+	}
+#endif /* MINIMALISTIC */
+
+	/*
+	 * Reset optind to 2, and reset getopt, so these routines can parse
+	 * the arguments again.
+	 */
+	optind = optstart;
+	optreset = 1;
+
+	switch(cmdlist) {
+#ifndef MINIMALISTIC
+		case CAM_CMD_DEVLIST:
+			error = getdevlist(cam_dev);
+			break;
+#endif /* MINIMALISTIC */
+		case CAM_CMD_DEVTREE:
+			error = getdevtree();
+			break;
+#ifndef MINIMALISTIC
+		case CAM_CMD_TUR:
+			error = testunitready(cam_dev, retry_count, timeout, 0);
+			break;
+		case CAM_CMD_INQUIRY:
+			error = scsidoinquiry(cam_dev, argc, argv, combinedopt,
+					      retry_count, timeout);
+			break;
+		case CAM_CMD_IDENTIFY:
+			error = ataidentify(cam_dev, retry_count, timeout);
+			break;
+		case CAM_CMD_STARTSTOP:
+			error = scsistart(cam_dev, arglist & CAM_ARG_START_UNIT,
+					  arglist & CAM_ARG_EJECT, retry_count,
+					  timeout);
+			break;
+#endif /* MINIMALISTIC */
+		case CAM_CMD_RESCAN:
+			error = dorescan_or_reset(argc, argv, 1);
+			break;
+		case CAM_CMD_RESET:
+			error = dorescan_or_reset(argc, argv, 0);
+			break;
+#ifndef MINIMALISTIC
+		case CAM_CMD_READ_DEFECTS:
+			error = readdefects(cam_dev, argc, argv, combinedopt,
+					    retry_count, timeout);
+			break;
+		case CAM_CMD_MODE_PAGE:
+			modepage(cam_dev, argc, argv, combinedopt,
+				 retry_count, timeout);
+			break;
+		case CAM_CMD_SCSI_CMD:
+			error = scsicmd(cam_dev, argc, argv, combinedopt,
+					retry_count, timeout);
+			break;
+		case CAM_CMD_DEBUG:
+			error = camdebug(argc, argv, combinedopt);
+			break;
+		case CAM_CMD_TAG:
+			error = tagcontrol(cam_dev, argc, argv, combinedopt);
+			break;
+		case CAM_CMD_RATE:
+			error = ratecontrol(cam_dev, retry_count, timeout,
+					    argc, argv, combinedopt);
+			break;
+		case CAM_CMD_FORMAT:
+			error = scsiformat(cam_dev, argc, argv,
+					   combinedopt, retry_count, timeout);
+			break;
+		case CAM_CMD_REPORTLUNS:
+			error = scsireportluns(cam_dev, argc, argv,
+					       combinedopt, retry_count,
+					       timeout);
+			break;
+		case CAM_CMD_READCAP:
+			error = scsireadcapacity(cam_dev, argc, argv,
+						 combinedopt, retry_count,
+						 timeout);
+			break;
+#endif /* MINIMALISTIC */
+		case CAM_CMD_USAGE:
+			usage(1);
+			break;
+		default:
+			usage(0);
+			error = 1;
+			break;
+	}
+
+	if (cam_dev != NULL)
+		cam_close_device(cam_dev);
+
+	exit(error);
+}
--- a/sbin/camcontrol/camcontrol.h
+++ b/sbin/camcontrol/camcontrol.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 1998 Kenneth D. Merry.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _CAMCONTROL_H
+#define _CAMCONTROL_H
+/*
+ * get_hook: Structure for evaluating args in a callback.
+ */
+struct get_hook
+{
+	int argc;
+	char **argv;
+	int got;
+};
+
+void mode_sense(struct cam_device *device, int mode_page, int page_control,
+		int dbd, int retry_count, int timeout, u_int8_t *data,
+		int datalen);
+void mode_select(struct cam_device *device, int save_pages, int retry_count,
+		 int timeout, u_int8_t *data, int datalen);
+void mode_edit(struct cam_device *device, int page, int page_control, int dbd,
+	       int edit, int binary, int retry_count, int timeout);
+void mode_list(struct cam_device *device, int page_control, int dbd,
+	       int retry_count, int timeout);
+char *cget(void *hook, char *name);
+int iget(void *hook, char *name);
+void arg_put(void *hook, int letter, void *arg, int count, char *name);
+void usage(int verbose);
+#endif /* _CAMCONTROL_H */
--- a/sbin/camcontrol/Makefile
+++ b/sbin/camcontrol/Makefile
@@ -0,0 +1,19 @@
+# $FreeBSD$
+
+PROG=	camcontrol
+SRCS=	camcontrol.c util.c
+.if !defined(RELEASE_CRUNCH)
+SRCS+=	modeedit.c
+.else
+CFLAGS+= -DMINIMALISTIC
+.endif
+.if ${MACHINE_ARCH} == "arm"
+WARNS?= 3
+.else
+WARNS?=	6
+.endif
+DPADD=	${LIBCAM} ${LIBSBUF} ${LIBUTIL}
+LDADD=	-lcam -lsbuf -lutil
+MAN=	camcontrol.8
+
+.include <bsd.prog.mk>
--- a/sbin/camcontrol/modeedit.c
+++ b/sbin/camcontrol/modeedit.c
@@ -0,0 +1,909 @@
+/*-
+ * Copyright (c) 2000 Kelly Yancey <kbyanc@posi.net>
+ * Derived from work done by Julian Elischer <julian@tfs.com,
+ * julian@dialix.oz.au>, 1993, and Peter Dufault <dufault@hda.com>, 1994.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution. 
+ *    
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/queue.h>
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sysexits.h>
+#include <unistd.h>
+
+#include <cam/scsi/scsi_all.h>
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <camlib.h>
+#include "camcontrol.h"
+
+int verbose = 0;
+
+#define	DEFAULT_SCSI_MODE_DB	"/usr/share/misc/scsi_modes"
+#define	DEFAULT_EDITOR		"vi"
+#define	MAX_FORMAT_SPEC		4096	/* Max CDB format specifier. */
+#define	MAX_PAGENUM_LEN		10	/* Max characters in page num. */
+#define	MAX_PAGENAME_LEN	64	/* Max characters in page name. */
+#define	PAGEDEF_START		'{'	/* Page definition delimiter. */
+#define	PAGEDEF_END		'}'	/* Page definition delimiter. */
+#define	PAGENAME_START		'"'	/* Page name delimiter. */
+#define	PAGENAME_END		'"'	/* Page name delimiter. */
+#define	PAGEENTRY_END		';'	/* Page entry terminator (optional). */
+#define	MAX_COMMAND_SIZE	255	/* Mode/Log sense data buffer size. */
+#define PAGE_CTRL_SHIFT		6	/* Bit offset to page control field. */
+
+
+/* Macros for working with mode pages. */
+#define	MODE_PAGE_HEADER(mh)						\
+	(struct scsi_mode_page_header *)find_mode_page_6(mh)
+
+#define	MODE_PAGE_DATA(mph)						\
+	(u_int8_t *)(mph) + sizeof(struct scsi_mode_page_header)
+
+
+struct editentry {
+	STAILQ_ENTRY(editentry) link;
+	char	*name;
+	char	type;
+	int	editable;
+	int	size;
+	union {
+		int	ivalue;
+		char	*svalue;
+	} value;
+};
+STAILQ_HEAD(, editentry) editlist;	/* List of page entries. */
+int editlist_changed = 0;		/* Whether any entries were changed. */
+
+struct pagename {
+	SLIST_ENTRY(pagename) link;
+	int pagenum;
+	char *name;
+};
+SLIST_HEAD(, pagename) namelist;	/* Page number to name mappings. */
+
+static char format[MAX_FORMAT_SPEC];	/* Buffer for scsi cdb format def. */
+
+static FILE *edit_file = NULL;		/* File handle for edit file. */
+static char edit_path[] = "/tmp/camXXXXXX";
+
+
+/* Function prototypes. */
+static void		 editentry_create(void *hook, int letter, void *arg,
+					  int count, char *name);
+static void		 editentry_update(void *hook, int letter, void *arg,
+					  int count, char *name);
+static int		 editentry_save(void *hook, char *name);
+static struct editentry	*editentry_lookup(char *name);
+static int		 editentry_set(char *name, char *newvalue,
+				       int editonly);
+static void		 editlist_populate(struct cam_device *device,
+					   int modepage, int page_control,
+					   int dbd, int retries, int timeout);
+static void		 editlist_save(struct cam_device *device, int modepage,
+				       int page_control, int dbd, int retries,
+				       int timeout);
+static void		 nameentry_create(int pagenum, char *name);
+static struct pagename	*nameentry_lookup(int pagenum);
+static int		 load_format(const char *pagedb_path, int page);
+static int		 modepage_write(FILE *file, int editonly);
+static int		 modepage_read(FILE *file);
+static void		 modepage_edit(void);
+static void		 modepage_dump(struct cam_device *device, int page,
+				       int page_control, int dbd, int retries,
+				       int timeout);
+static void		 cleanup_editfile(void);
+
+
+#define	returnerr(code) do {						\
+	errno = code;							\
+	return (-1);							\
+} while (0)
+
+
+#define	RTRIM(string) do {						\
+	int _length;							\
+	while (isspace(string[_length = strlen(string) - 1]))		\
+		string[_length] = '\0';					\
+} while (0)
+
+
+static void
+editentry_create(void *hook __unused, int letter, void *arg, int count,
+		 char *name)
+{
+	struct editentry *newentry;	/* Buffer to hold new entry. */
+
+	/* Allocate memory for the new entry and a copy of the entry name. */
+	if ((newentry = malloc(sizeof(struct editentry))) == NULL ||
+	    (newentry->name = strdup(name)) == NULL)
+		err(EX_OSERR, NULL);
+
+	/* Trim any trailing whitespace for the entry name. */
+	RTRIM(newentry->name);
+
+	newentry->editable = (arg != NULL);
+	newentry->type = letter;
+	newentry->size = count;		/* Placeholder; not accurate. */
+	newentry->value.svalue = NULL;
+
+	STAILQ_INSERT_TAIL(&editlist, newentry, link);
+}
+
+static void
+editentry_update(void *hook __unused, int letter, void *arg, int count,
+		 char *name)
+{
+	struct editentry *dest;		/* Buffer to hold entry to update. */
+
+	dest = editentry_lookup(name);
+	assert(dest != NULL);
+
+	dest->type = letter;
+	dest->size = count;		/* We get the real size now. */
+
+	switch (dest->type) {
+	case 'i':			/* Byte-sized integral type. */
+	case 'b':			/* Bit-sized integral types. */
+	case 't':
+		dest->value.ivalue = (intptr_t)arg;
+		break;
+
+	case 'c':			/* Character array. */
+	case 'z':			/* Null-padded string. */
+		editentry_set(name, (char *)arg, 0);
+		break;
+	default:
+		; /* NOTREACHED */
+	}
+}
+
+static int
+editentry_save(void *hook __unused, char *name)
+{
+	struct editentry *src;		/* Entry value to save. */
+
+	src = editentry_lookup(name);
+	assert(src != NULL);
+
+	switch (src->type) {
+	case 'i':			/* Byte-sized integral type. */
+	case 'b':			/* Bit-sized integral types. */
+	case 't':
+		return (src->value.ivalue);
+		/* NOTREACHED */
+
+	case 'c':			/* Character array. */
+	case 'z':			/* Null-padded string. */
+		return ((intptr_t)src->value.svalue);
+		/* NOTREACHED */
+
+	default:
+		; /* NOTREACHED */
+	}
+
+	return (0);			/* This should never happen. */
+}
+
+static struct editentry *
+editentry_lookup(char *name)
+{
+	struct editentry *scan;
+
+	assert(name != NULL);
+
+	STAILQ_FOREACH(scan, &editlist, link) {
+		if (strcasecmp(scan->name, name) == 0)
+			return (scan);
+	}
+
+	/* Not found during list traversal. */
+	return (NULL);
+}
+
+static int
+editentry_set(char *name, char *newvalue, int editonly)
+{
+	struct editentry *dest;	/* Modepage entry to update. */
+	char *cval;		/* Pointer to new string value. */
+	char *convertend;	/* End-of-conversion pointer. */
+	int ival;		/* New integral value. */
+	int resolution;		/* Resolution in bits for integer conversion. */
+
+/*
+ * Macro to determine the maximum value of the given size for the current
+ * resolution.
+ * XXX Lovely x86's optimize out the case of shifting by 32 and gcc doesn't
+ *     currently workaround it (even for int64's), so we have to kludge it.
+ */
+#define	RESOLUTION_MAX(size) ((resolution * (size) == 32)? 		\
+	(int)0xffffffff: (1 << (resolution * (size))) - 1)
+
+	assert(newvalue != NULL);
+	if (*newvalue == '\0')
+		return (0);	/* Nothing to do. */
+
+	if ((dest = editentry_lookup(name)) == NULL)
+		returnerr(ENOENT);
+	if (!dest->editable && editonly)
+		returnerr(EPERM);
+
+	switch (dest->type) {
+	case 'i':		/* Byte-sized integral type. */
+	case 'b':		/* Bit-sized integral types. */
+	case 't':
+		/* Convert the value string to an integer. */
+		resolution = (dest->type == 'i')? 8: 1;
+		ival = (int)strtol(newvalue, &convertend, 0);
+		if (*convertend != '\0')
+			returnerr(EINVAL);
+		if (ival > RESOLUTION_MAX(dest->size) || ival < 0) {
+			int newival = (ival < 0)? 0: RESOLUTION_MAX(dest->size);
+			warnx("value %d is out of range for entry %s; clipping "
+			    "to %d", ival, name, newival);
+			ival = newival;
+		}
+		if (dest->value.ivalue != ival)
+			editlist_changed = 1;
+		dest->value.ivalue = ival;
+		break;
+
+	case 'c':		/* Character array. */
+	case 'z':		/* Null-padded string. */
+		if ((cval = malloc(dest->size + 1)) == NULL)
+			err(EX_OSERR, NULL);
+		bzero(cval, dest->size + 1);
+		strncpy(cval, newvalue, dest->size);
+		if (dest->type == 'z') {
+			/* Convert trailing spaces to nulls. */
+			char *convertend2;
+
+			for (convertend2 = cval + dest->size;
+			    convertend2 >= cval; convertend2--) {
+				if (*convertend2 == ' ')
+					*convertend2 = '\0';
+				else if (*convertend2 != '\0')
+					break;
+			}
+		}
+		if (strncmp(dest->value.svalue, cval, dest->size) == 0) {
+			/* Nothing changed, free the newly allocated string. */
+			free(cval);
+			break;
+		}
+		if (dest->value.svalue != NULL) {
+			/* Free the current string buffer. */
+			free(dest->value.svalue);
+			dest->value.svalue = NULL;
+		}
+		dest->value.svalue = cval;
+		editlist_changed = 1;
+		break;
+
+	default:
+		; /* NOTREACHED */
+	}
+
+	return (0);
+#undef RESOLUTION_MAX
+}
+
+static void
+nameentry_create(int pagenum, char *name) {
+	struct pagename *newentry;
+
+	if (pagenum < 0 || name == NULL || name[0] == '\0')
+		return;
+
+	/* Allocate memory for the new entry and a copy of the entry name. */
+	if ((newentry = malloc(sizeof(struct pagename))) == NULL ||
+	    (newentry->name = strdup(name)) == NULL)
+		err(EX_OSERR, NULL);
+
+	/* Trim any trailing whitespace for the page name. */
+	RTRIM(newentry->name);
+
+	newentry->pagenum = pagenum;
+	SLIST_INSERT_HEAD(&namelist, newentry, link);
+}
+
+static struct pagename *
+nameentry_lookup(int pagenum) {
+	struct pagename *scan;
+
+	SLIST_FOREACH(scan, &namelist, link) {
+		if (pagenum == scan->pagenum)
+			return (scan);
+	}
+
+	/* Not found during list traversal. */
+	return (NULL);
+}
+
+static int
+load_format(const char *pagedb_path, int page)
+{
+	FILE *pagedb;
+	char str_pagenum[MAX_PAGENUM_LEN];
+	char str_pagename[MAX_PAGENAME_LEN];
+	int pagenum;
+	int depth;			/* Quoting depth. */
+	int found;
+	int lineno;
+	enum { LOCATE, PAGENAME, PAGEDEF } state;
+	int ch;
+	char c;
+
+#define	SETSTATE_LOCATE do {						\
+	str_pagenum[0] = '\0';						\
+	str_pagename[0] = '\0';						\
+	pagenum = -1;							\
+	state = LOCATE;							\
+} while (0)
+
+#define	SETSTATE_PAGENAME do {						\
+	str_pagename[0] = '\0';						\
+	state = PAGENAME;						\
+} while (0)
+
+#define	SETSTATE_PAGEDEF do {						\
+	format[0] = '\0';						\
+	state = PAGEDEF;						\
+} while (0)
+
+#define	UPDATE_LINENO do {						\
+	if (c == '\n')							\
+		lineno++;						\
+} while (0)
+
+#define	BUFFERFULL(buffer)	(strlen(buffer) + 1 >= sizeof(buffer))
+
+	if ((pagedb = fopen(pagedb_path, "r")) == NULL)
+		returnerr(ENOENT);
+
+	SLIST_INIT(&namelist);
+
+	depth = 0;
+	lineno = 0;
+	found = 0;
+	SETSTATE_LOCATE;
+	while ((ch = fgetc(pagedb)) != EOF) {
+
+		/* Keep a line count to make error messages more useful. */
+		UPDATE_LINENO;
+
+		/* Skip over comments anywhere in the mode database. */
+		if (ch == '#') {
+			do {
+				ch = fgetc(pagedb);
+			} while (ch != '\n' && ch != EOF);
+			UPDATE_LINENO;
+			continue;
+		}
+		c = ch;
+
+		/* Strip out newline characters. */
+		if (c == '\n')
+			continue;
+
+		/* Keep track of the nesting depth for braces. */
+		if (c == PAGEDEF_START)
+			depth++;
+		else if (c == PAGEDEF_END) {
+			depth--;
+			if (depth < 0) {
+				errx(EX_OSFILE, "%s:%d: %s", pagedb_path,
+				    lineno, "mismatched bracket");
+			}
+		}
+
+		switch (state) {
+		case LOCATE:
+			/*
+			 * Locate the page the user is interested in, skipping
+			 * all others.
+			 */
+			if (isspace(c)) {
+				/* Ignore all whitespace between pages. */
+				break;
+			} else if (depth == 0 && c == PAGEENTRY_END) {
+				/*
+				 * A page entry terminator will reset page
+				 * scanning (useful for assigning names to
+				 * modes without providing a mode definition).
+				 */
+				/* Record the name of this page. */
+				pagenum = strtol(str_pagenum, NULL, 0);
+				nameentry_create(pagenum, str_pagename);
+				SETSTATE_LOCATE;
+			} else if (depth == 0 && c == PAGENAME_START) {
+				SETSTATE_PAGENAME;
+			} else if (c == PAGEDEF_START) {
+				pagenum = strtol(str_pagenum, NULL, 0);
+				if (depth == 1) {
+					/* Record the name of this page. */
+					nameentry_create(pagenum, str_pagename);
+					/*
+					 * Only record the format if this is
+					 * the page we are interested in.
+					 */
+					if (page == pagenum && !found)
+						SETSTATE_PAGEDEF;
+				}
+			} else if (c == PAGEDEF_END) {
+				/* Reset the processor state. */
+				SETSTATE_LOCATE;
+			} else if (depth == 0 && ! BUFFERFULL(str_pagenum)) {
+				strncat(str_pagenum, &c, 1);
+			} else if (depth == 0) {
+				errx(EX_OSFILE, "%s:%d: %s %zd %s", pagedb_path,
+				    lineno, "page identifier exceeds",
+				    sizeof(str_pagenum) - 1, "characters");
+			}
+			break;
+
+		case PAGENAME:
+			if (c == PAGENAME_END) {
+				/*
+				 * Return to LOCATE state without resetting the
+				 * page number buffer.
+				 */
+				state = LOCATE;
+			} else if (! BUFFERFULL(str_pagename)) {
+				strncat(str_pagename, &c, 1);
+			} else {
+				errx(EX_OSFILE, "%s:%d: %s %zd %s", pagedb_path,
+				    lineno, "page name exceeds",
+				    sizeof(str_pagenum) - 1, "characters");
+			}
+			break;
+
+		case PAGEDEF:
+			/*
+			 * Transfer the page definition into a format buffer
+			 * suitable for use with CDB encoding/decoding routines.
+			 */
+			if (depth == 0) {
+				found = 1;
+				SETSTATE_LOCATE;
+			} else if (! BUFFERFULL(format)) {
+				strncat(format, &c, 1);
+			} else {
+				errx(EX_OSFILE, "%s:%d: %s %zd %s", pagedb_path,
+				    lineno, "page definition exceeds",
+				    sizeof(format) - 1, "characters");
+			}
+			break;
+
+		default:
+			; /* NOTREACHED */
+		}
+
+		/* Repeat processing loop with next character. */
+	}
+
+	if (ferror(pagedb))
+		err(EX_OSFILE, "%s", pagedb_path);
+
+	/* Close the SCSI page database. */
+	fclose(pagedb);
+
+	if (!found)			/* Never found a matching page. */
+		returnerr(ESRCH);
+
+	return (0);
+}
+
+static void
+editlist_populate(struct cam_device *device, int modepage, int page_control,
+		  int dbd, int retries, int timeout)
+{
+	u_int8_t data[MAX_COMMAND_SIZE];/* Buffer to hold sense data. */
+	u_int8_t *mode_pars;		/* Pointer to modepage params. */
+	struct scsi_mode_header_6 *mh;	/* Location of mode header. */
+	struct scsi_mode_page_header *mph;
+
+	STAILQ_INIT(&editlist);
+
+	/* Fetch changeable values; use to build initial editlist. */
+	mode_sense(device, modepage, 1, dbd, retries, timeout, data,
+		   sizeof(data));
+
+	mh = (struct scsi_mode_header_6 *)data;
+	mph = MODE_PAGE_HEADER(mh);
+	mode_pars = MODE_PAGE_DATA(mph);
+
+	/* Decode the value data, creating edit_entries for each value. */
+	buff_decode_visit(mode_pars, mh->data_length, format,
+	    editentry_create, 0);
+
+	/* Fetch the current/saved values; use to set editentry values. */
+	mode_sense(device, modepage, page_control, dbd, retries, timeout, data,
+		   sizeof(data));
+	buff_decode_visit(mode_pars, mh->data_length, format,
+	    editentry_update, 0);
+}
+
+static void
+editlist_save(struct cam_device *device, int modepage, int page_control,
+	      int dbd, int retries, int timeout)
+{
+	u_int8_t data[MAX_COMMAND_SIZE];/* Buffer to hold sense data. */
+	u_int8_t *mode_pars;		/* Pointer to modepage params. */
+	struct scsi_mode_header_6 *mh;	/* Location of mode header. */
+	struct scsi_mode_page_header *mph;
+
+	/* Make sure that something changed before continuing. */
+	if (! editlist_changed)
+		return;
+
+	/*
+	 * Preload the CDB buffer with the current mode page data.
+	 * XXX If buff_encode_visit would return the number of bytes encoded
+	 *     we *should* use that to build a header from scratch. As it is
+	 *     now, we need mode_sense to find out the page length.
+	 */
+	mode_sense(device, modepage, page_control, dbd, retries, timeout, data,
+		   sizeof(data));
+
+	/* Initial headers & offsets. */
+	mh = (struct scsi_mode_header_6 *)data;
+	mph = MODE_PAGE_HEADER(mh);
+	mode_pars = MODE_PAGE_DATA(mph);
+
+	/* Encode the value data to be passed back to the device. */
+	buff_encode_visit(mode_pars, mh->data_length, format,
+	    editentry_save, 0);
+
+	/* Eliminate block descriptors. */
+	bcopy(mph, ((u_int8_t *)mh) + sizeof(*mh),
+	    sizeof(*mph) + mph->page_length);
+
+	/* Recalculate headers & offsets. */
+	mh->blk_desc_len = 0;		/* No block descriptors. */
+	mh->dev_spec = 0;		/* Clear device-specific parameters. */
+	mph = MODE_PAGE_HEADER(mh);
+	mode_pars = MODE_PAGE_DATA(mph);
+
+	mph->page_code &= SMS_PAGE_CODE;/* Isolate just the page code. */
+	mh->data_length = 0;		/* Reserved for MODE SELECT command. */
+
+	/*
+	 * Write the changes back to the device. If the user editted control
+	 * page 3 (saved values) then request the changes be permanently
+	 * recorded.
+	 */
+	mode_select(device,
+	    (page_control << PAGE_CTRL_SHIFT == SMS_PAGE_CTRL_SAVED),
+	    retries, timeout, (u_int8_t *)mh,
+	    sizeof(*mh) + mh->blk_desc_len + sizeof(*mph) + mph->page_length);
+}
+
+static int
+modepage_write(FILE *file, int editonly)
+{
+	struct editentry *scan;
+	int written = 0;
+
+	STAILQ_FOREACH(scan, &editlist, link) {
+		if (scan->editable || !editonly) {
+			written++;
+			if (scan->type == 'c' || scan->type == 'z') {
+				fprintf(file, "%s:  %s\n", scan->name,
+				    scan->value.svalue);
+			} else {
+				fprintf(file, "%s:  %d\n", scan->name,
+				    scan->value.ivalue);
+			}
+		}
+	}
+	return (written);
+}
+
+static int
+modepage_read(FILE *file)
+{
+	char *buffer;			/* Pointer to dynamic line buffer.  */
+	char *line;			/* Pointer to static fgetln buffer. */
+	char *name;			/* Name portion of the line buffer. */
+	char *value;			/* Value portion of line buffer.    */
+	size_t length;			/* Length of static fgetln buffer.  */
+
+#define	ABORT_READ(message, param) do {					\
+	warnx(message, param);						\
+	free(buffer);							\
+	returnerr(EAGAIN);						\
+} while (0)
+
+	while ((line = fgetln(file, &length)) != NULL) {
+		/* Trim trailing whitespace (including optional newline). */
+		while (length > 0 && isspace(line[length - 1]))
+			length--;
+
+	    	/* Allocate a buffer to hold the line + terminating null. */
+	    	if ((buffer = malloc(length + 1)) == NULL)
+			err(EX_OSERR, NULL);
+		memcpy(buffer, line, length);
+		buffer[length] = '\0';
+
+		/* Strip out comments. */
+		if ((value = strchr(buffer, '#')) != NULL)
+			*value = '\0';
+
+		/* The name is first in the buffer. Trim whitespace.*/
+		name = buffer;
+		RTRIM(name);
+		while (isspace(*name))
+			name++;
+
+		/* Skip empty lines. */
+		if (strlen(name) == 0)
+			continue;
+
+		/* The name ends at the colon; the value starts there. */
+		if ((value = strrchr(buffer, ':')) == NULL)
+			ABORT_READ("no value associated with %s", name);
+		*value = '\0';			/* Null-terminate name. */
+		value++;			/* Value starts afterwards. */
+
+		/* Trim leading and trailing whitespace. */
+		RTRIM(value);
+		while (isspace(*value))
+			value++;
+
+		/* Make sure there is a value left. */
+		if (strlen(value) == 0)
+			ABORT_READ("no value associated with %s", name);
+
+		/* Update our in-memory copy of the modepage entry value. */
+		if (editentry_set(name, value, 1) != 0) {
+			if (errno == ENOENT) {
+				/* No entry by the name. */
+				ABORT_READ("no such modepage entry \"%s\"",
+				    name);
+			} else if (errno == EINVAL) {
+				/* Invalid value. */
+				ABORT_READ("Invalid value for entry \"%s\"",
+				    name);
+			} else if (errno == ERANGE) {
+				/* Value out of range for entry type. */
+				ABORT_READ("value out of range for %s", name);
+			} else if (errno == EPERM) {
+				/* Entry is not editable; not fatal. */
+				warnx("modepage entry \"%s\" is read-only; "
+				    "skipping.", name);
+			}
+		}
+
+		free(buffer);
+	}
+	return (ferror(file)? -1: 0);
+
+#undef ABORT_READ
+}
+
+static void
+modepage_edit(void)
+{
+	const char *editor;
+	char *commandline;
+	int fd;
+	int written;
+
+	if (!isatty(fileno(stdin))) {
+		/* Not a tty, read changes from stdin. */
+		modepage_read(stdin);
+		return;
+	}
+
+	/* Lookup editor to invoke. */
+	if ((editor = getenv("EDITOR")) == NULL)
+		editor = DEFAULT_EDITOR;
+
+	/* Create temp file for editor to modify. */
+	if ((fd = mkstemp(edit_path)) == -1)
+		errx(EX_CANTCREAT, "mkstemp failed");
+
+	atexit(cleanup_editfile);
+
+	if ((edit_file = fdopen(fd, "w")) == NULL)
+		err(EX_NOINPUT, "%s", edit_path);
+
+	written = modepage_write(edit_file, 1);
+
+	fclose(edit_file);
+	edit_file = NULL;
+
+	if (written == 0) {
+		warnx("no editable entries");
+		cleanup_editfile();
+		return;
+	}
+
+	/*
+	 * Allocate memory to hold the command line (the 2 extra characters
+	 * are to hold the argument separator (a space), and the terminating
+	 * null character.
+	 */
+	commandline = malloc(strlen(editor) + strlen(edit_path) + 2);
+	if (commandline == NULL)
+		err(EX_OSERR, NULL);
+	sprintf(commandline, "%s %s", editor, edit_path);
+
+	/* Invoke the editor on the temp file. */
+	if (system(commandline) == -1)
+		err(EX_UNAVAILABLE, "could not invoke %s", editor);
+	free(commandline);
+
+	if ((edit_file = fopen(edit_path, "r")) == NULL)
+		err(EX_NOINPUT, "%s", edit_path);
+
+	/* Read any changes made to the temp file. */
+	modepage_read(edit_file);
+
+	cleanup_editfile();
+}
+
+static void
+modepage_dump(struct cam_device *device, int page, int page_control, int dbd,
+	      int retries, int timeout)
+{
+	u_int8_t data[MAX_COMMAND_SIZE];/* Buffer to hold sense data. */
+	u_int8_t *mode_pars;		/* Pointer to modepage params. */
+	struct scsi_mode_header_6 *mh;	/* Location of mode header. */
+	struct scsi_mode_page_header *mph;
+	int indx;			/* Index for scanning mode params. */
+
+	mode_sense(device, page, page_control, dbd, retries, timeout, data,
+		   sizeof(data));
+
+	mh = (struct scsi_mode_header_6 *)data;
+	mph = MODE_PAGE_HEADER(mh);
+	mode_pars = MODE_PAGE_DATA(mph);
+
+	/* Print the raw mode page data with newlines each 8 bytes. */
+	for (indx = 0; indx < mph->page_length; indx++) {
+		printf("%02x%c",mode_pars[indx],
+		    (((indx + 1) % 8) == 0) ? '\n' : ' ');
+	}
+	putchar('\n');
+}
+
+static void
+cleanup_editfile(void)
+{
+	if (edit_file == NULL)
+		return;
+	if (fclose(edit_file) != 0 || unlink(edit_path) != 0)
+		warn("%s", edit_path);
+	edit_file = NULL;
+}
+
+void
+mode_edit(struct cam_device *device, int page, int page_control, int dbd,
+	  int edit, int binary, int retry_count, int timeout)
+{
+	const char *pagedb_path;	/* Path to modepage database. */
+
+	if (edit && binary)
+		errx(EX_USAGE, "cannot edit in binary mode.");
+
+	if (! binary) {
+		if ((pagedb_path = getenv("SCSI_MODES")) == NULL)
+			pagedb_path = DEFAULT_SCSI_MODE_DB;
+
+		if (load_format(pagedb_path, page) != 0 && (edit || verbose)) {
+			if (errno == ENOENT) {
+				/* Modepage database file not found. */
+				warn("cannot open modepage database \"%s\"",
+				    pagedb_path);
+			} else if (errno == ESRCH) {
+				/* Modepage entry not found in database. */
+				warnx("modepage %d not found in database"
+				    "\"%s\"", page, pagedb_path);
+			}
+			/* We can recover in display mode, otherwise we exit. */
+			if (!edit) {
+				warnx("reverting to binary display only");
+				binary = 1;
+			} else
+				exit(EX_OSFILE);
+		}
+
+		editlist_populate(device, page, page_control, dbd, retry_count,
+			timeout);
+	}
+
+	if (edit) {
+		if (page_control << PAGE_CTRL_SHIFT != SMS_PAGE_CTRL_CURRENT &&
+		    page_control << PAGE_CTRL_SHIFT != SMS_PAGE_CTRL_SAVED)
+			errx(EX_USAGE, "it only makes sense to edit page 0 "
+			    "(current) or page 3 (saved values)");
+		modepage_edit();
+		editlist_save(device, page, page_control, dbd, retry_count,
+			timeout);
+	} else if (binary || STAILQ_EMPTY(&editlist)) {
+		/* Display without formatting information. */
+		modepage_dump(device, page, page_control, dbd, retry_count,
+		    timeout);
+	} else {
+		/* Display with format. */
+		modepage_write(stdout, 0);
+	}
+}
+
+void
+mode_list(struct cam_device *device, int page_control, int dbd,
+	  int retry_count, int timeout)
+{
+	u_int8_t data[MAX_COMMAND_SIZE];/* Buffer to hold sense data. */
+	u_int8_t *mode_pars;		/* Pointer to modepage params. */
+	struct scsi_mode_header_6 *mh;	/* Location of mode header. */
+	struct scsi_mode_page_header *mph;
+	struct pagename *nameentry;
+	const char *pagedb_path;
+	int len;
+
+	if ((pagedb_path = getenv("SCSI_MODES")) == NULL)
+		pagedb_path = DEFAULT_SCSI_MODE_DB;
+
+	if (load_format(pagedb_path, 0) != 0 && verbose && errno == ENOENT) {
+		/* Modepage database file not found. */
+		warn("cannot open modepage database \"%s\"", pagedb_path);
+	}
+
+	/* Build the list of all mode pages by querying the "all pages" page. */
+	mode_sense(device, SMS_ALL_PAGES_PAGE, page_control, dbd, retry_count,
+	    timeout, data, sizeof(data));
+
+	mh = (struct scsi_mode_header_6 *)data;
+	len = mh->blk_desc_len;		/* Skip block descriptors. */
+	/* Iterate through the pages in the reply. */
+	while (len < mh->data_length) {
+		/* Locate the next mode page header. */
+		mph = (struct scsi_mode_page_header *)
+		    ((intptr_t)mh + sizeof(*mh) + len);
+		mode_pars = MODE_PAGE_DATA(mph);
+
+		mph->page_code &= SMS_PAGE_CODE;
+		nameentry = nameentry_lookup(mph->page_code);
+
+		if (nameentry == NULL || nameentry->name == NULL)
+			printf("0x%02x\n", mph->page_code);
+		else
+			printf("0x%02x\t%s\n", mph->page_code,
+			    nameentry->name); 
+		len += mph->page_length + sizeof(*mph);
+	}
+}
--- a/sbin/camcontrol/util.c
+++ b/sbin/camcontrol/util.c
@@ -0,0 +1,156 @@
+/*
+ * Written By Julian ELischer
+ * Copyright julian Elischer 1993.
+ * Permission is granted to use or redistribute this file in any way as long
+ * as this notice remains. Julian Elischer does not guarantee that this file
+ * is totally correct for any given task and users of this file must
+ * accept responsibility for any damage that occurs from the application of this
+ * file.
+ *
+ * (julian@tfs.com julian@dialix.oz.au)
+ *
+ * User SCSI hooks added by Peter Dufault:
+ *
+ * Copyright (c) 1994 HD Associates
+ * (contact: dufault@hda.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of HD Associates
+ *    may not be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL HD ASSOCIATES BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ * Taken from the original scsi(8) program.
+ * from: scsi.c,v 1.17 1998/01/12 07:57:57 charnier Exp $";
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/stdint.h>
+#include <sys/types.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <camlib.h>
+#include "camcontrol.h"
+
+int verbose;
+
+/* iget: Integer argument callback
+ */
+int
+iget(void *hook, char *name)
+{
+	struct get_hook *h = (struct get_hook *)hook;
+	int arg;
+
+	if (h->got >= h->argc)
+	{
+		fprintf(stderr, "Expecting an integer argument.\n");
+		usage(0);
+		exit(1);
+	}
+	arg = strtol(h->argv[h->got], 0, 0);
+	h->got++;
+
+	if (verbose && name && *name)
+		printf("%s: %d\n", name, arg);
+
+	return arg;
+}
+
+/* cget: char * argument callback
+ */
+char *
+cget(void *hook, char *name)
+{
+	struct get_hook *h = (struct get_hook *)hook;
+	char *arg;
+
+	if (h->got >= h->argc)
+	{
+		fprintf(stderr, "Expecting a character pointer argument.\n");
+		usage(0);
+		exit(1);
+	}
+	arg = h->argv[h->got];
+	h->got++;
+
+	if (verbose && name)
+		printf("cget: %s: %s", name, arg);
+
+	return arg;
+}
+
+/* arg_put: "put argument" callback
+ */
+void
+arg_put(void *hook __unused, int letter, void *arg, int count, char *name)
+{
+	if (verbose && name && *name)
+		printf("%s:  ", name);
+
+	switch(letter)
+	{
+		case 'i':
+		case 'b':
+		printf("%jd ", (intmax_t)(intptr_t)arg);
+		break;
+
+		case 'c':
+		case 'z':
+		{
+			char *p;
+
+			p = malloc(count + 1);
+			if (p == NULL) {
+				fprintf(stderr, "can't malloc memory for p\n");
+				exit(1);
+			}
+
+			bzero(p, count +1);
+			strncpy(p, (char *)arg, count);
+			if (letter == 'z')
+			{
+				int i;
+				for (i = count - 1; i >= 0; i--)
+					if (p[i] == ' ')
+						p[i] = 0;
+					else
+						break;
+			}
+			printf("%s ", p);
+
+			free(p);
+		}
+
+		break;
+
+		default:
+		printf("Unknown format letter: '%c'\n", letter);
+	}
+	if (verbose)
+		putchar('\n');
+}
