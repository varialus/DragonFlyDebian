
Generated with:

find b -type f -name \*.c -or -name \*.y | while read i ; do \
	sed -i $i \
		-e 's/defined\( \|\t\)*(\( \|\t\)*__FreeBSD__\( \|\t\)*)/defined(__FreeBSD_kernel__)/g' \
		-e 's/#\( \|\t\)*ifdef\( \|\t\)*__FreeBSD__/#ifdef __FreeBSD_kernel__/g' \
		-e 's/#\( \|\t\)*ifndef\( \|\t\)*__FreeBSD__/#ifndef __FreeBSD_kernel__/g' \
	; done

--- a/contrib/pf/pfctl/parse.y
+++ b/contrib/pf/pfctl/parse.y
@@ -2223,7 +2223,7 @@
 				}
 				free($9.queues.pqname);
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			r.divert.port = $9.divert.port;
 #else
 			if ((r.divert.port = $9.divert.port)) {
@@ -2368,7 +2368,7 @@
 			filter_opts.rtableid = $2;
 		}
 		| DIVERTTO portplain {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			filter_opts.divert.port = $2.a;
 			if (!filter_opts.divert.port) {
 				yyerror("invalid divert port: %u", ntohs($2.a));
@@ -2377,7 +2377,7 @@
 #endif
 		}
 		| DIVERTTO STRING PORT portplain {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 			if ((filter_opts.divert.addr = host($2)) == NULL) {
 				yyerror("could not parse divert address: %s",
 				    $2);
@@ -2395,7 +2395,7 @@
 			}
 		}
 		| DIVERTREPLY {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			yyerror("divert-reply has no meaning in FreeBSD pf(4)");
 			YYERROR;
 #else
@@ -2861,7 +2861,7 @@
 			char	*buf;
 
 			/* ie. for 10/8 parsing */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (asprintf(&buf, "%lld/%lld", (long long)$1, (long long)$3) == -1)
 #else
 			if (asprintf(&buf, "%lld/%lld", $1, $3) == -1)
--- a/contrib/pf/authpf/authpf.c
+++ b/contrib/pf/authpf/authpf.c
@@ -33,7 +33,7 @@
 
 #include <err.h>
 #include <errno.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <inttypes.h>
 #endif
 #include <login_cap.h>
@@ -74,7 +74,7 @@
 
 volatile sig_atomic_t	want_death;
 static void		need_death(int signo);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static __dead2 void	do_death(int);
 #else
 static __dead void	do_death(int);
@@ -155,7 +155,7 @@
 	else
 		shell = pw->pw_shell;
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	login_close(lc);
 #endif
 
@@ -163,7 +163,7 @@
 	    strcmp(shell, PATH_AUTHPF_SHELL_NOIP)) {
 		syslog(LOG_ERR, "wrong shell for user %s, uid %u",
 		    pw->pw_name, pw->pw_uid);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	login_close(lc);
 #else
 		if (shell != pw->pw_shell)
@@ -172,7 +172,7 @@
 		goto die;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	login_close(lc);
 #else
 	if (shell != pw->pw_shell)
@@ -932,7 +932,7 @@
 /*
  * function that removes our stuff when we go away.
  */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static __dead2 void
 #else
 static __dead void
--- a/contrib/pf/ftp-proxy/ftp-proxy.c
+++ b/contrib/pf/ftp-proxy/ftp-proxy.c
@@ -585,7 +585,7 @@
 
 		/* We don't care about truncation. */
 		vsnprintf(buf, sizeof buf, message, ap);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		strvis(visbuf, buf, VIS_CSTYLE | VIS_NL);
 #else
 		strnvis(visbuf, buf, sizeof visbuf, VIS_CSTYLE | VIS_NL);
--- a/contrib/pf/libevent/kqueue.c
+++ b/contrib/pf/libevent/kqueue.c
@@ -48,7 +48,7 @@
 #include <inttypes.h>
 #endif
 
-#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD_kernel__)
 #define INTPTR(x)	(intptr_t)x
 #else
 #define INTPTR(x)	x
--- a/contrib/pf/pfctl/pf_print_state.c
+++ b/contrib/pf/pfctl/pf_print_state.c
@@ -35,7 +35,7 @@
 
 #include <sys/types.h>
 #include <sys/socket.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/endian.h>
 #define	betoh64	be64toh
 #endif
@@ -322,7 +322,7 @@
 		bcopy(s->bytes[0], &bytes[0], sizeof(u_int64_t));
 		bcopy(s->bytes[1], &bytes[1], sizeof(u_int64_t));
 		printf(", %llu:%llu pkts, %llu:%llu bytes",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)betoh64(packets[0]),
 		    (unsigned long long)betoh64(packets[1]),
 		    (unsigned long long)betoh64(bytes[0]),
@@ -352,7 +352,7 @@
 
 		bcopy(&s->id, &id, sizeof(u_int64_t));
 		printf("   id: %016llx creatorid: %08x",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)betoh64(id), ntohl(s->creatorid));
 #else
 		    betoh64(id), ntohl(s->creatorid));
--- a/contrib/pf/pfctl/pfctl.c
+++ b/contrib/pf/pfctl/pfctl.c
@@ -39,7 +39,7 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/endian.h>
 #endif
 
@@ -251,7 +251,7 @@
 	if (ioctl(dev, DIOCSTART)) {
 		if (errno == EEXIST)
 			errx(1, "pf already enabled");
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (errno == ESRCH)
 			errx(1, "pfil registeration failed");
 #endif
@@ -1585,7 +1585,7 @@
 	pf->limit[PF_LIMIT_TABLE_ENTRIES] = PFR_KENTRY_HIWAT;
 
 	mib[0] = CTL_HW;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	mib[1] = HW_PHYSMEM;
 #else
 	mib[1] = HW_PHYSMEM64;
@@ -2202,7 +2202,7 @@
 		/* turn off options */
 		opts &= ~ (PF_OPT_DISABLE | PF_OPT_ENABLE);
 		clearopt = showopt = debugopt = NULL;
-#if defined(__FreeBSD__) && !defined(ENABLE_ALTQ)
+#if defined(__FreeBSD_kernel__) && !defined(ENABLE_ALTQ)
 		altqsupport = 0;
 #else
 		altqsupport = 1;
--- a/contrib/pf/pfctl/pfctl_altq.c
+++ b/contrib/pf/pfctl/pfctl_altq.c
@@ -77,7 +77,7 @@
 			     double);
 static double		 sc_x2y(struct service_curve *, double);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 u_int32_t	getifspeed(int, char *);
 #else
 u_int32_t	 getifspeed(char *);
@@ -153,7 +153,7 @@
 		return;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->local_flags & PFALTQ_FLAG_IF_REMOVED)
 		printf("INACTIVE ");
 #endif
@@ -193,7 +193,7 @@
 {
 	unsigned int	i;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->local_flags & PFALTQ_FLAG_IF_REMOVED)
 		printf("INACTIVE ");
 #endif
@@ -239,7 +239,7 @@
 	if (bw->bw_absolute > 0)
 		pa->ifbandwidth = bw->bw_absolute;
 	else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((rate = getifspeed(pf->dev, pa->ifname)) == 0) {
 #else
 		if ((rate = getifspeed(pa->ifname)) == 0) {
@@ -1095,7 +1095,7 @@
 	return (buf);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /*
  * XXX
  * FreeBSD does not have SIOCGIFDATA.
@@ -1150,7 +1150,7 @@
 	    sizeof(ifr.ifr_name))
 		errx(1, "getifmtu: strlcpy");
 	if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == -1)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		ifr.ifr_mtu = 1500;
 #else
 		err(1, "SIOCGIFMTU");
--- a/contrib/pf/pfctl/pfctl_optimize.c
+++ b/contrib/pf/pfctl/pfctl_optimize.c
@@ -862,7 +862,7 @@
 				break;
 			}
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (por2 == NULL)
 #else
 		if (por2 == TAILQ_END(&block->sb_rules))
--- a/contrib/pf/pfctl/pfctl_parser.c
+++ b/contrib/pf/pfctl/pfctl_parser.c
@@ -580,7 +580,7 @@
 		    s->src_nodes, "");
 		for (i = 0; i < SCNT_MAX; i++) {
 			printf("  %-25s %14lld ", pf_scounters[i],
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    (long long)s->scounters[i]);
 #else
 				    s->scounters[i]);
@@ -606,7 +606,7 @@
 		printf("Limit Counters\n");
 		for (i = 0; i < LCNT_MAX; i++) {
 			printf("  %-25s %14lld ", pf_lcounters[i],
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    (unsigned long long)s->lcounters[i]);
 #else
 				    s->lcounters[i]);
@@ -655,7 +655,7 @@
 			    sn->expire, min, sec);
 		}
 		printf(", %llu pkts, %llu bytes",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    (unsigned long long)(sn->packets[0] + sn->packets[1]),
 		    (unsigned long long)(sn->bytes[0] + sn->bytes[1]));
 #else
@@ -1019,7 +1019,7 @@
 	if (r->rtableid != -1)
 		printf(" rtable %u", r->rtableid);
 	if (r->divert.port) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		printf(" divert-to %u", ntohs(r->divert.port));
 #else
 		if (PF_AZERO(&r->divert.addr, r->af)) {
--- a/contrib/pf/pfctl/pfctl_qstats.c
+++ b/contrib/pf/pfctl/pfctl_qstats.c
@@ -89,7 +89,7 @@
 	struct pf_altq_node	*root = NULL, *node;
 	int			 nodes, dotitle = (opts & PF_OPT_SHOWALL);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!altqsupport)
 		return (-1);
 #endif
@@ -118,7 +118,7 @@
 		for (node = root; node != NULL; node = node->next) {
 			if (iface != NULL && strcmp(node->altq.ifname, iface))
 				continue;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (node->altq.local_flags & PFALTQ_FLAG_IF_REMOVED)
 				continue;
 #endif
@@ -161,7 +161,7 @@
 			warn("DIOCGETALTQ");
 			return (-1);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pa.altq.qid > 0 &&
 		    !(pa.altq.local_flags & PFALTQ_FLAG_IF_REMOVED)) {
 #else
@@ -184,7 +184,7 @@
 				pfctl_insert_altq_node(root, pa.altq, qstats);
 			}
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (pa.altq.local_flags & PFALTQ_FLAG_IF_REMOVED) {
 			memset(&qstats.data, 0, sizeof(qstats.data));
 			if ((node = pfctl_find_altq_node(*root, pa.altq.qname,
@@ -303,7 +303,7 @@
 	if (a->altq.qid == 0)
 		return;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (a->altq.local_flags & PFALTQ_FLAG_IF_REMOVED)
 		return;
 #endif
--- a/contrib/pf/pflogd/pflogd.c
+++ b/contrib/pf/pflogd/pflogd.c
@@ -51,7 +51,7 @@
 #include <errno.h>
 #include <stdarg.h>
 #include <fcntl.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <ifaddrs.h>
 #include "pidfile.h"
 #else
@@ -161,7 +161,7 @@
 	va_end(ap);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 __dead2 void
 #else
 __dead void
@@ -215,7 +215,7 @@
 int
 if_exists(char *ifname)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ifaddrs *ifdata, *mb;
 	int exists = 0;
 
@@ -406,7 +406,7 @@
 scan_dump(FILE *fp, off_t size)
 {
 	struct pcap_file_header hdr;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr ph;
 #else
 	struct pcap_pkthdr ph;
@@ -479,7 +479,7 @@
 dump_packet_nobuf(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 {
 	FILE *f = (FILE *)user;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr sh;
 #endif
 
@@ -488,7 +488,7 @@
 		return;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sh.ts.tv_sec = (bpf_int32)h->ts.tv_sec;
 	sh.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
 	sh.caplen = h->caplen;
@@ -501,7 +501,7 @@
 		off_t pos = ftello(f);
 
 		/* try to undo header to prevent corruption */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pos < sizeof(sh) ||
 		    ftruncate(fileno(f), pos - sizeof(sh))) {
 #else
@@ -576,7 +576,7 @@
 dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 {
 	FILE *f = (FILE *)user;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pcap_sf_pkthdr sh;
 	size_t len = sizeof(sh) + h->caplen;
 #else
@@ -609,7 +609,7 @@
 	}
 
  append:       
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sh.ts.tv_sec = (bpf_int32)h->ts.tv_sec;
 	sh.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
 	sh.caplen = h->caplen;
--- a/contrib/pf/pflogd/pidfile.c
+++ b/contrib/pf/pflogd/pidfile.c
@@ -48,7 +48,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "pidfile.h"
 #else
 #include <util.h>
--- a/contrib/pf/pflogd/privsep.c
+++ b/contrib/pf/pflogd/privsep.c
@@ -73,7 +73,7 @@
 	int snaplen, ret, olderrno;
 	struct passwd *pw;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	for (i = 1; i < NSIG; i++)
 #else
 	for (i = 1; i < _NSIG; i++)
--- a/contrib/pf/tftp-proxy/filter.c
+++ b/contrib/pf/tftp-proxy/filter.c
@@ -298,7 +298,7 @@
 		pfr.rule.quick = 1;
 		pfr.rule.log = rule_log;
 		pfr.rule.keep_state = 1;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pfr.rule.flags = (proto == IPPROTO_TCP ? TH_SYN : 0);
 		pfr.rule.flagset = (proto == IPPROTO_TCP ?
 		    (TH_SYN|TH_ACK|TH_FIN|TH_RST) : 0);
--- a/sys/contrib/pf/net/if_pflog.c
+++ b/sys/contrib/pf/net/if_pflog.c
@@ -33,7 +33,7 @@
  * PURPOSE.
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 #include "opt_bpf.h"
@@ -64,7 +64,7 @@
 #include <sys/mbuf.h>
 #include <sys/proc.h>
 #include <sys/socket.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/kernel.h>
 #include <sys/limits.h>
 #include <sys/malloc.h>
@@ -75,7 +75,7 @@
 #endif
 
 #include <net/if.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/if_clone.h>
 #endif
 #include <net/if_types.h>
@@ -99,7 +99,7 @@
 #include <net/pfvar.h>
 #include <net/if_pflog.h>
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef INET
 #include <machine/in_cksum.h>
 #endif /* INET */
@@ -115,14 +115,14 @@
 
 void	pflogattach(int);
 int	pflogoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	    struct route *);
 #else
 	    struct rtentry *);
 #endif
 int	pflogioctl(struct ifnet *, u_long, caddr_t);
 void	pflogstart(struct ifnet *);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static int pflog_clone_create(struct if_clone *, int, caddr_t);
 static void pflog_clone_destroy(struct ifnet *);
 #else
@@ -131,7 +131,7 @@
 #endif
 
 LIST_HEAD(, pflog_softc)	pflogif_list;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 IFC_SIMPLE_DECLARE(pflog, 1);
 #else
 struct if_clone	pflog_cloner =
@@ -150,7 +150,7 @@
 	if_clone_attach(&pflog_cloner);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static int
 pflog_clone_create(struct if_clone *ifc, int unit, caddr_t param)
 #else
@@ -170,7 +170,7 @@
 		return (ENOMEM);
 
 	pflogif->sc_unit = unit;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	ifp = pflogif->sc_ifp = if_alloc(IFT_PFLOG);
 	if (ifp == NULL) {
 		free(pflogif, M_DEVBUF);
@@ -186,18 +186,18 @@
 	ifp->if_ioctl = pflogioctl;
 	ifp->if_output = pflogoutput;
 	ifp->if_start = pflogstart;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	ifp->if_type = IFT_PFLOG;
 #endif
 	ifp->if_snd.ifq_maxlen = ifqmaxlen;
 	ifp->if_hdrlen = PFLOG_HDRLEN;
 	if_attach(ifp);
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	if_alloc_sadl(ifp);
 #endif
 
 #if NBPFILTER > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	bpfattach(ifp, DLT_PFLOG, PFLOG_HDRLEN);
 #else
 	bpfattach(&pflogif->sc_if.if_bpf, ifp, DLT_PFLOG, PFLOG_HDRLEN);
@@ -205,13 +205,13 @@
 #endif
 
 	s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX: Why pf(4) lock?! Better add a pflog lock?! */
 	PF_LOCK();
 #endif
 	LIST_INSERT_HEAD(&pflogif_list, pflogif, sc_list);
 	pflogifs[unit] = ifp;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -219,7 +219,7 @@
 	return (0);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static void
 pflog_clone_destroy(struct ifnet *ifp)
 #else
@@ -231,12 +231,12 @@
 	int			 s;
 
 	s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	pflogifs[pflogif->sc_unit] = NULL;
 	LIST_REMOVE(pflogif, sc_list);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -245,11 +245,11 @@
 	bpfdetach(ifp);
 #endif
 	if_detach(ifp);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if_free(ifp);
 #endif
 	free(pflogif, M_DEVBUF);
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	return (0);
 #endif
 }
@@ -261,12 +261,12 @@
 pflogstart(struct ifnet *ifp)
 {
 	struct mbuf *m;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	int s;
 #endif
 
 	for (;;) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		IF_LOCK(&ifp->if_snd);
 		_IF_DROP(&ifp->if_snd);
 		_IF_DEQUEUE(&ifp->if_snd, m);
@@ -287,7 +287,7 @@
 
 int
 pflogoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct route *rt)
 #else
 	struct rtentry *rt)
@@ -303,7 +303,7 @@
 {
 	switch (cmd) {
 	case SIOCSIFFLAGS:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (ifp->if_flags & IFF_UP)
 			ifp->if_drv_flags |= IFF_DRV_RUNNING;
 		else
@@ -355,7 +355,7 @@
 			    sizeof(hdr.ruleset));
 	}
 	if (rm->log & PF_LOG_SOCKET_LOOKUP && !pd->lookup.done)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/*
 		 * XXX: This should not happen as we force an early lookup
 		 * via debug.pfugidhack
@@ -387,7 +387,7 @@
 
 	ifn->if_opackets++;
 	ifn->if_obytes += m->m_pkthdr.len;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	BPF_MTAP2(ifn, &hdr, PFLOG_HDRLEN, m);
 #else
 	bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, PFLOG_HDRLEN, m,
@@ -398,7 +398,7 @@
 	return (0);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static int
 pflog_modevent(module_t mod, int type, void *data)
 {
--- a/sys/contrib/pf/net/if_pfsync.c
+++ b/sys/contrib/pf/net/if_pfsync.c
@@ -42,7 +42,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 #include "opt_bpf.h"
@@ -72,7 +72,7 @@
 
 #include <sys/param.h>
 #include <sys/kernel.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/bus.h>
 #include <sys/interrupt.h>
 #include <sys/priv.h>
@@ -82,7 +82,7 @@
 #include <sys/time.h>
 #include <sys/mbuf.h>
 #include <sys/socket.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/endian.h>
 #include <sys/malloc.h>
 #include <sys/module.h>
@@ -95,19 +95,19 @@
 #include <sys/timeout.h>
 #endif
 #include <sys/sysctl.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/pool.h>
 #endif
 
 #include <net/if.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/if_clone.h>
 #endif
 #include <net/if_types.h>
 #include <net/route.h>
 #include <net/bpf.h>
 #include <net/netisr.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/vnet.h>
 #endif
 
@@ -127,7 +127,7 @@
 #include <netinet6/nd6.h>
 #endif /* INET6 */
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include "carp.h"
 #endif
 #if NCARP > 0
@@ -137,7 +137,7 @@
 #include <net/pfvar.h>
 #include <net/if_pfsync.h>
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include "bpfilter.h"
 #include "pfsync.h"
 #endif
@@ -222,7 +222,7 @@
 	TAILQ_ENTRY(pfsync_deferral)		 pd_entry;
 	struct pf_state				*pd_st;
 	struct mbuf				*pd_m;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct callout				 pd_tmo;
 #else
 	struct timeout				 pd_tmo;
@@ -238,14 +238,14 @@
 #endif
 
 struct pfsync_softc {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ifnet		*sc_ifp;
 #else
 	struct ifnet		 sc_if;
 #endif
 	struct ifnet		*sc_sync_if;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	uma_zone_t		 sc_pool;
 #else
 	struct pool		 sc_pool;
@@ -255,7 +255,7 @@
 
 	struct in_addr		 sc_sync_peer;
 	u_int8_t		 sc_maxupdates;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int			 pfsync_sync_ok;
 #endif
 
@@ -274,7 +274,7 @@
 
 	u_int32_t		 sc_ureq_sent;
 	int			 sc_bulk_tries;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct callout		 sc_bulkfail_tmo;
 #else
 	struct timeout		 sc_bulkfail_tmo;
@@ -283,7 +283,7 @@
 	u_int32_t		 sc_ureq_received;
 	struct pf_state		*sc_bulk_next;
 	struct pf_state		*sc_bulk_last;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct callout		 sc_bulk_tmo;
 #else
 	struct timeout		 sc_bulk_tmo;
@@ -291,18 +291,18 @@
 
 	TAILQ_HEAD(, tdb)	 sc_tdb_q;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct callout		 sc_tmo;
 #else
 	struct timeout		 sc_tmo;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	eventhandler_tag	 sc_detachtag;
 #endif
 
 };
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static VNET_DEFINE(struct pfsync_softc	*, pfsyncif) = NULL;
 #define	V_pfsyncif		VNET(pfsyncif)
 
@@ -319,7 +319,7 @@
 #define	V_pfsyncstats	 pfsyncstats
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static void	pfsyncintr(void *);
 struct pfsync_swi {
 	void *	pfsync_swi_cookie;
@@ -330,7 +330,7 @@
 #endif
 
 void	pfsyncattach(int);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int	pfsync_clone_create(struct if_clone *, int, caddr_t);
 void	pfsync_clone_destroy(struct ifnet *);
 #else
@@ -341,7 +341,7 @@
 	    struct pf_state_peer *);
 void	pfsync_update_net_tdb(struct pfsync_tdb *);
 int	pfsyncoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	    struct route *);
 #else
 	    struct rtentry *);
@@ -373,7 +373,7 @@
 void	pfsync_bulk_update(void *);
 void	pfsync_bulk_fail(void *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void	pfsync_ifdetach(void *, struct ifnet *);
 
 /* XXX: ugly */
@@ -382,11 +382,11 @@
 #endif
 
 #define PFSYNC_MAX_BULKTRIES	12
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 int	pfsync_sync_ok;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 IFC_SIMPLE_DECLARE(pfsync, 1);
 #else
 struct if_clone	pfsync_cloner =
@@ -399,7 +399,7 @@
 	if_clone_attach(&pfsync_cloner);
 }
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pfsync_clone_create(struct if_clone *ifc, int unit, caddr_t param)
 #else
 pfsync_clone_create(struct if_clone *ifc, int unit)
@@ -412,7 +412,7 @@
 	if (unit != 0)
 		return (EINVAL);
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	pfsync_sync_ok = 1;
 #endif
 
@@ -423,7 +423,7 @@
 	for (q = 0; q < PFSYNC_S_COUNT; q++)
 		TAILQ_INIT(&sc->sc_qs[q]);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sc->pfsync_sync_ok = 1;
 	sc->sc_pool = uma_zcreate("pfsync", PFSYNC_PLSIZE,
 			NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
@@ -443,7 +443,7 @@
 	sc->sc_len = PFSYNC_MINPKT;
 	sc->sc_maxupdates = 128;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sc->sc_imo.imo_membership = (struct in_multi **)malloc(
 	    (sizeof(struct in_multi *) * IP_MIN_MEMBERSHIPS), M_DEVBUF,
 	    M_NOWAIT | M_ZERO);
@@ -456,7 +456,7 @@
 	sc->sc_imo.imo_max_memberships = IP_MIN_MEMBERSHIPS;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	ifp = sc->sc_ifp = if_alloc(IFT_PFSYNC);
 	if (ifp == NULL) {
 		free(sc->sc_imo.imo_membership, M_DEVBUF);
@@ -467,7 +467,7 @@
 	if_initname(ifp, ifc->ifc_name, unit);
 
 	sc->sc_detachtag = EVENTHANDLER_REGISTER(ifnet_departure_event,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	    pfsync_ifdetach, V_pfsyncif, EVENTHANDLER_PRI_ANY);
 #else
 	    pfsync_ifdetach, pfsyncif, EVENTHANDLER_PRI_ANY);
@@ -491,7 +491,7 @@
 	ifp->if_snd.ifq_maxlen = ifqmaxlen;
 	ifp->if_hdrlen = sizeof(struct pfsync_header);
 	ifp->if_mtu = 1500; /* XXX */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	callout_init(&sc->sc_tmo, CALLOUT_MPSAFE);
 	callout_init_mtx(&sc->sc_bulk_tmo, &pf_task_mtx, 0);
 	callout_init(&sc->sc_bulkfail_tmo, CALLOUT_MPSAFE);
@@ -503,7 +503,7 @@
 #endif
 
 	if_attach(ifp);
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	if_alloc_sadl(ifp);
 #endif
 
@@ -512,14 +512,14 @@
 #endif
 
 #if NBPFILTER > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	bpfattach(ifp, DLT_PFSYNC, PFSYNC_HDRLEN);
 #else
 	bpfattach(&sc->sc_if.if_bpf, ifp, DLT_PFSYNC, PFSYNC_HDRLEN);
 #endif
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfsyncif = sc;
 #else
 	pfsyncif = sc;
@@ -528,7 +528,7 @@
 	return (0);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 #else
 int
@@ -537,14 +537,14 @@
 {
 	struct pfsync_softc *sc = ifp->if_softc;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	EVENTHANDLER_DEREGISTER(ifnet_departure_event, sc->sc_detachtag);
 #endif
 	timeout_del(&sc->sc_bulk_tmo);	/* XXX: need PF_LOCK() before */
 	timeout_del(&sc->sc_tmo);
 #if NCARP > 0
 #ifdef notyet
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!sc->pfsync_sync_ok)
 #else
 	if (!pfsync_sync_ok)
@@ -562,12 +562,12 @@
 	while (sc->sc_deferred > 0)
 		pfsync_undefer(TAILQ_FIRST(&sc->sc_deferrals), 0);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	UMA_DESTROY(sc->sc_pool);
 #else
 	pool_destroy(&sc->sc_pool);
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if_free(ifp);
 	free(sc->sc_imo.imo_membership, M_DEVBUF);
 #else
@@ -575,13 +575,13 @@
 #endif
 	free(sc, M_DEVBUF);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfsyncif = NULL;
 #else
 	pfsyncif = NULL;
 #endif
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	return (0);
 #endif
 }
@@ -590,11 +590,11 @@
 pfsync_if_dequeue(struct ifnet *ifp)
 {
 	struct mbuf *m;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	int s;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	IF_LOCK(&ifp->if_snd);
 	_IF_DROP(&ifp->if_snd);
 	_IF_DEQUEUE(&ifp->if_snd, m);
@@ -617,7 +617,7 @@
 	struct mbuf *m;
 
 	while ((m = pfsync_if_dequeue(ifp)) != NULL) {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 		IF_DROP(&ifp->if_snd);
 #endif
 		m_freem(m);
@@ -629,7 +629,7 @@
     struct pf_state_peer *d)
 {
 	if (s->scrub.scrub_flag && d->scrub == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		d->scrub = pool_get(&V_pf_state_scrub_pl, PR_NOWAIT | PR_ZERO);
 #else
 		d->scrub = pool_get(&pf_state_scrub_pl, PR_NOWAIT | PR_ZERO);
@@ -641,7 +641,7 @@
 	return (0);
 }
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 void
 pfsync_state_export(struct pfsync_state *sp, struct pf_state *st)
 {
@@ -716,7 +716,7 @@
 
 	PF_LOCK_ASSERT();
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sp->creatorid == 0 && V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 	if (sp->creatorid == 0 && pf_status.debug >= PF_DEBUG_MISC) {
@@ -727,7 +727,7 @@
 	}
 
 	if ((kif = pfi_kif_get(sp->ifname)) == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC)
@@ -749,7 +749,7 @@
 		r = pf_main_ruleset.rules[
 		    PF_RULESET_FILTER].active.ptr_array[ntohl(sp->rule)];
 	else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		r = &V_pf_default_rule;
 #else
 		r = &pf_default_rule;
@@ -758,7 +758,7 @@
 	if ((r->max_states && r->states_cur >= r->max_states))
 		goto cleanup;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (flags & PFSYNC_SI_IOCTL)
 		pool_flags = PR_WAITOK | PR_ZERO;
 	else
@@ -856,7 +856,7 @@
 		CLR(st->state_flags, PFSTATE_NOSYNC);
 		if (ISSET(st->state_flags, PFSTATE_ACK)) {
 			pfsync_q_ins(st, PFSYNC_S_IACK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pfsync_sendout();
 #else
 			schednetisr(NETISR_PFSYNC);
@@ -871,7 +871,7 @@
 	error = ENOMEM;
 	if (skw == sks)
 		sks = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (skw != NULL)
 		pool_put(&V_pf_state_key_pl, skw);
 	if (sks != NULL)
@@ -885,7 +885,7 @@
 
 cleanup_state:	/* pf_state_insert frees the state keys */
 	if (st) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (st->dst.scrub)
 			pool_put(&V_pf_state_scrub_pl, st->dst.scrub);
 		if (st->src.scrub)
@@ -903,13 +903,13 @@
 }
 
 void
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pfsync_input(struct mbuf *m, __unused int off)
 #else
 pfsync_input(struct mbuf *m, ...)
 #endif
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -925,7 +925,7 @@
 	V_pfsyncstats.pfsyncs_ipackets++;
 
 	/* verify that we have a sync interface configured */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!sc || !sc->sc_sync_if || !V_pf_status.running)
 #else
 	if (!sc || !sc->sc_sync_if || !pf_status.running)
@@ -938,7 +938,7 @@
 		goto done;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sc->sc_ifp->if_ipackets++;
 	sc->sc_ifp->if_ibytes += m->m_pkthdr.len;
 #else
@@ -984,7 +984,7 @@
 	pkt.src = ip->ip_src;
 	pkt.flags = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!bcmp(&ph->pfcksum, &V_pf_status.pf_chksum, PF_MD5_DIGEST_LENGTH))
 #else
 	if (!bcmp(&ph->pfcksum, &pf_status.pf_chksum, PF_MD5_DIGEST_LENGTH))
@@ -1035,14 +1035,14 @@
 	clr = (struct pfsync_clr *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
 		creatorid = clr[i].creatorid;
 
 		if (clr[i].ifname[0] == '\0') {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			for (st = RB_MIN(pf_state_tree_id, &V_tree_id);
 			    st; st = nexts) {
 				nexts = RB_NEXT(pf_state_tree_id, &V_tree_id, st);
@@ -1061,14 +1061,14 @@
 				continue;
 
 			/* XXX correct? */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			for (sk = RB_MIN(pf_state_tree, &V_pf_statetbl);
 #else
 			for (sk = RB_MIN(pf_state_tree, &pf_statetbl);
 #endif
 			    sk; sk = nextsk) {
 				nextsk = RB_NEXT(pf_state_tree,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    &V_pf_statetbl, sk);
 #else
 				    &pf_statetbl, sk);
@@ -1083,7 +1083,7 @@
 			}
 		}
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1109,7 +1109,7 @@
 	sa = (struct pfsync_state *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1121,7 +1121,7 @@
 		    sp->dst.state > PF_TCPS_PROXY_DST ||
 		    sp->direction > PF_OUT ||
 		    (sp->af != AF_INET && sp->af != AF_INET6)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1138,7 +1138,7 @@
 			break;
 		}
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1166,7 +1166,7 @@
 	iaa = (struct pfsync_ins_ack *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1182,7 +1182,7 @@
 		if (ISSET(st->state_flags, PFSTATE_ACK))
 			pfsync_deferred(st, 0);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1250,7 +1250,7 @@
 	sa = (struct pfsync_state *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1260,7 +1260,7 @@
 		if (sp->timeout >= PFTM_MAX ||
 		    sp->src.state > PF_TCPS_PROXY_DST ||
 		    sp->dst.state > PF_TCPS_PROXY_DST) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1302,7 +1302,7 @@
 		}
 
 		if (sfail) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1316,7 +1316,7 @@
 			V_pfsyncstats.pfsyncs_stale++;
 
 			pfsync_update_state(st);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pfsync_sendout();
 #else
 			schednetisr(NETISR_PFSYNC);
@@ -1330,7 +1330,7 @@
 		st->timeout = sp->timeout;
 		st->pfsync_time = time_second;
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1361,7 +1361,7 @@
 	ua = (struct pfsync_upd_c *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1371,7 +1371,7 @@
 		if (up->timeout >= PFTM_MAX ||
 		    up->src.state > PF_TCPS_PROXY_DST ||
 		    up->dst.state > PF_TCPS_PROXY_DST) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1412,7 +1412,7 @@
 		}
 
 		if (sfail) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1426,7 +1426,7 @@
 			V_pfsyncstats.pfsyncs_stale++;
 
 			pfsync_update_state(st);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pfsync_sendout();
 #else
 			schednetisr(NETISR_PFSYNC);
@@ -1440,7 +1440,7 @@
 		st->timeout = up->timeout;
 		st->pfsync_time = time_second;
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1511,7 +1511,7 @@
 	sa = (struct pfsync_state *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1528,7 +1528,7 @@
 		SET(st->state_flags, PFSTATE_NOSYNC);
 		pf_unlink_state(st);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1555,7 +1555,7 @@
 	sa = (struct pfsync_del_c *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++) {
@@ -1573,7 +1573,7 @@
 		SET(st->state_flags, PFSTATE_NOSYNC);
 		pf_unlink_state(st);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1584,7 +1584,7 @@
 int
 pfsync_in_bus(struct pfsync_pkt *pkt, struct mbuf *m, int offset, int count)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -1607,7 +1607,7 @@
 
 	switch (bus->status) {
 	case PFSYNC_BUS_START:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		callout_reset(&sc->sc_bulkfail_tmo, 5 * hz, pfsync_bulk_fail,
 		    V_pfsyncif);
 #else
@@ -1617,7 +1617,7 @@
 		    pf_pool_limits[PF_LIMIT_STATES].limit /
 		    (PFSYNC_BULKPACKETS * sc->sc_maxcount));
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC)
@@ -1634,7 +1634,7 @@
 			timeout_del(&sc->sc_bulkfail_tmo);
 #if NCARP > 0
 #ifdef notyet
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (!sc->pfsync_sync_ok)
 #else
 			if (!pfsync_sync_ok)
@@ -1642,12 +1642,12 @@
 				carp_group_demote_adj(&sc->sc_if, -1);
 #endif
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			sc->pfsync_sync_ok = 1;
 #else
 			pfsync_sync_ok = 1;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC)
@@ -1655,7 +1655,7 @@
 				printf("pfsync: received valid "
 				    "bulk update end\n");
 		} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC)
@@ -1689,12 +1689,12 @@
 	tp = (struct pfsync_tdb *)(mp->m_data + offp);
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	for (i = 0; i < count; i++)
 		pfsync_update_net_tdb(&tp[i]);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
@@ -1737,7 +1737,7 @@
 	return;
 
 bad:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 	if (pf_status.debug >= PF_DEBUG_MISC)
@@ -1773,7 +1773,7 @@
 
 int
 pfsyncoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct route *rt)
 #else
 	struct rtentry *rt)
@@ -1787,7 +1787,7 @@
 int
 pfsyncioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
 {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	struct proc *p = curproc;
 #endif
 	struct pfsync_softc *sc = ifp->if_softc;
@@ -1805,7 +1805,7 @@
 	case SIOCSIFDSTADDR:
 #endif
 	case SIOCSIFFLAGS:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (ifp->if_flags & IFF_UP)
 			ifp->if_drv_flags |= IFF_DRV_RUNNING;
 		else
@@ -1824,11 +1824,11 @@
 			ifr->ifr_mtu = MCLBYTES;
 		if (ifr->ifr_mtu < ifp->if_mtu) {
 			s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_LOCK();
 #endif
 			pfsync_sendout();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 #endif
 			splx(s);
@@ -1846,7 +1846,7 @@
 		return (copyout(&pfsyncr, ifr->ifr_data, sizeof(pfsyncr)));
 
 	case SIOCSETPFSYNC:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((error = priv_check(curthread, PRIV_NETINET_PF)) != 0)
 #else
 		if ((error = suser(p, p->p_acflag)) != 0)
@@ -1855,11 +1855,11 @@
 		if ((error = copyin(ifr->ifr_data, &pfsyncr, sizeof(pfsyncr))))
 			return (error);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		if (pfsyncr.pfsyncr_syncpeer.s_addr == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			sc->sc_sync_peer.s_addr = htonl(INADDR_PFSYNC_GROUP);
 #else
 			sc->sc_sync_peer.s_addr = INADDR_PFSYNC_GROUP;
@@ -1869,19 +1869,19 @@
 			    pfsyncr.pfsyncr_syncpeer.s_addr;
 
 		if (pfsyncr.pfsyncr_maxupdates > 255)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		{
 			PF_UNLOCK();
 #endif
 			return (EINVAL);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		}
 #endif
 		sc->sc_maxupdates = pfsyncr.pfsyncr_maxupdates;
 
 		if (pfsyncr.pfsyncr_syncdev[0] == 0) {
 			sc->sc_sync_if = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 #endif
 			if (imo->imo_num_memberships > 0) {
@@ -1892,17 +1892,17 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		if ((sifp = ifunit(pfsyncr.pfsyncr_syncdev)) == NULL)
 			return (EINVAL);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (sifp->if_mtu < sc->sc_ifp->if_mtu ||
 #else
 		if (sifp->if_mtu < sc->sc_if.if_mtu ||
@@ -1914,18 +1914,18 @@
 		sc->sc_sync_if = sifp;
 
 		if (imo->imo_num_memberships > 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 #endif
 			in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_LOCK();
 #endif
 			imo->imo_multicast_ifp = NULL;
 		}
 
 		if (sc->sc_sync_if &&
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    sc->sc_sync_peer.s_addr == htonl(INADDR_PFSYNC_GROUP)) {
 #else
 		    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
@@ -1934,20 +1934,20 @@
 
 			if (!(sc->sc_sync_if->if_flags & IFF_MULTICAST)) {
 				sc->sc_sync_if = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				PF_UNLOCK();
 #endif
 				splx(s);
 				return (EADDRNOTAVAIL);
 			}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			addr.s_addr = htonl(INADDR_PFSYNC_GROUP);
 #else
 			addr.s_addr = INADDR_PFSYNC_GROUP;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 #endif
 			if ((imo->imo_membership[0] =
@@ -1956,7 +1956,7 @@
 				splx(s);
 				return (ENOBUFS);
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_LOCK();
 #endif
 			imo->imo_num_memberships++;
@@ -1971,7 +1971,7 @@
 		ip->ip_hl = sizeof(sc->sc_template) >> 2;
 		ip->ip_tos = IPTOS_LOWDELAY;
 		/* len and id are set later */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		ip->ip_off = IP_DF;
 #else
 		ip->ip_off = htons(IP_DF);
@@ -1986,7 +1986,7 @@
 			sc->sc_ureq_sent = time_uptime;
 #if NCARP > 0
 #ifdef notyet
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (sc->pfsync_sync_ok)
 #else
 			if (pfsync_sync_ok)
@@ -1994,18 +1994,18 @@
 				carp_group_demote_adj(&sc->sc_if, 1);
 #endif
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			sc->pfsync_sync_ok = 0;
 #else
 			pfsync_sync_ok = 0;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC)
 #endif
 				printf("pfsync: requesting bulk update\n");
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			callout_reset(&sc->sc_bulkfail_tmo, 5 * hz,
 			    pfsync_bulk_fail, V_pfsyncif);
 #else
@@ -2013,7 +2013,7 @@
 #endif
 			pfsync_request_update(0, 0);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		splx(s);
@@ -2100,7 +2100,7 @@
 
 		TAILQ_FOREACH(st, &sc->sc_qs[q], sync_list) {
 #ifdef PFSYNC_DEBUG
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			KASSERT(st->sync_state == q,
 				("%s: st->sync_state == q", 
 					__FUNCTION__));
@@ -2135,13 +2135,13 @@
 void
 pfsync_sendout(void)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 #if NBPFILTER > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ifnet *ifp = sc->sc_ifp;
 #else
 	struct ifnet *ifp = &sc->sc_if;
@@ -2156,14 +2156,14 @@
 #ifdef notyet
 	struct tdb *t;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	size_t pktlen;
 	int dummy_error;
 #endif
 	int offset;
 	int q, count = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_NET);
@@ -2183,7 +2183,7 @@
 
 	MGETHDR(m, M_DONTWAIT, MT_DATA);
 	if (m == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		sc->sc_ifp->if_oerrors++;
 #else
 		sc->sc_if.if_oerrors++;
@@ -2193,7 +2193,7 @@
 		return;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pktlen = max_linkhdr + sc->sc_len;
 	if (pktlen > MHLEN) {
 		/* Find the right pool to allocate from. */
@@ -2210,7 +2210,7 @@
 #endif
 		if (!ISSET(m->m_flags, M_EXT)) {
 			m_free(m);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			sc->sc_ifp->if_oerrors++;
 #else
 			sc->sc_if.if_oerrors++;
@@ -2228,7 +2228,7 @@
 	bcopy(&sc->sc_template, ip, sizeof(*ip));
 	offset = sizeof(*ip);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	ip->ip_len = m->m_pkthdr.len;
 #else
 	ip->ip_len = htons(m->m_pkthdr.len);
@@ -2242,7 +2242,7 @@
 
 	ph->version = PFSYNC_VERSION;
 	ph->len = htons(sc->sc_len - sizeof(*ip));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	bcopy(V_pf_status.pf_chksum, ph->pfcksum, PF_MD5_DIGEST_LENGTH);
 #else
 	bcopy(pf_status.pf_chksum, ph->pfcksum, PF_MD5_DIGEST_LENGTH);
@@ -2259,7 +2259,7 @@
 		count = 0;
 		TAILQ_FOREACH(st, &sc->sc_qs[q], sync_list) {
 #ifdef PFSYNC_DEBUG
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			KASSERT(st->sync_state == q,
 				("%s: st->sync_state == q",
 					__FUNCTION__));
@@ -2343,7 +2343,7 @@
 	if (ifp->if_bpf) {
 		m->m_data += sizeof(*ip);
 		m->m_len = m->m_pkthdr.len = sc->sc_len - sizeof(*ip);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		BPF_MTAP(ifp, m);
 #else
 		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@@ -2359,7 +2359,7 @@
 	}
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sc->sc_ifp->if_opackets++;
 	sc->sc_ifp->if_obytes += m->m_pkthdr.len;
 	sc->sc_len = PFSYNC_MINPKT;
@@ -2383,13 +2383,13 @@
 void
 pfsync_insert_state(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2405,7 +2405,7 @@
 		return;
 
 #ifdef PFSYNC_DEBUG
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(st->sync_state == PFSYNC_S_NONE,
 		("%s: st->sync_state == PFSYNC_S_NONE", __FUNCTION__));
 #else
@@ -2414,7 +2414,7 @@
 #endif
 
 	if (sc->sc_len == PFSYNC_MINPKT)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		callout_reset(&sc->sc_tmo, 1 * hz, pfsync_timeout,
 		    V_pfsyncif);
 #else
@@ -2424,7 +2424,7 @@
 	pfsync_q_ins(st, PFSYNC_S_INS);
 
 	if (ISSET(st->state_flags, PFSTATE_ACK))
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pfsync_sendout();
 #else
 		schednetisr(NETISR_PFSYNC);
@@ -2438,14 +2438,14 @@
 int
 pfsync_defer(struct pf_state *st, struct mbuf *m)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 	struct pfsync_deferral *pd;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2459,7 +2459,7 @@
 		return (0);
 	sc->sc_deferred++;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	m->m_flags |= M_SKIP_FIREWALL;
 #else
 	m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
@@ -2470,7 +2470,7 @@
 	pd->pd_m = m;
 
 	TAILQ_INSERT_TAIL(&sc->sc_deferrals, pd, pd_entry);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	callout_init(&pd->pd_tmo, CALLOUT_MPSAFE);
 	callout_reset(&pd->pd_tmo, defer, pfsync_defer_tmo,
 		pd);
@@ -2485,14 +2485,14 @@
 void
 pfsync_undefer(struct pfsync_deferral *pd, int drop)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 	int s;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2507,13 +2507,13 @@
 		m_freem(pd->pd_m);
 	else {
 		s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/* XXX: use pf_defered?! */
 		PF_UNLOCK();
 #endif
 		ip_output(pd->pd_m, (void *)NULL, (void *)NULL, 0,
 		    (void *)NULL, (void *)NULL);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		splx(s);
@@ -2525,18 +2525,18 @@
 void
 pfsync_defer_tmo(void *arg)
 {
-#if defined(__FreeBSD__) && defined(VIMAGE)
+#if defined(__FreeBSD_kernel__) && defined(VIMAGE)
 	struct pfsync_deferral *pd = arg;
 #endif
 	int s;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_SET(pd->pd_m->m_pkthdr.rcvif->if_vnet); /* XXX */
 	PF_LOCK();
 #endif
 	pfsync_undefer(arg, 0);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 	CURVNET_RESTORE();
 #endif
@@ -2546,7 +2546,7 @@
 void
 pfsync_deferred(struct pf_state *st, int drop)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2568,14 +2568,14 @@
 void
 pfsync_update_state(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 	int sync = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2593,7 +2593,7 @@
 	}
 
 	if (sc->sc_len == PFSYNC_MINPKT)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		callout_reset(&sc->sc_tmo, 1 * hz, pfsync_timeout,
 		    V_pfsyncif);
 #else
@@ -2625,7 +2625,7 @@
 
 	if (sync || (time_second - st->pfsync_time) < 2) {
 		pfsync_upds++;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pfsync_sendout();
 #else
 		schednetisr(NETISR_PFSYNC);
@@ -2636,7 +2636,7 @@
 void
 pfsync_request_update(u_int32_t creatorid, u_int64_t id)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2664,7 +2664,7 @@
 	if (TAILQ_EMPTY(&sc->sc_upd_req_list))
 		nlen += sizeof(struct pfsync_subheader);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sc->sc_len + nlen > sc->sc_ifp->if_mtu) {
 #else
 	if (sc->sc_len + nlen > sc->sc_if.if_mtu) {
@@ -2680,7 +2680,7 @@
 	TAILQ_INSERT_TAIL(&sc->sc_upd_req_list, item, ur_entry);
 	sc->sc_len += nlen;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pfsync_sendout();
 #else
 	schednetisr(NETISR_PFSYNC);
@@ -2690,7 +2690,7 @@
 void
 pfsync_update_state_req(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2713,7 +2713,7 @@
 		pfsync_q_del(st);
 	case PFSYNC_S_NONE:
 		pfsync_q_ins(st, PFSYNC_S_UPD);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pfsync_sendout();
 #else
 		schednetisr(NETISR_PFSYNC);
@@ -2735,13 +2735,13 @@
 void
 pfsync_delete_state(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2759,7 +2759,7 @@
 	}
 
 	if (sc->sc_len == PFSYNC_MINPKT)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		callout_reset(&sc->sc_tmo, 1 * hz, pfsync_timeout,
 		    V_pfsyncif);
 #else
@@ -2796,13 +2796,13 @@
 		struct pfsync_clr clr;
 	} __packed r;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #else
 	splassert(IPL_SOFTNET);
@@ -2825,7 +2825,7 @@
 void
 pfsync_q_ins(struct pf_state *st, int q)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2835,7 +2835,7 @@
 
 	PF_LOCK_ASSERT();
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(st->sync_state == PFSYNC_S_NONE,
 		("%s: st->sync_state == PFSYNC_S_NONE", __FUNCTION__));
 #else
@@ -2844,7 +2844,7 @@
 
 #if 1 || defined(PFSYNC_DEBUG)
 	if (sc->sc_len < PFSYNC_MINPKT)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		panic("pfsync pkt len is too low %zu", sc->sc_len);
 #else
 		panic("pfsync pkt len is too low %d", sc->sc_len);
@@ -2853,7 +2853,7 @@
 	if (TAILQ_EMPTY(&sc->sc_qs[q]))
 		nlen += sizeof(struct pfsync_subheader);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sc->sc_len + nlen > sc->sc_ifp->if_mtu) {
 #else
 	if (sc->sc_len + nlen > sc->sc_if.if_mtu) {
@@ -2873,14 +2873,14 @@
 void
 pfsync_q_del(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 	int q = st->sync_state;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(st->sync_state != PFSYNC_S_NONE, 
 		("%s: st->sync_state != PFSYNC_S_NONE", __FUNCTION__));
 #else
@@ -2899,7 +2899,7 @@
 void
 pfsync_update_tdb(struct tdb *t, int output)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2943,7 +2943,7 @@
 void
 pfsync_delete_tdb(struct tdb *t)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -2998,20 +2998,20 @@
 void
 pfsync_bulk_start(void)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 	if (pf_status.debug >= PF_DEBUG_MISC)
 #endif
 		printf("pfsync: received bulk update request\n");
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 	if (TAILQ_EMPTY(&V_state_list))
 #else
@@ -3021,7 +3021,7 @@
 	else {
 		sc->sc_ureq_received = time_uptime;
 		if (sc->sc_bulk_next == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			sc->sc_bulk_next = TAILQ_FIRST(&V_state_list);
 #else
 			sc->sc_bulk_next = TAILQ_FIRST(&state_list);
@@ -3032,7 +3032,7 @@
 			callout_reset(&sc->sc_bulk_tmo, 1,
 			    pfsync_bulk_update, sc);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 }
@@ -3048,7 +3048,7 @@
 	PF_LOCK_ASSERT();
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_SET(sc->sc_ifp->if_vnet);
 #endif
 	for (;;) {
@@ -3061,7 +3061,7 @@
 
 		st = TAILQ_NEXT(st, entry_list);
 		if (st == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			st = TAILQ_FIRST(&V_state_list);
 #else
 			st = TAILQ_FIRST(&state_list);
@@ -3075,7 +3075,7 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (i > 1 && (sc->sc_ifp->if_mtu - sc->sc_len) <
 #else
 		if (i > 1 && (sc->sc_if.if_mtu - sc->sc_len) <
@@ -3083,7 +3083,7 @@
 		    sizeof(struct pfsync_state)) {
 			/* we've filled a packet */
 			sc->sc_bulk_next = st;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			callout_reset(&sc->sc_bulk_tmo, 1,
 			    pfsync_bulk_update, sc);
 #else
@@ -3093,7 +3093,7 @@
 		}
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_RESTORE();
 #endif
 	splx(s);
@@ -3107,7 +3107,7 @@
 		struct pfsync_bus bus;
 	} __packed r;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -3120,7 +3120,7 @@
 	r.subh.action = PFSYNC_ACT_BUS;
 	r.subh.count = htons(1);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	r.bus.creatorid = V_pf_status.hostid;
 #else
 	r.bus.creatorid = pf_status.hostid;
@@ -3136,13 +3136,13 @@
 {
 	struct pfsync_softc *sc = arg;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_SET(sc->sc_ifp->if_vnet);
 #endif
 
 	if (sc->sc_bulk_tries++ < PFSYNC_MAX_BULKTRIES) {
 		/* Try again */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		callout_reset(&sc->sc_bulkfail_tmo, 5 * hz,
 		    pfsync_bulk_fail, V_pfsyncif);
 #else
@@ -3157,7 +3157,7 @@
 		sc->sc_bulk_tries = 0;
 #if NCARP > 0
 #ifdef notyet
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (!sc->pfsync_sync_ok)
 #else
 		if (!pfsync_sync_ok)
@@ -3165,12 +3165,12 @@
 			carp_group_demote_adj(&sc->sc_if, -1);
 #endif
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		sc->pfsync_sync_ok = 1;
 #else
 		pfsync_sync_ok = 1;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC)
@@ -3178,7 +3178,7 @@
 			printf("pfsync: failed to receive bulk update\n");
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_RESTORE();
 #endif
 }
@@ -3186,7 +3186,7 @@
 void
 pfsync_send_plus(void *plus, size_t pluslen)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -3195,7 +3195,7 @@
 
 	PF_LOCK_ASSERT();
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sc->sc_len + pluslen > sc->sc_ifp->if_mtu) {
 #else
 	if (sc->sc_len + pluslen > sc->sc_if.if_mtu) {
@@ -3216,13 +3216,13 @@
 int
 pfsync_up(void)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sc == NULL || !ISSET(sc->sc_ifp->if_flags, IFF_DRV_RUNNING))
 #else
 	if (sc == NULL || !ISSET(sc->sc_if.if_flags, IFF_RUNNING))
@@ -3235,7 +3235,7 @@
 int
 pfsync_state_in_use(struct pf_state *st)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfsync_softc *sc = V_pfsyncif;
 #else
 	struct pfsync_softc *sc = pfsyncif;
@@ -3258,35 +3258,35 @@
 void
 pfsync_timeout(void *arg)
 {
-#if defined(__FreeBSD__) && defined(VIMAGE)
+#if defined(__FreeBSD_kernel__) && defined(VIMAGE)
 	struct pfsync_softc *sc = arg;
 #endif
 	int s;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_SET(sc->sc_ifp->if_vnet);
 #endif
 
 	pfsync_tmos++;
 
 	s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #endif
 	pfsync_sendout();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	splx(s);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	CURVNET_RESTORE();
 #endif
 }
 
 /* this is a softnet/netisr handler */
 void
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pfsyncintr(void *arg)
 {
 	struct pfsync_softc *sc = arg;
@@ -3342,7 +3342,7 @@
 	return (ENOPROTOOPT);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 pfsync_ifdetach(void *arg, struct ifnet *ifp)
 {
@@ -3449,12 +3449,12 @@
 
 	switch (type) {
 	case MOD_LOAD:
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 		pfsyncattach(0);
 #endif
 		break;
 	case MOD_UNLOAD:
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 		if_clone_detach(&pfsync_cloner);
 #endif
 		break;
--- a/sys/contrib/pf/net/pf.c
+++ b/sys/contrib/pf/net/pf.c
@@ -35,7 +35,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 
@@ -43,7 +43,7 @@
 __FBSDID("$FreeBSD$");
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_bpf.h"
 #include "opt_pf.h"
 
@@ -86,7 +86,7 @@
 #include <sys/socketvar.h>
 #include <sys/kernel.h>
 #include <sys/time.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/random.h>
 #include <sys/sysctl.h>
 #include <sys/endian.h>
@@ -95,7 +95,7 @@
 #include <sys/pool.h>
 #endif
 #include <sys/proc.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/kthread.h>
 #include <sys/lock.h>
 #include <sys/sx.h>
@@ -103,7 +103,7 @@
 #include <sys/rwlock.h>
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/md5.h>
 #else
 #include <crypto/md5.h>
@@ -113,7 +113,7 @@
 #include <net/if_types.h>
 #include <net/bpf.h>
 #include <net/route.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RADIX_MPATH
 #include <net/radix_mpath.h>
 #endif
@@ -136,12 +136,12 @@
 #include <netinet/udp_var.h>
 #include <netinet/icmp_var.h>
 #include <netinet/if_ether.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <netinet/ip_fw.h>
 #include <netinet/ipfw/ip_fw_private.h> /* XXX: only for DIR_IN/DIR_OUT */
 #endif
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <dev/rndvar.h>
 #endif
 #include <net/pfvar.h>
@@ -154,13 +154,13 @@
 #include <netinet/in_pcb.h>
 #include <netinet/icmp6.h>
 #include <netinet6/nd6.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <netinet6/ip6_var.h>
 #include <netinet6/in6_pcb.h>
 #endif
 #endif /* INET6 */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <machine/in_cksum.h>
 #include <sys/limits.h>
 #include <sys/ucred.h>
@@ -169,7 +169,7 @@
 extern int ip_optcopy(struct ip *, struct ip *);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	DPFPRINTF(n, x)	if (V_pf_status.debug >= (n)) printf x
 #else
 #define	DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
@@ -180,7 +180,7 @@
  */
 
 /* state tables */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(struct pf_state_tree,	 pf_statetbl);
 
 VNET_DEFINE(struct pf_altqqueue,	 pf_altqs[2]);
@@ -268,7 +268,7 @@
 			    struct pf_addr *, struct pf_addr *, u_int16_t,
 			    u_int16_t *, u_int16_t *, u_int16_t *,
 			    u_int16_t *, u_int8_t, sa_family_t);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void			 pf_send_tcp(struct mbuf *,
 			    const struct pf_rule *, sa_family_t,
 #else
@@ -286,7 +286,7 @@
 int			 pf_test_rule(struct pf_rule **, struct pf_state **,
 			    int, struct pfi_kif *, struct mbuf *, int,
 			    void *, struct pf_pdesc *, struct pf_rule **,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    struct pf_ruleset **, struct ifqueue *,
 			    struct inpcb *);
 #else
@@ -328,7 +328,7 @@
 void			 pf_route6(struct mbuf **, struct pf_rule *, int,
 			    struct ifnet *, struct pf_state *,
 			    struct pf_pdesc *);
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 int			 pf_socket_lookup(int, struct pf_pdesc *);
 #endif
 u_int8_t		 pf_get_wscale(struct mbuf *, int, u_int16_t,
@@ -341,7 +341,7 @@
 			    struct pf_addr *);
 int			 pf_check_proto_cksum(struct mbuf *, int, int,
 			    u_int8_t, sa_family_t);
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 struct pf_divert	*pf_get_divert(struct mbuf *);
 #endif
 void			 pf_print_state_parts(struct pf_state *,
@@ -350,7 +350,7 @@
 			    struct pf_addr_wrap *);
 int			 pf_compare_state_keys(struct pf_state_key *,
 			    struct pf_state_key *, struct pfi_kif *, u_int);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 struct pf_state		*pf_find_state(struct pfi_kif *,
 			    struct pf_state_key_cmp *, u_int, struct mbuf *,
 			    struct pf_mtag *);
@@ -361,7 +361,7 @@
 int			 pf_src_connlimit(struct pf_state **);
 int			 pf_check_congestion(struct ifqueue *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int in4_cksum(struct mbuf *m, u_int8_t nxt, int off, int len);
 
 VNET_DECLARE(int, pf_end_threads);
@@ -380,7 +380,7 @@
 };
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	PPACKET_LOOPED()						\
 	(pd->pf_mtag->flags & PF_PACKET_LOOPED)
 
@@ -420,7 +420,7 @@
 	} while (0)
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	BOUND_IFACE(r, k) \
 	((r)->rule_flag & PFRULE_IFBOUND) ? (k) : V_pfi_all
 #else
@@ -457,7 +457,7 @@
 static __inline int pf_state_compare_id(struct pf_state *,
 	struct pf_state *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(struct pf_src_tree,	 	 tree_src_tracking);
 
 VNET_DEFINE(struct pf_state_tree_id,	 tree_id);
@@ -580,7 +580,7 @@
 	if ((*state)->rule.ptr->max_src_conn &&
 	    (*state)->rule.ptr->max_src_conn <
 	    (*state)->src_node->conn) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.lcounters[LCNT_SRCCONN]++;
 #else
 		pf_status.lcounters[LCNT_SRCCONN]++;
@@ -590,7 +590,7 @@
 
 	if ((*state)->rule.ptr->max_src_conn_rate.limit &&
 	    pf_check_threshold(&(*state)->src_node->conn_rate)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.lcounters[LCNT_SRCCONNRATE]++;
 #else
 		pf_status.lcounters[LCNT_SRCCONNRATE]++;
@@ -605,7 +605,7 @@
 		struct pfr_addr p;
 		u_int32_t	killed = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.lcounters[LCNT_OVERLOAD_TABLE]++;
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
@@ -642,7 +642,7 @@
 			struct pf_state_key *sk;
 			struct pf_state *st;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_status.lcounters[LCNT_OVERLOAD_FLUSH]++;
 			RB_FOREACH(st, pf_state_tree_id, &V_tree_id) {
 #else
@@ -672,14 +672,14 @@
 					killed++;
 				}
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC)
 #endif
 				printf(", %u states killed", killed);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC)
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC)
@@ -707,7 +707,7 @@
 			k.rule.ptr = rule;
 		else
 			k.rule.ptr = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
 		*sn = RB_FIND(pf_src_tree, &V_tree_src_tracking, &k);
 #else
@@ -718,13 +718,13 @@
 	if (*sn == NULL) {
 		if (!rule->max_src_nodes ||
 		    rule->src_nodes < rule->max_src_nodes)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			(*sn) = pool_get(&V_pf_src_tree_pl, PR_NOWAIT | PR_ZERO);
 #else
 			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT | PR_ZERO);
 #endif
 		else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_status.lcounters[LCNT_SRCNODES]++;
 #else
 			pf_status.lcounters[LCNT_SRCNODES]++;
@@ -744,7 +744,7 @@
 			(*sn)->rule.ptr = NULL;
 		PF_ACPY(&(*sn)->addr, src, af);
 		if (RB_INSERT(pf_src_tree,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    &V_tree_src_tracking, *sn) != NULL) {
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
@@ -755,7 +755,7 @@
 				pf_print_host(&(*sn)->addr, 0, af);
 				printf("\n");
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_src_tree_pl, *sn);
 #else
 			pool_put(&pf_src_tree_pl, *sn);
@@ -766,7 +766,7 @@
 		(*sn)->ruletype = rule->action;
 		if ((*sn)->rule.ptr != NULL)
 			(*sn)->rule.ptr->src_nodes++;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
 		V_pf_status.src_nodes++;
 #else
@@ -776,7 +776,7 @@
 	} else {
 		if (rule->max_src_states &&
 		    (*sn)->states >= rule->max_src_states) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_status.lcounters[LCNT_SRCSTATES]++;
 #else
 			pf_status.lcounters[LCNT_SRCSTATES]++;
@@ -879,13 +879,13 @@
 	struct pf_state_key	*cur;
 	struct pf_state		*olds = NULL;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(s->key[idx] == NULL, ("%s: key is null!", __FUNCTION__));
 #else
 	KASSERT(s->key[idx] == NULL);	/* XXX handle this? */
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((cur = RB_INSERT(pf_state_tree, &V_pf_statetbl, sk)) != NULL) {
 #else
 	if ((cur = RB_INSERT(pf_state_tree, &pf_statetbl, sk)) != NULL) {
@@ -902,7 +902,7 @@
 					/* unlink late or sks can go away */
 					olds = si->s;
 				} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 					if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -925,7 +925,7 @@
 						    sk : NULL);
 						printf("\n");
 					}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					pool_put(&V_pf_state_key_pl, sk);
 #else
 					pool_put(&pf_state_key_pl, sk);
@@ -933,7 +933,7 @@
 					return (-1);	/* collision! */
 				}
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_state_key_pl, sk);
 #else
 		pool_put(&pf_state_key_pl, sk);
@@ -942,7 +942,7 @@
 	} else
 		s->key[idx] = sk;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((si = pool_get(&V_pf_state_item_pl, PR_NOWAIT)) == NULL) {
 #else
 	if ((si = pool_get(&pf_state_item_pl, PR_NOWAIT)) == NULL) {
@@ -953,7 +953,7 @@
 	si->s = s;
 
 	/* list is sorted, if-bound states before floating */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (s->kif == V_pfi_all)
 #else
 	if (s->kif == pfi_all)
@@ -992,7 +992,7 @@
 
 	if (si) {
 		TAILQ_REMOVE(&s->key[idx]->states, si, entry);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_state_item_pl, si);
 #else
 		pool_put(&pf_state_item_pl, si);
@@ -1000,20 +1000,20 @@
 	}
 
 	if (TAILQ_EMPTY(&s->key[idx]->states)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_state_tree, &V_pf_statetbl, s->key[idx]);
 #else
 		RB_REMOVE(pf_state_tree, &pf_statetbl, s->key[idx]);
 #endif
 		if (s->key[idx]->reverse)
 			s->key[idx]->reverse->reverse = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX: implement this */
 #else
 		if (s->key[idx]->inp)
 			s->key[idx]->inp->inp_pf_sk = NULL;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_state_key_pl, s->key[idx]);
 #else
 		pool_put(&pf_state_key_pl, s->key[idx]);
@@ -1027,7 +1027,7 @@
 {
 	struct pf_state_key	*sk;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((sk = pool_get(&V_pf_state_key_pl, pool_flags)) == NULL)
 #else
 	if ((sk = pool_get(&pf_state_key_pl, pool_flags)) == NULL)
@@ -1045,7 +1045,7 @@
 	struct pf_addr *saddr, struct pf_addr *daddr,
 	u_int16_t sport, u_int16_t dport)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((*skp == NULL && *nkp == NULL),
 		("%s: skp == NULL && nkp == NULL", __FUNCTION__));
 #else
@@ -1091,7 +1091,7 @@
 pf_state_insert(struct pfi_kif *kif, struct pf_state_key *skw,
     struct pf_state_key *sks, struct pf_state *s)
 {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	splassert(IPL_SOFTNET);
 #endif
 
@@ -1103,7 +1103,7 @@
 		s->key[PF_SK_STACK] = s->key[PF_SK_WIRE];
 	} else {
 		if (pf_state_key_attach(skw, s, PF_SK_WIRE)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_state_key_pl, sks);
 #else
 			pool_put(&pf_state_key_pl, sks);
@@ -1117,7 +1117,7 @@
 	}
 
 	if (s->id == 0 && s->creatorid == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		s->id = htobe64(V_pf_status.stateid++);
 		s->creatorid = V_pf_status.hostid;
 #else
@@ -1125,7 +1125,7 @@
 		s->creatorid = pf_status.hostid;
 #endif
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (RB_INSERT(pf_state_tree_id, &V_tree_id, s) != NULL) {
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
@@ -1134,7 +1134,7 @@
 #endif
 			printf("pf: state insert failed: "
 			    "id: %016llx creatorid: %08x",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    (unsigned long long)betoh64(s->id), ntohl(s->creatorid));
 #else
 			    betoh64(s->id), ntohl(s->creatorid));
@@ -1144,7 +1144,7 @@
 		pf_detach_state(s);
 		return (-1);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_INSERT_TAIL(&V_state_list, s, entry_list);
 	V_pf_status.fcounters[FCNT_STATE_INSERT]++;
 	V_pf_status.states++;
@@ -1155,7 +1155,7 @@
 #endif
 	pfi_kif_ref(kif, PFI_KIF_REF_STATE);
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pfsync_insert_state_ptr != NULL)
 		pfsync_insert_state_ptr(s);
 #else
@@ -1168,7 +1168,7 @@
 struct pf_state *
 pf_find_state_byid(struct pf_state_cmp *key)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pf_status.fcounters[FCNT_STATE_SEARCH]++;
 
 	return (RB_FIND(pf_state_tree_id, &V_tree_id, (struct pf_state *)key));
@@ -1211,7 +1211,7 @@
 }
 
 struct pf_state *
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_find_state(struct pfi_kif *kif, struct pf_state_key_cmp *key, u_int dir,
     struct mbuf *m, struct pf_mtag *pftag)
 #else
@@ -1222,18 +1222,18 @@
 	struct pf_state_key	*sk;
 	struct pf_state_item	*si;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pf_status.fcounters[FCNT_STATE_SEARCH]++;
 #else
 	pf_status.fcounters[FCNT_STATE_SEARCH]++;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (dir == PF_OUT && pftag->statekey &&
 	    ((struct pf_state_key *)pftag->statekey)->reverse)
 		sk = ((struct pf_state_key *)pftag->statekey)->reverse;
 	else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((sk = RB_FIND(pf_state_tree, &V_pf_statetbl,
 #else
 		if ((sk = RB_FIND(pf_state_tree, &pf_statetbl,
@@ -1253,7 +1253,7 @@
 	    ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->reverse)
 		sk = ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->reverse;
 	else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((sk = RB_FIND(pf_state_tree, &V_pf_statetbl,
 #else
 		if ((sk = RB_FIND(pf_state_tree, &pf_statetbl,
@@ -1271,7 +1271,7 @@
 #endif
 
 	if (dir == PF_OUT)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pftag->statekey = NULL;
 #else
 		m->m_pkthdr.pf.statekey = NULL;
@@ -1279,7 +1279,7 @@
 
 	/* list is sorted, if-bound states before floating ones */
 	TAILQ_FOREACH(si, &sk->states, entry)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((si->s->kif == V_pfi_all || si->s->kif == kif) &&
 #else
 		if ((si->s->kif == pfi_all || si->s->kif == kif) &&
@@ -1297,13 +1297,13 @@
 	struct pf_state_key	*sk;
 	struct pf_state_item	*si, *ret = NULL;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pf_status.fcounters[FCNT_STATE_SEARCH]++;
 #else
 	pf_status.fcounters[FCNT_STATE_SEARCH]++;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	sk = RB_FIND(pf_state_tree, &V_pf_statetbl, (struct pf_state_key *)key);
 #else
 	sk = RB_FIND(pf_state_tree, &pf_statetbl, (struct pf_state_key *)key);
@@ -1332,7 +1332,7 @@
 pf_purge_thread(void *v)
 {
 	int nloops = 0, s;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int locked;
 #endif
 
@@ -1341,7 +1341,7 @@
 	for (;;) {
 		tsleep(pf_purge_thread, PWAIT, "pftm", 1 * hz);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		sx_slock(&V_pf_consistency_lock);
 		PF_LOCK();
 		locked = 0;
@@ -1366,7 +1366,7 @@
 		s = splsoftnet();
 
 		/* process a fraction of the state table every second */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (!pf_purge_expired_states(1 + (V_pf_status.states /
 		    V_pf_default_rule.timeout[PFTM_INTERVAL]), 0)) {
 			PF_UNLOCK();
@@ -1384,7 +1384,7 @@
 #endif
 
 		/* purge other expired types every PFTM_INTERVAL seconds */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (++nloops >= V_pf_default_rule.timeout[PFTM_INTERVAL]) {
 #else
 		if (++nloops >= pf_default_rule.timeout[PFTM_INTERVAL]) {
@@ -1395,7 +1395,7 @@
 		}
 
 		splx(s);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 		if (locked)
 			sx_xunlock(&V_pf_consistency_lock);
@@ -1419,7 +1419,7 @@
 		return (time_second);
 	if (state->timeout == PFTM_UNTIL_PACKET)
 		return (0);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(state->timeout != PFTM_UNLINKED,
 	    ("pf_state_expires: timeout == PFTM_UNLINKED"));
 	KASSERT((state->timeout < PFTM_MAX), 
@@ -1430,7 +1430,7 @@
 #endif
 	timeout = state->rule.ptr->timeout[state->timeout];
 	if (!timeout)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		timeout = V_pf_default_rule.timeout[state->timeout];
 #else
 		timeout = pf_default_rule.timeout[state->timeout];
@@ -1440,7 +1440,7 @@
 		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
 		states = state->rule.ptr->states_cur;
 	} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		start = V_pf_default_rule.timeout[PFTM_ADAPTIVE_START];
 		end = V_pf_default_rule.timeout[PFTM_ADAPTIVE_END];
 		states = V_pf_status.states;
@@ -1460,7 +1460,7 @@
 	return (state->expire + timeout);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int
 pf_purge_expired_src_nodes(int waslocked)
 #else
@@ -1471,7 +1471,7 @@
 	struct pf_src_node		*cur, *next;
 	int				 locked = waslocked;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	for (cur = RB_MIN(pf_src_tree, &V_tree_src_tracking); cur; cur = next) {
 	next = RB_NEXT(pf_src_tree, &V_tree_src_tracking, cur);
 #else
@@ -1481,14 +1481,14 @@
 
 		if (cur->states <= 0 && cur->expire <= time_second) {
 			if (! locked) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (!sx_try_upgrade(&V_pf_consistency_lock))
 					return (0);
 #else
 				rw_enter_write(&pf_consistency_lock);
 #endif
 				next = RB_NEXT(pf_src_tree,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    &V_tree_src_tracking, cur);
 #else
 				    &tree_src_tracking, cur);
@@ -1501,7 +1501,7 @@
 				    cur->rule.ptr->max_src_nodes <= 0)
 					pf_rm_rule(NULL, cur->rule.ptr);
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			RB_REMOVE(pf_src_tree, &V_tree_src_tracking, cur);
 			V_pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
 			V_pf_status.src_nodes--;
@@ -1516,7 +1516,7 @@
 	}
 
 	if (locked && !waslocked)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		sx_downgrade(&V_pf_consistency_lock);
 	}
@@ -1538,7 +1538,7 @@
 			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
 			if (!timeout)
 				timeout =
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    V_pf_default_rule.timeout[PFTM_SRC_NODE];
 #else
 				    pf_default_rule.timeout[PFTM_SRC_NODE];
@@ -1551,7 +1551,7 @@
 			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
 			if (!timeout)
 				timeout =
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    V_pf_default_rule.timeout[PFTM_SRC_NODE];
 #else
 				    pf_default_rule.timeout[PFTM_SRC_NODE];
@@ -1566,7 +1566,7 @@
 void
 pf_unlink_state(struct pf_state *cur)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (cur->local_flags & PFSTATE_EXPIRING)
 		return;
 	cur->local_flags |= PFSTATE_EXPIRING;
@@ -1576,7 +1576,7 @@
 
 	if (cur->src.state == PF_TCPS_PROXY_DST) {
 		/* XXX wire key the right one? */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_send_tcp(NULL, cur->rule.ptr, cur->key[PF_SK_WIRE]->af,
 #else
 		pf_send_tcp(cur->rule.ptr, cur->key[PF_SK_WIRE]->af,
@@ -1588,14 +1588,14 @@
 		    cur->src.seqhi, cur->src.seqlo + 1,
 		    TH_RST|TH_ACK, 0, 0, 0, 1, cur->tag, NULL, NULL);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_REMOVE(pf_state_tree_id, &V_tree_id, cur);
 #else
 	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
 #endif
 #if NPFLOW > 0
 	if (cur->state_flags & PFSTATE_PFLOW)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (export_pflow_ptr != NULL)
 			export_pflow_ptr(cur);
 #else
@@ -1603,7 +1603,7 @@
 #endif
 #endif
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pfsync_delete_state_ptr != NULL)
 		pfsync_delete_state_ptr(cur);
 #else
@@ -1620,12 +1620,12 @@
 void
 pf_free_state(struct pf_state *cur)
 {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	splassert(IPL_SOFTNET);
 #endif
 
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pfsync_state_in_use_ptr != NULL &&
 		pfsync_state_in_use_ptr(cur))
 #else
@@ -1633,7 +1633,7 @@
 #endif
 		return;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT(cur->timeout == PFTM_UNLINKED,
 	    ("pf_free_state: cur->timeout != PFTM_UNLINKED"));
 #else
@@ -1651,14 +1651,14 @@
 			pf_rm_rule(NULL, cur->anchor.ptr);
 	pf_normalize_tcp_cleanup(cur);
 	pfi_kif_unref(cur->kif, PFI_KIF_REF_STATE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_REMOVE(&V_state_list, cur, entry_list);
 #else
 	TAILQ_REMOVE(&state_list, cur, entry_list);
 #endif
 	if (cur->tag)
 		pf_tag_unref(cur->tag);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pf_state_pl, cur);
 	V_pf_status.fcounters[FCNT_STATE_REMOVALS]++;
 	V_pf_status.states--;
@@ -1669,7 +1669,7 @@
 #endif
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int
 pf_purge_expired_states(u_int32_t maxcheck, int waslocked)
 #else
@@ -1679,7 +1679,7 @@
 {
 	static struct pf_state	*cur = NULL;
 	struct pf_state		*next;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int			 locked = waslocked;
 #else
 	int			 locked = 0;
@@ -1688,7 +1688,7 @@
 	while (maxcheck--) {
 		/* wrap to start of list when we hit the end */
 		if (cur == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			cur = TAILQ_FIRST(&V_state_list);
 #else
 			cur = TAILQ_FIRST(&state_list);
@@ -1703,7 +1703,7 @@
 		if (cur->timeout == PFTM_UNLINKED) {
 			/* free unlinked state */
 			if (! locked) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (!sx_try_upgrade(&V_pf_consistency_lock))
 					return (0);
 #else
@@ -1716,7 +1716,7 @@
 			/* unlink and free expired state */
 			pf_unlink_state(cur);
 			if (! locked) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (!sx_try_upgrade(&V_pf_consistency_lock))
 					return (0);
 #else
@@ -1729,7 +1729,7 @@
 		cur = next;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!waslocked && locked)
 		sx_downgrade(&V_pf_consistency_lock);
 
@@ -2216,7 +2216,7 @@
     struct tcphdr *th, struct pf_state_peer *dst)
 {
 	int hlen = (th->th_off << 2) - sizeof(*th), thoptlen = hlen;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int8_t opts[TCP_MAXOLEN], *opt = opts;
 #else
 	u_int8_t opts[MAX_TCPOPTLEN], *opt = opts;
@@ -2264,7 +2264,7 @@
 	}
 
 	if (copyback)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m_copyback(m, off + sizeof(*th), thoptlen, (caddr_t)opts);
 #else
 		m_copyback(m, off + sizeof(*th), thoptlen, opts);
@@ -2273,7 +2273,7 @@
 }
 
 void
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_send_tcp(struct mbuf *replyto, const struct pf_rule *r, sa_family_t af,
 #else
 pf_send_tcp(const struct pf_rule *r, sa_family_t af,
@@ -2293,7 +2293,7 @@
 #endif /* INET6 */
 	struct tcphdr	*th;
 	char		*opt;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pf_mtag  *pf_mtag;
 
 	KASSERT(
@@ -2341,7 +2341,7 @@
 	m = m_gethdr(M_DONTWAIT, MT_HEADER);
 	if (m == NULL)
 		return;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef MAC
 	mac_netinet_firewall_send(m);
 #endif
@@ -2351,7 +2351,7 @@
 	}
 #endif
 	if (tag)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m->m_flags |= M_SKIP_FIREWALL;
 	pf_mtag->tag = rtag;
 #else
@@ -2360,20 +2360,20 @@
 #endif
 
 	if (r != NULL && r->rtableid >= 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		M_SETFIB(m, r->rtableid);
 		pf_mtag->rtableid = r->rtableid;
 #else
 		m->m_pkthdr.pf.rtableid = r->rtableid;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	}
 #endif
 
 #ifdef ALTQ
 	if (r != NULL && r->qid) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_mtag->qid = r->qid;
 
 		/* add hints for ecn */
@@ -2445,7 +2445,7 @@
 		h->ip_v = 4;
 		h->ip_hl = sizeof(*h) >> 2;
 		h->ip_tos = IPTOS_LOWDELAY;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		h->ip_off = V_path_mtu_discovery ? IP_DF : 0;
 		h->ip_len = len;
 		h->ip_ttl = ttl ? ttl : V_ip_defttl;
@@ -2456,7 +2456,7 @@
 #endif
 		h->ip_sum = 0;
 		if (eh == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 		ip_output(m, (void *)NULL, (void *)NULL, 0,
 		    (void *)NULL, (void *)NULL);
@@ -2481,7 +2481,7 @@
 			bcopy(eh->ether_dhost, e->ether_shost, ETHER_ADDR_LEN);
 			bcopy(eh->ether_shost, e->ether_dhost, ETHER_ADDR_LEN);
 			e->ether_type = eh->ether_type;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 			/* XXX_IMPORT: later */
 			ip_output(m, (void *)NULL, &ro, 0,
@@ -2503,7 +2503,7 @@
 		h6->ip6_vfc |= IPV6_VERSION;
 		h6->ip6_hlim = IPV6_DEFHLIM;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 		ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
 		PF_LOCK();
@@ -2520,14 +2520,14 @@
     struct pf_rule *r)
 {
 	struct mbuf	*m0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef INET
 	struct ip *ip;
 #endif
 	struct pf_mtag *pf_mtag;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	m0 = m_copypacket(m, M_DONTWAIT);
 	if (m0 == NULL)
 		return;
@@ -2536,7 +2536,7 @@
 		return;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((pf_mtag = pf_get_mtag(m0)) == NULL)
 		return;
 	/* XXX: revisit */
@@ -2546,20 +2546,20 @@
 #endif
 
 	if (r->rtableid >= 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		M_SETFIB(m0, r->rtableid);
 		pf_mtag->rtableid = r->rtableid;
 #else
 		m0->m_pkthdr.pf.rtableid = r->rtableid;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	}
 #endif
 
 #ifdef ALTQ
 	if (r->qid) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_mtag->qid = r->qid;
 		/* add hints for ecn */
 		pf_mtag->hdr = mtod(m0, struct ip *);
@@ -2574,7 +2574,7 @@
 	switch (af) {
 #ifdef INET
 	case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/* icmp_error() expects host byte ordering */
 		ip = mtod(m0, struct ip *);
 		NTOHS(ip->ip_len);
@@ -2589,11 +2589,11 @@
 #endif /* INET */
 #ifdef INET6
 	case AF_INET6:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		icmp6_error(m0, type, code, 0);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		break;
@@ -2737,7 +2737,7 @@
 }
 
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_match_tag(struct mbuf *m, struct pf_rule *r, int *tag,
     struct pf_mtag *pf_mtag)
 #else
@@ -2745,7 +2745,7 @@
 #endif
 {
 	if (*tag == -1)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		*tag = pf_mtag->tag;
 #else
 		*tag = m->m_pkthdr.pf.tag;
@@ -2756,7 +2756,7 @@
 }
 
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_tag_packet(struct mbuf *m, int tag, int rtableid,
     struct pf_mtag *pf_mtag)
 #else
@@ -2767,13 +2767,13 @@
 		return (0);
 
 	if (tag > 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_mtag->tag = tag;
 #else
 		m->m_pkthdr.pf.tag = tag;
 #endif
 	if (rtableid >= 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		M_SETFIB(m, rtableid);
 	}
@@ -2793,7 +2793,7 @@
 	(*r)->anchor->match = 0;
 	if (match)
 		*match = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (*depth >= sizeof(V_pf_anchor_stack) /
 	    sizeof(V_pf_anchor_stack[0])) {
 #else
@@ -2805,7 +2805,7 @@
 		return;
 	} else if (*depth == 0 && a != NULL)
 		*a = *r;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	f = V_pf_anchor_stack + (*depth)++;
 #else
 	f = pf_anchor_stack + (*depth)++;
@@ -2838,7 +2838,7 @@
 	do {
 		if (*depth <= 0)
 			break;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		f = V_pf_anchor_stack + *depth - 1;
 #else
 		f = pf_anchor_stack + *depth - 1;
@@ -2929,7 +2929,7 @@
 #endif /* INET6 */
 
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_socket_lookup(int direction, struct pf_pdesc *pd, struct inpcb *inp_arg)
 #else
 pf_socket_lookup(int direction, struct pf_pdesc *pd)
@@ -2937,7 +2937,7 @@
 {
 	struct pf_addr		*saddr, *daddr;
 	u_int16_t		 sport, dport;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct inpcbinfo	*pi;
 #else
 	struct inpcbtable	*tb;
@@ -2950,7 +2950,7 @@
 	pd->lookup.gid = GID_MAX;
 	pd->lookup.pid = NO_PID;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (inp_arg != NULL) {
 		INP_LOCK_ASSERT(inp_arg);
 		pd->lookup.uid = inp_arg->inp_cred->cr_uid;
@@ -2965,7 +2965,7 @@
 			return (-1);
 		sport = pd->hdr.tcp->th_sport;
 		dport = pd->hdr.tcp->th_dport;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pi = &V_tcbinfo;
 #else
 		tb = &tcbtable;
@@ -2976,7 +2976,7 @@
 			return (-1);
 		sport = pd->hdr.udp->uh_sport;
 		dport = pd->hdr.udp->uh_dport;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pi = &V_udbinfo;
 #else
 		tb = &udbtable;
@@ -3000,7 +3000,7 @@
 	switch (pd->af) {
 #ifdef INET
 	case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/*
 		 * XXXRW: would be nice if we had an mbuf here so that we
 		 * could use in_pcblookup_mbuf().
@@ -3027,7 +3027,7 @@
 #endif /* INET */
 #ifdef INET6
 	case AF_INET6:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/*
 		 * XXXRW: would be nice if we had an mbuf here so that we
 		 * could use in6_pcblookup_mbuf().
@@ -3057,7 +3057,7 @@
 	default:
 		return (-1);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	INP_RLOCK_ASSERT(inp);
 	pd->lookup.uid = inp->inp_cred->cr_uid;
 	pd->lookup.gid = inp->inp_cred->cr_groups[0];
@@ -3116,7 +3116,7 @@
 	int		 hlen;
 	u_int8_t	 hdr[60];
 	u_int8_t	*opt, optlen;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int16_t	 mss = V_tcp_mssdflt;
 #else
 	u_int16_t	 mss = tcp_mssdflt;
@@ -3164,7 +3164,7 @@
 	struct route_in6	 ro6;
 #endif /* INET6 */
 	struct rtentry		*rt = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int			 hlen = 0;
 	u_int16_t		 mss = V_tcp_mssdflt;
 #else
@@ -3181,7 +3181,7 @@
 		dst->sin_family = AF_INET;
 		dst->sin_len = sizeof(*dst);
 		dst->sin_addr = addr->v4;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RTF_PRCLONING
 		rtalloc_ign(&ro, (RTF_CLONING | RTF_PRCLONING));
 #else /* !RTF_PRCLONING */
@@ -3201,7 +3201,7 @@
 		dst6->sin6_family = AF_INET6;
 		dst6->sin6_len = sizeof(*dst6);
 		dst6->sin6_addr = addr->v6;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RTF_PRCLONING
 		rtalloc_ign((struct route *)&ro6,
 		    (RTF_CLONING | RTF_PRCLONING));
@@ -3218,7 +3218,7 @@
 
 	if (rt && rt->rt_ifp) {
 		mss = rt->rt_ifp->if_mtu - hlen - sizeof(struct tcphdr);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		mss = max(V_tcp_mssdflt, mss);
 #else
 		mss = max(tcp_mssdflt, mss);
@@ -3261,7 +3261,7 @@
 	MD5_CTX ctx;
 	u_int32_t digest[4];
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pf_tcp_secret_init == 0) {
 		read_random(&V_pf_tcp_secret, sizeof(V_pf_tcp_secret));
 		MD5Init(&V_pf_tcp_secret_ctx);
@@ -3293,7 +3293,7 @@
 		MD5Update(&ctx, (char *)&pd->dst->v4, sizeof(struct in_addr));
 	}
 	MD5Final((u_char *)digest, &ctx);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pf_tcp_iss_off += 4096;
 #define	ISN_RANDOM_INCREMENT (4096 - 1)
 	return (digest[0] + (arc4random() & ISN_RANDOM_INCREMENT) +
@@ -3309,7 +3309,7 @@
 pf_test_rule(struct pf_rule **rm, struct pf_state **sm, int direction,
     struct pfi_kif *kif, struct mbuf *m, int off, void *h,
     struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
     struct ifqueue *ifq, struct inpcb *inp)
 #else
     struct ifqueue *ifq)
@@ -3330,7 +3330,7 @@
 	int			 asd = 0;
 	int			 match = 0;
 	int			 state_icmp = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int16_t		 sport = 0, dport = 0;
 	u_int16_t		 bproto_sum = 0, bip_sum = 0;
 #else
@@ -3345,7 +3345,7 @@
 		return (PF_DROP);
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (inp != NULL)
 		pd->lookup.done = pf_socket_lookup(direction, pd, inp);
 	else if (V_debug_pfugidhack) {
@@ -3576,7 +3576,7 @@
 			r = TAILQ_NEXT(r, entries);
 		/* tcp/udp only. uid.op always 0 in other cases */
 		else if (r->uid.op && (pd->lookup.done || (pd->lookup.done =
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    pf_socket_lookup(direction, pd, inp), 1)) &&
 #else
 		    pf_socket_lookup(direction, pd), 1)) &&
@@ -3586,7 +3586,7 @@
 			r = TAILQ_NEXT(r, entries);
 		/* tcp/udp only. gid.op always 0 in other cases */
 		else if (r->gid.op && (pd->lookup.done || (pd->lookup.done =
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    pf_socket_lookup(direction, pd, inp), 1)) &&
 #else
 		    pf_socket_lookup(direction, pd), 1)) &&
@@ -3595,13 +3595,13 @@
 		    pd->lookup.gid))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->prob &&
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    r->prob <= arc4random())
 #else
 		    r->prob <= arc4random_uniform(UINT_MAX - 1) + 1)
 #endif
 			r = TAILQ_NEXT(r, entries);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (r->match_tag && !pf_match_tag(m, r, &tag, pd->pf_mtag))
 #else
 		else if (r->match_tag && !pf_match_tag(m, r, &tag))
@@ -3699,7 +3699,7 @@
 					ack++;
 				if (th->th_flags & TH_FIN)
 					ack++;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pf_send_tcp(m, r, af, pd->dst,
 #else
 				pf_send_tcp(r, af, pd->dst,
@@ -3721,7 +3721,7 @@
 	if (r->action == PF_DROP)
 		goto cleanup;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pf_tag_packet(m, tag, rtableid, pd->pf_mtag)) {
 #else
 	if (pf_tag_packet(m, tag, rtableid)) {
@@ -3739,7 +3739,7 @@
 		if (action != PF_PASS)
 			return (action);
 	} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (sk != NULL)
 			pool_put(&V_pf_state_key_pl, sk);
 		if (nk != NULL)
@@ -3758,7 +3758,7 @@
 
 #if NPFSYNC > 0
 	if (*sm != NULL && !ISSET((*sm)->state_flags, PFSTATE_NOSYNC) &&
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	    direction == PF_OUT && pfsync_up_ptr != NULL && pfsync_up_ptr()) {
 #else
 	    direction == PF_OUT && pfsync_up()) {
@@ -3769,7 +3769,7 @@
 		 * firewall has to know about it to allow
 		 * replies through it.
 		 */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pfsync_defer_ptr != NULL &&
 			pfsync_defer_ptr(*sm, m))
 #else
@@ -3782,7 +3782,7 @@
 	return (PF_PASS);
 
 cleanup:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sk != NULL)
 		pool_put(&V_pf_state_key_pl, sk);
 	if (nk != NULL)
@@ -3807,7 +3807,7 @@
 	struct pf_state		*s = NULL;
 	struct pf_src_node	*sn = NULL;
 	struct tcphdr		*th = pd->hdr.tcp;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int16_t		 mss = V_tcp_mssdflt;
 #else
 	u_int16_t		 mss = tcp_mssdflt;
@@ -3816,7 +3816,7 @@
 
 	/* check maximums */
 	if (r->max_states && (r->states_cur >= r->max_states)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.lcounters[LCNT_STATES]++;
 #else
 		pf_status.lcounters[LCNT_STATES]++;
@@ -3837,7 +3837,7 @@
 		REASON_SET(&reason, PFRES_SRCLIMIT);
 		goto csfailed;
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	s = pool_get(&V_pf_state_pl, PR_NOWAIT | PR_ZERO);
 #else
 	s = pool_get(&pf_state_pl, PR_NOWAIT | PR_ZERO);
@@ -3932,7 +3932,7 @@
 			REASON_SET(&reason, PFRES_MEMORY);
 			pf_src_tree_remove_state(s);
 			STATE_DEC_COUNTERS(s);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_state_pl, s);
 #else
 			pool_put(&pf_state_pl, s);
@@ -3948,7 +3948,7 @@
 			pf_normalize_tcp_cleanup(s);
 			pf_src_tree_remove_state(s);
 			STATE_DEC_COUNTERS(s);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_state_pl, s);
 #else
 			pool_put(&pf_state_pl, s);
@@ -3968,7 +3968,7 @@
 		REASON_SET(&reason, PFRES_STATEINS);
 		pf_src_tree_remove_state(s);
 		STATE_DEC_COUNTERS(s);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_state_pl, s);
 #else
 		pool_put(&pf_state_pl, s);
@@ -4008,7 +4008,7 @@
 		mss = pf_calc_mss(pd->src, pd->af, mss);
 		mss = pf_calc_mss(pd->dst, pd->af, mss);
 		s->src.mss = mss;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_send_tcp(NULL, r, pd->af, pd->dst, pd->src, th->th_dport,
 #else
 		pf_send_tcp(r, pd->af, pd->dst, pd->src, th->th_dport,
@@ -4022,7 +4022,7 @@
 	return (PF_PASS);
 
 csfailed:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (sk != NULL)
 		pool_put(&V_pf_state_key_pl, sk);
 	if (nk != NULL)
@@ -4035,7 +4035,7 @@
 #endif
 
 	if (sn != NULL && sn->states == 0 && sn->expire == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_src_tree, &V_tree_src_tracking, sn);
 		V_pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
 		V_pf_status.src_nodes--;
@@ -4048,7 +4048,7 @@
 #endif
 	}
 	if (nsn != sn && nsn != NULL && nsn->states == 0 && nsn->expire == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_src_tree, &V_tree_src_tracking, nsn);
 		V_pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
 		V_pf_status.src_nodes--;
@@ -4110,7 +4110,7 @@
 		else if (r->prob && r->prob <=
 		    (arc4random() % (UINT_MAX - 1) + 1))
 			r = TAILQ_NEXT(r, entries);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (r->match_tag && !pf_match_tag(m, r, &tag, pd->pf_mtag))
 #else
 		else if (r->match_tag && !pf_match_tag(m, r, &tag))
@@ -4146,7 +4146,7 @@
 	if (r->action != PF_PASS)
 		return (PF_DROP);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pf_tag_packet(m, tag, -1, pd->pf_mtag)) {
 #else
 	if (pf_tag_packet(m, tag, -1)) {
@@ -4405,7 +4405,7 @@
 		 * and keep updating the state TTL.
 		 */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -4415,7 +4415,7 @@
 			pf_print_flags(th->th_flags);
 			printf(" seq=%u (%u) ack=%u len=%u ackskew=%d "
 			    "pkts=%llu:%llu dir=%s,%s\n", seq, orig_seq, ack,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    pd->p_len, ackskew, (unsigned long long)(*state)->packets[0],
 			    (unsigned long long)(*state)->packets[1],
 #else
@@ -4460,7 +4460,7 @@
 		    (*state)->src.state == TCPS_SYN_SENT) {
 			/* Send RST for state mismatches during handshake */
 			if (!(th->th_flags & TH_RST))
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pf_send_tcp(NULL, (*state)->rule.ptr, pd->af,
 #else
 				pf_send_tcp((*state)->rule.ptr, pd->af,
@@ -4473,7 +4473,7 @@
 			src->seqlo = 0;
 			src->seqhi = 1;
 			src->max_win = 1;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		} else if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 		} else if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -4484,7 +4484,7 @@
 			printf(" seq=%u (%u) ack=%u len=%u ackskew=%d "
 			    "pkts=%llu:%llu dir=%s,%s\n",
 			    seq, orig_seq, ack, pd->p_len, ackskew,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    (unsigned long long)(*state)->packets[0],
 			    (unsigned long long)(*state)->packets[1],
 #else
@@ -4604,7 +4604,7 @@
 		key.port[0] = th->th_dport;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 	STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -4630,7 +4630,7 @@
 				REASON_SET(reason, PFRES_SYNPROXY);
 				return (PF_DROP);
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pf_send_tcp(NULL, (*state)->rule.ptr, pd->af, pd->dst,
 #else
 			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
@@ -4664,7 +4664,7 @@
 			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
 			if ((*state)->dst.seqhi == 1)
 				(*state)->dst.seqhi = htonl(arc4random());
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pf_send_tcp(NULL, (*state)->rule.ptr, pd->af,
 #else
 			pf_send_tcp((*state)->rule.ptr, pd->af,
@@ -4683,7 +4683,7 @@
 		} else {
 			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
 			(*state)->dst.seqlo = ntohl(th->th_seq);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pf_send_tcp(NULL, (*state)->rule.ptr, pd->af, pd->dst,
 #else
 			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
@@ -4692,7 +4692,7 @@
 			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
 			    TH_ACK, (*state)->src.max_win, 0, 0, 0,
 			    (*state)->tag, NULL, NULL);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pf_send_tcp(NULL, (*state)->rule.ptr, pd->af,
 #else
 			pf_send_tcp((*state)->rule.ptr, pd->af,
@@ -4721,7 +4721,7 @@
 	if (((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN) &&
 	    dst->state >= TCPS_FIN_WAIT_2 &&
 	    src->state >= TCPS_FIN_WAIT_2) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -4767,7 +4767,7 @@
 
 	/* Copyback sequence modulation or stateful scrub changes if needed */
 	if (copyback)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m_copyback(m, off, sizeof(*th), (caddr_t)th);
 #else
 		m_copyback(m, off, sizeof(*th), th);
@@ -4798,7 +4798,7 @@
 		key.port[0] = uh->uh_dport;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 	STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -4840,7 +4840,7 @@
 			pf_change_ap(pd->dst, &uh->uh_dport, pd->ip_sum,
 			    &uh->uh_sum, &nk->addr[pd->didx],
 			    nk->port[pd->didx], 1, pd->af);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
 #else
 		m_copyback(m, off, sizeof(*uh), uh);
@@ -4855,7 +4855,7 @@
     struct mbuf *m, int off, void *h, struct pf_pdesc *pd, u_short *reason)
 {
 	struct pf_addr  *saddr = pd->src, *daddr = pd->dst;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int16_t	 icmpid = 0, *icmpsum;
 #else
 	u_int16_t	 icmpid, *icmpsum;
@@ -4911,7 +4911,7 @@
 			PF_ACPY(&key.addr[0], pd->dst, key.af);
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 		STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -4950,7 +4950,7 @@
 				}
 
 				m_copyback(m, off, ICMP_MINLEN,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    (caddr_t)
 #endif
 				    pd->hdr.icmp);
@@ -4972,7 +4972,7 @@
 
 				m_copyback(m, off,
 				    sizeof(struct icmp6_hdr),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    (caddr_t)
 #endif
 				    pd->hdr.icmp6);
@@ -4989,7 +4989,7 @@
 		 */
 
 		struct pf_pdesc	pd2;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		bzero(&pd2, sizeof pd2);
 #endif
 #ifdef INET
@@ -4999,7 +4999,7 @@
 		struct ip6_hdr	h2_6;
 		int		terminal = 0;
 #endif /* INET6 */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		int		ipoff2 = 0;
 		int		off2 = 0;
 #else
@@ -5126,7 +5126,7 @@
 			key.port[pd2.sidx] = th.th_sport;
 			key.port[pd2.didx] = th.th_dport;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 			STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5156,7 +5156,7 @@
 			if (!((*state)->state_flags & PFSTATE_SLOPPY) &&
 			    (!SEQ_GEQ(src->seqhi, seq) ||
 			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)))) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 				if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -5173,7 +5173,7 @@
 				REASON_SET(reason, PFRES_BADSTATE);
 				return (PF_DROP);
 			} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 				if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -5221,12 +5221,12 @@
 #ifdef INET
 				case AF_INET:
 					m_copyback(m, off, ICMP_MINLEN,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    pd->hdr.icmp);
 					m_copyback(m, ipoff2, sizeof(h2),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    &h2);
@@ -5236,19 +5236,19 @@
 				case AF_INET6:
 					m_copyback(m, off,
 					    sizeof(struct icmp6_hdr),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    pd->hdr.icmp6);
 					m_copyback(m, ipoff2, sizeof(h2_6),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    &h2_6);
 					break;
 #endif /* INET6 */
 				}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				m_copyback(m, off2, 8, (caddr_t)&th);
 #else
 				m_copyback(m, off2, 8, &th);
@@ -5276,7 +5276,7 @@
 			key.port[pd2.sidx] = uh.uh_sport;
 			key.port[pd2.didx] = uh.uh_dport;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 			STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5311,11 +5311,11 @@
 #ifdef INET
 				case AF_INET:
 					m_copyback(m, off, ICMP_MINLEN,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    pd->hdr.icmp);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					m_copyback(m, ipoff2, sizeof(h2), (caddr_t)&h2);
 #else
 					m_copyback(m, ipoff2, sizeof(h2), &h2);
@@ -5326,19 +5326,19 @@
 				case AF_INET6:
 					m_copyback(m, off,
 					    sizeof(struct icmp6_hdr),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    pd->hdr.icmp6);
 					m_copyback(m, ipoff2, sizeof(h2_6),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    &h2_6);
 					break;
 #endif /* INET6 */
 				}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				m_copyback(m, off2, sizeof(uh), (caddr_t)&uh);
 #else
 				m_copyback(m, off2, sizeof(uh), &uh);
@@ -5365,7 +5365,7 @@
 			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
 			key.port[0] = key.port[1] = iih.icmp_id;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 			STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5396,7 +5396,7 @@
 					    pd2.ip_sum, icmpsum,
 					    pd->ip_sum, 0, AF_INET);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				m_copyback(m, off, ICMP_MINLEN, (caddr_t)pd->hdr.icmp);
 				m_copyback(m, ipoff2, sizeof(h2), (caddr_t)&h2);
 				m_copyback(m, off2, ICMP_MINLEN, (caddr_t)&iih);
@@ -5428,7 +5428,7 @@
 			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
 			key.port[0] = key.port[1] = iih.icmp6_id;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 			STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5459,7 +5459,7 @@
 					    pd2.ip_sum, icmpsum,
 					    pd->ip_sum, 0, AF_INET6);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				m_copyback(m, off, sizeof(struct icmp6_hdr),
 				    (caddr_t)pd->hdr.icmp6);
 				m_copyback(m, ipoff2, sizeof(h2_6), (caddr_t)&h2_6);
@@ -5484,7 +5484,7 @@
 			PF_ACPY(&key.addr[pd2.didx], pd2.dst, key.af);
 			key.port[0] = key.port[1] = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 			STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5514,7 +5514,7 @@
 				switch (pd2.af) {
 #ifdef INET
 				case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					m_copyback(m, off, ICMP_MINLEN,
 					    (caddr_t)pd->hdr.icmp);
 					m_copyback(m, ipoff2, sizeof(h2), (caddr_t)&h2);
@@ -5529,12 +5529,12 @@
 				case AF_INET6:
 					m_copyback(m, off,
 					    sizeof(struct icmp6_hdr),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    pd->hdr.icmp6);
 					m_copyback(m, ipoff2, sizeof(h2_6),
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    (caddr_t)
 #endif
 					    &h2_6);
@@ -5568,7 +5568,7 @@
 		key.port[1] = key.port[0] = 0;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	STATE_LOOKUP(kif, &key, direction, *state, m, pd->pf_mtag);
 #else
 	STATE_LOOKUP(kif, &key, direction, *state, m);
@@ -5599,7 +5599,7 @@
 	if ((*state)->key[PF_SK_WIRE] != (*state)->key[PF_SK_STACK]) {
 		struct pf_state_key *nk = (*state)->key[pd->didx];
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		KASSERT(nk, ("%s: nk is null", __FUNCTION__));
 		KASSERT(pd, ("%s: pd is null", __FUNCTION__));
 		KASSERT(pd->src, ("%s: pd->src is null", __FUNCTION__));
@@ -5695,7 +5695,7 @@
 int
 pf_routable(struct pf_addr *addr, sa_family_t af, struct pfi_kif *kif)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RADIX_MPATH
 	struct radix_node_head	*rnh;
 #endif
@@ -5703,11 +5703,11 @@
 	struct sockaddr_in	*dst;
 	int			 ret = 1;
 	int			 check_mpath;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	extern int		 ipmultipath;
 #endif
 #ifdef INET6
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	extern int		 ip6_multipath;
 #endif
 	struct sockaddr_in6	*dst6;
@@ -5720,7 +5720,7 @@
 	struct ifnet		*ifp;
 
 	check_mpath = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RADIX_MPATH
 	/* XXX: stick to table 0 for now */
 	rnh = rt_tables_get_rnh(0, af);
@@ -5735,7 +5735,7 @@
 		dst->sin_family = AF_INET;
 		dst->sin_len = sizeof(*dst);
 		dst->sin_addr = addr->v4;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 		if (ipmultipath)
 			check_mpath = 1;
 #endif
@@ -5752,7 +5752,7 @@
 		dst6->sin6_family = AF_INET6;
 		dst6->sin6_len = sizeof(*dst6);
 		dst6->sin6_addr = addr->v6;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 		if (ip6_multipath)
 			check_mpath = 1;
 #endif
@@ -5766,7 +5766,7 @@
 	if (kif != NULL && kif->pfik_ifp->if_type == IFT_ENC)
 		goto out;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /* XXX MRT not always INET */ /* stick with table 0 though */
 #ifdef INET
 	if (af == AF_INET)
@@ -5793,7 +5793,7 @@
 		rn = (struct radix_node *)ro.ro_rt;
 		do {
 			rt = (struct rtentry *)rn;
-#ifndef __FreeBSD__ /* CARPDEV */
+#ifndef __FreeBSD_kernel__ /* CARPDEV */
 			if (rt->rt_ifp->if_type == IFT_CARP)
 				ifp = rt->rt_ifp->if_carpdev;
 			else
@@ -5802,7 +5802,7 @@
 
 			if (kif->pfik_ifp == ifp)
 				ret = 1;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef RADIX_MPATH
 			rn = rn_mpath_next(rn);
 #endif
@@ -5850,7 +5850,7 @@
 		return (0);
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 # ifdef RTF_PRCLONING
 	rtalloc_ign((struct route *)&ro, (RTF_CLONING|RTF_PRCLONING));
 # else /* !RTF_PRCLONING */
@@ -5866,7 +5866,7 @@
 #endif
 
 	if (ro.ro_rt != NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/* XXX_IMPORT: later */
 #else
 		if (ro.ro_rt->rt_labelid == aw->v.rtlabel)
@@ -5892,7 +5892,7 @@
 	struct pf_addr		 naddr;
 	struct pf_src_node	*sn = NULL;
 	int			 error = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int sw_csum;
 #endif
 #ifdef IPSEC
@@ -5903,7 +5903,7 @@
 	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
 		panic("pf_route: invalid parameters");
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pd->pf_mtag->routed++ > 3) {
 #else
 	if ((*m)->m_pkthdr.pf.routed++ > 3) {
@@ -5914,7 +5914,7 @@
 	}
 
 	if (r->rt == PF_DUPTO) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((m0 = m_dup(*m, M_DONTWAIT)) == NULL)
 #else
 		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
@@ -5942,13 +5942,13 @@
 	dst->sin_addr = ip->ip_dst;
 
 	if (r->rt == PF_FASTROUTE) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		in_rtalloc(ro, 0);
 #else
 		rtalloc(ro);
 #endif
 		if (ro->ro_rt == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			KMOD_IPSTAT_INC(ips_noroute);
 #else
 			ipstat.ips_noroute++;
@@ -5985,7 +5985,7 @@
 		goto bad;
 
 	if (oifp != ifp) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 		if (pf_test(PF_OUT, ifp, &m0, NULL, NULL) != PF_PASS) {
 			PF_LOCK();
@@ -6009,7 +6009,7 @@
 		ip = mtod(m0, struct ip *);
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* Copied from FreeBSD 5.1-CURRENT ip_output. */
 	m0->m_pkthdr.csum_flags |= CSUM_IP;
 	sw_csum = m0->m_pkthdr.csum_flags & ~ifp->if_hwassist;
@@ -6083,7 +6083,7 @@
 		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
 		    ifp->if_bridge == NULL) {
 			m0->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			KMOD_IPSTAT_INC(ips_outhwcsum);
 #else
 			ipstat.ips_outhwcsum++;
@@ -6105,13 +6105,13 @@
 	 * Must be able to put at least 8 bytes per fragment.
 	 */
 	if (ip->ip_off & htons(IP_DF)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		KMOD_IPSTAT_INC(ips_cantfrag);
 #else
 		ipstat.ips_cantfrag++;
 #endif
 		if (r->rt != PF_DUPTO) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			/* icmp_error() expects host byte ordering */
 			NTOHS(ip->ip_len);
 			NTOHS(ip->ip_off);
@@ -6129,7 +6129,7 @@
 	}
 
 	m1 = m0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/*
 	 * XXX: is cheaper + less error prone than own function
 	 */
@@ -6140,7 +6140,7 @@
 	error = ip_fragment(m0, ifp, ifp->if_mtu);
 #endif
 	if (error) {
-#ifndef __FreeBSD__    /* ip_fragment does not do m_freem() on FreeBSD */
+#ifndef __FreeBSD_kernel__    /* ip_fragment does not do m_freem() on FreeBSD */
 		m0 = NULL;
 #endif
 		goto bad;
@@ -6149,7 +6149,7 @@
 	for (m0 = m1; m0; m0 = m1) {
 		m1 = m0->m_nextpkt;
 		m0->m_nextpkt = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (error == 0) {
 			PF_UNLOCK();
 			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
@@ -6166,7 +6166,7 @@
 	}
 
 	if (error == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		KMOD_IPSTAT_INC(ips_fragmented);
 #else
 		ipstat.ips_fragmented++;
@@ -6203,7 +6203,7 @@
 	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
 		panic("pf_route6: invalid parameters");
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pd->pf_mtag->routed++ > 3) {
 #else
 	if ((*m)->m_pkthdr.pf.routed++ > 3) {
@@ -6214,7 +6214,7 @@
 	}
 
 	if (r->rt == PF_DUPTO) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((m0 = m_dup(*m, M_DONTWAIT)) == NULL)
 #else
 		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
@@ -6242,7 +6242,7 @@
 
 	/* Cheat. XXX why only in the v6 case??? */
 	if (r->rt == PF_FASTROUTE) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m0->m_flags |= M_SKIP_FIREWALL;
 		PF_UNLOCK();
 		ip6_output(m0, NULL, NULL, 0, NULL, NULL, NULL);
@@ -6275,7 +6275,7 @@
 		goto bad;
 
 	if (oifp != ifp) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 		if (pf_test6(PF_OUT, ifp, &m0, NULL, NULL) != PF_PASS) {
 			PF_LOCK();
@@ -6306,16 +6306,16 @@
 	if (IN6_IS_SCOPE_EMBED(&dst->sin6_addr))
 		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
 	if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		nd6_output(ifp, ifp, m0, dst, NULL);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 	} else {
 		in6_ifstat_inc(ifp, ifs6_in_toobig);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (r->rt != PF_DUPTO) {
 			PF_UNLOCK();
 			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
@@ -6340,7 +6340,7 @@
 }
 #endif /* INET6 */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 /*
  * FreeBSD supports cksum offloads for the following drivers.
  *  em(4), fxp(4), ixgb(4), lge(4), ndis(4), nge(4), re(4),
@@ -6570,7 +6570,7 @@
 }
 #endif
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 struct pf_divert *
 pf_find_divert(struct mbuf *m)
 {
@@ -6602,7 +6602,7 @@
 
 #ifdef INET
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_test(int dir, struct ifnet *ifp, struct mbuf **m0,
     struct ether_header *eh, struct inpcb *inp)
 #else
@@ -6613,7 +6613,7 @@
 	struct pfi_kif		*kif;
 	u_short			 action, reason = 0, log = 0;
 	struct mbuf		*m = *m0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ip		*h = NULL;
 	struct m_tag		*ipfwtag;
 	struct pf_rule		*a = NULL, *r = &V_pf_default_rule, *tr, *nr;
@@ -6626,7 +6626,7 @@
 	struct pf_pdesc		 pd;
 	int			 off, dirndx, pqid = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 	if (!V_pf_status.running)
 	{
@@ -6639,7 +6639,7 @@
 #endif
 
 	memset(&pd, 0, sizeof(pd));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
 		PF_UNLOCK();
 		DPFPRINTF(PF_DEBUG_URGENT,
@@ -6647,7 +6647,7 @@
 		return (PF_DROP);
 	}
 #endif
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	if (ifp->if_type == IFT_CARP && ifp->if_carpdev)
 		kif = (struct pfi_kif *)ifp->if_carpdev->if_pf_kif;
 	else
@@ -6655,7 +6655,7 @@
 		kif = (struct pfi_kif *)ifp->if_pf_kif;
 
 	if (kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		DPFPRINTF(PF_DEBUG_URGENT,
@@ -6663,16 +6663,16 @@
 		return (PF_DROP);
 	}
 	if (kif->pfik_flags & PFI_IFLAG_SKIP)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		PF_UNLOCK();
 #endif
 		return (PF_PASS);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	}
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	M_ASSERTPKTHDR(m);
 #else
 #ifdef DIAGNOSTIC
@@ -6688,7 +6688,7 @@
 		goto done;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (m->m_flags & M_SKIP_FIREWALL) {
 		PF_UNLOCK();
 		return (PF_PASS);
@@ -6698,7 +6698,7 @@
 		return (PF_PASS);
 #endif
 	
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (ip_divert_ptr != NULL &&
 	    ((ipfwtag = m_tag_locate(m, MTAG_IPFW_RULE, 0, NULL)) != NULL)) {
 		struct ipfw_rule_ref *rr = (struct ipfw_rule_ref *)(ipfwtag+1);
@@ -6770,7 +6770,7 @@
 		    &reason);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -6781,7 +6781,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -6810,7 +6810,7 @@
 		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -6821,7 +6821,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -6844,7 +6844,7 @@
 		    &reason);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -6855,7 +6855,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -6878,7 +6878,7 @@
 		action = pf_test_state_other(&s, dir, kif, m, &pd);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -6889,7 +6889,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif, m, off, h,
 			    &pd, &a, &ruleset, NULL, inp);
 #else
@@ -6910,14 +6910,14 @@
 	}
 
 	if ((s && s->tag) || r->rtableid)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_tag_packet(m, s ? s->tag : 0, r->rtableid, pd.pf_mtag);
 #else
 		pf_tag_packet(m, s ? s->tag : 0, r->rtableid);
 #endif
 
 	if (dir == PF_IN && s && s->key[PF_SK_STACK])
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pd.pf_mtag->statekey = s->key[PF_SK_STACK];
 #else
 		m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
@@ -6925,7 +6925,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pqid || (pd.tos & IPTOS_LOWDELAY))
 			pd.pf_mtag->qid = r->pqid;
 		else
@@ -6954,13 +6954,13 @@
 	    (s->nat_rule.ptr->action == PF_RDR ||
 	    s->nat_rule.ptr->action == PF_BINAT) &&
 	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m->m_flags |= M_SKIP_FIREWALL;
 #else
 		m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (action == PF_PASS && r->divert.port &&
 	    ip_divert_ptr != NULL && !PACKET_LOOPED()) {
 
@@ -7047,7 +7047,7 @@
 		}
 		tr = r;
 		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (nr != NULL && r == &V_pf_default_rule)
 #else
 		if (nr != NULL && r == &pf_default_rule)
@@ -7082,7 +7082,7 @@
 			pf_route(m0, r, dir, kif->pfik_ifp, s, &pd);
 		break;
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	return (action);
@@ -7091,7 +7091,7 @@
 
 #ifdef INET6
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0,
     struct ether_header *eh, struct inpcb *inp)
 #else
@@ -7102,7 +7102,7 @@
 	struct pfi_kif		*kif;
 	u_short			 action, reason = 0, log = 0;
 	struct mbuf		*m = *m0, *n = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ip6_hdr		*h = NULL;
 	struct pf_rule		*a = NULL, *r = &V_pf_default_rule, *tr, *nr;
 #else
@@ -7114,7 +7114,7 @@
 	struct pf_pdesc		 pd;
 	int			 off, terminal = 0, dirndx, rh_cnt = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 	if (!V_pf_status.running) {
 		PF_UNLOCK();
@@ -7126,7 +7126,7 @@
 #endif
 
 	memset(&pd, 0, sizeof(pd));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
 		PF_UNLOCK();
 		DPFPRINTF(PF_DEBUG_URGENT,
@@ -7134,7 +7134,7 @@
 		return (PF_DROP);
 	}
 #endif
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	if (ifp->if_type == IFT_CARP && ifp->if_carpdev)
 		kif = (struct pfi_kif *)ifp->if_carpdev->if_pf_kif;
 	else
@@ -7142,7 +7142,7 @@
 		kif = (struct pfi_kif *)ifp->if_pf_kif;
 
 	if (kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		DPFPRINTF(PF_DEBUG_URGENT,
@@ -7150,16 +7150,16 @@
 		return (PF_DROP);
 	}
 	if (kif->pfik_flags & PFI_IFLAG_SKIP)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	{
 		PF_UNLOCK();
 #endif
 		return (PF_PASS);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	}
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	M_ASSERTPKTHDR(m);
 #else
 #ifdef DIAGNOSTIC
@@ -7175,14 +7175,14 @@
 		goto done;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pd.pf_mtag->flags & PF_TAG_GENERATED) {
 		PF_UNLOCK();
 #else
 	if (m->m_pkthdr.pf.flags & PF_TAG_GENERATED)
 #endif
 		return (PF_PASS);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	}
 #endif
 
@@ -7310,7 +7310,7 @@
 		    &reason);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -7321,7 +7321,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -7350,7 +7350,7 @@
 		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -7361,7 +7361,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -7391,7 +7391,7 @@
 		    m, off, h, &pd, &reason);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -7402,7 +7402,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, NULL, inp);
 #else
@@ -7416,7 +7416,7 @@
 		action = pf_test_state_other(&s, dir, kif, m, &pd);
 		if (action == PF_PASS) {
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (pfsync_update_state_ptr != NULL)
 				pfsync_update_state_ptr(s);
 #else
@@ -7427,7 +7427,7 @@
 			a = s->anchor.ptr;
 			log = s->log;
 		} else if (s == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			action = pf_test_rule(&r, &s, dir, kif, m, off, h,
 			    &pd, &a, &ruleset, NULL, inp);
 #else
@@ -7454,14 +7454,14 @@
 	}
 
 	if ((s && s->tag) || r->rtableid)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_tag_packet(m, s ? s->tag : 0, r->rtableid, pd.pf_mtag);
 #else
 		pf_tag_packet(m, s ? s->tag : 0, r->rtableid);
 #endif
 
 	if (dir == PF_IN && s && s->key[PF_SK_STACK])
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pd.pf_mtag->statekey = s->key[PF_SK_STACK];
 #else
 		m->m_pkthdr.pf.statekey = s->key[PF_SK_STACK];
@@ -7469,7 +7469,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pd.tos & IPTOS_LOWDELAY)
 			pd.pf_mtag->qid = r->pqid;
 		else
@@ -7492,13 +7492,13 @@
 	    (s->nat_rule.ptr->action == PF_RDR ||
 	    s->nat_rule.ptr->action == PF_BINAT) &&
 	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6))
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m->m_flags |= M_SKIP_FIREWALL;
 #else
 		m->m_pkthdr.pf.flags |= PF_TAG_TRANSLATE_LOCALHOST;
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX: Anybody working on it?! */
 	if (r->divert.port)
 		printf("pf: divert(9) is not supported for IPv6\n");
@@ -7556,7 +7556,7 @@
 		}
 		tr = r;
 		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (nr != NULL && r == &V_pf_default_rule)
 #else
 		if (nr != NULL && r == &pf_default_rule)
@@ -7590,7 +7590,7 @@
 		break;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 #endif
 	return (action);
@@ -7600,7 +7600,7 @@
 int
 pf_check_congestion(struct ifqueue *ifq)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX_IMPORT: later */
 	return (0);
 #else
@@ -7618,7 +7618,7 @@
 void
 pf_pkt_addr_changed(struct mbuf *m)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pf_mtag	*pf_tag;
 
 	if ((pf_tag = pf_find_mtag(m)) != NULL)
--- a/sys/contrib/pf/net/pf_if.c
+++ b/sys/contrib/pf/net/pf_if.c
@@ -32,7 +32,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD_kernel__)
 #include "opt_inet.h"
 #include "opt_inet6.h"
 
@@ -42,7 +42,7 @@
 
 #include <sys/param.h>
 #include <sys/systm.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/malloc.h>
 #endif
 #include <sys/mbuf.h>
@@ -50,17 +50,17 @@
 #include <sys/socket.h>
 #include <sys/socketvar.h>
 #include <sys/kernel.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/device.h>
 #endif
 #include <sys/time.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/pool.h>
 #endif
 
 #include <net/if.h>
 #include <net/if_types.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/vnet.h>
 #endif
 
@@ -76,7 +76,7 @@
 #include <netinet/ip6.h>
 #endif /* INET6 */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(struct pfi_kif *,	 pfi_all);
 VNET_DEFINE(uma_zone_t,		 pfi_addr_pl);
 VNET_DEFINE(struct pfi_ifhead,	 pfi_ifs);
@@ -98,7 +98,7 @@
 int			  pfi_buffer_cnt;
 int			  pfi_buffer_max;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 eventhandler_tag	 pfi_attach_cookie;
 eventhandler_tag	 pfi_detach_cookie;
 eventhandler_tag	 pfi_attach_group_cookie;
@@ -117,7 +117,7 @@
 int		 pfi_if_compare(struct pfi_kif *, struct pfi_kif *);
 int		 pfi_skip_if(const char *, struct pfi_kif *);
 int		 pfi_unmask(void *);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void		 pfi_attach_ifnet_event(void * __unused, struct ifnet *);
 void		 pfi_detach_ifnet_event(void * __unused, struct ifnet *);
 void		 pfi_attach_group_event(void *, struct ifg_group *);
@@ -135,18 +135,18 @@
 void
 pfi_initialize(void)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pfi_all != NULL)	/* already initialized */
 #else
 	if (pfi_all != NULL)	/* already initialized */
 #endif
 		return;
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	pool_init(&V_pfi_addr_pl, sizeof(struct pfi_dynaddr), 0, 0, 0,
 	    "pfiaddrpl", &pool_allocator_nointr);
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_buffer_max = 64;
 	V_pfi_buffer = malloc(V_pfi_buffer_max * sizeof(*V_pfi_buffer),
 	    PFI_MTYPE, M_WAITOK);
@@ -160,7 +160,7 @@
 	if ((pfi_all = pfi_kif_get(IFG_ALL)) == NULL)
 #endif
 		panic("pfi_kif_get for pfi_all failed");
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct ifg_group *ifg;
 	struct ifnet *ifp;
 
@@ -186,7 +186,7 @@
 #endif
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 pfi_cleanup(void)
 {
@@ -224,7 +224,7 @@
 
 	bzero(&s, sizeof(s));
 	strlcpy(s.pfik_name, kif_name, sizeof(s.pfik_name));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((kif = RB_FIND(pfi_ifhead, &V_pfi_ifs, (struct pfi_kif *)&s)) != NULL)
 #else
 	if ((kif = RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&s)) != NULL)
@@ -232,7 +232,7 @@
 		return (kif);
 
 	/* create new one */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((kif = malloc(sizeof(*kif), PFI_MTYPE, M_NOWAIT | M_ZERO)) == NULL)
 #else
 	if ((kif = malloc(sizeof(*kif), PFI_MTYPE, M_DONTWAIT|M_ZERO)) == NULL)
@@ -240,7 +240,7 @@
 		return (NULL);
 
 	strlcpy(kif->pfik_name, kif_name, sizeof(kif->pfik_name));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/*
 	 * It seems that the value of time_second is in unintialzied state
 	 * when pf sets interface statistics clear time in boot phase if pf
@@ -254,7 +254,7 @@
 #endif
 	TAILQ_INIT(&kif->pfik_dynaddrs);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_INSERT(pfi_ifhead, &V_pfi_ifs, kif);
 #else
 	RB_INSERT(pfi_ifhead, &pfi_ifs, kif);
@@ -305,7 +305,7 @@
 		panic("pfi_kif_unref with unknown type");
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (kif->pfik_ifp != NULL || kif->pfik_group != NULL || kif == V_pfi_all)
 #else
 	if (kif->pfik_ifp != NULL || kif->pfik_group != NULL || kif == pfi_all)
@@ -315,7 +315,7 @@
 	if (kif->pfik_rules || kif->pfik_states)
 		return;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_REMOVE(pfi_ifhead, &V_pfi_ifs, kif);
 #else
 	RB_REMOVE(pfi_ifhead, &pfi_ifs, kif);
@@ -347,7 +347,7 @@
 
 	pfi_initialize();
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
@@ -358,7 +358,7 @@
 	kif->pfik_ifp = ifp;
 	ifp->if_pf_kif = (caddr_t)kif;
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	if ((kif->pfik_ah_cookie = hook_establish(ifp->if_addrhooks, 1,
 	    pfi_kifaddr_update, kif)) == NULL)
 		panic("pfi_attach_ifnet: cannot allocate '%s' address hook",
@@ -380,12 +380,12 @@
 		return;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
 #endif
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	hook_disestablish(ifp->if_addrhooks, kif->pfik_ah_cookie);
 #endif
 	pfi_kif_update(kif);
@@ -404,7 +404,7 @@
 
 	pfi_initialize();
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
@@ -428,7 +428,7 @@
 		return;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
@@ -447,7 +447,7 @@
 	int			 s;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
@@ -505,7 +505,7 @@
 
 	if (aw->type != PF_ADDR_DYNIFTL)
 		return (0);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX: revisit! */
 	if ((dyn = pool_get(&V_pfi_addr_pl, PR_WAITOK | PR_ZERO))
 #else
@@ -567,7 +567,7 @@
 		pf_remove_if_empty_ruleset(ruleset);
 	if (dyn->pfid_kif != NULL)
 		pfi_kif_unref(dyn->pfid_kif, PFI_KIF_REF_RULE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pfi_addr_pl, dyn);
 #else
 	pool_put(&pfi_addr_pl, dyn);
@@ -605,14 +605,14 @@
 	kif = dyn->pfid_kif;
 	kt = dyn->pfid_kt;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (kt->pfrkt_larg != V_pfi_update) {
 #else
 	if (kt->pfrkt_larg != pfi_update) {
 #endif
 		/* this table needs to be brought up-to-date */
 		pfi_table_update(kt, kif, dyn->pfid_net, dyn->pfid_iflags);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt->pfrkt_larg = V_pfi_update;
 #else
 		kt->pfrkt_larg = pfi_update;
@@ -627,7 +627,7 @@
 	int			 e, size2 = 0;
 	struct ifg_member	*ifgm;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_buffer_cnt = 0;
 #else
 	pfi_buffer_cnt = 0;
@@ -639,7 +639,7 @@
 		TAILQ_FOREACH(ifgm, &kif->pfik_group->ifg_members, ifgm_next)
 			pfi_instance_add(ifgm->ifgm_ifp, net, flags);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((e = pfr_set_addrs(&kt->pfrkt_t, V_pfi_buffer, V_pfi_buffer_cnt, &size2,
 	    NULL, NULL, NULL, 0, PFR_TFLAG_ALLMASK)))
 		printf("pfi_table_update: cannot set %d new addresses "
@@ -667,7 +667,7 @@
 		af = ia->ifa_addr->sa_family;
 		if (af != AF_INET && af != AF_INET6)
 			continue;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		/*
 		 * XXX: For point-to-point interfaces, (ifname:0) and IPv4,
 		 *      jump over addresses without a proper route to work
@@ -727,7 +727,7 @@
 	struct pfr_addr	*p;
 	int		 i;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pfi_buffer_cnt >= V_pfi_buffer_max) {
 		int		 new_max = V_pfi_buffer_max * 2;
 #else
@@ -737,7 +737,7 @@
 
 		if (new_max > PFI_BUFFER_MAX) {
 			printf("pfi_address_add: address buffer full (%d/%d)\n",
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    V_pfi_buffer_cnt, PFI_BUFFER_MAX);
 #else
 			    pfi_buffer_cnt, PFI_BUFFER_MAX);
@@ -745,21 +745,21 @@
 			return;
 		}
 		p = malloc(new_max * sizeof(*V_pfi_buffer), PFI_MTYPE,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    M_NOWAIT);
 #else
 		    M_DONTWAIT);
 #endif
 		if (p == NULL) {
 			printf("pfi_address_add: no memory to grow buffer "
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    "(%d/%d)\n", V_pfi_buffer_cnt, PFI_BUFFER_MAX);
 #else
 			    "(%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
 #endif
 			return;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		memcpy(V_pfi_buffer, p, V_pfi_buffer_cnt * sizeof(*V_pfi_buffer));
 		/* no need to zero buffer */
 		free(V_pfi_buffer, PFI_MTYPE);
@@ -775,7 +775,7 @@
 	}
 	if (af == AF_INET && net > 32)
 		net = 128;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	p = V_pfi_buffer + V_pfi_buffer_cnt++;
 #else
 	p = pfi_buffer + pfi_buffer_cnt++;
@@ -812,7 +812,7 @@
 	aw->p.dyn->pfid_kif = NULL;
 	pfr_detach_table(aw->p.dyn->pfid_kt);
 	aw->p.dyn->pfid_kt = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pfi_addr_pl, aw->p.dyn);
 #else
 	pool_put(&pfi_addr_pl, aw->p.dyn);
@@ -837,7 +837,7 @@
 	struct pfi_kif		*kif = (struct pfi_kif *)v;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_pfi_update++;
 #else
 	pfi_update++;
@@ -863,7 +863,7 @@
 
 	strlcpy(key.pfik_name, name, sizeof(key.pfik_name));
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	p = RB_FIND(pfi_ifhead, &V_pfi_ifs, (struct pfi_kif *)&key);
 #else
 	p = RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&key);
@@ -915,12 +915,12 @@
 {
 	struct pfi_kif	*p, *nextp;
 	int		 s, n = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	int		 error;
 #endif
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	for (p = RB_MIN(pfi_ifhead, &V_pfi_ifs); p; p = nextp) {
 		nextp = RB_NEXT(pfi_ifhead, &V_pfi_ifs, p);
 #else
@@ -933,7 +933,7 @@
 			if (!p->pfik_tzero)
 				p->pfik_tzero = time_second;
 			pfi_kif_ref(p, PFI_KIF_REF_RULE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYOUT(p, buf++, sizeof(*buf), error);
 			if (error) {
 #else
@@ -943,7 +943,7 @@
 				splx(s);
 				return (EFAULT);
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			nextp = RB_NEXT(pfi_ifhead, &V_pfi_ifs, p);
 #else
 			nextp = RB_NEXT(pfi_ifhead, &pfi_ifs, p);
@@ -982,7 +982,7 @@
 	int		 s;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_FOREACH(p, pfi_ifhead, &V_pfi_ifs) {
 #else
 	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
@@ -1002,7 +1002,7 @@
 	int		 s;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_FOREACH(p, pfi_ifhead, &V_pfi_ifs) {
 #else
 	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
@@ -1035,7 +1035,7 @@
 	return (b);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 pfi_attach_ifnet_event(void *arg __unused, struct ifnet *ifp)
 {
--- a/sys/contrib/pf/net/pf_ioctl.c
+++ b/sys/contrib/pf/net/pf_ioctl.c
@@ -35,7 +35,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
@@ -76,7 +76,7 @@
 #include <sys/socketvar.h>
 #include <sys/kernel.h>
 #include <sys/time.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/ucred.h>
 #include <sys/jail.h>
 #include <sys/module.h>
@@ -90,14 +90,14 @@
 #include <sys/proc.h>
 #include <sys/malloc.h>
 #include <sys/kthread.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/rwlock.h>
 #include <uvm/uvm_extern.h>
 #endif
 
 #include <net/if.h>
 #include <net/if_types.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <net/vnet.h>
 #endif
 #include <net/route.h>
@@ -109,7 +109,7 @@
 #include <netinet/ip_var.h>
 #include <netinet/ip_icmp.h>
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/md5.h>
 #else
 #include <dev/rndvar.h>
@@ -132,14 +132,14 @@
 #include <altq/altq.h>
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/limits.h>
 #include <sys/lock.h>
 #include <sys/mutex.h>
 #include <net/pfil.h>
 #endif /* __FreeBSD__ */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void			 init_zone_var(void);
 void			 cleanup_pf_zone(void);
 int			 pfattach(void);
@@ -154,7 +154,7 @@
 
 void			 pf_mv_pool(struct pf_palist *, struct pf_palist *);
 void			 pf_empty_pool(struct pf_palist *);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int			 pfioctl(struct cdev *, u_long, caddr_t, int, struct thread *);
 #else
 int			 pfioctl(dev_t, u_long, caddr_t, int, struct proc *);
@@ -178,7 +178,7 @@
 
 #define	TAGID_MAX	 50000
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(struct pf_rule,	 pf_default_rule);
 VNET_DEFINE(struct sx,		 pf_consistency_lock);
 
@@ -216,13 +216,13 @@
 void			 pf_rtlabel_remove(struct pf_addr_wrap *);
 void			 pf_rtlabel_copyout(struct pf_addr_wrap *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define DPFPRINTF(n, x) if (V_pf_status.debug >= (n)) printf x
 #else
 #define DPFPRINTF(n, x) if (pf_status.debug >= (n)) printf x
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 struct cdev *pf_dev;
  
 /*
@@ -607,7 +607,7 @@
 		pf_tbladdr_remove(&empty_pool_pa->addr);
 		pfi_kif_unref(empty_pool_pa->kif, PFI_KIF_REF_RULE);
 		TAILQ_REMOVE(poola, empty_pool_pa, entries);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_pooladdr_pl, empty_pool_pa);
 #else
 		pool_put(&pf_pooladdr_pl, empty_pool_pa);
@@ -658,7 +658,7 @@
 	pfi_kif_unref(rule->kif, PFI_KIF_REF_RULE);
 	pf_anchor_remove(rule);
 	pf_empty_pool(&rule->rpool.list);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pf_rule_pl, rule);
 #else
 	pool_put(&pf_rule_pl, rule);
@@ -743,7 +743,7 @@
 u_int16_t
 pf_tagname2tag(char *tagname)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	return (tagname2tag(&V_pf_tags, tagname));
 #else
 	return (tagname2tag(&pf_tags, tagname));
@@ -753,7 +753,7 @@
 void
 pf_tag2tagname(u_int16_t tagid, char *p)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	tag2tagname(&V_pf_tags, tagid, p);
 #else
 	tag2tagname(&pf_tags, tagid, p);
@@ -765,7 +765,7 @@
 {
 	struct pf_tagname *t;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_FOREACH(t, &V_pf_tags, entries)
 #else
 	TAILQ_FOREACH(t, &pf_tags, entries)
@@ -779,7 +779,7 @@
 void
 pf_tag_unref(u_int16_t tag)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	tag_unref(&V_pf_tags, tag);
 #else
 	tag_unref(&pf_tags, tag);
@@ -789,7 +789,7 @@
 int
 pf_rtlabel_add(struct pf_addr_wrap *a)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX_IMPORT: later */
 	return (0);
 #else
@@ -803,7 +803,7 @@
 void
 pf_rtlabel_remove(struct pf_addr_wrap *a)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX_IMPORT: later */
 #else
 	if (a->type == PF_ADDR_RTLABEL)
@@ -814,7 +814,7 @@
 void
 pf_rtlabel_copyout(struct pf_addr_wrap *a)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/* XXX_IMPORT: later */
 	if (a->type == PF_ADDR_RTLABEL && a->v.rtlabel)
 		strlcpy(a->v.rtlabelname, "?", sizeof(a->v.rtlabelname));
@@ -836,7 +836,7 @@
 u_int32_t
 pf_qname2qid(char *qname)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	return ((u_int32_t)tagname2tag(&V_pf_qids, qname));
 #else
 	return ((u_int32_t)tagname2tag(&pf_qids, qname));
@@ -846,7 +846,7 @@
 void
 pf_qid2qname(u_int32_t qid, char *p)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	tag2tagname(&V_pf_qids, (u_int16_t)qid, p);
 #else
 	tag2tagname(&pf_qids, (u_int16_t)qid, p);
@@ -856,7 +856,7 @@
 void
 pf_qid_unref(u_int32_t qid)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	tag_unref(&V_pf_qids, (u_int16_t)qid);
 #else
 	tag_unref(&pf_qids, (u_int16_t)qid);
@@ -870,7 +870,7 @@
 	int		 error = 0;
 
 	/* Purge the old altq list */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while ((altq = TAILQ_FIRST(V_pf_altqs_inactive)) != NULL) {
 		TAILQ_REMOVE(V_pf_altqs_inactive, altq, entries);
 		if (altq->qname[0] == 0 &&
@@ -884,7 +884,7 @@
 			error = altq_remove(altq);
 		} else
 			pf_qid_unref(altq->qid);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_altq_pl, altq);
 #else
 		pool_put(&pf_altq_pl, altq);
@@ -892,7 +892,7 @@
 	}
 	if (error)
 		return (error);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	*ticket = ++V_ticket_altqs_inactive;
 	V_altqs_inactive_open = 1;
 #else
@@ -908,7 +908,7 @@
 	struct pf_altq	*altq;
 	int		 error = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!V_altqs_inactive_open || ticket != V_ticket_altqs_inactive)
 		return (0);
 	/* Purge the old altq list */
@@ -928,13 +928,13 @@
 			error = altq_remove(altq);
 		} else
 			pf_qid_unref(altq->qid);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_altq_pl, altq);
 #else
 		pool_put(&pf_altq_pl, altq);
 #endif
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_altqs_inactive_open = 0;
 #else
 	altqs_inactive_open = 0;
@@ -949,7 +949,7 @@
 	struct pf_altq		*altq;
 	int			 s, err, error = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (!V_altqs_inactive_open || ticket != V_ticket_altqs_inactive)
 #else
 	if (!altqs_inactive_open || ticket != ticket_altqs_inactive)
@@ -958,7 +958,7 @@
 
 	/* swap altqs, keep the old. */
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	old_altqs = V_pf_altqs_active;
 	V_pf_altqs_active = V_pf_altqs_inactive;
 	V_pf_altqs_inactive = old_altqs;
@@ -971,7 +971,7 @@
 #endif
 
 	/* Attach new disciplines */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_FOREACH(altq, V_pf_altqs_active, entries) {
 	if (altq->qname[0] == 0 &&
 	   (altq->local_flags & PFALTQ_FLAG_IF_REMOVED) == 0) {
@@ -981,7 +981,7 @@
 #endif
 			/* attach the discipline */
 			error = altq_pfattach(altq);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (error == 0 && V_pf_altq_running)
 #else
 			if (error == 0 && pf_altq_running)
@@ -995,7 +995,7 @@
 	}
 
 	/* Purge the old altq list */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while ((altq = TAILQ_FIRST(V_pf_altqs_inactive)) != NULL) {
 		TAILQ_REMOVE(V_pf_altqs_inactive, altq, entries);
 		if (altq->qname[0] == 0 &&
@@ -1006,7 +1006,7 @@
 		if (altq->qname[0] == 0) {
 #endif
 			/* detach and destroy the discipline */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_altq_running)
 #else
 			if (pf_altq_running)
@@ -1020,7 +1020,7 @@
 				error = err;
 		} else
 			pf_qid_unref(altq->qid);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_altq_pl, altq);
 #else
 		pool_put(&pf_altq_pl, altq);
@@ -1028,7 +1028,7 @@
 	}
 	splx(s);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	V_altqs_inactive_open = 0;
 #else
 	altqs_inactive_open = 0;
@@ -1054,11 +1054,11 @@
 		tb.rate = altq->ifbandwidth;
 		tb.depth = altq->tbrsize;
 		s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		error = tbr_set(&ifp->if_snd, &tb);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		splx(s);
@@ -1090,11 +1090,11 @@
 		/* clear tokenbucket regulator */
 		tb.rate = 0;
 		s = splnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		error = tbr_set(&ifp->if_snd, &tb);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		splx(s);
@@ -1103,7 +1103,7 @@
 	return (error);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 pf_altq_ifnet_event(struct ifnet *ifp, int remove)
 {
@@ -1113,7 +1113,7 @@
 	int		 error = 0;
 
 	/* Interrupt userland queue modifications */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_altqs_inactive_open)
 		pf_rollback_altq(V_ticket_altqs_inactive);
 #else
@@ -1126,7 +1126,7 @@
 		return;
 
 	/* Copy the current active set */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_FOREACH(a1, V_pf_altqs_active, entries) {
 		a2 = pool_get(&V_pf_altq_pl, PR_NOWAIT);
 #else
@@ -1142,7 +1142,7 @@
 		if (a2->qname[0] != 0) {
 			if ((a2->qid = pf_qname2qid(a2->qname)) == 0) {
 				error = EBUSY;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_altq_pl, a2);
 #else
 				pool_put(&pf_altq_pl, a2);
@@ -1150,7 +1150,7 @@
 				break;
 			}
 			a2->altq_disc = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			TAILQ_FOREACH(a3, V_pf_altqs_inactive, entries) {
 #else
 			TAILQ_FOREACH(a3, pf_altqs_inactive, entries) {
@@ -1172,7 +1172,7 @@
 			error = altq_add(a2);
 			PF_LOCK();
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (ticket != V_ticket_altqs_inactive)
 #else
 			if (ticket != ticket_altqs_inactive)
@@ -1180,7 +1180,7 @@
 				error = EBUSY;
 
 			if (error) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_altq_pl, a2);
 #else
 				pool_put(&pf_altq_pl, a2);
@@ -1189,7 +1189,7 @@
 			}
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_INSERT_TAIL(V_pf_altqs_inactive, a2, entries);
 #else
 		TAILQ_INSERT_TAIL(pf_altqs_inactive, a2, entries);
@@ -1420,7 +1420,7 @@
 	}
 
 	MD5Final(digest, &ctx);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	memcpy(V_pf_status.pf_chksum, digest, sizeof(V_pf_status.pf_chksum));
 #else
 	memcpy(pf_status.pf_chksum, digest, sizeof(pf_status.pf_chksum));
@@ -1448,7 +1448,7 @@
 }
 
 int
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 pfioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flags, struct thread *td)
 #else
 pfioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
@@ -1456,7 +1456,7 @@
 {
 	struct pf_pooladdr	*pa = NULL;
 	struct pf_pool		*pool = NULL;
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	int			 s;
 #endif
 	int			 error = 0;
@@ -1464,7 +1464,7 @@
 	CURVNET_SET(TD_TO_VNET(td));
 
 	/* XXX keep in sync with switch() below */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (securelevel_gt(td->td_ucred, 2))
 #else
 	if (securelevel > 1)
@@ -1504,7 +1504,7 @@
 		case DIOCGETSRCNODES:
 		case DIOCCLRSRCNODES:
 		case DIOCIGETIFACES:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		case DIOCGIFSPEED:
 #endif
 		case DIOCSETIFFLAG:
@@ -1546,7 +1546,7 @@
 		case DIOCOSFPGET:
 		case DIOCGETSRCNODES:
 		case DIOCIGETIFACES:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		case DIOCGIFSPEED:
 #endif
 			break;
@@ -1575,7 +1575,7 @@
 		}
 
 	if (flags & FWRITE)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		sx_xlock(&V_pf_consistency_lock);
 	else
 		sx_slock(&V_pf_consistency_lock);
@@ -1585,7 +1585,7 @@
 		rw_enter_read(&pf_consistency_lock);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK();
 #else
 	s = splsoftnet();
@@ -1593,14 +1593,14 @@
 	switch (cmd) {
 
 	case DIOCSTART:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.running)
 #else
 		if (pf_status.running)
 #endif
 			error = EEXIST;
 		else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_UNLOCK();
 			error = hook_pf();
 			PF_LOCK();
@@ -1630,7 +1630,7 @@
 		break;
 
 	case DIOCSTOP:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (!V_pf_status.running)
 			error = ENOENT;
 		else {
@@ -1678,7 +1678,7 @@
 			break;
 		}
 		if (pr->ticket != ruleset->rules[rs_num].inactive.ticket) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			DPFPRINTF(PF_DEBUG_MISC,
 			    ("ticket: %d != [%d]%d\n", pr->ticket, rs_num,
 			    ruleset->rules[rs_num].inactive.ticket));
@@ -1686,7 +1686,7 @@
 			error = EBUSY;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pr->pool_ticket != V_ticket_pabuf) {
 			DPFPRINTF(PF_DEBUG_MISC,
 			    ("pool_ticket: %d != %d\n", pr->pool_ticket,
@@ -1697,7 +1697,7 @@
 			error = EBUSY;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rule = pool_get(&V_pf_rule_pl, PR_NOWAIT);
 #else
 		rule = pool_get(&pf_rule_pl, PR_WAITOK|PR_LIMITFAIL);
@@ -1707,7 +1707,7 @@
 			break;
 		}
 		bcopy(&pr->rule, rule, sizeof(struct pf_rule));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rule->cuid = td->td_ucred->cr_ruid;
 		rule->cpid = td->td_proc ? td->td_proc->p_pid : 0;
 #else
@@ -1723,7 +1723,7 @@
 		rule->entries.tqe_prev = NULL;
 #ifndef INET
 		if (rule->af == AF_INET) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_rule_pl, rule);
 #else
 			pool_put(&pf_rule_pl, rule);
@@ -1734,7 +1734,7 @@
 #endif /* INET */
 #ifndef INET6
 		if (rule->af == AF_INET6) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_rule_pl, rule);
 #else
 			pool_put(&pf_rule_pl, rule);
@@ -1752,7 +1752,7 @@
 		if (rule->ifname[0]) {
 			rule->kif = pfi_kif_get(rule->ifname);
 			if (rule->kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_rule_pl, rule);
 #else
 				pool_put(&pf_rule_pl, rule);
@@ -1763,7 +1763,7 @@
 			pfi_kif_ref(rule->kif, PFI_KIF_REF_RULE);
 		}
 
-#ifdef __FreeBSD__ /* ROUTING */
+#ifdef __FreeBSD_kernel__ /* ROUTING */
 		if (rule->rtableid > 0 && rule->rtableid > rt_numfibs)
 #else
 		if (rule->rtableid > 0 && !rtable_exists(rule->rtableid))
@@ -1807,7 +1807,7 @@
 			error = EINVAL;
 		if (pf_anchor_setup(rule, ruleset, pr->anchor_call))
 			error = EINVAL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_FOREACH(pa, &V_pf_pabuf, entries)
 #else
 		TAILQ_FOREACH(pa, &pf_pabuf, entries)
@@ -1824,7 +1824,7 @@
 				    PFR_TFLAG_ACTIVE;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_mv_pool(&V_pf_pabuf, &rule->rpool.list);
 #else
 		pf_mv_pool(&pf_pabuf, &rule->rpool.list);
@@ -1840,7 +1840,7 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (!V_debug_pfugidhack && (rule->uid.op || rule->gid.op ||
 		    rule->log & PF_LOG_SOCKET_LOOKUP)) {
 			DPFPRINTF(PF_DEBUG_MISC,
@@ -1944,7 +1944,7 @@
 
 		if (!(pcr->action == PF_CHANGE_REMOVE ||
 		    pcr->action == PF_CHANGE_GET_TICKET) &&
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    pcr->pool_ticket != V_ticket_pabuf) {
 #else
 		    pcr->pool_ticket != ticket_pabuf) {
@@ -1985,7 +1985,7 @@
 		}
 
 		if (pcr->action != PF_CHANGE_REMOVE) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			newrule = pool_get(&V_pf_rule_pl, PR_NOWAIT);
 #else
 			newrule = pool_get(&pf_rule_pl, PR_WAITOK|PR_LIMITFAIL);
@@ -1995,7 +1995,7 @@
 				break;
 			}
 			bcopy(&pcr->rule, newrule, sizeof(struct pf_rule));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			newrule->cuid = td->td_ucred->cr_ruid;
 			newrule->cpid = td->td_proc ? td->td_proc->p_pid : 0;
 #else
@@ -2008,7 +2008,7 @@
 			newrule->entries.tqe_prev = NULL;
 #ifndef INET
 			if (newrule->af == AF_INET) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_rule_pl, newrule);
 #else
 				pool_put(&pf_rule_pl, newrule);
@@ -2019,7 +2019,7 @@
 #endif /* INET */
 #ifndef INET6
 			if (newrule->af == AF_INET6) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_rule_pl, newrule);
 #else
 				pool_put(&pf_rule_pl, newrule);
@@ -2031,7 +2031,7 @@
 			if (newrule->ifname[0]) {
 				newrule->kif = pfi_kif_get(newrule->ifname);
 				if (newrule->kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					pool_put(&V_pf_rule_pl, newrule);
 #else
 					pool_put(&pf_rule_pl, newrule);
@@ -2044,7 +2044,7 @@
 				newrule->kif = NULL;
 
 			if (newrule->rtableid > 0 &&
-#ifdef __FreeBSD__ /* ROUTING */
+#ifdef __FreeBSD_kernel__ /* ROUTING */
 			    newrule->rtableid > rt_numfibs)
 #else
 			    !rtable_exists(newrule->rtableid))
@@ -2090,7 +2090,7 @@
 				error = EINVAL;
 			if (pf_anchor_setup(newrule, ruleset, pcr->anchor_call))
 				error = EINVAL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			TAILQ_FOREACH(pa, &V_pf_pabuf, entries)
 #else
 			TAILQ_FOREACH(pa, &pf_pabuf, entries)
@@ -2108,7 +2108,7 @@
 					    PFR_TFLAG_ACTIVE;
 			}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pf_mv_pool(&V_pf_pabuf, &newrule->rpool.list);
 #else
 			pf_mv_pool(&pf_pabuf, &newrule->rpool.list);
@@ -2126,7 +2126,7 @@
 				break;
 			}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (!V_debug_pfugidhack && (newrule->uid.op ||
 			    newrule->gid.op ||
 			    newrule->log & PF_LOG_SOCKET_LOOKUP)) {
@@ -2141,7 +2141,7 @@
 			newrule->packets[0] = newrule->packets[1] = 0;
 			newrule->bytes[0] = newrule->bytes[1] = 0;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_empty_pool(&V_pf_pabuf);
 #else
 		pf_empty_pool(&pf_pabuf);
@@ -2202,7 +2202,7 @@
 		struct pfioc_state_kill *psk = (struct pfioc_state_kill *)addr;
 		u_int			 killed = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		for (s = RB_MIN(pf_state_tree_id, &V_tree_id); s; s = nexts) {
 			nexts = RB_NEXT(pf_state_tree_id, &V_tree_id, s);
 #else
@@ -2222,7 +2222,7 @@
 		}
 		psk->psk_killed = killed;
 #if NPFSYNC > 0
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pfsync_clear_states_ptr != NULL)
 			pfsync_clear_states_ptr(V_pf_status.hostid, psk->psk_ifname);
 #else
@@ -2242,7 +2242,7 @@
 
 		if (psk->psk_pfcmp.id) {
 			if (psk->psk_pfcmp.creatorid == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				psk->psk_pfcmp.creatorid = V_pf_status.hostid;
 #else
 				psk->psk_pfcmp.creatorid = pf_status.hostid;
@@ -2254,7 +2254,7 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		for (s = RB_MIN(pf_state_tree_id, &V_tree_id); s;
 		    s = nexts) {
 			nexts = RB_NEXT(pf_state_tree_id, &V_tree_id, s);
@@ -2316,7 +2316,7 @@
 			error = EINVAL;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pfsync_state_import_ptr != NULL)
 			error = pfsync_state_import_ptr(sp, PFSYNC_SI_IOCTL);
 #else
@@ -2350,7 +2350,7 @@
 		u_int32_t		 nr = 0;
 
 		if (ps->ps_len == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			nr = V_pf_status.states;
 #else
 			nr = pf_status.states;
@@ -2359,17 +2359,17 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		pstore = malloc(sizeof(*pstore), M_TEMP, M_WAITOK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 
 		p = ps->ps_states;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		state = TAILQ_FIRST(&V_state_list);
 #else
 		state = TAILQ_FIRST(&state_list);
@@ -2379,7 +2379,7 @@
 				if ((nr+1) * sizeof(*p) > (unsigned)ps->ps_len)
 					break;
 				pfsync_state_export(pstore, state);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				PF_COPYOUT(pstore, p, sizeof(*p), error);
 #else
 				error = copyout(pstore, p, sizeof(*p));
@@ -2402,7 +2402,7 @@
 
 	case DIOCGETSTATUS: {
 		struct pf_status *s = (struct pf_status *)addr;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		bcopy(&V_pf_status, s, sizeof(struct pf_status));
 #else
 		bcopy(&pf_status, s, sizeof(struct pf_status));
@@ -2415,14 +2415,14 @@
 		struct pfioc_if	*pi = (struct pfioc_if *)addr;
 
 		if (pi->ifname[0] == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			bzero(V_pf_status.ifname, IFNAMSIZ);
 #else
 			bzero(pf_status.ifname, IFNAMSIZ);
 #endif
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		strlcpy(V_pf_status.ifname, pi->ifname, IFNAMSIZ);
 #else
 		strlcpy(pf_status.ifname, pi->ifname, IFNAMSIZ);
@@ -2431,7 +2431,7 @@
 	}
 
 	case DIOCCLRSTATUS: {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		bzero(V_pf_status.counters, sizeof(V_pf_status.counters));
 		bzero(V_pf_status.fcounters, sizeof(V_pf_status.fcounters));
 		bzero(V_pf_status.scounters, sizeof(V_pf_status.scounters));
@@ -2501,14 +2501,14 @@
 			error = EINVAL;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		old = V_pf_default_rule.timeout[pt->timeout];
 #else
 		old = pf_default_rule.timeout[pt->timeout];
 #endif
 		if (pt->timeout == PFTM_INTERVAL && pt->seconds == 0)
 			pt->seconds = 1;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_default_rule.timeout[pt->timeout] = pt->seconds;
 #else
 		pf_default_rule.timeout[pt->timeout] = pt->seconds;
@@ -2526,7 +2526,7 @@
 			error = EINVAL;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pt->seconds = V_pf_default_rule.timeout[pt->timeout];
 #else
 		pt->seconds = pf_default_rule.timeout[pt->timeout];
@@ -2541,7 +2541,7 @@
 			error = EINVAL;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pl->limit = V_pf_pool_limits[pl->index].limit;
 #else
 		pl->limit = pf_pool_limits[pl->index].limit;
@@ -2554,7 +2554,7 @@
 		int			 old_limit;
 
 		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX ||
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    V_pf_pool_limits[pl->index].pp == NULL) {
 #else
 		    pf_pool_limits[pl->index].pp == NULL) {
@@ -2562,7 +2562,7 @@
 			error = EINVAL;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		uma_zone_set_max(V_pf_pool_limits[pl->index].pp, pl->limit);
 		old_limit = V_pf_pool_limits[pl->index].limit;
 		V_pf_pool_limits[pl->index].limit = pl->limit;
@@ -2583,7 +2583,7 @@
 	case DIOCSETDEBUG: {
 		u_int32_t	*level = (u_int32_t *)addr;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.debug = *level;
 #else
 		pf_status.debug = *level;
@@ -2605,7 +2605,7 @@
 		break;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	case DIOCGIFSPEED: {
 		struct pf_ifspeed	*psp = (struct pf_ifspeed *)addr;
 		struct pf_ifspeed	ps;
@@ -2630,7 +2630,7 @@
 		struct pf_altq		*altq;
 
 		/* enable all altq interfaces on active list */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_FOREACH(altq, V_pf_altqs_active, entries) {
 			if (altq->qname[0] == 0 && (altq->local_flags &
 			    PFALTQ_FLAG_IF_REMOVED) == 0) {
@@ -2644,7 +2644,7 @@
 			}
 		}
 		if (error == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_altq_running = 1;
 #else
 			pf_altq_running = 1;
@@ -2657,7 +2657,7 @@
 		struct pf_altq		*altq;
 
 		/* disable all altq interfaces on active list */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_FOREACH(altq, V_pf_altqs_active, entries) {
 			if (altq->qname[0] == 0 && (altq->local_flags &
 			    PFALTQ_FLAG_IF_REMOVED) == 0) {
@@ -2671,7 +2671,7 @@
 			}
 		}
 		if (error == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_altq_running = 0;
 #else
 			pf_altq_running = 0;
@@ -2684,7 +2684,7 @@
 		struct pfioc_altq	*pa = (struct pfioc_altq *)addr;
 		struct pf_altq		*altq, *a;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pa->ticket != V_ticket_altqs_inactive) {
 #else
 		if (pa->ticket != ticket_altqs_inactive) {
@@ -2692,7 +2692,7 @@
 			error = EBUSY;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		altq = pool_get(&V_pf_altq_pl, PR_NOWAIT);
 #else
 		altq = pool_get(&pf_altq_pl, PR_WAITOK|PR_LIMITFAIL);
@@ -2702,7 +2702,7 @@
 			break;
 		}
 		bcopy(&pa->altq, altq, sizeof(struct pf_altq));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		altq->local_flags = 0;
 #endif
 
@@ -2713,7 +2713,7 @@
 		if (altq->qname[0] != 0) {
 			if ((altq->qid = pf_qname2qid(altq->qname)) == 0) {
 				error = EBUSY;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_altq_pl, altq);
 #else
 				pool_put(&pf_altq_pl, altq);
@@ -2721,7 +2721,7 @@
 				break;
 			}
 			altq->altq_disc = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			TAILQ_FOREACH(a, V_pf_altqs_inactive, entries) {
 #else
 			TAILQ_FOREACH(a, pf_altqs_inactive, entries) {
@@ -2734,7 +2734,7 @@
 			}
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		struct ifnet *ifp;
 
 		if ((ifp = ifunit(altq->ifname)) == NULL) {
@@ -2743,12 +2743,12 @@
 			PF_UNLOCK();
 #endif
 		error = altq_add(altq);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_LOCK();
 		}
 #endif
 		if (error) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_altq_pl, altq);
 #else
 			pool_put(&pf_altq_pl, altq);
@@ -2756,7 +2756,7 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_INSERT_TAIL(V_pf_altqs_inactive, altq, entries);
 #else
 		TAILQ_INSERT_TAIL(pf_altqs_inactive, altq, entries);
@@ -2770,7 +2770,7 @@
 		struct pf_altq		*altq;
 
 		pa->nr = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_FOREACH(altq, V_pf_altqs_active, entries)
 			pa->nr++;
 		pa->ticket = V_ticket_altqs_active;
@@ -2787,7 +2787,7 @@
 		struct pf_altq		*altq;
 		u_int32_t		 nr;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pa->ticket != V_ticket_altqs_active) {
 #else
 		if (pa->ticket != ticket_altqs_active) {
@@ -2796,7 +2796,7 @@
 			break;
 		}
 		nr = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		altq = TAILQ_FIRST(V_pf_altqs_active);
 #else
 		altq = TAILQ_FIRST(pf_altqs_active);
@@ -2824,7 +2824,7 @@
 		u_int32_t		 nr;
 		int			 nbytes;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pq->ticket != V_ticket_altqs_active) {
 #else
 		if (pq->ticket != ticket_altqs_active) {
@@ -2834,7 +2834,7 @@
 		}
 		nbytes = pq->nbytes;
 		nr = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		altq = TAILQ_FIRST(V_pf_altqs_active);
 #else
 		altq = TAILQ_FIRST(pf_altqs_active);
@@ -2848,7 +2848,7 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((altq->local_flags & PFALTQ_FLAG_IF_REMOVED) != 0) {
 			error = ENXIO;
 			break;
@@ -2856,7 +2856,7 @@
 		PF_UNLOCK();
 #endif
 		error = altq_getqstats(altq, pq->buf, &nbytes);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		if (error == 0) {
@@ -2870,7 +2870,7 @@
 	case DIOCBEGINADDRS: {
 		struct pfioc_pooladdr	*pp = (struct pfioc_pooladdr *)addr;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_empty_pool(&V_pf_pabuf);
 		pp->ticket = ++V_ticket_pabuf;
 #else
@@ -2883,7 +2883,7 @@
 	case DIOCADDADDR: {
 		struct pfioc_pooladdr	*pp = (struct pfioc_pooladdr *)addr;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (pp->ticket != V_ticket_pabuf) {
 #else
 		if (pp->ticket != ticket_pabuf) {
@@ -2909,7 +2909,7 @@
 			error = EINVAL;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pa = pool_get(&V_pf_pooladdr_pl, PR_NOWAIT);
 #else
 		pa = pool_get(&pf_pooladdr_pl, PR_WAITOK|PR_LIMITFAIL);
@@ -2922,7 +2922,7 @@
 		if (pa->ifname[0]) {
 			pa->kif = pfi_kif_get(pa->ifname);
 			if (pa->kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_pooladdr_pl, pa);
 #else
 				pool_put(&pf_pooladdr_pl, pa);
@@ -2935,7 +2935,7 @@
 		if (pfi_dynaddr_setup(&pa->addr, pp->af)) {
 			pfi_dynaddr_remove(&pa->addr);
 			pfi_kif_unref(pa->kif, PFI_KIF_REF_RULE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_pooladdr_pl, pa);
 #else
 			pool_put(&pf_pooladdr_pl, pa);
@@ -2943,7 +2943,7 @@
 			error = EINVAL;
 			break;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		TAILQ_INSERT_TAIL(&V_pf_pabuf, pa, entries);
 #else
 		TAILQ_INSERT_TAIL(&pf_pabuf, pa, entries);
@@ -3019,7 +3019,7 @@
 			break;
 		}
 		if (pca->action != PF_CHANGE_REMOVE) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			newpa = pool_get(&V_pf_pooladdr_pl,
 			    PR_NOWAIT);
 #else
@@ -3033,7 +3033,7 @@
 			bcopy(&pca->addr, newpa, sizeof(struct pf_pooladdr));
 #ifndef INET
 			if (pca->af == AF_INET) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_pooladdr_pl, newpa);
 #else
 				pool_put(&pf_pooladdr_pl, newpa);
@@ -3044,7 +3044,7 @@
 #endif /* INET */
 #ifndef INET6
 			if (pca->af == AF_INET6) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_pooladdr_pl, newpa);
 #else
 				pool_put(&pf_pooladdr_pl, newpa);
@@ -3056,7 +3056,7 @@
 			if (newpa->ifname[0]) {
 				newpa->kif = pfi_kif_get(newpa->ifname);
 				if (newpa->kif == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					pool_put(&V_pf_pooladdr_pl, newpa);
 #else
 					pool_put(&pf_pooladdr_pl, newpa);
@@ -3071,7 +3071,7 @@
 			    pf_tbladdr_setup(ruleset, &newpa->addr)) {
 				pfi_dynaddr_remove(&newpa->addr);
 				pfi_kif_unref(newpa->kif, PFI_KIF_REF_RULE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_pooladdr_pl, newpa);
 #else
 				pool_put(&pf_pooladdr_pl, newpa);
@@ -3104,7 +3104,7 @@
 			pfi_dynaddr_remove(&oldpa->addr);
 			pf_tbladdr_remove(&oldpa->addr);
 			pfi_kif_unref(oldpa->kif, PFI_KIF_REF_RULE);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_pooladdr_pl, oldpa);
 #else
 			pool_put(&pf_pooladdr_pl, oldpa);
@@ -3139,7 +3139,7 @@
 		pr->nr = 0;
 		if (ruleset->anchor == NULL) {
 			/* XXX kludge for pf_main_ruleset */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			RB_FOREACH(anchor, pf_anchor_global, &V_pf_anchors)
 #else
 			RB_FOREACH(anchor, pf_anchor_global, &pf_anchors)
@@ -3168,7 +3168,7 @@
 		pr->name[0] = 0;
 		if (ruleset->anchor == NULL) {
 			/* XXX kludge for pf_main_ruleset */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			RB_FOREACH(anchor, pf_anchor_global, &V_pf_anchors)
 #else
 			RB_FOREACH(anchor, pf_anchor_global, &pf_anchors)
@@ -3414,16 +3414,16 @@
 			error = ENODEV;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		ioe = malloc(sizeof(*ioe), M_TEMP, M_WAITOK);
 		table = malloc(sizeof(*table), M_TEMP, M_WAITOK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		for (i = 0; i < io->size; i++) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_COPYIN(io->array+i, ioe, sizeof(*ioe), error);
 		if (error) {
 #else
@@ -3470,7 +3470,7 @@
 				}
 				break;
 			}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYOUT(ioe, io->array+i, sizeof(io->array[i]),
 			    error);
 			if (error) {
@@ -3498,16 +3498,16 @@
 			error = ENODEV;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		ioe = malloc(sizeof(*ioe), M_TEMP, M_WAITOK);
 		table = malloc(sizeof(*table), M_TEMP, M_WAITOK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		for (i = 0; i < io->size; i++) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYIN(io->array+i, ioe, sizeof(*ioe), error);
 			if (error) {
 #else
@@ -3571,17 +3571,17 @@
 			error = ENODEV;
 			goto fail;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		ioe = malloc(sizeof(*ioe), M_TEMP, M_WAITOK);
 		table = malloc(sizeof(*table), M_TEMP, M_WAITOK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		/* first makes sure everything will succeed */
 		for (i = 0; i < io->size; i++) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYIN(io->array+i, ioe, sizeof(*ioe), error);
 			if (error) {
 #else
@@ -3601,7 +3601,7 @@
 					error = EINVAL;
 					goto fail;
 				}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				if (!V_altqs_inactive_open || ioe->ticket !=
 				    V_ticket_altqs_inactive) {
 #else
@@ -3648,7 +3648,7 @@
 		}
 		/* now do the commit - no errors should happen here */
 		for (i = 0; i < io->size; i++) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYIN(io->array+i, ioe, sizeof(*ioe), error);
 			if (error) {
 #else
@@ -3702,7 +3702,7 @@
 		int			 space = psn->psn_len;
 
 		if (space == 0) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			RB_FOREACH(n, pf_src_tree, &V_tree_src_tracking)
 #else
 			RB_FOREACH(n, pf_src_tree, &tree_src_tracking)
@@ -3712,15 +3712,15 @@
 			break;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_UNLOCK();
 #endif
 		pstore = malloc(sizeof(*pstore), M_TEMP, M_WAITOK);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK();
 #endif
 		p = psn->psn_src_nodes;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_FOREACH(n, pf_src_tree, &V_tree_src_tracking) {
 #else
 		RB_FOREACH(n, pf_src_tree, &tree_src_tracking) {
@@ -3748,7 +3748,7 @@
 				    n->conn_rate.count * diff /
 				    n->conn_rate.seconds;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			PF_COPYOUT(pstore, p, sizeof(*p), error);
 #else
 			error = copyout(pstore, p, sizeof(*p));
@@ -3770,7 +3770,7 @@
 		struct pf_src_node	*n;
 		struct pf_state		*state;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_FOREACH(state, pf_state_tree_id, &V_tree_id) {
 #else
 		RB_FOREACH(state, pf_state_tree_id, &tree_id) {
@@ -3778,7 +3778,7 @@
 			state->src_node = NULL;
 			state->nat_src_node = NULL;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_FOREACH(n, pf_src_tree, &V_tree_src_tracking) {
 #else
 		RB_FOREACH(n, pf_src_tree, &tree_src_tracking) {
@@ -3787,7 +3787,7 @@
 			n->states = 0;
 		}
 		pf_purge_expired_src_nodes(1);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.src_nodes = 0;
 #else
 		pf_status.src_nodes = 0;
@@ -3802,7 +3802,7 @@
 		    (struct pfioc_src_node_kill *)addr;
 		u_int			killed = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_FOREACH(sn, pf_src_tree, &V_tree_src_tracking) {
 #else
 		RB_FOREACH(sn, pf_src_tree, &tree_src_tracking) {
@@ -3818,7 +3818,7 @@
 				/* Handle state to src_node linkage */
 				if (sn->states != 0) {
 					RB_FOREACH(s, pf_state_tree_id,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					    &V_tree_id) {
 #else
 					    &tree_id) {
@@ -3845,7 +3845,7 @@
 	case DIOCSETHOSTID: {
 		u_int32_t	*hostid = (u_int32_t *)addr;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (*hostid == 0)
 			V_pf_status.hostid = arc4random();
 		else
@@ -3894,7 +3894,7 @@
 		break;
 	}
 fail:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_UNLOCK();
 
 	if (flags & FWRITE)
@@ -3914,7 +3914,7 @@
 	return (error);
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 void
 pfsync_state_export(struct pfsync_state *sp, struct pf_state *st)
 {
@@ -3984,7 +3984,7 @@
 {
 	struct pf_state	*state;
  
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_FOREACH(state, pf_state_tree_id, &V_tree_id) {
 #else
 	RB_FOREACH(state, pf_state_tree_id, &tree_id) {
@@ -4025,7 +4025,7 @@
 	struct pf_src_node	*n;
 	struct pf_state		*state;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_FOREACH(state, pf_state_tree_id, &V_tree_id) {
 #else
 	RB_FOREACH(state, pf_state_tree_id, &tree_id) {
@@ -4033,7 +4033,7 @@
 		state->src_node = NULL;
 		state->nat_src_node = NULL;
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	RB_FOREACH(n, pf_src_tree, &V_tree_src_tracking) {
 #else
 	RB_FOREACH(n, pf_src_tree, &tree_src_tracking) {
--- a/sys/contrib/pf/net/pf_lb.c
+++ b/sys/contrib/pf/net/pf_lb.c
@@ -35,7 +35,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 
@@ -43,7 +43,7 @@
 __FBSDID("$FreeBSD$");
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_bpf.h"
 #include "opt_pf.h"
 
@@ -86,14 +86,14 @@
 #include <sys/socketvar.h>
 #include <sys/kernel.h>
 #include <sys/time.h>
-#ifdef  __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/sysctl.h>
 #endif
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/pool.h>
 #endif
 #include <sys/proc.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/kthread.h>
 #include <sys/lock.h>
 #include <sys/sx.h>
@@ -101,7 +101,7 @@
 #include <sys/rwlock.h>
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/md5.h>
 #else
 #include <crypto/md5.h>
@@ -129,7 +129,7 @@
 #include <netinet/icmp_var.h>
 #include <netinet/if_ether.h>
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <dev/rndvar.h>
 #endif
 #include <net/pfvar.h>
@@ -148,7 +148,7 @@
 #endif /* INET6 */
 
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define DPFPRINTF(n, x)	if (V_pf_status.debug >= (n)) printf x
 #else
 #define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
@@ -278,7 +278,7 @@
 		    !pf_match_port(dst->port_op, dst->port[0],
 		    dst->port[1], dport))
 			r = r->skip[PF_SKIP_DST_PORT].ptr;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (r->match_tag && !pf_match_tag(m, r, &tag, pd->pf_mtag))
 #else
 		else if (r->match_tag && !pf_match_tag(m, r, &tag))
@@ -303,7 +303,7 @@
 			pf_step_out_of_anchor(&asd, &ruleset, rs_num, &r,
 			    NULL, NULL);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (pf_tag_packet(m, tag, rtableid, pd->pf_mtag))
 #else
 	if (pf_tag_packet(m, tag, rtableid))
@@ -369,7 +369,7 @@
 				high = tmp;
 			}
 			/* low < high */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			cut = htonl(arc4random()) % (1 + high - low) + low;
 #else
 			cut = arc4random_uniform(1 + high - low) + low;
@@ -378,7 +378,7 @@
 			for (tmp = cut; tmp <= high; ++(tmp)) {
 				key.port[0] = htons(tmp);
 				if (pf_find_state_all(&key, PF_IN, NULL) ==
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    NULL) {
 #else
 				    NULL && !in_baddynamic(tmp, proto)) {
@@ -390,7 +390,7 @@
 			for (tmp = cut - 1; tmp >= low; --(tmp)) {
 				key.port[0] = htons(tmp);
 				if (pf_find_state_all(&key, PF_IN, NULL) ==
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				    NULL) {
 #else
 				    NULL && !in_baddynamic(tmp, proto)) {
@@ -437,7 +437,7 @@
 			k.rule.ptr = r;
 		else
 			k.rule.ptr = NULL;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
 		*sn = RB_FIND(pf_src_tree, &V_tree_src_tracking, &k);
 #else
@@ -446,7 +446,7 @@
 #endif
 		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
 			PF_ACPY(naddr, &(*sn)->raddr, af);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -597,7 +597,7 @@
 	if (*sn != NULL)
 		PF_ACPY(&(*sn)->raddr, naddr, af);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (V_pf_status.debug >= PF_DEBUG_MISC &&
 #else
 	if (pf_status.debug >= PF_DEBUG_MISC &&
@@ -775,7 +775,7 @@
 		 * Pretend there was no match.
 		 */
 		if (!bcmp(*skp, *nkp, sizeof(struct pf_state_key_cmp))) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_state_key_pl, *nkp);
 			pool_put(&V_pf_state_key_pl, *skp);
 #else
--- a/sys/contrib/pf/net/pf_norm.c
+++ b/sys/contrib/pf/net/pf_norm.c
@@ -25,7 +25,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 #include "opt_pf.h"
@@ -50,7 +50,7 @@
 #include <sys/socket.h>
 #include <sys/kernel.h>
 #include <sys/time.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/pool.h>
 
 #include <dev/rndvar.h>
@@ -77,7 +77,7 @@
 
 #include <net/pfvar.h>
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 struct pf_frent {
 	LIST_ENTRY(pf_frent) fr_next;
 	struct ip *fr_ip;
@@ -96,7 +96,7 @@
 #define PFFRAG_DROP	0x0004		/* Drop all fragments */
 #define BUFFER_FRAGMENTS(fr)	(!((fr)->fr_flags & PFFRAG_NOBUFFER))
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 struct pf_fragment {
 	RB_ENTRY(pf_fragment) fr_entry;
 	TAILQ_ENTRY(pf_fragment) frag_next;
@@ -116,7 +116,7 @@
 };
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 TAILQ_HEAD(pf_fragqueue, pf_fragment);
 TAILQ_HEAD(pf_cachequeue, pf_fragment);
 VNET_DEFINE(struct pf_fragqueue,	pf_fragqueue);
@@ -128,7 +128,7 @@
 TAILQ_HEAD(pf_cachequeue, pf_fragment)	pf_cachequeue;
 #endif
 
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 static __inline int	 pf_frag_compare(struct pf_fragment *,
 			    struct pf_fragment *);
 #else
@@ -136,7 +136,7 @@
 			    struct pf_fragment *);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 RB_HEAD(pf_frag_tree, pf_fragment);
 VNET_DEFINE(struct pf_frag_tree,	pf_frag_tree);
 #define	V_pf_frag_tree			VNET(pf_frag_tree)
@@ -165,7 +165,7 @@
 #ifdef INET6
 void			 pf_scrub_ip6(struct mbuf **, u_int8_t);
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	DPFPRINTF(x) do {				\
 	if (V_pf_status.debug >= PF_DEBUG_MISC) {	\
 		printf("%s: ", __func__);		\
@@ -182,7 +182,7 @@
 #endif
 
 /* Globals */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(uma_zone_t,		pf_frent_pl);
 VNET_DEFINE(uma_zone_t,		pf_frag_pl);
 VNET_DEFINE(uma_zone_t,		pf_cache_pl);
@@ -202,7 +202,7 @@
 void
 pf_normalize_init(void)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	/*
 	 * XXX
 	 * No high water mark support(It's hint not hard limit).
@@ -229,7 +229,7 @@
 	pool_sethardlimit(&pf_cent_pl, PFFRAG_FRCENT_HIWAT, NULL, 0);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	TAILQ_INIT(&V_pf_fragqueue);
 	TAILQ_INIT(&V_pf_cachequeue);
 #else
@@ -238,7 +238,7 @@
 #endif
 }
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static int
 #else
 static __inline int
@@ -266,7 +266,7 @@
 pf_purge_expired_fragments(void)
 {
 	struct pf_fragment	*frag;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_int32_t		 expire = time_second -
 				    V_pf_default_rule.timeout[PFTM_FRAG];
 #else
@@ -274,7 +274,7 @@
 				    pf_default_rule.timeout[PFTM_FRAG];
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while ((frag = TAILQ_LAST(&V_pf_fragqueue, pf_fragqueue)) != NULL) {
 		KASSERT((BUFFER_FRAGMENTS(frag)),
 		    ("BUFFER_FRAGMENTS(frag) == 0: %s", __FUNCTION__));
@@ -289,7 +289,7 @@
 		pf_free_fragment(frag);
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while ((frag = TAILQ_LAST(&V_pf_cachequeue, pf_cachequeue)) != NULL) {
 		KASSERT((!BUFFER_FRAGMENTS(frag)),
 		    ("BUFFER_FRAGMENTS(frag) != 0: %s", __FUNCTION__));
@@ -302,7 +302,7 @@
 
 		DPFPRINTF(("expiring %d(%p)\n", frag->fr_id, frag));
 		pf_free_fragment(frag);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		KASSERT((TAILQ_EMPTY(&V_pf_cachequeue) ||
 		    TAILQ_LAST(&V_pf_cachequeue, pf_cachequeue) != frag),
 		    ("!(TAILQ_EMPTY() || TAILQ_LAST() == farg): %s",
@@ -324,7 +324,7 @@
 	struct pf_fragment	*frag;
 	int			 goal;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	goal = V_pf_nfrents * 9 / 10;
 	DPFPRINTF(("trying to free > %d frents\n",
 	    V_pf_nfrents - goal));
@@ -335,7 +335,7 @@
 	    pf_nfrents - goal));
 	while (goal < pf_nfrents) {
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		frag = TAILQ_LAST(&V_pf_fragqueue, pf_fragqueue);
 #else
 		frag = TAILQ_LAST(&pf_fragqueue, pf_fragqueue);
@@ -346,7 +346,7 @@
 	}
 
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	goal = V_pf_ncache * 9 / 10;
 	DPFPRINTF(("trying to free > %d cache entries\n",
 	    V_pf_ncache - goal));
@@ -357,7 +357,7 @@
 	    pf_ncache - goal));
 	while (goal < pf_ncache) {
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		frag = TAILQ_LAST(&V_pf_cachequeue, pf_cachequeue);
 #else
 		frag = TAILQ_LAST(&pf_cachequeue, pf_cachequeue);
@@ -383,7 +383,7 @@
 			LIST_REMOVE(frent, fr_next);
 
 			m_freem(frent->fr_m);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pf_frent_pl, frent);
 			V_pf_nfrents--;
 #else
@@ -396,7 +396,7 @@
 		    frcache = LIST_FIRST(&frag->fr_cache)) {
 			LIST_REMOVE(frcache, fr_next);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			KASSERT((LIST_EMPTY(&frag->fr_cache) ||
 			    LIST_FIRST(&frag->fr_cache)->fr_off >
 			    frcache->fr_end),
@@ -441,7 +441,7 @@
 		/* XXX Are we sure we want to update the timeout? */
 		frag->fr_timeout = time_second;
 		if (BUFFER_FRAGMENTS(frag)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			TAILQ_REMOVE(&V_pf_fragqueue, frag, frag_next);
 			TAILQ_INSERT_HEAD(&V_pf_fragqueue, frag, frag_next);
 #else
@@ -449,7 +449,7 @@
 			TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);
 #endif
 		} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			TAILQ_REMOVE(&V_pf_cachequeue, frag, frag_next);
 			TAILQ_INSERT_HEAD(&V_pf_cachequeue, frag, frag_next);
 #else
@@ -468,7 +468,7 @@
 pf_remove_fragment(struct pf_fragment *frag)
 {
 	if (BUFFER_FRAGMENTS(frag)) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_frag_tree, &V_pf_frag_tree, frag);
 		TAILQ_REMOVE(&V_pf_fragqueue, frag, frag_next);
 		pool_put(&V_pf_frag_pl, frag);
@@ -478,7 +478,7 @@
 		pool_put(&pf_frag_pl, frag);
 #endif
 	} else {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_frag_tree, &V_pf_cache_tree, frag);
 		TAILQ_REMOVE(&V_pf_cachequeue, frag, frag_next);
 		pool_put(&V_pf_cache_pl, frag);
@@ -504,7 +504,7 @@
 	u_int16_t	 ip_len = ntohs(ip->ip_len) - ip->ip_hl * 4;
 	u_int16_t	 max = ip_len + off;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((*frag == NULL || BUFFER_FRAGMENTS(*frag)),
 	    ("! (*frag == NULL || BUFFER_FRAGMENTS(*frag)): %s", __FUNCTION__));
 #else
@@ -517,14 +517,14 @@
 
 	/* Create a new reassembly queue for this packet */
 	if (*frag == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		*frag = pool_get(&V_pf_frag_pl, PR_NOWAIT);
 #else
 		*frag = pool_get(&pf_frag_pl, PR_NOWAIT);
 #endif
 		if (*frag == NULL) {
 			pf_flush_fragments();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			*frag = pool_get(&V_pf_frag_pl, PR_NOWAIT);
 #else
 			*frag = pool_get(&pf_frag_pl, PR_NOWAIT);
@@ -542,7 +542,7 @@
 		(*frag)->fr_timeout = time_second;
 		LIST_INIT(&(*frag)->fr_queue);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_INSERT(pf_frag_tree, &V_pf_frag_tree, *frag);
 		TAILQ_INSERT_HEAD(&V_pf_fragqueue, *frag, frag_next);
 #else
@@ -565,7 +565,7 @@
 		frep = frea;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((frep != NULL || frea != NULL),
 	    ("!(frep != NULL || frea != NULL): %s", __FUNCTION__));;
 #else
@@ -613,7 +613,7 @@
 		next = LIST_NEXT(frea, fr_next);
 		m_freem(frea->fr_m);
 		LIST_REMOVE(frea, fr_next);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_frent_pl, frea);
 		V_pf_nfrents--;
 #else
@@ -660,7 +660,7 @@
 
 	/* We have all the data */
 	frent = LIST_FIRST(&(*frag)->fr_queue);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((frent != NULL), ("frent == NULL: %s", __FUNCTION__));
 #else
 	KASSERT(frent != NULL);
@@ -679,7 +679,7 @@
 	m2 = m->m_next;
 	m->m_next = NULL;
 	m_cat(m, m2);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pf_frent_pl, frent);
 	V_pf_nfrents--;
 #else
@@ -690,21 +690,21 @@
 		next = LIST_NEXT(frent, fr_next);
 
 		m2 = frent->fr_m;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pf_frent_pl, frent);
 		V_pf_nfrents--;
 #else
 		pool_put(&pf_frent_pl, frent);
 		pf_nfrents--;
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m->m_pkthdr.csum_flags &= m2->m_pkthdr.csum_flags;
 		m->m_pkthdr.csum_data += m2->m_pkthdr.csum_data;
 #endif
 		m_cat(m, m2);
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while (m->m_pkthdr.csum_data & 0xffff0000)
 		m->m_pkthdr.csum_data = (m->m_pkthdr.csum_data & 0xffff) +
 		    (m->m_pkthdr.csum_data >> 16);
@@ -735,7 +735,7 @@
 
  drop_fragment:
 	/* Oops - fail safe - drop packet */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pf_frent_pl, frent);
 	V_pf_nfrents--;
 #else
@@ -757,7 +757,7 @@
 	u_int16_t		 max = ip_len + off;
 	int			 hosed = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((*frag == NULL || !BUFFER_FRAGMENTS(*frag)),
 	    ("!(*frag == NULL || !BUFFER_FRAGMENTS(*frag)): %s", __FUNCTION__));
 #else
@@ -766,14 +766,14 @@
 
 	/* Create a new range queue for this packet */
 	if (*frag == NULL) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		*frag = pool_get(&V_pf_cache_pl, PR_NOWAIT);
 #else
 		*frag = pool_get(&pf_cache_pl, PR_NOWAIT);
 #endif
 		if (*frag == NULL) {
 			pf_flush_fragments();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			*frag = pool_get(&V_pf_cache_pl, PR_NOWAIT);
 #else
 			*frag = pool_get(&pf_cache_pl, PR_NOWAIT);
@@ -783,7 +783,7 @@
 		}
 
 		/* Get an entry for the queue */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		cur = pool_get(&V_pf_cent_pl, PR_NOWAIT);
 		if (cur == NULL) {
 			pool_put(&V_pf_cache_pl, *frag);
@@ -795,7 +795,7 @@
 			*frag = NULL;
 			goto no_mem;
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_ncache++;
 #else
 		pf_ncache++;
@@ -814,7 +814,7 @@
 		LIST_INIT(&(*frag)->fr_cache);
 		LIST_INSERT_HEAD(&(*frag)->fr_cache, cur, fr_next);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_INSERT(pf_frag_tree, &V_pf_cache_tree, *frag);
 		TAILQ_INSERT_HEAD(&V_pf_cachequeue, *frag, frag_next);
 #else
@@ -838,7 +838,7 @@
 		frp = fra;
 	}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((frp != NULL || fra != NULL),
 	    ("!(frp != NULL || fra != NULL): %s", __FUNCTION__));
 #else
@@ -885,14 +885,14 @@
 				 * than this mbuf magic.  For my next trick,
 				 * I'll pull a rabbit out of my laptop.
 				 */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				*m0 = m_dup(m, M_DONTWAIT);
 #else
 				*m0 = m_copym2(m, 0, h->ip_hl << 2, M_NOWAIT);
 #endif
 				if (*m0 == NULL)
 					goto no_mem;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				/* From KAME Project : We have missed this! */
 				m_adj(*m0, (h->ip_hl << 2) -
 				    (*m0)->m_pkthdr.len);
@@ -917,7 +917,7 @@
 
 				h = mtod(m, struct ip *);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				KASSERT(((int)m->m_len ==
 				    ntohs(h->ip_len) - precut),
 				    ("m->m_len != ntohs(h->ip_len) - precut: %s",
@@ -939,14 +939,14 @@
 			    h->ip_id, -precut, frp->fr_off, frp->fr_end, off,
 			    max));
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			cur = pool_get(&V_pf_cent_pl, PR_NOWAIT);
 #else
 			cur = pool_get(&pf_cent_pl, PR_NOWAIT);
 #endif
 			if (cur == NULL)
 				goto no_mem;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_ncache++;
 #else
 			pf_ncache++;
@@ -989,7 +989,7 @@
 					m->m_pkthdr.len = plen;
 				}
 				h = mtod(m, struct ip *);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				KASSERT(((int)m->m_len == ntohs(h->ip_len) - aftercut),
 				    ("m->m_len != ntohs(h->ip_len) - aftercut: %s",
 				    __FUNCTION__));
@@ -1007,14 +1007,14 @@
 			    h->ip_id, -aftercut, off, max, fra->fr_off,
 			    fra->fr_end));
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			cur = pool_get(&V_pf_cent_pl, PR_NOWAIT);
 #else
 			cur = pool_get(&pf_cent_pl, PR_NOWAIT);
 #endif
 			if (cur == NULL)
 				goto no_mem;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			V_pf_ncache++;
 #else
 			pf_ncache++;
@@ -1036,7 +1036,7 @@
 				    max, fra->fr_off, fra->fr_end));
 				fra->fr_off = cur->fr_off;
 				LIST_REMOVE(cur, fr_next);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_cent_pl, cur);
 				V_pf_ncache--;
 #else
@@ -1047,7 +1047,7 @@
 
 			} else if (frp && fra->fr_off <= frp->fr_end) {
 				/* Need to merge in a modified 'frp' */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				KASSERT((cur == NULL), ("cur != NULL: %s",
 				    __FUNCTION__));
 #else
@@ -1059,7 +1059,7 @@
 				    max, fra->fr_off, fra->fr_end));
 				fra->fr_off = frp->fr_off;
 				LIST_REMOVE(frp, fr_next);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				pool_put(&V_pf_cent_pl, frp);
 				V_pf_ncache--;
 #else
@@ -1169,7 +1169,7 @@
 		    (struct pf_addr *)&h->ip_dst.s_addr, AF_INET,
 		    r->dst.neg, NULL))
 			r = r->skip[PF_SKIP_DST_ADDR].ptr;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		else if (r->match_tag && !pf_match_tag(m, r, &tag, pd->pf_mtag))
 #else
 		else if (r->match_tag && !pf_match_tag(m, r, &tag))
@@ -1233,7 +1233,7 @@
 	if ((r->rule_flag & (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0) {
 		/* Fully buffer all of the fragments */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		frag = pf_find_fragment(h, &V_pf_frag_tree);
 #else
 		frag = pf_find_fragment(h, &pf_frag_tree);
@@ -1245,7 +1245,7 @@
 			goto bad;
 
 		/* Get an entry for the fragment queue */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		frent = pool_get(&V_pf_frent_pl, PR_NOWAIT);
 #else
 		frent = pool_get(&pf_frent_pl, PR_NOWAIT);
@@ -1254,7 +1254,7 @@
 			REASON_SET(reason, PFRES_MEMORY);
 			return (PF_DROP);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pf_nfrents++;
 #else
 		pf_nfrents++;
@@ -1289,7 +1289,7 @@
 		/* non-buffering fragment cache (drops or masks overlaps) */
 		int	nomem = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (dir == PF_OUT && pd->pf_mtag->flags & PF_TAG_FRAGCACHE) {
 #else
 		if (dir == PF_OUT && m->m_pkthdr.pf.flags & PF_TAG_FRAGCACHE) {
@@ -1302,7 +1302,7 @@
 			goto fragment_pass;
 		}
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		frag = pf_find_fragment(h, &V_pf_cache_tree);
 #else
 		frag = pf_find_fragment(h, &pf_cache_tree);
@@ -1337,7 +1337,7 @@
 		}
 #endif
 		if (dir == PF_IN)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pd->pf_mtag->flags |= PF_TAG_FRAGCACHE;
 #else
 			m->m_pkthdr.pf.flags |= PF_TAG_FRAGCACHE;
@@ -1674,7 +1674,7 @@
 
 	/* copy back packet headers if we sanitized */
 	if (rewrite)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		m_copyback(m, off, sizeof(*th), (caddr_t)th);
 #else
 		m_copyback(m, off, sizeof(*th), th);
@@ -1697,7 +1697,7 @@
 	u_int8_t hdr[60];
 	u_int8_t *opt;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((src->scrub == NULL), 
 	    ("pf_normalize_tcp_init: src->scrub != NULL"));
 
@@ -1782,7 +1782,7 @@
 void
 pf_normalize_tcp_cleanup(struct pf_state *state)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (state->src.scrub)
 		pool_put(&V_pf_state_scrub_pl, state->src.scrub);
 	if (state->dst.scrub)
@@ -1810,7 +1810,7 @@
 	int copyback = 0;
 	int got_ts = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	KASSERT((src->scrub || dst->scrub), 
 	    ("pf_normalize_tcp_statefull: src->scrub && dst->scrub!"));
 #else
@@ -1870,7 +1870,7 @@
 
 				if (got_ts) {
 					/* Huh?  Multiple timestamps!? */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 					if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 					if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1943,7 +1943,7 @@
 	if (src->scrub && (src->scrub->pfss_flags & PFSS_PAWS) &&
 	    (uptime.tv_sec - src->scrub->pfss_last.tv_sec > TS_MAX_IDLE ||
 	    time_second - state->creation > TS_MAX_CONN))  {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -1957,7 +1957,7 @@
 	}
 	if (dst->scrub && (dst->scrub->pfss_flags & PFSS_PAWS) &&
 	    uptime.tv_sec - dst->scrub->pfss_last.tv_sec > TS_MAX_IDLE) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 		if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -2045,7 +2045,7 @@
 		 * this packet.
 		 */
 		if ((ts_fudge = state->rule.ptr->timeout[PFTM_TS_DIFF]) == 0)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			ts_fudge = V_pf_default_rule.timeout[PFTM_TS_DIFF];
 #else
 			ts_fudge = pf_default_rule.timeout[PFTM_TS_DIFF];
@@ -2055,7 +2055,7 @@
 		/* Calculate max ticks since the last timestamp */
 #define TS_MAXFREQ	1100		/* RFC max TS freq of 1Khz + 10% skew */
 #define TS_MICROSECS	1000000		/* microseconds per second */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifndef timersub
 #define	timersub(tvp, uvp, vvp)						\
 	do {								\
@@ -2092,7 +2092,7 @@
 			    tsval_from_last) ? '1' : ' ',
 			    SEQ_GT(tsecr, dst->scrub->pfss_tsval) ? '2' : ' ',
 			    SEQ_LT(tsecr, dst->scrub->pfss_tsval0)? '3' : ' '));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			DPFPRINTF((" tsval: %u  tsecr: %u  +ticks: %u  "
 			    "idle: %jus %lums\n",
 			    tsval, tsecr, tsval_from_last,
@@ -2114,7 +2114,7 @@
 			    "\n", dst->scrub->pfss_tsval,
 			    dst->scrub->pfss_tsecr, dst->scrub->pfss_tsval0));
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -2166,7 +2166,7 @@
 			 * Hey!  Someone tried to sneak a packet in.  Or the
 			 * stack changed its RFC1323 behavior?!?!
 			 */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC) {
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC) {
@@ -2197,7 +2197,7 @@
 			src->scrub->pfss_flags |= PFSS_DATA_TS;
 		else {
 			src->scrub->pfss_flags |= PFSS_DATA_NOTS;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			if (V_pf_status.debug >= PF_DEBUG_MISC && dst->scrub &&
 #else
 			if (pf_status.debug >= PF_DEBUG_MISC && dst->scrub &&
@@ -2255,7 +2255,7 @@
 	int		 thoff;
 	int		 opt, cnt, optlen = 0;
 	int		 rewrite = 0;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	u_char		 opts[TCP_MAXOLEN];
 #else
 	u_char		 opts[MAX_TCPOPTLEN];
--- a/sys/contrib/pf/net/pf_osfp.c
+++ b/sys/contrib/pf/net/pf_osfp.c
@@ -17,7 +17,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 #endif
@@ -26,7 +26,7 @@
 #include <sys/socket.h>
 #ifdef _KERNEL
 #include <sys/systm.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <sys/pool.h>
 #endif
 #endif /* _KERNEL */
@@ -47,7 +47,7 @@
 
 
 #ifdef _KERNEL
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	DPFPRINTF(format, x...)		\
 	if (V_pf_status.debug >= PF_DEBUG_NOISY)	\
 		printf(format , ##x)
@@ -56,7 +56,7 @@
 	if (pf_status.debug >= PF_DEBUG_NOISY)	\
 		printf(format , ##x)
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 typedef uma_zone_t pool_t;
 #else
 typedef struct pool pool_t;
@@ -76,7 +76,7 @@
 #define	pool_put(pool, item)	free(item)
 #define	pool_init(pool, size, a, ao, f, m, p)	(*(pool)) = (size)
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define	NTOHS(x) (x) = ntohs((u_int16_t)(x))
 #endif
 
@@ -89,7 +89,7 @@
 #endif /* _KERNEL */
 
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 SLIST_HEAD(pf_osfp_list, pf_os_fingerprint);
 VNET_DEFINE(struct pf_osfp_list,	pf_osfp_list);
 #define	V_pf_osfp_list			VNET(pf_osfp_list)
@@ -284,7 +284,7 @@
 	    (fp.fp_flags & PF_OSFP_WSCALE_DC) ? "*" : "",
 	    fp.fp_wscale);
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((fpresult = pf_osfp_find(&V_pf_osfp_list, &fp,
 #else
 	if ((fpresult = pf_osfp_find(&pf_osfp_list, &fp,
@@ -325,14 +325,14 @@
 }
 
 /* Initialize the OS fingerprint system */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 int
 #else
 void
 #endif
 pf_osfp_initialize(void)
 {
-#if defined(__FreeBSD__) && defined(_KERNEL)
+#if defined(__FreeBSD_kernel__) && defined(_KERNEL)
 	int error = ENOMEM;
 
 	do {
@@ -351,7 +351,7 @@
 	SLIST_INIT(&pf_osfp_list);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #ifdef _KERNEL
 	return (error);
 #else
@@ -360,7 +360,7 @@
 #endif
 }
 
-#if defined(__FreeBSD__) && (_KERNEL)
+#if defined(__FreeBSD_kernel__) && (_KERNEL)
 void
 pf_osfp_cleanup(void)
 {
@@ -377,7 +377,7 @@
 	struct pf_os_fingerprint *fp;
 	struct pf_osfp_entry *entry;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	while ((fp = SLIST_FIRST(&V_pf_osfp_list))) {
 		SLIST_REMOVE_HEAD(&V_pf_osfp_list, fp_next);
 #else
@@ -436,7 +436,7 @@
 	    fpioc->fp_os.fp_os);
 #endif
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if ((fp = pf_osfp_find_exact(&V_pf_osfp_list, &fpadd))) {
 #else
 	if ((fp = pf_osfp_find_exact(&pf_osfp_list, &fpadd))) {
@@ -446,7 +446,7 @@
 				return (EEXIST);
 		}
 		if ((entry = pool_get(&pf_osfp_entry_pl,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    PR_NOWAIT)) == NULL)
 #else
 		    PR_WAITOK|PR_LIMITFAIL)) == NULL)
@@ -454,7 +454,7 @@
 			return (ENOMEM);
 	} else {
 		if ((fp = pool_get(&pf_osfp_pl,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    PR_NOWAIT)) == NULL)
 #else
 		    PR_WAITOK|PR_LIMITFAIL)) == NULL)
@@ -471,7 +471,7 @@
 		fp->fp_ttl = fpioc->fp_ttl;
 		SLIST_INIT(&fp->fp_oses);
 		if ((entry = pool_get(&pf_osfp_entry_pl,
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		    PR_NOWAIT)) == NULL) {
 #else
 		    PR_WAITOK|PR_LIMITFAIL)) == NULL) {
@@ -479,7 +479,7 @@
 			pool_put(&pf_osfp_pl, fp);
 			return (ENOMEM);
 		}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pf_osfp_insert(&V_pf_osfp_list, fp);
 #else
 		pf_osfp_insert(&pf_osfp_list, fp);
@@ -625,7 +625,7 @@
 
 
 	memset(fpioc, 0, sizeof(*fpioc));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	SLIST_FOREACH(fp, &V_pf_osfp_list, fp_next) {
 #else
 	SLIST_FOREACH(fp, &pf_osfp_list, fp_next) {
@@ -656,7 +656,7 @@
 {
 	struct pf_os_fingerprint *f, *f2, find;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	SLIST_FOREACH(f, &V_pf_osfp_list, fp_next) {
 #else
 	SLIST_FOREACH(f, &pf_osfp_list, fp_next) {
@@ -672,7 +672,7 @@
 			find.fp_wsize *= (find.fp_mss + 40);
 		else if (f->fp_flags & PF_OSFP_WSIZE_MOD)
 			find.fp_wsize *= 2;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (f != (f2 = pf_osfp_find(&V_pf_osfp_list, &find, 0))) {
 #else
 		if (f != (f2 = pf_osfp_find(&pf_osfp_list, &find, 0))) {
--- a/sys/contrib/pf/net/pf_ruleset.c
+++ b/sys/contrib/pf/net/pf_ruleset.c
@@ -35,7 +35,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 #endif
@@ -61,7 +61,7 @@
 
 
 #ifdef _KERNEL
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define DPFPRINTF(format, x...)				\
 	if (V_pf_status.debug >= PF_DEBUG_NOISY)	\
 		printf(format , ##x)
@@ -70,7 +70,7 @@
 	if (pf_status.debug >= PF_DEBUG_NOISY)		\
 		printf(format , ##x)
 #endif
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #define rs_malloc(x)		malloc(x, M_TEMP, M_NOWAIT|M_ZERO)
 #else
 #define rs_malloc(x)		malloc(x, M_TEMP, M_WAITOK|M_CANFAIL|M_ZERO)
@@ -96,7 +96,7 @@
 #endif /* PFDEBUG */
 #endif /* _KERNEL */
 
-#if defined(__FreeBSD__) && !defined(_KERNEL)
+#if defined(__FreeBSD_kernel__) && !defined(_KERNEL)
 #undef V_pf_anchors
 #define V_pf_anchors		 pf_anchors
 
@@ -104,7 +104,7 @@
 #define pf_main_ruleset		 pf_main_anchor.ruleset
 #endif
 
-#if defined(__FreeBSD__) && defined(_KERNEL)
+#if defined(__FreeBSD_kernel__) && defined(_KERNEL)
 VNET_DEFINE(struct pf_anchor_global,	pf_anchors);
 VNET_DEFINE(struct pf_anchor,		pf_main_anchor);
 #else
@@ -178,7 +178,7 @@
 	if (key == NULL)
 		return (NULL);
 	strlcpy(key->path, path, sizeof(key->path));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	found = RB_FIND(pf_anchor_global, &V_pf_anchors, key);
 #else
 	found = RB_FIND(pf_anchor_global, &pf_anchors, key);
@@ -208,7 +208,7 @@
 {
 	char			*p, *q, *r;
 	struct pf_ruleset	*ruleset;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pf_anchor	*anchor = NULL, *dup, *parent = NULL;
 #else
 	struct pf_anchor	*anchor, *dup, *parent = NULL;
@@ -263,7 +263,7 @@
 			strlcat(anchor->path, "/", sizeof(anchor->path));
 		}
 		strlcat(anchor->path, anchor->name, sizeof(anchor->path));
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if ((dup = RB_INSERT(pf_anchor_global, &V_pf_anchors, anchor)) !=
 #else
 		if ((dup = RB_INSERT(pf_anchor_global, &pf_anchors, anchor)) !=
@@ -284,7 +284,7 @@
 				    "RB_INSERT2 '%s' '%s' collides with "
 				    "'%s' '%s'\n", anchor->path, anchor->name,
 				    dup->path, dup->name);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 				RB_REMOVE(pf_anchor_global, &V_pf_anchors,
 #else
 				RB_REMOVE(pf_anchor_global, &pf_anchors,
@@ -324,7 +324,7 @@
 			    !TAILQ_EMPTY(ruleset->rules[i].inactive.ptr) ||
 			    ruleset->rules[i].inactive.open)
 				return;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		RB_REMOVE(pf_anchor_global, &V_pf_anchors, ruleset->anchor);
 #else
 		RB_REMOVE(pf_anchor_global, &pf_anchors, ruleset->anchor);
--- a/sys/contrib/pf/net/pf_table.c
+++ b/sys/contrib/pf/net/pf_table.c
@@ -30,7 +30,7 @@
  *
  */
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include "opt_inet.h"
 #include "opt_inet6.h"
 
@@ -43,7 +43,7 @@
 #include <sys/socket.h>
 #include <sys/mbuf.h>
 #include <sys/kernel.h>
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 #include <sys/malloc.h>
 #else
 #include <sys/pool.h>
@@ -52,7 +52,7 @@
 #include <net/if.h>
 #include <net/route.h>
 #include <netinet/in.h>
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 #include <netinet/ip_ipsp.h>
 #endif
 #include <net/pfvar.h>
@@ -64,7 +64,7 @@
 			return (EINVAL);	\
 	} while (0)
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 static inline int
 _copyin(const void *uaddr, void *kaddr, size_t len)
 {
@@ -175,7 +175,7 @@
 
 #define	senderr(e)	do { rv = (e); goto _bad; } while (0)
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 VNET_DEFINE(uma_zone_t,			pfr_ktable_pl);
 VNET_DEFINE(uma_zone_t,			pfr_kentry_pl);
 VNET_DEFINE(uma_zone_t,			pfr_kcounters_pl);
@@ -255,7 +255,7 @@
 void
 pfr_initialize(void)
 {
-#ifndef __FreeBSD__
+#ifndef __FreeBSD_kernel__
 	pool_init(&pfr_ktable_pl, sizeof(struct pfr_ktable), 0, 0, 0,
 	    "pfrktable", NULL);
 	pool_init(&pfr_kentry_pl, sizeof(struct pfr_kentry), 0, 0, 0,
@@ -661,13 +661,13 @@
 	w.pfrw_addr = addr;
 	w.pfrw_free = kt->pfrkt_cnt;
 	w.pfrw_flags = flags;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	rv = kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #else
 	rv = rn_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #endif
 	if (!rv)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rv = kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree,
 		    &w);
 #else
@@ -714,13 +714,13 @@
 	w.pfrw_flags = flags;
 	if (flags & PFR_FLAG_ATOMIC)
 		s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	rv = kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #else
 	rv = rn_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #endif
 	if (!rv)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rv = kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree, 
 		    &w);
 #else
@@ -841,7 +841,7 @@
 	w.pfrw_op = sweep ? PFRW_SWEEP : PFRW_ENQUEUE;
 	w.pfrw_workq = workq;
 	if (kt->pfrkt_ip4 != NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, 
 		    &w))
 #else
@@ -849,7 +849,7 @@
 #endif
 			printf("pfr_enqueue_addrs: IPv4 walktree failed.\n");
 	if (kt->pfrkt_ip6 != NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree, 
 		    &w))
 #else
@@ -867,13 +867,13 @@
 
 	bzero(&w, sizeof(w));
 	w.pfrw_op = PFRW_MARK;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, &w))
 #else
 	if (rn_walktree(kt->pfrkt_ip4, pfr_walktree, &w))
 #endif
 		printf("pfr_mark_addrs: IPv4 walktree failed.\n");
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree, &w))
 #else
 	if (rn_walktree(kt->pfrkt_ip6, pfr_walktree, &w))
@@ -886,7 +886,7 @@
 pfr_lookup_addr(struct pfr_ktable *kt, struct pfr_addr *ad, int exact)
 {
 	union sockaddr_union	 sa, mask;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct radix_node_head	*head = NULL;
 #else
 	struct radix_node_head	*head;
@@ -905,7 +905,7 @@
 	if (ADDR_NETWORK(ad)) {
 		pfr_prepare_network(&mask, ad->pfra_af, ad->pfra_net);
 		s = splsoftnet(); /* rn_lookup makes use of globals */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_LOCK_ASSERT();
 #endif
 		ke = (struct pfr_kentry *)rn_lookup(&sa, &mask, head);
@@ -928,13 +928,13 @@
 	struct pfr_kentry	*ke;
 
 	if (intr)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		ke = pool_get(&V_pfr_kentry_pl, PR_NOWAIT | PR_ZERO);
 #else
 		ke = pool_get(&pfr_kentry_pl, PR_NOWAIT | PR_ZERO);
 #endif
 	else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		ke = pool_get(&V_pfr_kentry_pl, PR_WAITOK|PR_ZERO);
 #else
 		ke = pool_get(&pfr_kentry_pl, PR_WAITOK|PR_ZERO|PR_LIMITFAIL);
@@ -967,7 +967,7 @@
 pfr_destroy_kentry(struct pfr_kentry *ke)
 {
 	if (ke->pfrke_counters)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		pool_put(&V_pfr_kcounters_pl, ke->pfrke_counters);
 	pool_put(&V_pfr_kentry_pl, ke);
 #else
@@ -1055,7 +1055,7 @@
 		if (negchange)
 			p->pfrke_not = !p->pfrke_not;
 		if (p->pfrke_counters) {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pool_put(&V_pfr_kcounters_pl, p->pfrke_counters);
 #else
 			pool_put(&pfr_kcounters_pl, p->pfrke_counters);
@@ -1112,7 +1112,7 @@
 {
 	union sockaddr_union	 mask;
 	struct radix_node	*rn;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct radix_node_head	*head = NULL;
 #else
 	struct radix_node_head	*head;
@@ -1126,18 +1126,18 @@
 		head = kt->pfrkt_ip6;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #endif
 	if (KENTRY_NETWORK(ke)) {
 		pfr_prepare_network(&mask, ke->pfrke_af, ke->pfrke_net);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rn = rn_addroute(&ke->pfrke_sa, &mask, head, ke->pfrke_node);
 #else
 		rn = rn_addroute(&ke->pfrke_sa, &mask, head, ke->pfrke_node, 0);
 #endif
 	} else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rn = rn_addroute(&ke->pfrke_sa, NULL, head, ke->pfrke_node);
 #else
 		rn = rn_addroute(&ke->pfrke_sa, NULL, head, ke->pfrke_node, 0);
@@ -1152,7 +1152,7 @@
 {
 	union sockaddr_union	 mask;
 	struct radix_node	*rn;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct radix_node_head	*head = NULL;
 #else
 	struct radix_node_head	*head;
@@ -1165,18 +1165,18 @@
 		head = kt->pfrkt_ip6;
 
 	s = splsoftnet();
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	PF_LOCK_ASSERT();
 #endif
 	if (KENTRY_NETWORK(ke)) {
 		pfr_prepare_network(&mask, ke->pfrke_af, ke->pfrke_net);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rn = rn_delete(&ke->pfrke_sa, &mask, head);
 #else
 		rn = rn_delete(&ke->pfrke_sa, &mask, head, NULL);
 #endif
 	} else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		rn = rn_delete(&ke->pfrke_sa, NULL, head);
 #else
 		rn = rn_delete(&ke->pfrke_sa, NULL, head, NULL);
@@ -1271,7 +1271,7 @@
 		if (ke->pfrke_af == AF_INET) {
 			if (w->pfrw_dyn->pfid_acnt4++ > 0)
 				break;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pfr_prepare_network(&V_pfr_mask, AF_INET, ke->pfrke_net);
 #else
 			pfr_prepare_network(&pfr_mask, AF_INET, ke->pfrke_net);
@@ -1279,7 +1279,7 @@
 			w->pfrw_dyn->pfid_addr4 = *SUNION2PF(
 			    &ke->pfrke_sa, AF_INET);
 			w->pfrw_dyn->pfid_mask4 = *SUNION2PF(
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    &V_pfr_mask, AF_INET);
 #else
 			    &pfr_mask, AF_INET);
@@ -1287,7 +1287,7 @@
 		} else if (ke->pfrke_af == AF_INET6){
 			if (w->pfrw_dyn->pfid_acnt6++ > 0)
 				break;
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			pfr_prepare_network(&V_pfr_mask, AF_INET6, ke->pfrke_net);
 #else
 			pfr_prepare_network(&pfr_mask, AF_INET6, ke->pfrke_net);
@@ -1295,7 +1295,7 @@
 			w->pfrw_dyn->pfid_addr6 = *SUNION2PF(
 			    &ke->pfrke_sa, AF_INET6);
 			w->pfrw_dyn->pfid_mask6 = *SUNION2PF(
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			    &V_pfr_mask, AF_INET6);
 #else
 			    &pfr_mask, AF_INET6);
@@ -2082,13 +2082,13 @@
 	struct pf_ruleset	*rs;
 
 	if (intr)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt = pool_get(&V_pfr_ktable_pl, PR_NOWAIT|PR_ZERO);
 #else
 		kt = pool_get(&pfr_ktable_pl, PR_NOWAIT|PR_ZERO|PR_LIMITFAIL);
 #endif
 	else
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt = pool_get(&V_pfr_ktable_pl, PR_WAITOK|PR_ZERO);
 #else
 		kt = pool_get(&pfr_ktable_pl, PR_WAITOK|PR_ZERO|PR_LIMITFAIL);
@@ -2140,7 +2140,7 @@
 		pfr_clean_node_mask(kt, &addrq);
 		pfr_destroy_kentries(&addrq);
 	}
-#if defined(__FreeBSD__) && (__FreeBSD_version >= 500100)
+#if defined(__FreeBSD_kernel__) && (__FreeBSD_version >= 500100)
 	if (kt->pfrkt_ip4 != NULL) {
 		RADIX_NODE_HEAD_DESTROY(kt->pfrkt_ip4);
 		free((caddr_t)kt->pfrkt_ip4, M_RTABLE);
@@ -2161,7 +2161,7 @@
 		kt->pfrkt_rs->tables--;
 		pf_remove_if_empty_ruleset(kt->pfrkt_rs);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pool_put(&V_pfr_ktable_pl, kt);
 #else
 	pool_put(&pfr_ktable_pl, kt);
@@ -2200,7 +2200,7 @@
 	switch (af) {
 #ifdef INET
 	case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pfr_sin.sin_addr.s_addr = a->addr32[0];
 		ke = (struct pfr_kentry *)rn_match(&V_pfr_sin, kt->pfrkt_ip4);
 #else
@@ -2213,7 +2213,7 @@
 #endif /* INET */
 #ifdef INET6
 	case AF_INET6:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		bcopy(a, &V_pfr_sin6.sin6_addr, sizeof(V_pfr_sin6.sin6_addr));
 		ke = (struct pfr_kentry *)rn_match(&V_pfr_sin6, kt->pfrkt_ip6);
 #else
@@ -2247,7 +2247,7 @@
 	switch (af) {
 #ifdef INET
 	case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		V_pfr_sin.sin_addr.s_addr = a->addr32[0];
 		ke = (struct pfr_kentry *)rn_match(&V_pfr_sin, kt->pfrkt_ip4);
 #else
@@ -2260,7 +2260,7 @@
 #endif /* INET */
 #ifdef INET6
 	case AF_INET6:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		bcopy(a, &V_pfr_sin6.sin6_addr, sizeof(V_pfr_sin6.sin6_addr));
 		ke = (struct pfr_kentry *)rn_match(&V_pfr_sin6, kt->pfrkt_ip6);
 #else
@@ -2284,7 +2284,7 @@
 	if (ke != NULL && op_pass != PFR_OP_XPASS &&
 	    (kt->pfrkt_flags & PFR_TFLAG_COUNTERS)) {
 		if (ke->pfrke_counters == NULL)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 			ke->pfrke_counters = pool_get(&V_pfr_kcounters_pl,
 #else
 			ke->pfrke_counters = pool_get(&pfr_kcounters_pl,
@@ -2347,7 +2347,7 @@
 pfr_pool_get(struct pfr_ktable *kt, int *pidx, struct pf_addr *counter,
     struct pf_addr **raddr, struct pf_addr **rmask, sa_family_t af)
 {
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	struct pfr_kentry	*ke, *ke2 = NULL;
 	struct pf_addr		*addr = NULL;
 #else
@@ -2357,7 +2357,7 @@
 	union sockaddr_union	 mask;
 	int			 idx = -1, use_counter = 0;
 
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	if (af == AF_INET)
 		addr = (struct pf_addr *)&V_pfr_sin.sin_addr;
 	else if (af == AF_INET6)
@@ -2386,13 +2386,13 @@
 		kt->pfrkt_nomatch++;
 		return (1);
 	}
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	pfr_prepare_network(&V_pfr_mask, af, ke->pfrke_net);
 #else
 	pfr_prepare_network(&pfr_mask, af, ke->pfrke_net);
 #endif
 	*raddr = SUNION2PF(&ke->pfrke_sa, af);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 	*rmask = SUNION2PF(&V_pfr_mask, af);
 #else
 	*rmask = SUNION2PF(&pfr_mask, af);
@@ -2421,7 +2421,7 @@
 	}
 	for (;;) {
 		/* we don't want to use a nested block */
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		if (af == AF_INET)
 			ke2 = (struct pfr_kentry *)rn_match(&V_pfr_sin,
 			    kt->pfrkt_ip4);
@@ -2447,7 +2447,7 @@
 
 		/* we need to increase the counter past the nested block */
 		pfr_prepare_network(&mask, AF_INET, ke2->pfrke_net);
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		PF_POOLMASK(addr, addr, SUNION2PF(&mask, af), &V_pfr_ffaddr, af);
 #else
 		PF_POOLMASK(addr, addr, SUNION2PF(&mask, af), &pfr_ffaddr, af);
@@ -2475,7 +2475,7 @@
 	switch (af) {
 #ifdef INET
 	case AF_INET:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #else
 		rn_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
@@ -2484,7 +2484,7 @@
 #endif /* INET */
 #ifdef INET6
 	case AF_INET6:
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree, &w);
 #else
 		rn_walktree(kt->pfrkt_ip6, pfr_walktree, &w);
@@ -2510,13 +2510,13 @@
 	dyn->pfid_acnt4 = 0;
 	dyn->pfid_acnt6 = 0;
 	if (!dyn->pfid_af || dyn->pfid_af == AF_INET)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt->pfrkt_ip4->rnh_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #else
 		rn_walktree(kt->pfrkt_ip4, pfr_walktree, &w);
 #endif
 	if (!dyn->pfid_af || dyn->pfid_af == AF_INET6)
-#ifdef __FreeBSD__
+#ifdef __FreeBSD_kernel__
 		kt->pfrkt_ip6->rnh_walktree(kt->pfrkt_ip6, pfr_walktree, &w);
 #else
 		rn_walktree(kt->pfrkt_ip6, pfr_walktree, &w);
