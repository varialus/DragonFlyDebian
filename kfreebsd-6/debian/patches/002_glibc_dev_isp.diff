
Merged in 7-CURRENT as of 2006-02-15.

--- sys.old/dev/isp/isp.c	2005-01-23 01:26:45.000000000 -0500
+++ sys/dev/isp/isp.c	2005-09-03 16:08:55.000000000 -0400
@@ -113,12 +113,12 @@
 /*
  * Local function prototypes.
  */
-static int isp_parse_async(struct ispsoftc *, u_int16_t);
+static int isp_parse_async(struct ispsoftc *, uint16_t);
 static int isp_handle_other_response(struct ispsoftc *, int, isphdr_t *,
-    u_int16_t *);
+    uint16_t *);
 static void
 isp_parse_status(struct ispsoftc *, ispstatusreq_t *, XS_T *);
-static void isp_fastpost_complete(struct ispsoftc *, u_int16_t);
+static void isp_fastpost_complete(struct ispsoftc *, uint16_t);
 static int isp_mbox_continue(struct ispsoftc *);
 static void isp_scsi_init(struct ispsoftc *);
 static void isp_scsi_channel_init(struct ispsoftc *, int);
@@ -126,7 +126,7 @@
 static void isp_mark_getpdb_all(struct ispsoftc *);
 static int isp_getmap(struct ispsoftc *, fcpos_map_t *);
 static int isp_getpdb(struct ispsoftc *, int, isp_pdb_t *);
-static u_int64_t isp_get_portname(struct ispsoftc *, int, int);
+static uint64_t isp_get_portname(struct ispsoftc *, int, int);
 static int isp_fclink_test(struct ispsoftc *, int);
 static char *isp2100_fw_statename(int);
 static int isp_pdb_sync(struct ispsoftc *);
@@ -142,11 +142,11 @@
 static void isp_update_bus(struct ispsoftc *, int);
 static void isp_setdfltparm(struct ispsoftc *, int);
 static int isp_read_nvram(struct ispsoftc *);
-static void isp_rdnvram_word(struct ispsoftc *, int, u_int16_t *);
-static void isp_parse_nvram_1020(struct ispsoftc *, u_int8_t *);
-static void isp_parse_nvram_1080(struct ispsoftc *, int, u_int8_t *);
-static void isp_parse_nvram_12160(struct ispsoftc *, int, u_int8_t *);
-static void isp_parse_nvram_2100(struct ispsoftc *, u_int8_t *);
+static void isp_rdnvram_word(struct ispsoftc *, int, uint16_t *);
+static void isp_parse_nvram_1020(struct ispsoftc *, uint8_t *);
+static void isp_parse_nvram_1080(struct ispsoftc *, int, uint8_t *);
+static void isp_parse_nvram_12160(struct ispsoftc *, int, uint8_t *);
+static void isp_parse_nvram_2100(struct ispsoftc *, uint8_t *);
 
 /*
  * Reset Hardware.
@@ -160,7 +160,7 @@
 isp_reset(struct ispsoftc *isp)
 {
 	mbreg_t mbs;
-	u_int16_t code_org;
+	uint16_t code_org;
 	int loops, i, dodnld = 1;
 	char *btype = "????";
 
@@ -275,7 +275,7 @@
 		 */
 	} else if (IS_ULTRA2(isp)) {
 		static const char m[] = "bus %d is in %s Mode";
-		u_int16_t l;
+		uint16_t l;
 		sdparam *sdp = isp->isp_param;
 
 		isp->isp_clock = 100;
@@ -517,7 +517,7 @@
 	 * be done later after fetching from NVRAM.
 	 */
 	if (IS_SCSI(isp)) {
-		u_int16_t tmp = isp->isp_mdvec->dv_conf1;
+		uint16_t tmp = isp->isp_mdvec->dv_conf1;
 		/*
 		 * Busted FIFO. Turn off all but burst enables.
 		 */
@@ -1021,7 +1021,7 @@
 #endif
 #endif
 	if (mbs.param[1] != 0) {
-		u_int16_t sfeat = mbs.param[1];
+		uint16_t sfeat = mbs.param[1];
 		isp_mboxcmd(isp, &mbs, MBLOGALL);
 		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
 			isp_prt(isp, ISP_LOGINFO,
@@ -1063,7 +1063,7 @@
 	 */
 	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
 		int lun;
-		u_int16_t sdf;
+		uint16_t sdf;
 
 		if (sdp->isp_devparam[tgt].dev_enable == 0) {
 			continue;
@@ -1162,7 +1162,7 @@
 	isp_icb_t local, *icbp = &local;
 	mbreg_t mbs;
 	int loopid;
-	u_int64_t nwwn, pwwn;
+	uint64_t nwwn, pwwn;
 
 	fcp = isp->isp_param;
 
@@ -1387,10 +1387,10 @@
 		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
 		isp_prt(isp, ISP_LOGDEBUG1,
 		    "Setting ICB Node 0x%08x%08x Port 0x%08x%08x",
-		    ((u_int32_t) (nwwn >> 32)),
-		    ((u_int32_t) (nwwn & 0xffffffff)),
-		    ((u_int32_t) (pwwn >> 32)),
-		    ((u_int32_t) (pwwn & 0xffffffff)));
+		    ((uint32_t) (nwwn >> 32)),
+		    ((uint32_t) (nwwn & 0xffffffff)),
+		    ((uint32_t) (pwwn >> 32)),
+		    ((uint32_t) (pwwn & 0xffffffff)));
 	} else {
 		isp_prt(isp, ISP_LOGDEBUG1, "Not using any WWNs");
 		icbp->icb_fwoptions &= ~(ICBOPT_BOTH_WWNS|ICBOPT_FULL_LOGIN);
@@ -1522,10 +1522,10 @@
 	return (-1);
 }
 
-static u_int64_t
+static uint64_t
 isp_get_portname(struct ispsoftc *isp, int loopid, int nodename)
 {
-	u_int64_t wwn = 0;
+	uint64_t wwn = 0;
 	mbreg_t mbs;
 
 	mbs.param[0] = MBOX_GET_PORT_NAME;
@@ -1535,14 +1535,14 @@
 	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
 	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
 		wwn =
-		    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |
-		    (((u_int64_t)(mbs.param[2] >> 8))	<< 48) |
-		    (((u_int64_t)(mbs.param[3] & 0xff))	<< 40) |
-		    (((u_int64_t)(mbs.param[3] >> 8))	<< 32) |
-		    (((u_int64_t)(mbs.param[6] & 0xff))	<< 24) |
-		    (((u_int64_t)(mbs.param[6] >> 8))	<< 16) |
-		    (((u_int64_t)(mbs.param[7] & 0xff))	<<  8) |
-		    (((u_int64_t)(mbs.param[7] >> 8)));
+		    (((uint64_t)(mbs.param[2] & 0xff)) << 56) |
+		    (((uint64_t)(mbs.param[2] >> 8))	<< 48) |
+		    (((uint64_t)(mbs.param[3] & 0xff))	<< 40) |
+		    (((uint64_t)(mbs.param[3] >> 8))	<< 32) |
+		    (((uint64_t)(mbs.param[6] & 0xff))	<< 24) |
+		    (((uint64_t)(mbs.param[6] >> 8))	<< 16) |
+		    (((uint64_t)(mbs.param[7] & 0xff))	<<  8) |
+		    (((uint64_t)(mbs.param[7] >> 8)));
 	}
 	return (wwn);
 }
@@ -1563,7 +1563,7 @@
 	};
 	mbreg_t mbs;
 	int count, check_for_fabric;
-	u_int8_t lwfs;
+	uint8_t lwfs;
 	fcparam *fcp;
 	struct lportdb *lp;
 	isp_pdb_t pdb;
@@ -1580,8 +1580,8 @@
 	lwfs = FW_CONFIG_WAIT;
 	count = 0;
 	while (count < usdelay) {
-		u_int64_t enano;
-		u_int32_t wrk;
+		uint64_t enano;
+		uint32_t wrk;
 		NANOTIME_T hra, hrb;
 
 		GET_NANOTIME(&hra);
@@ -1606,7 +1606,7 @@
 		isp_prt(isp, ISP_LOGDEBUG1,
 		    "usec%d: 0x%lx->0x%lx enano 0x%x%08x",
 		    count, (long) GET_NANOSEC(&hra), (long) GET_NANOSEC(&hrb),
-		    (u_int32_t)(enano >> 32), (u_int32_t)(enano & 0xffffffff));
+		    (uint32_t)(enano >> 32), (uint32_t)(enano & 0xffffffff));
 
 		/*
 		 * If the elapsed time is less than 1 millisecond,
@@ -1614,23 +1614,23 @@
 		 * waiting.
 		 *
 		 * This peculiar code is an attempt to try and avoid
-		 * invoking u_int64_t math support functions for some
+		 * invoking uint64_t math support functions for some
 		 * platforms where linkage is a problem.
 		 */
 		if (enano < (1000 * 1000)) {
 			count += 1000;
 			enano = (1000 * 1000) - enano;
-			while (enano > (u_int64_t) 4000000000U) {
+			while (enano > (uint64_t) 4000000000U) {
 				USEC_SLEEP(isp, 4000000);
-				enano -= (u_int64_t) 4000000000U;
+				enano -= (uint64_t) 4000000000U;
 			}
 			wrk = enano;
 			wrk /= 1000;
 			USEC_SLEEP(isp, wrk);
 		} else {
-			while (enano > (u_int64_t) 4000000000U) {
+			while (enano > (uint64_t) 4000000000U) {
 				count += 4000000;
-				enano -= (u_int64_t) 4000000000U;
+				enano -= (uint64_t) 4000000000U;
 			}
 			wrk = enano;
 			count += (wrk / 1000);
@@ -1707,23 +1707,23 @@
 		 */
 		lp = &fcp->portdb[loopid];
 		lp->node_wwn =
-		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_nodename[7]));
+		    (((uint64_t)pdb.pdb_nodename[0]) << 56) |
+		    (((uint64_t)pdb.pdb_nodename[1]) << 48) |
+		    (((uint64_t)pdb.pdb_nodename[2]) << 40) |
+		    (((uint64_t)pdb.pdb_nodename[3]) << 32) |
+		    (((uint64_t)pdb.pdb_nodename[4]) << 24) |
+		    (((uint64_t)pdb.pdb_nodename[5]) << 16) |
+		    (((uint64_t)pdb.pdb_nodename[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_nodename[7]));
 		lp->port_wwn =
-		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_portname[7]));
+		    (((uint64_t)pdb.pdb_portname[0]) << 56) |
+		    (((uint64_t)pdb.pdb_portname[1]) << 48) |
+		    (((uint64_t)pdb.pdb_portname[2]) << 40) |
+		    (((uint64_t)pdb.pdb_portname[3]) << 32) |
+		    (((uint64_t)pdb.pdb_portname[4]) << 24) |
+		    (((uint64_t)pdb.pdb_portname[5]) << 16) |
+		    (((uint64_t)pdb.pdb_portname[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_portname[7]));
 		lp->roles =
 		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
 		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
@@ -1887,7 +1887,7 @@
 	 * for the moment.
 	 */
 	for (lp = &fcp->portdb[base]; lp < &fcp->portdb[lim]; lp++) {
-		u_int32_t portid;
+		uint32_t portid;
 		mbreg_t mbs;
 
 		loopid = lp - fcp->portdb;
@@ -1922,29 +1922,29 @@
 		if (lp->loggedin && lp->force_logout == 0 &&
 		    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
 			int nrole;
-			u_int64_t nwwnn, nwwpn;
+			uint64_t nwwnn, nwwpn;
 			nwwnn =
-			    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
-			    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
-			    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
-			    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
-			    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
-			    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
-			    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
-			    (((u_int64_t)pdb.pdb_nodename[7]));
+			    (((uint64_t)pdb.pdb_nodename[0]) << 56) |
+			    (((uint64_t)pdb.pdb_nodename[1]) << 48) |
+			    (((uint64_t)pdb.pdb_nodename[2]) << 40) |
+			    (((uint64_t)pdb.pdb_nodename[3]) << 32) |
+			    (((uint64_t)pdb.pdb_nodename[4]) << 24) |
+			    (((uint64_t)pdb.pdb_nodename[5]) << 16) |
+			    (((uint64_t)pdb.pdb_nodename[6]) <<  8) |
+			    (((uint64_t)pdb.pdb_nodename[7]));
 			nwwpn =
-			    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
-			    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
-			    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
-			    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
-			    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
-			    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
-			    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
-			    (((u_int64_t)pdb.pdb_portname[7]));
+			    (((uint64_t)pdb.pdb_portname[0]) << 56) |
+			    (((uint64_t)pdb.pdb_portname[1]) << 48) |
+			    (((uint64_t)pdb.pdb_portname[2]) << 40) |
+			    (((uint64_t)pdb.pdb_portname[3]) << 32) |
+			    (((uint64_t)pdb.pdb_portname[4]) << 24) |
+			    (((uint64_t)pdb.pdb_portname[5]) << 16) |
+			    (((uint64_t)pdb.pdb_portname[6]) <<  8) |
+			    (((uint64_t)pdb.pdb_portname[7]));
 			nrole = (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >>
 			    SVC3_ROLE_SHIFT;
 			if (pdb.pdb_loopid == lp->loopid && lp->portid ==
-			    (u_int32_t) BITS2WORD(pdb.pdb_portid_bits) &&
+			    (uint32_t) BITS2WORD(pdb.pdb_portid_bits) &&
 			    nwwnn == lp->node_wwn && nwwpn == lp->port_wwn &&
 			    lp->roles == nrole && lp->force_logout == 0) {
 				lp->loggedin = lp->valid = 1;
@@ -2065,7 +2065,7 @@
 			goto dump_em;
 		}
 
-		if (lp->portid != (u_int32_t) BITS2WORD(pdb.pdb_portid_bits)) {
+		if (lp->portid != (uint32_t) BITS2WORD(pdb.pdb_portid_bits)) {
 			isp_prt(isp, ISP_LOGWARN, pdbmfail2,
 			    lp->portid, BITS2WORD(pdb.pdb_portid_bits));
 			goto dump_em;
@@ -2074,23 +2074,23 @@
 		lp->roles =
 		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
 		lp->node_wwn =
-		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_nodename[7]));
+		    (((uint64_t)pdb.pdb_nodename[0]) << 56) |
+		    (((uint64_t)pdb.pdb_nodename[1]) << 48) |
+		    (((uint64_t)pdb.pdb_nodename[2]) << 40) |
+		    (((uint64_t)pdb.pdb_nodename[3]) << 32) |
+		    (((uint64_t)pdb.pdb_nodename[4]) << 24) |
+		    (((uint64_t)pdb.pdb_nodename[5]) << 16) |
+		    (((uint64_t)pdb.pdb_nodename[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_nodename[7]));
 		lp->port_wwn =
-		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_portname[7]));
+		    (((uint64_t)pdb.pdb_portname[0]) << 56) |
+		    (((uint64_t)pdb.pdb_portname[1]) << 48) |
+		    (((uint64_t)pdb.pdb_portname[2]) << 40) |
+		    (((uint64_t)pdb.pdb_portname[3]) << 32) |
+		    (((uint64_t)pdb.pdb_portname[4]) << 24) |
+		    (((uint64_t)pdb.pdb_portname[5]) << 16) |
+		    (((uint64_t)pdb.pdb_portname[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_portname[7]));
 		/*
 		 * Check to make sure this all makes sense.
 		 */
@@ -2213,23 +2213,23 @@
 		 * Save the pertinent info locally.
 		 */
 		lp->node_wwn =
-		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_nodename[7]));
+		    (((uint64_t)pdb.pdb_nodename[0]) << 56) |
+		    (((uint64_t)pdb.pdb_nodename[1]) << 48) |
+		    (((uint64_t)pdb.pdb_nodename[2]) << 40) |
+		    (((uint64_t)pdb.pdb_nodename[3]) << 32) |
+		    (((uint64_t)pdb.pdb_nodename[4]) << 24) |
+		    (((uint64_t)pdb.pdb_nodename[5]) << 16) |
+		    (((uint64_t)pdb.pdb_nodename[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_nodename[7]));
 		lp->port_wwn =
-		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
-		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
-		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
-		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
-		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
-		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
-		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
-		    (((u_int64_t)pdb.pdb_portname[7]));
+		    (((uint64_t)pdb.pdb_portname[0]) << 56) |
+		    (((uint64_t)pdb.pdb_portname[1]) << 48) |
+		    (((uint64_t)pdb.pdb_portname[2]) << 40) |
+		    (((uint64_t)pdb.pdb_portname[3]) << 32) |
+		    (((uint64_t)pdb.pdb_portname[4]) << 24) |
+		    (((uint64_t)pdb.pdb_portname[5]) << 16) |
+		    (((uint64_t)pdb.pdb_portname[6]) <<  8) |
+		    (((uint64_t)pdb.pdb_portname[7]));
 		lp->roles =
 		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
 		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
@@ -2449,7 +2449,7 @@
 isp_scan_fabric(struct ispsoftc *isp, int ftype)
 {
 	fcparam *fcp = isp->isp_param;
-	u_int32_t portid, first_portid, last_portid;
+	uint32_t portid, first_portid, last_portid;
 	int hicap, last_port_same;
 
 	if (fcp->isp_onfabric == 0) {
@@ -2473,7 +2473,7 @@
 		sns_screq_t *rq;
 		sns_ga_nxt_rsp_t *rs0, *rs1;
 		struct lportdb lcl;
-		u_int8_t sc[SNS_GA_NXT_RESP_SIZE];
+		uint8_t sc[SNS_GA_NXT_RESP_SIZE];
 
 		rq = (sns_screq_t *)sc;
 		MEMZERO((void *) rq, SNS_GA_NXT_REQ_SIZE);
@@ -2506,7 +2506,7 @@
 		}
 		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GA_NXT_RESP_SIZE);
 		rs1 = (sns_ga_nxt_rsp_t *) sc;
-		rs0 = (sns_ga_nxt_rsp_t *) ((u_int8_t *)fcp->isp_scratch+0x100);
+		rs0 = (sns_ga_nxt_rsp_t *) ((uint8_t *)fcp->isp_scratch+0x100);
 		isp_get_ga_nxt_response(isp, rs0, rs1);
 		if (rs1->snscb_cthdr.ct_response != FS_ACC) {
 			int level;
@@ -2523,9 +2523,9 @@
 			return (0);
 		}
 		portid =
-		    (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
-		    (((u_int32_t) rs1->snscb_port_id[1]) << 8) |
-		    (((u_int32_t) rs1->snscb_port_id[2]));
+		    (((uint32_t) rs1->snscb_port_id[0]) << 16) |
+		    (((uint32_t) rs1->snscb_port_id[1]) << 8) |
+		    (((uint32_t) rs1->snscb_port_id[2]));
 
 		/*
 		 * XXX: We should check to make sure that this entry
@@ -2544,23 +2544,23 @@
 		lcl.fc4_type = ftype;
 		lcl.portid = portid;
 		lcl.node_wwn =
-		    (((u_int64_t)rs1->snscb_nodename[0]) << 56) |
-		    (((u_int64_t)rs1->snscb_nodename[1]) << 48) |
-		    (((u_int64_t)rs1->snscb_nodename[2]) << 40) |
-		    (((u_int64_t)rs1->snscb_nodename[3]) << 32) |
-		    (((u_int64_t)rs1->snscb_nodename[4]) << 24) |
-		    (((u_int64_t)rs1->snscb_nodename[5]) << 16) |
-		    (((u_int64_t)rs1->snscb_nodename[6]) <<  8) |
-		    (((u_int64_t)rs1->snscb_nodename[7]));
+		    (((uint64_t)rs1->snscb_nodename[0]) << 56) |
+		    (((uint64_t)rs1->snscb_nodename[1]) << 48) |
+		    (((uint64_t)rs1->snscb_nodename[2]) << 40) |
+		    (((uint64_t)rs1->snscb_nodename[3]) << 32) |
+		    (((uint64_t)rs1->snscb_nodename[4]) << 24) |
+		    (((uint64_t)rs1->snscb_nodename[5]) << 16) |
+		    (((uint64_t)rs1->snscb_nodename[6]) <<  8) |
+		    (((uint64_t)rs1->snscb_nodename[7]));
 		lcl.port_wwn =
-		    (((u_int64_t)rs1->snscb_portname[0]) << 56) |
-		    (((u_int64_t)rs1->snscb_portname[1]) << 48) |
-		    (((u_int64_t)rs1->snscb_portname[2]) << 40) |
-		    (((u_int64_t)rs1->snscb_portname[3]) << 32) |
-		    (((u_int64_t)rs1->snscb_portname[4]) << 24) |
-		    (((u_int64_t)rs1->snscb_portname[5]) << 16) |
-		    (((u_int64_t)rs1->snscb_portname[6]) <<  8) |
-		    (((u_int64_t)rs1->snscb_portname[7]));
+		    (((uint64_t)rs1->snscb_portname[0]) << 56) |
+		    (((uint64_t)rs1->snscb_portname[1]) << 48) |
+		    (((uint64_t)rs1->snscb_portname[2]) << 40) |
+		    (((uint64_t)rs1->snscb_portname[3]) << 32) |
+		    (((uint64_t)rs1->snscb_portname[4]) << 24) |
+		    (((uint64_t)rs1->snscb_portname[5]) << 16) |
+		    (((uint64_t)rs1->snscb_portname[6]) <<  8) |
+		    (((uint64_t)rs1->snscb_portname[7]));
 
 		/*
 		 * Does this fabric object support the type we want?
@@ -2661,7 +2661,7 @@
 	}
 	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN);
 	rs1 = (sns_gid_ft_rsp_t *) fcp->tport;
-	rs0 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+IGPOFF);
+	rs0 = (sns_gid_ft_rsp_t *) ((uint8_t *)fcp->isp_scratch+IGPOFF);
 	isp_get_gid_ft_response(isp, rs0, rs1, NGENT);
 	if (rs1->snscb_cthdr.ct_response != FS_ACC) {
 		int level;
@@ -2699,9 +2699,9 @@
 		MEMZERO(&lcl, sizeof (lcl));
 		lcl.fc4_type = ftype;
 		lcl.portid =
-		    (((u_int32_t) rs1->snscb_ports[i].portid[0]) << 16) |
-		    (((u_int32_t) rs1->snscb_ports[i].portid[1]) << 8) |
-		    (((u_int32_t) rs1->snscb_ports[i].portid[2]));
+		    (((uint32_t) rs1->snscb_ports[i].portid[0]) << 16) |
+		    (((uint32_t) rs1->snscb_ports[i].portid[1]) << 8) |
+		    (((uint32_t) rs1->snscb_ports[i].portid[2]));
 
 		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
 		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
@@ -2736,7 +2736,7 @@
 			return (-1);
 		}
 		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
-		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
+		gs0 = (sns_gxn_id_rsp_t *) ((uint8_t *)fcp->isp_scratch+GXOFF);
 		isp_get_gxn_id_response(isp, gs0, gs1);
 		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
 			isp_prt(isp, ISP_LOGWARN, swrej, "GPN_ID",
@@ -2749,14 +2749,14 @@
 			continue;
 		}
 		lcl.port_wwn = 
-		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
-		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
-		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
-		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
-		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
-		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
-		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
-		    (((u_int64_t)gs1->snscb_wwn[7]));
+		    (((uint64_t)gs1->snscb_wwn[0]) << 56) |
+		    (((uint64_t)gs1->snscb_wwn[1]) << 48) |
+		    (((uint64_t)gs1->snscb_wwn[2]) << 40) |
+		    (((uint64_t)gs1->snscb_wwn[3]) << 32) |
+		    (((uint64_t)gs1->snscb_wwn[4]) << 24) |
+		    (((uint64_t)gs1->snscb_wwn[5]) << 16) |
+		    (((uint64_t)gs1->snscb_wwn[6]) <<  8) |
+		    (((uint64_t)gs1->snscb_wwn[7]));
 
 		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
 		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
@@ -2791,7 +2791,7 @@
 			return (-1);
 		}
 		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
-		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
+		gs0 = (sns_gxn_id_rsp_t *) ((uint8_t *)fcp->isp_scratch+GXOFF);
 		isp_get_gxn_id_response(isp, gs0, gs1);
 		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
 			isp_prt(isp, ISP_LOGWARN, swrej, "GNN_ID",
@@ -2804,14 +2804,14 @@
 			continue;
 		}
 		lcl.node_wwn = 
-		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
-		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
-		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
-		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
-		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
-		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
-		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
-		    (((u_int64_t)gs1->snscb_wwn[7]));
+		    (((uint64_t)gs1->snscb_wwn[0]) << 56) |
+		    (((uint64_t)gs1->snscb_wwn[1]) << 48) |
+		    (((uint64_t)gs1->snscb_wwn[2]) << 40) |
+		    (((uint64_t)gs1->snscb_wwn[3]) << 32) |
+		    (((uint64_t)gs1->snscb_wwn[4]) << 24) |
+		    (((uint64_t)gs1->snscb_wwn[5]) << 16) |
+		    (((uint64_t)gs1->snscb_wwn[6]) <<  8) |
+		    (((uint64_t)gs1->snscb_wwn[7]));
 
 		/*
 		 * The QLogic f/w is bouncing this with a parameter error.
@@ -2854,7 +2854,7 @@
 			return (-1);
 		}
 		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GFF_ID_RESP_SIZE);
-		fs0 = (sns_gff_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
+		fs0 = (sns_gff_id_rsp_t *) ((uint8_t *)fcp->isp_scratch+GXOFF);
 		isp_get_gff_id_response(isp, fs0, fs1);
 		if (fs1->snscb_cthdr.ct_response != FS_ACC) {
 			isp_prt(isp, /* ISP_LOGDEBUG0 */ ISP_LOGWARN,
@@ -2914,7 +2914,7 @@
 isp_register_fc4_type(struct ispsoftc *isp)
 {
 	fcparam *fcp = isp->isp_param;
-	u_int8_t local[SNS_RFT_ID_REQ_SIZE];
+	uint8_t local[SNS_RFT_ID_REQ_SIZE];
 	sns_screq_t *reqp = (sns_screq_t *) local;
 	mbreg_t mbs;
 
@@ -2958,8 +2958,8 @@
 isp_start(XS_T *xs)
 {
 	struct ispsoftc *isp;
-	u_int16_t nxti, optr, handle;
-	u_int8_t local[QENTRY_LEN];
+	uint16_t nxti, optr, handle;
+	uint8_t local[QENTRY_LEN];
 	ispreq_t *reqp, *qep;
 	int target, i;
 
@@ -3205,7 +3205,7 @@
 	 */
 	reqp = (ispreq_t *) local;
 	if (isp->isp_sendmarker) {
-		u_int8_t n = (IS_DUALBUS(isp)? 2: 1);
+		uint8_t n = (IS_DUALBUS(isp)? 2: 1);
 		/*
 		 * Check ports to send markers for...
 		 */
@@ -3331,7 +3331,7 @@
 	XS_T *xs;
 	mbreg_t mbs;
 	int bus, tgt;
-	u_int16_t handle;
+	uint16_t handle;
 
 	switch (ctl) {
 	default:
@@ -3524,10 +3524,10 @@
 #endif
 
 void
-isp_intr(struct ispsoftc *isp, u_int16_t isr, u_int16_t sema, u_int16_t mbox)
+isp_intr(struct ispsoftc *isp, uint16_t isr, uint16_t sema, uint16_t mbox)
 {
 	XS_T *complist[MAX_REQUESTQ_COMPLETIONS], *xs;
-	u_int16_t iptr, optr, junk;
+	uint16_t iptr, optr, junk;
 	int i, nlooked = 0, ndone = 0;
 
 again:
@@ -3676,7 +3676,7 @@
 		ispstatusreq_t local, *sp = &local;
 		isphdr_t *hp;
 		int type;
-		u_int16_t oop;
+		uint16_t oop;
 		int buddaboom = 0;
 
 		hp = (isphdr_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);
@@ -3787,7 +3787,7 @@
 		}
 		xs = isp_find_xs(isp, sp->req_handle);
 		if (xs == NULL) {
-			u_int8_t ts = sp->req_completion_status & 0xff;
+			uint8_t ts = sp->req_completion_status & 0xff;
 			MEMZERO(hp, QENTRY_LEN);	/* PERF */
 			/*
 			 * Only whine if this isn't the expected fallout of
@@ -3969,7 +3969,7 @@
  */
 
 static int
-isp_parse_async(struct ispsoftc *isp, u_int16_t mbox)
+isp_parse_async(struct ispsoftc *isp, uint16_t mbox)
 {
 	int rval = 0;
 	int bus;
@@ -4298,7 +4298,7 @@
 
 	if (bus & 0x100) {
 		int i, nh;
-		u_int16_t handles[16];
+		uint16_t handles[16];
 
 		for (nh = 0, i = 1; i < MAX_MAILBOX; i++) {
 			if ((bus & (1 << i)) == 0) {
@@ -4327,7 +4327,7 @@
 
 static int
 isp_handle_other_response(struct ispsoftc *isp, int type,
-    isphdr_t *hp, u_int16_t *optrp)
+    isphdr_t *hp, uint16_t *optrp)
 {
 	switch (type) {
 	case RQSTYPE_STATUS_CONT:
@@ -4759,7 +4759,7 @@
 }
 
 static void
-isp_fastpost_complete(struct ispsoftc *isp, u_int16_t fph)
+isp_fastpost_complete(struct ispsoftc *isp, uint16_t fph)
 {
 	XS_T *xs;
 
@@ -4795,7 +4795,7 @@
 isp_mbox_continue(struct ispsoftc *isp)
 {
 	mbreg_t mbs;
-	u_int16_t *ptr;
+	uint16_t *ptr;
 
 	switch (isp->isp_lastmbxcmd) {
 	case MBOX_WRITE_RAM_WORD:
@@ -4843,7 +4843,7 @@
 #define	HIBYT(x)			((x) >> 0x8)
 #define	LOBYT(x)			((x)  & 0xff)
 #define	ISPOPMAP(a, b)			(((a) << 8) | (b))
-static const u_int16_t mbpscsi[] = {
+static const uint16_t mbpscsi[] = {
 	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
 	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
 	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
@@ -5039,7 +5039,7 @@
 };
 #endif
 
-static const u_int16_t mbpfc[] = {
+static const uint16_t mbpfc[] = {
 	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
 	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
 	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
@@ -5312,7 +5312,7 @@
 isp_mboxcmd_qnw(struct ispsoftc *isp, mbreg_t *mbp, int nodelay)
 {
 	unsigned int ibits, obits, box, opcode;
-	const u_int16_t *mcp;
+	const uint16_t *mcp;
 
 	if (IS_FC(isp)) {
 		mcp = mbpfc;
@@ -5351,7 +5351,7 @@
 {
 	char *cname, *xname, tname[16], mname[16];
 	unsigned int lim, ibits, obits, box, opcode;
-	const u_int16_t *mcp;
+	const uint16_t *mcp;
 
 	if (IS_FC(isp)) {
 		mcp = mbpfc;
@@ -5537,7 +5537,7 @@
 	sdp += bus;
 
 	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
-		u_int16_t flags, period, offset;
+		uint16_t flags, period, offset;
 		int get;
 
 		if (sdp->isp_devparam[tgt].dev_enable == 0) {
@@ -5706,8 +5706,8 @@
 		}
 		if (isp->isp_confopts & ISP_CFG_OWNWWNN) {
 			isp_prt(isp, ISP_LOGCONFIG, "Using Node WWN 0x%08x%08x",
-			    (u_int32_t) (DEFAULT_NODEWWN(isp) >> 32),
-			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
+			    (uint32_t) (DEFAULT_NODEWWN(isp) >> 32),
+			    (uint32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
 			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
 		} else {
 			/*
@@ -5718,8 +5718,8 @@
 		}
 		if (isp->isp_confopts & ISP_CFG_OWNWWPN) {
 			isp_prt(isp, ISP_LOGCONFIG, "Using Port WWN 0x%08x%08x",
-			    (u_int32_t) (DEFAULT_PORTWWN(isp) >> 32),
-			    (u_int32_t) (DEFAULT_PORTWWN(isp) & 0xffffffff));
+			    (uint32_t) (DEFAULT_PORTWWN(isp) >> 32),
+			    (uint32_t) (DEFAULT_PORTWWN(isp) & 0xffffffff));
 			ISP_PORTWWN(isp) = DEFAULT_PORTWWN(isp);
 		} else {
 			/*
@@ -5816,7 +5816,7 @@
 	 * the default to the SAFE default state- that's not the goal state.
 	 */
 	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
-		u_int8_t off, per;
+		uint8_t off, per;
 		sdp->isp_devparam[tgt].actv_offset = 0;
 		sdp->isp_devparam[tgt].actv_period = 0;
 		sdp->isp_devparam[tgt].actv_flags = 0;
@@ -5894,7 +5894,7 @@
 	isp->isp_nactive = 0;
 
 	for (i = 0; i < isp->isp_maxcmds; i++) {
-		u_int16_t handle;
+		uint16_t handle;
 		xs = isp->isp_xflist[i];
 		if (xs == NULL) {
 			continue;
@@ -5919,10 +5919,10 @@
 isp_read_nvram(struct ispsoftc *isp)
 {
 	int i, amt;
-	u_int8_t csum, minversion;
+	uint8_t csum, minversion;
 	union {
-		u_int8_t _x[ISP2100_NVRAM_SIZE];
-		u_int16_t _s[ISP2100_NVRAM_SIZE>>1];
+		uint8_t _x[ISP2100_NVRAM_SIZE];
+		uint16_t _s[ISP2100_NVRAM_SIZE>>1];
 	} _n;
 #define	nvram_data	_n._x
 #define	nvram_words	_n._s
@@ -5990,10 +5990,10 @@
 }
 
 static void
-isp_rdnvram_word(struct ispsoftc *isp, int wo, u_int16_t *rp)
+isp_rdnvram_word(struct ispsoftc *isp, int wo, uint16_t *rp)
 {
 	int i, cbits;
-	u_int16_t bit, rqst;
+	uint16_t bit, rqst;
 
 	ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);
 	USEC_DELAY(2);
@@ -6038,7 +6038,7 @@
 	 */
 	*rp = 0;
 	for (i = 0; i < 16; i++) {
-		u_int16_t rv;
+		uint16_t rv;
 		*rp <<= 1;
 		ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);
 		USEC_DELAY(2);
@@ -6056,7 +6056,7 @@
 }
 
 static void
-isp_parse_nvram_1020(struct ispsoftc *isp, u_int8_t *nvram_data)
+isp_parse_nvram_1020(struct ispsoftc *isp, uint8_t *nvram_data)
 {
 	sdparam *sdp = (sdparam *) isp->isp_param;
 	int tgt;
@@ -6182,7 +6182,7 @@
 }
 
 static void
-isp_parse_nvram_1080(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
+isp_parse_nvram_1080(struct ispsoftc *isp, int bus, uint8_t *nvram_data)
 {
 	sdparam *sdp = (sdparam *) isp->isp_param;
 	int tgt;
@@ -6274,7 +6274,7 @@
 }
 
 static void
-isp_parse_nvram_12160(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
+isp_parse_nvram_12160(struct ispsoftc *isp, int bus, uint8_t *nvram_data)
 {
 	sdparam *sdp = (sdparam *) isp->isp_param;
 	int tgt;
@@ -6365,10 +6365,10 @@
 }
 
 static void
-isp_parse_nvram_2100(struct ispsoftc *isp, u_int8_t *nvram_data)
+isp_parse_nvram_2100(struct ispsoftc *isp, uint8_t *nvram_data)
 {
 	fcparam *fcp = (fcparam *) isp->isp_param;
-	u_int64_t wwn;
+	uint64_t wwn;
 
 	/*
 	 * There is NVRAM storage for both Port and Node entities-
@@ -6384,9 +6384,9 @@
 	wwn = ISP2100_NVRAM_PORT_NAME(nvram_data);
 	if (wwn) {
 		isp_prt(isp, ISP_LOGCONFIG, "NVRAM Port WWN 0x%08x%08x",
-		    (u_int32_t) (wwn >> 32), (u_int32_t) (wwn & 0xffffffff));
+		    (uint32_t) (wwn >> 32), (uint32_t) (wwn & 0xffffffff));
 		if ((wwn >> 60) == 0) {
-			wwn |= (((u_int64_t) 2)<< 60);
+			wwn |= (((uint64_t) 2)<< 60);
 		}
 	}
 	fcp->isp_portwwn = wwn;
@@ -6394,14 +6394,14 @@
 		wwn = ISP2200_NVRAM_NODE_NAME(nvram_data);
 		if (wwn) {
 			isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
-			    (u_int32_t) (wwn >> 32),
-			    (u_int32_t) (wwn & 0xffffffff));
+			    (uint32_t) (wwn >> 32),
+			    (uint32_t) (wwn & 0xffffffff));
 			if ((wwn >> 60) == 0) {
-				wwn |= (((u_int64_t) 2)<< 60);
+				wwn |= (((uint64_t) 2)<< 60);
 			}
 		}
 	} else {
-		wwn &= ~((u_int64_t) 0xfff << 48);
+		wwn &= ~((uint64_t) 0xfff << 48);
 	}
 	fcp->isp_nodewwn = wwn;
 
@@ -6421,13 +6421,13 @@
 	 * for the Port WWN.
 	 */
 	if (fcp->isp_nodewwn && fcp->isp_portwwn) {
-		if ((fcp->isp_nodewwn & (((u_int64_t) 0xfff) << 48)) != 0 &&
+		if ((fcp->isp_nodewwn & (((uint64_t) 0xfff) << 48)) != 0 &&
 		    (fcp->isp_nodewwn >> 60) == 2) {
-			fcp->isp_nodewwn &= ~((u_int64_t) 0xfff << 48);
+			fcp->isp_nodewwn &= ~((uint64_t) 0xfff << 48);
 		}
-		if ((fcp->isp_portwwn & (((u_int64_t) 0xfff) << 48)) == 0 &&
+		if ((fcp->isp_portwwn & (((uint64_t) 0xfff) << 48)) == 0 &&
 		    (fcp->isp_portwwn >> 60) == 2) {
-			fcp->isp_portwwn |= ((u_int64_t) 1 << 56);
+			fcp->isp_portwwn |= ((uint64_t) 1 << 56);
 		}
 	}
 
@@ -6465,7 +6465,7 @@
 {
 	int i, j;
 	mbreg_t mbs;
-	u_int16_t *ptr;
+	uint16_t *ptr;
 
 	ptr = FCPARAM(isp)->isp_dump_data;
 	if (ptr == NULL) {
@@ -6609,7 +6609,7 @@
 {
 	int i, j;
 	mbreg_t mbs;
-	u_int16_t *ptr;
+	uint16_t *ptr;
 
 	ptr = FCPARAM(isp)->isp_dump_data;
 	if (ptr == NULL) {

--- sys.old/dev/isp/ispvar.h	2005-05-10 20:22:17.000000000 -0400
+++ sys/dev/isp/ispvar.h	2005-09-03 16:09:08.000000000 -0400
@@ -62,20 +62,20 @@
 struct ispsoftc;
 struct ispmdvec {
 	int		(*dv_rd_isr)
-	    (struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
-	u_int16_t	(*dv_rd_reg) (struct ispsoftc *, int);
-	void		(*dv_wr_reg) (struct ispsoftc *, int, u_int16_t);
+	    (struct ispsoftc *, uint16_t *, uint16_t *, uint16_t *);
+	uint16_t	(*dv_rd_reg) (struct ispsoftc *, int);
+	void		(*dv_wr_reg) (struct ispsoftc *, int, uint16_t);
 	int		(*dv_mbxdma) (struct ispsoftc *);
 	int		(*dv_dmaset) (struct ispsoftc *,
-	    XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
+	    XS_T *, ispreq_t *, uint16_t *, uint16_t);
 	void		(*dv_dmaclr)
-	    (struct ispsoftc *, XS_T *, u_int16_t);
+	    (struct ispsoftc *, XS_T *, uint16_t);
 	void		(*dv_reset0) (struct ispsoftc *);
 	void		(*dv_reset1) (struct ispsoftc *);
 	void		(*dv_dregs) (struct ispsoftc *, const char *);
-	u_int16_t	*dv_ispfw;	/* ptr to f/w */
-	u_int16_t	dv_conf1;
-	u_int16_t	dv_clock;	/* clock frequency */
+	uint16_t	*dv_ispfw;	/* ptr to f/w */
+	uint16_t	dv_conf1;
+	uint16_t	dv_clock;	/* clock frequency */
 };
 
 /*
@@ -90,9 +90,9 @@
  * 'Types'
  */
 #ifdef	ISP_DAC_SUPPORTED
-typedef	u_int64_t	isp_dma_addr_t;
+typedef	uint64_t	isp_dma_addr_t;
 #else
-typedef	u_int32_t	isp_dma_addr_t;
+typedef	uint32_t	isp_dma_addr_t;
 #endif
 
 /*
@@ -188,14 +188,14 @@
 			isp_fast_mttr		: 1,	/* fast sram */
 			isp_initiator_id	: 4,
 			isp_async_data_setup	: 4;
-	u_int16_t	isp_selection_timeout;
-	u_int16_t	isp_max_queue_depth;
-	u_int8_t	isp_tag_aging;
-	u_int8_t	isp_bus_reset_delay;
-	u_int8_t	isp_retry_count;
-	u_int8_t	isp_retry_delay;
+	uint16_t	isp_selection_timeout;
+	uint16_t	isp_max_queue_depth;
+	uint8_t	isp_tag_aging;
+	uint8_t	isp_bus_reset_delay;
+	uint8_t	isp_retry_count;
+	uint8_t	isp_retry_delay;
 	struct {
-		u_int32_t	
+		uint32_t	
 			exc_throttle	:	8,
 					:	1,
 			dev_enable	:	1,	/* ignored */
@@ -204,12 +204,12 @@
 			actv_offset	:	4,
 			goal_offset	:	4,
 			nvrm_offset	:	4;
-		u_int8_t	actv_period;	/* current sync period */
-		u_int8_t	goal_period;	/* goal sync period */
-		u_int8_t	nvrm_period;	/* nvram sync period */
-		u_int16_t	actv_flags;	/* current device flags */
-		u_int16_t	goal_flags;	/* goal device flags */
-		u_int16_t	nvrm_flags;	/* nvram device flags */
+		uint8_t	actv_period;	/* current sync period */
+		uint8_t	goal_period;	/* goal sync period */
+		uint8_t	nvrm_period;	/* nvram sync period */
+		uint16_t	actv_flags;	/* current device flags */
+		uint16_t	goal_flags;	/* goal device flags */
+		uint16_t	nvrm_flags;	/* nvram device flags */
 	} isp_devparam[MAX_TARGETS];
 } sdparam;
 
@@ -254,7 +254,7 @@
 #endif
 
 typedef struct {
-	u_int32_t		isp_fwoptions	: 16,
+	uint32_t		isp_fwoptions	: 16,
 				isp_gbspeed	: 2,
 				isp_iid_set	: 1,
 				loop_seen_once	: 1,
@@ -263,20 +263,20 @@
 				isp_gotdparms	: 1,
 				isp_topo	: 3,
 				isp_onfabric	: 1;
-	u_int8_t		isp_iid;	/* 'initiator' id */
-	u_int8_t		isp_loopid;	/* hard loop id */
-	u_int8_t		isp_alpa;	/* ALPA */
-	u_int32_t		isp_portid;
-	volatile u_int16_t	isp_lipseq;	/* LIP sequence # */
-	u_int16_t		isp_fwattr;	/* firmware attributes */
-	u_int8_t		isp_execthrottle;
-	u_int8_t		isp_retry_delay;
-	u_int8_t		isp_retry_count;
-	u_int8_t		isp_reserved;
-	u_int16_t		isp_maxalloc;
-	u_int16_t		isp_maxfrmlen;
-	u_int64_t		isp_nodewwn;
-	u_int64_t		isp_portwwn;
+	uint8_t		isp_iid;	/* 'initiator' id */
+	uint8_t		isp_loopid;	/* hard loop id */
+	uint8_t		isp_alpa;	/* ALPA */
+	uint32_t		isp_portid;
+	volatile uint16_t	isp_lipseq;	/* LIP sequence # */
+	uint16_t		isp_fwattr;	/* firmware attributes */
+	uint8_t		isp_execthrottle;
+	uint8_t		isp_retry_delay;
+	uint8_t		isp_retry_count;
+	uint8_t		isp_reserved;
+	uint16_t		isp_maxalloc;
+	uint16_t		isp_maxfrmlen;
+	uint64_t		isp_nodewwn;
+	uint64_t		isp_portwwn;
 	/*
 	 * Port Data Base. This is indexed by 'target', which is invariate.
 	 * However, elements within can move around due to loop changes,
@@ -287,7 +287,7 @@
 	 * to move around.
 	 */
 	struct lportdb {
-		u_int32_t
+		uint32_t
 					port_type	: 8,
 					loopid		: 8,
 					fc4_type	: 4,
@@ -300,9 +300,9 @@
 					loggedin	: 1,
 					roles		: 2,
 					valid		: 1;
-		u_int32_t		portid;
-		u_int64_t		node_wwn;
-		u_int64_t		port_wwn;
+		uint32_t		portid;
+		uint64_t		node_wwn;
+		uint64_t		port_wwn;
 	} portdb[MAX_FC_TARG], tport[FC_PORT_ID];
 
 	/*
@@ -311,7 +311,7 @@
 	caddr_t			isp_scratch;
 	isp_dma_addr_t		isp_scdma;
 #ifdef	ISP_FW_CRASH_DUMP
-	u_int16_t		*isp_dump_data;
+	uint16_t		*isp_dump_data;
 #endif
 } fcparam;
 
@@ -360,14 +360,14 @@
 	 */
 
 	void * 			isp_param;	/* type specific */
-	u_int16_t		isp_fwrev[3];	/* Loaded F/W revision */
-	u_int16_t		isp_romfw_rev[3]; /* PROM F/W revision */
-	u_int16_t		isp_maxcmds;	/* max possible I/O cmds */
-	u_int8_t		isp_type;	/* HBA Chip Type */
-	u_int8_t		isp_revision;	/* HBA Chip H/W Revision */
-	u_int32_t		isp_maxluns;	/* maximum luns supported */
+	uint16_t		isp_fwrev[3];	/* Loaded F/W revision */
+	uint16_t		isp_romfw_rev[3]; /* PROM F/W revision */
+	uint16_t		isp_maxcmds;	/* max possible I/O cmds */
+	uint8_t		isp_type;	/* HBA Chip Type */
+	uint8_t		isp_revision;	/* HBA Chip H/W Revision */
+	uint32_t		isp_maxluns;	/* maximum luns supported */
 
-	u_int32_t		isp_clock	: 8,	/* input clock */
+	uint32_t		isp_clock	: 8,	/* input clock */
 						: 4,
 				isp_port	: 1,	/* 23XX only */
 				isp_failed	: 1,	/* board failed */
@@ -378,47 +378,47 @@
 				isp_role	: 2,	/* roles supported */
 				isp_dblev	: 12;	/* debug log mask */
 
-	u_int32_t		isp_confopts;		/* config options */
+	uint32_t		isp_confopts;		/* config options */
 
-	u_int16_t		isp_rqstinrp;	/* register for REQINP */
-	u_int16_t		isp_rqstoutrp;	/* register for REQOUTP */
-	u_int16_t		isp_respinrp;	/* register for RESINP */
-	u_int16_t		isp_respoutrp;	/* register for RESOUTP */
+	uint16_t		isp_rqstinrp;	/* register for REQINP */
+	uint16_t		isp_rqstoutrp;	/* register for REQOUTP */
+	uint16_t		isp_respinrp;	/* register for RESINP */
+	uint16_t		isp_respoutrp;	/* register for RESOUTP */
 
 	/*
 	 * Instrumentation
 	 */
-	u_int64_t		isp_intcnt;		/* total int count */
-	u_int64_t		isp_intbogus;		/* spurious int count */
-	u_int64_t		isp_intmboxc;		/* mbox completions */
-	u_int64_t		isp_intoasync;		/* other async */
-	u_int64_t		isp_rsltccmplt;		/* CMDs on result q */
-	u_int64_t		isp_fphccmplt;		/* CMDs via fastpost */
-	u_int16_t		isp_rscchiwater;
-	u_int16_t		isp_fpcchiwater;
+	uint64_t		isp_intcnt;		/* total int count */
+	uint64_t		isp_intbogus;		/* spurious int count */
+	uint64_t		isp_intmboxc;		/* mbox completions */
+	uint64_t		isp_intoasync;		/* other async */
+	uint64_t		isp_rsltccmplt;		/* CMDs on result q */
+	uint64_t		isp_fphccmplt;		/* CMDs via fastpost */
+	uint16_t		isp_rscchiwater;
+	uint16_t		isp_fpcchiwater;
 
 	/*
 	 * Volatile state
 	 */
 
-	volatile u_int32_t
+	volatile uint32_t
 		isp_obits	:	8,	/* mailbox command output */
 		isp_mboxbsy	:	1,	/* mailbox command active */
 		isp_state	:	3,
 		isp_sendmarker	:	2,	/* send a marker entry */
 		isp_update	:	2,	/* update parameters */
 		isp_nactive	:	16;	/* how many commands active */
-	volatile u_int16_t	isp_reqodx;	/* index of last ISP pickup */
-	volatile u_int16_t	isp_reqidx;	/* index of next request */
-	volatile u_int16_t	isp_residx;	/* index of next result */
-	volatile u_int16_t	isp_resodx;	/* index of next result */
-	volatile u_int16_t	isp_rspbsy;
-	volatile u_int16_t	isp_lasthdls;	/* last handle seed */
-	volatile u_int16_t	isp_mboxtmp[MAX_MAILBOX];
-	volatile u_int16_t	isp_lastmbxcmd;	/* last mbox command sent */
-	volatile u_int16_t	isp_mbxwrk0;
-	volatile u_int16_t	isp_mbxwrk1;
-	volatile u_int16_t	isp_mbxwrk2;
+	volatile uint16_t	isp_reqodx;	/* index of last ISP pickup */
+	volatile uint16_t	isp_reqidx;	/* index of next request */
+	volatile uint16_t	isp_residx;	/* index of next result */
+	volatile uint16_t	isp_resodx;	/* index of next result */
+	volatile uint16_t	isp_rspbsy;
+	volatile uint16_t	isp_lasthdls;	/* last handle seed */
+	volatile uint16_t	isp_mboxtmp[MAX_MAILBOX];
+	volatile uint16_t	isp_lastmbxcmd;	/* last mbox command sent */
+	volatile uint16_t	isp_mbxwrk0;
+	volatile uint16_t	isp_mbxwrk1;
+	volatile uint16_t	isp_mbxwrk2;
 	void *			isp_mbxworkp;
 
 	/*
@@ -622,7 +622,7 @@
  * semaphore register and first mailbox register (if appropriate). This also
  * means that most spurious/bogus interrupts not for us can be filtered first.
  */
-void isp_intr(struct ispsoftc *, u_int16_t, u_int16_t, u_int16_t);
+void isp_intr(struct ispsoftc *, uint16_t, uint16_t, uint16_t);
 
 
 /*
@@ -808,7 +808,7 @@
  *
  *	GET_NANOTIME(NANOTIME_T *)		get current nanotime.
  *
- *	GET_NANOSEC(NANOTIME_T *)		get u_int64_t from NANOTIME_T
+ *	GET_NANOSEC(NANOTIME_T *)		get uint64_t from NANOTIME_T
  *
  *	NANOTIME_SUB(NANOTIME_T *, NANOTIME_T *)
  *						subtract two NANOTIME_T values
@@ -897,15 +897,15 @@
  *
  *	(XXX these do endian specific transformations- in transition XXX)
  *
- *	ISP_IOXPUT_8(struct ispsoftc *, u_int8_t srcval, u_int8_t *dstptr)
- *	ISP_IOXPUT_16(struct ispsoftc *, u_int16_t srcval, u_int16_t *dstptr)
- *	ISP_IOXPUT_32(struct ispsoftc *, u_int32_t srcval, u_int32_t *dstptr)
- *
- *	ISP_IOXGET_8(struct ispsoftc *, u_int8_t *srcptr, u_int8_t dstrval)
- *	ISP_IOXGET_16(struct ispsoftc *, u_int16_t *srcptr, u_int16_t dstrval)
- *	ISP_IOXGET_32(struct ispsoftc *, u_int32_t *srcptr, u_int32_t dstrval)
+ *	ISP_IOXPUT_8(struct ispsoftc *, uint8_t srcval, uint8_t *dstptr)
+ *	ISP_IOXPUT_16(struct ispsoftc *, uint16_t srcval, uint16_t *dstptr)
+ *	ISP_IOXPUT_32(struct ispsoftc *, uint32_t srcval, uint32_t *dstptr)
+ *
+ *	ISP_IOXGET_8(struct ispsoftc *, uint8_t *srcptr, uint8_t dstrval)
+ *	ISP_IOXGET_16(struct ispsoftc *, uint16_t *srcptr, uint16_t dstrval)
+ *	ISP_IOXGET_32(struct ispsoftc *, uint32_t *srcptr, uint32_t dstrval)
  *
- *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, u_int16_t *)
+ *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, uint16_t *)
  */
 
 #endif	/* _ISPVAR_H */
