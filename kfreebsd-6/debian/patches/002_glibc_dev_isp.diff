
Merged in 7-CURRENT as of 2006-02-15.

Note: This isn't actualy needed for the kernel, since it doesn't use Glibc
  headers.  But since ispvar.h is exported to userland we need to patch it.
  (maybe we should move this to kfreebsd-kernel-headers?)

--- sys.old/dev/isp/ispvar.h	2005-05-10 20:22:17.000000000 -0400
+++ sys/dev/isp/ispvar.h	2005-09-03 16:09:08.000000000 -0400
@@ -62,20 +62,20 @@
 struct ispsoftc;
 struct ispmdvec {
 	int		(*dv_rd_isr)
-	    (struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
-	u_int16_t	(*dv_rd_reg) (struct ispsoftc *, int);
-	void		(*dv_wr_reg) (struct ispsoftc *, int, u_int16_t);
+	    (struct ispsoftc *, uint16_t *, uint16_t *, uint16_t *);
+	uint16_t	(*dv_rd_reg) (struct ispsoftc *, int);
+	void		(*dv_wr_reg) (struct ispsoftc *, int, uint16_t);
 	int		(*dv_mbxdma) (struct ispsoftc *);
 	int		(*dv_dmaset) (struct ispsoftc *,
-	    XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
+	    XS_T *, ispreq_t *, uint16_t *, uint16_t);
 	void		(*dv_dmaclr)
-	    (struct ispsoftc *, XS_T *, u_int16_t);
+	    (struct ispsoftc *, XS_T *, uint16_t);
 	void		(*dv_reset0) (struct ispsoftc *);
 	void		(*dv_reset1) (struct ispsoftc *);
 	void		(*dv_dregs) (struct ispsoftc *, const char *);
-	u_int16_t	*dv_ispfw;	/* ptr to f/w */
-	u_int16_t	dv_conf1;
-	u_int16_t	dv_clock;	/* clock frequency */
+	uint16_t	*dv_ispfw;	/* ptr to f/w */
+	uint16_t	dv_conf1;
+	uint16_t	dv_clock;	/* clock frequency */
 };
 
 /*
@@ -90,9 +90,9 @@
  * 'Types'
  */
 #ifdef	ISP_DAC_SUPPORTED
-typedef	u_int64_t	isp_dma_addr_t;
+typedef	uint64_t	isp_dma_addr_t;
 #else
-typedef	u_int32_t	isp_dma_addr_t;
+typedef	uint32_t	isp_dma_addr_t;
 #endif
 
 /*
@@ -188,14 +188,14 @@
 			isp_fast_mttr		: 1,	/* fast sram */
 			isp_initiator_id	: 4,
 			isp_async_data_setup	: 4;
-	u_int16_t	isp_selection_timeout;
-	u_int16_t	isp_max_queue_depth;
-	u_int8_t	isp_tag_aging;
-	u_int8_t	isp_bus_reset_delay;
-	u_int8_t	isp_retry_count;
-	u_int8_t	isp_retry_delay;
+	uint16_t	isp_selection_timeout;
+	uint16_t	isp_max_queue_depth;
+	uint8_t	isp_tag_aging;
+	uint8_t	isp_bus_reset_delay;
+	uint8_t	isp_retry_count;
+	uint8_t	isp_retry_delay;
 	struct {
-		u_int32_t	
+		uint32_t	
 			exc_throttle	:	8,
 					:	1,
 			dev_enable	:	1,	/* ignored */
@@ -204,12 +204,12 @@
 			actv_offset	:	4,
 			goal_offset	:	4,
 			nvrm_offset	:	4;
-		u_int8_t	actv_period;	/* current sync period */
-		u_int8_t	goal_period;	/* goal sync period */
-		u_int8_t	nvrm_period;	/* nvram sync period */
-		u_int16_t	actv_flags;	/* current device flags */
-		u_int16_t	goal_flags;	/* goal device flags */
-		u_int16_t	nvrm_flags;	/* nvram device flags */
+		uint8_t	actv_period;	/* current sync period */
+		uint8_t	goal_period;	/* goal sync period */
+		uint8_t	nvrm_period;	/* nvram sync period */
+		uint16_t	actv_flags;	/* current device flags */
+		uint16_t	goal_flags;	/* goal device flags */
+		uint16_t	nvrm_flags;	/* nvram device flags */
 	} isp_devparam[MAX_TARGETS];
 } sdparam;
 
@@ -254,7 +254,7 @@
 #endif
 
 typedef struct {
-	u_int32_t		isp_fwoptions	: 16,
+	uint32_t		isp_fwoptions	: 16,
 				isp_gbspeed	: 2,
 				isp_iid_set	: 1,
 				loop_seen_once	: 1,
@@ -263,20 +263,20 @@
 				isp_gotdparms	: 1,
 				isp_topo	: 3,
 				isp_onfabric	: 1;
-	u_int8_t		isp_iid;	/* 'initiator' id */
-	u_int8_t		isp_loopid;	/* hard loop id */
-	u_int8_t		isp_alpa;	/* ALPA */
-	u_int32_t		isp_portid;
-	volatile u_int16_t	isp_lipseq;	/* LIP sequence # */
-	u_int16_t		isp_fwattr;	/* firmware attributes */
-	u_int8_t		isp_execthrottle;
-	u_int8_t		isp_retry_delay;
-	u_int8_t		isp_retry_count;
-	u_int8_t		isp_reserved;
-	u_int16_t		isp_maxalloc;
-	u_int16_t		isp_maxfrmlen;
-	u_int64_t		isp_nodewwn;
-	u_int64_t		isp_portwwn;
+	uint8_t		isp_iid;	/* 'initiator' id */
+	uint8_t		isp_loopid;	/* hard loop id */
+	uint8_t		isp_alpa;	/* ALPA */
+	uint32_t		isp_portid;
+	volatile uint16_t	isp_lipseq;	/* LIP sequence # */
+	uint16_t		isp_fwattr;	/* firmware attributes */
+	uint8_t		isp_execthrottle;
+	uint8_t		isp_retry_delay;
+	uint8_t		isp_retry_count;
+	uint8_t		isp_reserved;
+	uint16_t		isp_maxalloc;
+	uint16_t		isp_maxfrmlen;
+	uint64_t		isp_nodewwn;
+	uint64_t		isp_portwwn;
 	/*
 	 * Port Data Base. This is indexed by 'target', which is invariate.
 	 * However, elements within can move around due to loop changes,
@@ -287,7 +287,7 @@
 	 * to move around.
 	 */
 	struct lportdb {
-		u_int32_t
+		uint32_t
 					port_type	: 8,
 					loopid		: 8,
 					fc4_type	: 4,
@@ -300,9 +300,9 @@
 					loggedin	: 1,
 					roles		: 2,
 					valid		: 1;
-		u_int32_t		portid;
-		u_int64_t		node_wwn;
-		u_int64_t		port_wwn;
+		uint32_t		portid;
+		uint64_t		node_wwn;
+		uint64_t		port_wwn;
 	} portdb[MAX_FC_TARG], tport[FC_PORT_ID];
 
 	/*
@@ -311,7 +311,7 @@
 	caddr_t			isp_scratch;
 	isp_dma_addr_t		isp_scdma;
 #ifdef	ISP_FW_CRASH_DUMP
-	u_int16_t		*isp_dump_data;
+	uint16_t		*isp_dump_data;
 #endif
 } fcparam;
 
@@ -360,14 +360,14 @@
 	 */
 
 	void * 			isp_param;	/* type specific */
-	u_int16_t		isp_fwrev[3];	/* Loaded F/W revision */
-	u_int16_t		isp_romfw_rev[3]; /* PROM F/W revision */
-	u_int16_t		isp_maxcmds;	/* max possible I/O cmds */
-	u_int8_t		isp_type;	/* HBA Chip Type */
-	u_int8_t		isp_revision;	/* HBA Chip H/W Revision */
-	u_int32_t		isp_maxluns;	/* maximum luns supported */
+	uint16_t		isp_fwrev[3];	/* Loaded F/W revision */
+	uint16_t		isp_romfw_rev[3]; /* PROM F/W revision */
+	uint16_t		isp_maxcmds;	/* max possible I/O cmds */
+	uint8_t		isp_type;	/* HBA Chip Type */
+	uint8_t		isp_revision;	/* HBA Chip H/W Revision */
+	uint32_t		isp_maxluns;	/* maximum luns supported */
 
-	u_int32_t		isp_clock	: 8,	/* input clock */
+	uint32_t		isp_clock	: 8,	/* input clock */
 						: 4,
 				isp_port	: 1,	/* 23XX only */
 				isp_failed	: 1,	/* board failed */
@@ -378,47 +378,47 @@
 				isp_role	: 2,	/* roles supported */
 				isp_dblev	: 12;	/* debug log mask */
 
-	u_int32_t		isp_confopts;		/* config options */
+	uint32_t		isp_confopts;		/* config options */
 
-	u_int16_t		isp_rqstinrp;	/* register for REQINP */
-	u_int16_t		isp_rqstoutrp;	/* register for REQOUTP */
-	u_int16_t		isp_respinrp;	/* register for RESINP */
-	u_int16_t		isp_respoutrp;	/* register for RESOUTP */
+	uint16_t		isp_rqstinrp;	/* register for REQINP */
+	uint16_t		isp_rqstoutrp;	/* register for REQOUTP */
+	uint16_t		isp_respinrp;	/* register for RESINP */
+	uint16_t		isp_respoutrp;	/* register for RESOUTP */
 
 	/*
 	 * Instrumentation
 	 */
-	u_int64_t		isp_intcnt;		/* total int count */
-	u_int64_t		isp_intbogus;		/* spurious int count */
-	u_int64_t		isp_intmboxc;		/* mbox completions */
-	u_int64_t		isp_intoasync;		/* other async */
-	u_int64_t		isp_rsltccmplt;		/* CMDs on result q */
-	u_int64_t		isp_fphccmplt;		/* CMDs via fastpost */
-	u_int16_t		isp_rscchiwater;
-	u_int16_t		isp_fpcchiwater;
+	uint64_t		isp_intcnt;		/* total int count */
+	uint64_t		isp_intbogus;		/* spurious int count */
+	uint64_t		isp_intmboxc;		/* mbox completions */
+	uint64_t		isp_intoasync;		/* other async */
+	uint64_t		isp_rsltccmplt;		/* CMDs on result q */
+	uint64_t		isp_fphccmplt;		/* CMDs via fastpost */
+	uint16_t		isp_rscchiwater;
+	uint16_t		isp_fpcchiwater;
 
 	/*
 	 * Volatile state
 	 */
 
-	volatile u_int32_t
+	volatile uint32_t
 		isp_obits	:	8,	/* mailbox command output */
 		isp_mboxbsy	:	1,	/* mailbox command active */
 		isp_state	:	3,
 		isp_sendmarker	:	2,	/* send a marker entry */
 		isp_update	:	2,	/* update parameters */
 		isp_nactive	:	16;	/* how many commands active */
-	volatile u_int16_t	isp_reqodx;	/* index of last ISP pickup */
-	volatile u_int16_t	isp_reqidx;	/* index of next request */
-	volatile u_int16_t	isp_residx;	/* index of next result */
-	volatile u_int16_t	isp_resodx;	/* index of next result */
-	volatile u_int16_t	isp_rspbsy;
-	volatile u_int16_t	isp_lasthdls;	/* last handle seed */
-	volatile u_int16_t	isp_mboxtmp[MAX_MAILBOX];
-	volatile u_int16_t	isp_lastmbxcmd;	/* last mbox command sent */
-	volatile u_int16_t	isp_mbxwrk0;
-	volatile u_int16_t	isp_mbxwrk1;
-	volatile u_int16_t	isp_mbxwrk2;
+	volatile uint16_t	isp_reqodx;	/* index of last ISP pickup */
+	volatile uint16_t	isp_reqidx;	/* index of next request */
+	volatile uint16_t	isp_residx;	/* index of next result */
+	volatile uint16_t	isp_resodx;	/* index of next result */
+	volatile uint16_t	isp_rspbsy;
+	volatile uint16_t	isp_lasthdls;	/* last handle seed */
+	volatile uint16_t	isp_mboxtmp[MAX_MAILBOX];
+	volatile uint16_t	isp_lastmbxcmd;	/* last mbox command sent */
+	volatile uint16_t	isp_mbxwrk0;
+	volatile uint16_t	isp_mbxwrk1;
+	volatile uint16_t	isp_mbxwrk2;
 	void *			isp_mbxworkp;
 
 	/*
@@ -622,7 +622,7 @@
  * semaphore register and first mailbox register (if appropriate). This also
  * means that most spurious/bogus interrupts not for us can be filtered first.
  */
-void isp_intr(struct ispsoftc *, u_int16_t, u_int16_t, u_int16_t);
+void isp_intr(struct ispsoftc *, uint16_t, uint16_t, uint16_t);
 
 
 /*
@@ -808,7 +808,7 @@
  *
  *	GET_NANOTIME(NANOTIME_T *)		get current nanotime.
  *
- *	GET_NANOSEC(NANOTIME_T *)		get u_int64_t from NANOTIME_T
+ *	GET_NANOSEC(NANOTIME_T *)		get uint64_t from NANOTIME_T
  *
  *	NANOTIME_SUB(NANOTIME_T *, NANOTIME_T *)
  *						subtract two NANOTIME_T values
@@ -897,15 +897,15 @@
  *
  *	(XXX these do endian specific transformations- in transition XXX)
  *
- *	ISP_IOXPUT_8(struct ispsoftc *, u_int8_t srcval, u_int8_t *dstptr)
- *	ISP_IOXPUT_16(struct ispsoftc *, u_int16_t srcval, u_int16_t *dstptr)
- *	ISP_IOXPUT_32(struct ispsoftc *, u_int32_t srcval, u_int32_t *dstptr)
- *
- *	ISP_IOXGET_8(struct ispsoftc *, u_int8_t *srcptr, u_int8_t dstrval)
- *	ISP_IOXGET_16(struct ispsoftc *, u_int16_t *srcptr, u_int16_t dstrval)
- *	ISP_IOXGET_32(struct ispsoftc *, u_int32_t *srcptr, u_int32_t dstrval)
+ *	ISP_IOXPUT_8(struct ispsoftc *, uint8_t srcval, uint8_t *dstptr)
+ *	ISP_IOXPUT_16(struct ispsoftc *, uint16_t srcval, uint16_t *dstptr)
+ *	ISP_IOXPUT_32(struct ispsoftc *, uint32_t srcval, uint32_t *dstptr)
+ *
+ *	ISP_IOXGET_8(struct ispsoftc *, uint8_t *srcptr, uint8_t dstrval)
+ *	ISP_IOXGET_16(struct ispsoftc *, uint16_t *srcptr, uint16_t dstrval)
+ *	ISP_IOXGET_32(struct ispsoftc *, uint32_t *srcptr, uint32_t dstrval)
  *
- *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, u_int16_t *)
+ *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, uint16_t *)
  */
 
 #endif	/* _ISPVAR_H */
