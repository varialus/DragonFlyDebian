
Backport from 9-STABLE (r226626)

--- a/sys/dev/syscons/teken/sequences
+++ b/sys/dev/syscons/teken/sequences
@@ -88,6 +88,7 @@
 IL	Insert line				^[ [ L		n
 IND	Index					^[ D
 NEL	Next line				^[ E
+OSC	Operating System Command		^[ ]
 RI	Reverse index				^[ M
 RIS	Reset to Initial State			^[ c
 RM	Reset Mode				^[ [ l		r
@@ -104,6 +105,8 @@
 C25ADFG	Cons25 set adapter foreground		^[ [ = F	r
 C25BLPD	Cons25 set bell pitch duration		^[ [ = B	r r
 C25CURS	Cons25 set cursor type			^[ [ = S	r
+C25MODE	Cons25 set terminal mode		^[ [ = T	r
+C25SGR	Cons25 set graphic rendition		^[ [ x		r r
 C25VTSW	Cons25 switch virtual terminal		^[ [ z		r
 
 # VT52 compatibility
--- a/sys/dev/syscons/teken/teken.c
+++ b/sys/dev/syscons/teken/teken.c
@@ -32,61 +32,36 @@
 #include <sys/lock.h>
 #include <sys/systm.h>
 #define	teken_assert(x)		MPASS(x)
-#define	teken_printf(x,...)
 #else /* !(__FreeBSD__ && _KERNEL) */
 #include <sys/types.h>
 #include <assert.h>
-#include <inttypes.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <string.h>
 #define	teken_assert(x)		assert(x)
-#define	teken_printf(x,...)	do { \
-	if (df != NULL) \
-		fprintf(df, x, ## __VA_ARGS__); \
-} while (0)
-/* debug messages */
-static FILE *df;
 #endif /* __FreeBSD__ && _KERNEL */
 
-#include "teken.h"
-
-#ifdef TEKEN_UTF8
-#include "teken_wcwidth.h"
-#else /* !TEKEN_UTF8 */
-#ifdef TEKEN_XTERM
-#define	teken_wcwidth(c)	((c <= 0x1B) ? -1 : 1)
-#else /* !TEKEN_XTERM */
-#define	teken_wcwidth(c)	(1)
-#endif /* TEKEN_XTERM */
-#endif /* TEKEN_UTF8 */
-
-#if defined(TEKEN_XTERM) && defined(TEKEN_UTF8)
-#include "teken_scs.h"
-#else /* !(TEKEN_XTERM && TEKEN_UTF8) */
-#define	teken_scs_process(t, c)	(c)
-#define	teken_scs_restore(t)
-#define	teken_scs_save(t)
-#define	teken_scs_set(t, g, ts)
-#define	teken_scs_switch(t, g)
-#endif /* TEKEN_XTERM && TEKEN_UTF8 */
-
-/* Private flags for teken_format_t. */
-#define	TF_REVERSE	0x08
+/* debug messages */
+#define	teken_printf(x,...)
 
 /* Private flags for t_stateflags. */
-#define	TS_FIRSTDIGIT	0x01	/* First numeric digit in escape sequence. */
-#define	TS_INSERT	0x02	/* Insert mode. */
-#define	TS_AUTOWRAP	0x04	/* Autowrap. */
-#define	TS_ORIGIN	0x08	/* Origin mode. */
-#ifdef TEKEN_XTERM
-#define	TS_WRAPPED	0x10	/* Next character should be printed on col 0. */
-#else /* !TEKEN_XTERM */
-#define	TS_WRAPPED	0x00	/* Simple line wrapping. */
-#endif /* TEKEN_XTERM */
+#define	TS_FIRSTDIGIT	0x0001	/* First numeric digit in escape sequence. */
+#define	TS_INSERT	0x0002	/* Insert mode. */
+#define	TS_AUTOWRAP	0x0004	/* Autowrap. */
+#define	TS_ORIGIN	0x0008	/* Origin mode. */
+#define	TS_WRAPPED	0x0010	/* Next character should be printed on col 0. */
+#define	TS_8BIT		0x0020	/* UTF-8 disabled. */
+#define	TS_CONS25	0x0040	/* cons25 emulation. */
+#define	TS_INSTRING	0x0080	/* Inside string. */
+#define	TS_CURSORKEYS	0x0100	/* Cursor keys mode. */
 
 /* Character that blanks a cell. */
 #define	BLANK	' '
 
+#include "teken.h"
+#include "teken_wcwidth.h"
+#include "teken_scs.h"
+
 static teken_state_t	teken_state_init;
 
 /*
@@ -114,19 +89,10 @@
 teken_funcs_putchar(teken_t *t, const teken_pos_t *p, teken_char_t c,
     const teken_attr_t *a)
 {
-	teken_attr_t ta;
 
 	teken_assert(p->tp_row < t->t_winsize.tp_row);
 	teken_assert(p->tp_col < t->t_winsize.tp_col);
 
-	/* Apply inversion. */
-	if (a->ta_format & TF_REVERSE) {
-		ta.ta_format = a->ta_format;
-		ta.ta_fgcolor = a->ta_bgcolor;
-		ta.ta_bgcolor = a->ta_fgcolor;
-		a = &ta;
-	}
-
 	t->t_funcs->tf_putchar(t->t_softc, p, c, a);
 }
 
@@ -134,21 +100,12 @@
 teken_funcs_fill(teken_t *t, const teken_rect_t *r,
     const teken_char_t c, const teken_attr_t *a)
 {
-	teken_attr_t ta;
 
 	teken_assert(r->tr_end.tp_row > r->tr_begin.tp_row);
 	teken_assert(r->tr_end.tp_row <= t->t_winsize.tp_row);
 	teken_assert(r->tr_end.tp_col > r->tr_begin.tp_col);
 	teken_assert(r->tr_end.tp_col <= t->t_winsize.tp_col);
 
-	/* Apply inversion. */
-	if (a->ta_format & TF_REVERSE) {
-		ta.ta_format = a->ta_format;
-		ta.ta_fgcolor = a->ta_bgcolor;
-		ta.ta_bgcolor = a->ta_fgcolor;
-		a = &ta;
-	}
-
 	t->t_funcs->tf_fill(t->t_softc, r, c, a);
 }
 
@@ -192,26 +149,18 @@
 {
 	teken_pos_t tp = { .tp_row = 24, .tp_col = 80 };
 
-#if !(defined(__FreeBSD__) && defined(_KERNEL))
-	df = fopen("teken.log", "w");
-	if (df != NULL)
-		setvbuf(df, NULL, _IOLBF, BUFSIZ);
-#endif /* !(__FreeBSD__ && _KERNEL) */
-
 	t->t_funcs = tf;
 	t->t_softc = softc;
 
 	t->t_nextstate = teken_state_init;
+	t->t_stateflags = 0;
+	t->t_utf8_left = 0;
 
 	t->t_defattr.ta_format = 0;
 	t->t_defattr.ta_fgcolor = TC_WHITE;
 	t->t_defattr.ta_bgcolor = TC_BLACK;
 	teken_subr_do_reset(t);
 
-#ifdef TEKEN_UTF8
-	t->t_utf8_left = 0;
-#endif /* TEKEN_UTF8 */
-
 	teken_set_winsize(t, &tp);
 }
 
@@ -219,6 +168,24 @@
 teken_input_char(teken_t *t, teken_char_t c)
 {
 
+	/*
+	 * There is no support for DCS and OSC.  Just discard strings
+	 * until we receive characters that may indicate string
+	 * termination.
+	 */
+	if (t->t_stateflags & TS_INSTRING) {
+		switch (c) {
+		case '\x1B':
+			t->t_stateflags &= ~TS_INSTRING;
+			break;
+		case '\a':
+			t->t_stateflags &= ~TS_INSTRING;
+			return;
+		default:
+			return;
+		}
+	}
+
 	switch (c) {
 	case '\0':
 		break;
@@ -235,14 +202,18 @@
 	case '\x0C':
 		teken_subr_newpage(t);
 		break;
-#if defined(TEKEN_XTERM) && defined(TEKEN_UTF8)
 	case '\x0E':
-		teken_scs_switch(t, 1);
+		if (t->t_stateflags & TS_CONS25)
+			t->t_nextstate(t, c);
+		else
+			t->t_curscs = 1;
 		break;
 	case '\x0F':
-		teken_scs_switch(t, 0);
+		if (t->t_stateflags & TS_CONS25)
+			t->t_nextstate(t, c);
+		else
+			t->t_curscs = 0;
 		break;
-#endif /* TEKEN_XTERM && TEKEN_UTF8 */
 	case '\r':
 		teken_subr_carriage_return(t);
 		break;
@@ -274,11 +245,10 @@
 teken_input_byte(teken_t *t, unsigned char c)
 {
 
-#ifdef TEKEN_UTF8
 	/*
 	 * UTF-8 handling.
 	 */
-	if ((c & 0x80) == 0x00) {
+	if ((c & 0x80) == 0x00 || t->t_stateflags & TS_8BIT) {
 		/* One-byte sequence. */
 		t->t_utf8_left = 0;
 		teken_input_char(t, c);
@@ -304,9 +274,6 @@
 			teken_input_char(t, t->t_utf8_partial);
 		}
 	}
-#else /* !TEKEN_UTF8 */
-	teken_input_char(t, c);
-#endif /* TEKEN_UTF8 */
 }
 
 void
@@ -318,6 +285,13 @@
 		teken_input_byte(t, *c++);
 }
 
+const teken_pos_t *
+teken_get_cursor(teken_t *t)
+{
+
+	return (&t->t_cursor);
+}
+
 void
 teken_set_cursor(teken_t *t, const teken_pos_t *p)
 {
@@ -357,15 +331,33 @@
 	t->t_curattr = t->t_saved_curattr = t->t_defattr = *a;
 }
 
+const teken_pos_t *
+teken_get_winsize(teken_t *t)
+{
+
+	return (&t->t_winsize);
+}
+
 void
 teken_set_winsize(teken_t *t, const teken_pos_t *p)
 {
 
 	t->t_winsize = *p;
-	/* XXX: bounds checking with cursor/etc! */
-	t->t_scrollreg.ts_begin = 0;
-	t->t_scrollreg.ts_end = t->t_winsize.tp_row;
-	t->t_originreg = t->t_scrollreg;
+	teken_subr_do_reset(t);
+}
+
+void
+teken_set_8bit(teken_t *t)
+{
+
+	t->t_stateflags |= TS_8BIT;
+}
+
+void
+teken_set_cons25(teken_t *t)
+{
+
+	t->t_stateflags |= TS_CONS25;
 }
 
 /*
@@ -427,4 +419,115 @@
 	return (0);
 }
 
+teken_color_t
+teken_256to8(teken_color_t c)
+{
+	unsigned int r, g, b;
+
+	if (c < 16) {
+		/* Traditional color indices. */
+		return (c % 8);
+	} else if (c >= 244) {
+		/* Upper grayscale colors. */
+		return (TC_WHITE);
+	} else if (c >= 232) {
+		/* Lower grayscale colors. */
+		return (TC_BLACK);
+	}
+
+	/* Convert to RGB. */
+	c -= 16;
+	b = c % 6;
+	g = (c / 6) % 6;
+	r = c / 36;
+
+	if (r < g) {
+		/* Possibly green. */
+		if (g < b)
+			return (TC_BLUE);
+		else if (g > b)
+			return (TC_GREEN);
+		else
+			return (TC_CYAN);
+	} else if (r > g) {
+		/* Possibly red. */
+		if (r < b)
+			return (TC_BLUE);
+		else if (r > b)
+			return (TC_RED);
+		else
+			return (TC_MAGENTA);
+	} else {
+		/* Possibly brown. */
+		if (g < b)
+			return (TC_BLUE);
+		else if (g > b)
+			return (TC_BROWN);
+		else if (r < 3)
+			return (TC_BLACK);
+		else
+			return (TC_WHITE);
+	}
+}
+
+static const char * const special_strings_cons25[] = {
+	[TKEY_UP] = "\x1B[A",		[TKEY_DOWN] = "\x1B[B",
+	[TKEY_LEFT] = "\x1B[D",		[TKEY_RIGHT] = "\x1B[C",
+
+	[TKEY_HOME] = "\x1B[H",		[TKEY_END] = "\x1B[F",
+	[TKEY_INSERT] = "\x1B[L",	[TKEY_DELETE] = "\x7F",
+	[TKEY_PAGE_UP] = "\x1B[I",	[TKEY_PAGE_DOWN] = "\x1B[G",
+
+	[TKEY_F1] = "\x1B[M",		[TKEY_F2] = "\x1B[N",
+	[TKEY_F3] = "\x1B[O",		[TKEY_F4] = "\x1B[P",
+	[TKEY_F5] = "\x1B[Q",		[TKEY_F6] = "\x1B[R",
+	[TKEY_F7] = "\x1B[S",		[TKEY_F8] = "\x1B[T",
+	[TKEY_F9] = "\x1B[U",		[TKEY_F10] = "\x1B[V",
+	[TKEY_F11] = "\x1B[W",		[TKEY_F12] = "\x1B[X",
+};
+
+static const char * const special_strings_ckeys[] = {
+	[TKEY_UP] = "\x1BOA",		[TKEY_DOWN] = "\x1BOB",
+	[TKEY_LEFT] = "\x1BOD",		[TKEY_RIGHT] = "\x1BOC",
+
+	[TKEY_HOME] = "\x1BOH",		[TKEY_END] = "\x1BOF",
+};
+
+static const char * const special_strings_normal[] = {
+	[TKEY_UP] = "\x1B[A",		[TKEY_DOWN] = "\x1B[B",
+	[TKEY_LEFT] = "\x1B[D",		[TKEY_RIGHT] = "\x1B[C",
+
+	[TKEY_HOME] = "\x1B[H",		[TKEY_END] = "\x1B[F",
+	[TKEY_INSERT] = "\x1B[2~",	[TKEY_DELETE] = "\x1B[3~",
+	[TKEY_PAGE_UP] = "\x1B[5~",	[TKEY_PAGE_DOWN] = "\x1B[6~",
+
+	[TKEY_F1] = "\x1BOP",		[TKEY_F2] = "\x1BOQ",
+	[TKEY_F3] = "\x1BOR",		[TKEY_F4] = "\x1BOS",
+	[TKEY_F5] = "\x1B[15~",		[TKEY_F6] = "\x1B[17~",
+	[TKEY_F7] = "\x1B[18~",		[TKEY_F8] = "\x1B[19~",
+	[TKEY_F9] = "\x1B[20~",		[TKEY_F10] = "\x1B[21~",
+	[TKEY_F11] = "\x1B[23~",	[TKEY_F12] = "\x1B[24~",
+};
+
+const char *
+teken_get_sequence(teken_t *t, unsigned int k)
+{
+
+	/* Cons25 mode. */
+	if (t->t_stateflags & TS_CONS25 &&
+	    k < sizeof special_strings_cons25 / sizeof(char *))
+		return (special_strings_cons25[k]);
+
+	/* Cursor keys mode. */
+	if (t->t_stateflags & TS_CURSORKEYS &&
+	    k < sizeof special_strings_ckeys / sizeof(char *))
+		return (special_strings_ckeys[k]);
+
+	/* Default xterm sequences. */
+	if (k < sizeof special_strings_normal / sizeof(char *))
+		return (special_strings_normal[k]);
+
+	return (NULL);
+}
+
 #include "teken_state.h"
--- a/sys/dev/syscons/teken/teken.h
+++ b/sys/dev/syscons/teken/teken.h
@@ -29,31 +29,22 @@
 #ifndef _TEKEN_H_
 #define	_TEKEN_H_
 
+#include <sys/types.h>
+
 /*
  * libteken: terminal emulation library.
  *
  * This library converts an UTF-8 stream of bytes to terminal drawing
  * commands.
- *
- * Configuration switches:
- * - TEKEN_UTF8: Enable/disable UTF-8 handling.
- * - TEKEN_XTERM: Enable xterm-style emulation, instead of cons25.
  */
 
-#if defined(__FreeBSD__) && defined(_KERNEL)
-#include "opt_teken.h"
-#endif /* __FreeBSD__ && _KERNEL */
-
-#ifdef TEKEN_UTF8
 typedef uint32_t teken_char_t;
-#else /* !TEKEN_UTF8 */
-typedef unsigned char teken_char_t;
-#endif /* TEKEN_UTF8 */
 typedef unsigned short teken_unit_t;
 typedef unsigned char teken_format_t;
 #define	TF_BOLD		0x01
 #define	TF_UNDERLINE	0x02
 #define	TF_BLINK	0x04
+#define	TF_REVERSE	0x08
 typedef unsigned char teken_color_t;
 #define	TC_BLACK	0
 #define	TC_RED		1
@@ -100,14 +91,14 @@
 typedef void tf_copy_t(void *, const teken_rect_t *, const teken_pos_t *);
 typedef void tf_param_t(void *, int, unsigned int);
 #define	TP_SHOWCURSOR	0
-#define	TP_CURSORKEYS	1
-#define	TP_KEYPADAPP	2
-#define	TP_AUTOREPEAT	3
-#define	TP_SWITCHVT	4
-#define	TP_132COLS	5
-#define	TP_SETBELLPD	6
+#define	TP_KEYPADAPP	1
+#define	TP_AUTOREPEAT	2
+#define	TP_SWITCHVT	3
+#define	TP_132COLS	4
+#define	TP_SETBELLPD	5
 #define	TP_SETBELLPD_PITCH(pd)		((pd) >> 16)
 #define	TP_SETBELLPD_DURATION(pd)	((pd) & 0xffff)
+#define	TP_MOUSE	6
 typedef void tf_respond_t(void *, const void *, size_t);
 
 typedef struct {
@@ -120,9 +111,7 @@
 	tf_respond_t	*tf_respond;
 } teken_funcs_t;
 
-#if defined(TEKEN_XTERM) && defined(TEKEN_UTF8)
-typedef teken_char_t teken_scs_t(teken_char_t);
-#endif /* TEKEN_XTERM && TEKEN_UTF8 */
+typedef teken_char_t teken_scs_t(teken_t *, teken_char_t);
 
 /*
  * Terminal state.
@@ -155,16 +144,12 @@
 #define	T_NUMCOL	160
 	unsigned int	 t_tabstops[T_NUMCOL / (sizeof(unsigned int) * 8)];
 
-#ifdef TEKEN_UTF8
 	unsigned int	 t_utf8_left;
 	teken_char_t	 t_utf8_partial;
-#endif /* TEKEN_UTF8 */
 
-#if defined(TEKEN_XTERM) && defined(TEKEN_UTF8)
 	unsigned int	 t_curscs;
 	teken_scs_t	*t_saved_curscs;
 	teken_scs_t	*t_scs[2];
-#endif /* TEKEN_XTERM && TEKEN_UTF8 */
 };
 
 /* Initialize teken structure. */
@@ -174,11 +159,48 @@
 void	teken_input(teken_t *, const void *, size_t);
 
 /* Get/set teken attributes. */
+const teken_pos_t *teken_get_cursor(teken_t *);
 const teken_attr_t *teken_get_curattr(teken_t *);
 const teken_attr_t *teken_get_defattr(teken_t *);
+void	teken_get_defattr_cons25(teken_t *, int *, int *);
+const teken_pos_t *teken_get_winsize(teken_t *);
 void	teken_set_cursor(teken_t *, const teken_pos_t *);
 void	teken_set_curattr(teken_t *, const teken_attr_t *);
 void	teken_set_defattr(teken_t *, const teken_attr_t *);
 void	teken_set_winsize(teken_t *, const teken_pos_t *);
 
+/* Key input escape sequences. */
+#define	TKEY_UP		0x00
+#define	TKEY_DOWN	0x01
+#define	TKEY_LEFT	0x02
+#define	TKEY_RIGHT	0x03
+
+#define	TKEY_HOME	0x04
+#define	TKEY_END	0x05
+#define	TKEY_INSERT	0x06
+#define	TKEY_DELETE	0x07
+#define	TKEY_PAGE_UP	0x08
+#define	TKEY_PAGE_DOWN	0x09
+
+#define	TKEY_F1		0x0a
+#define	TKEY_F2		0x0b
+#define	TKEY_F3		0x0c
+#define	TKEY_F4		0x0d
+#define	TKEY_F5		0x0e
+#define	TKEY_F6		0x0f
+#define	TKEY_F7		0x10
+#define	TKEY_F8		0x11
+#define	TKEY_F9		0x12
+#define	TKEY_F10	0x13
+#define	TKEY_F11	0x14
+#define	TKEY_F12	0x15
+const char *teken_get_sequence(teken_t *, unsigned int);
+
+/* Legacy features. */
+void	teken_set_8bit(teken_t *);
+void	teken_set_cons25(teken_t *);
+
+/* Color conversion. */
+teken_color_t teken_256to8(teken_color_t);
+
 #endif /* !_TEKEN_H_ */
--- a/sys/dev/syscons/teken/teken_demo.c
+++ b/sys/dev/syscons/teken/teken_demo.c
@@ -45,7 +45,7 @@
 #include <util.h>
 #endif
 
-#include "teken.h"
+#include <teken.h>
 
 static tf_bell_t	test_bell;
 static tf_cursor_t	test_cursor;
@@ -71,11 +71,7 @@
 };
 
 #define NCOLS	80
-#ifdef TEKEN_XTERM
 #define NROWS	24
-#else /* !TEKEN_XTERM */
-#define NROWS	25
-#endif /* TEKEN_XTERM */
 struct pixel buffer[NCOLS][NROWS];
 
 static int ptfd;
@@ -92,10 +88,9 @@
 
 	getyx(stdscr, y, x);
 
- 	px = &buffer[p->tp_col][p->tp_row];
+	px = &buffer[p->tp_col][p->tp_row];
 
 	/* Convert Unicode to UTF-8. */
-#ifdef TEKEN_UTF8
 	if (px->c < 0x80) {
 		str[0] = px->c;
 	} else if (px->c < 0x800) {
@@ -111,9 +106,6 @@
 		str[2] = 0x80 | ((px->c >> 6) & 0x3f);
 		str[3] = 0x80 | (px->c & 0x3f);
 	}
-#else /* !TEKEN_UTF8 */
-	str[0] = px->c;
-#endif /* TEKEN_UTF8 */
 
 	if (px->a.ta_format & TF_BOLD)
 		attr |= A_BOLD;
@@ -121,8 +113,11 @@
 		attr |= A_UNDERLINE;
 	if (px->a.ta_format & TF_BLINK)
 		attr |= A_BLINK;
+	if (px->a.ta_format & TF_REVERSE)
+		attr |= A_REVERSE;
 
-	bkgdset(attr | COLOR_PAIR(px->a.ta_fgcolor + 8 * px->a.ta_bgcolor));
+	bkgdset(attr | COLOR_PAIR(teken_256to8(px->a.ta_fgcolor) +
+	      8 * teken_256to8(px->a.ta_bgcolor)));
 	mvaddstr(p->tp_row, p->tp_col, str);
 
 	move(y, x);
@@ -174,10 +169,10 @@
 	 * Copying is a little tricky. We must make sure we do it in
 	 * correct order, to make sure we don't overwrite our own data.
 	 */
-	
+
 	nrow = r->tr_end.tp_row - r->tr_begin.tp_row;
 	ncol = r->tr_end.tp_col - r->tr_begin.tp_col;
-	
+
 	if (p->tp_row < r->tr_begin.tp_row) {
 		/* Copy from top to bottom. */
 		if (p->tp_col < r->tr_begin.tp_col) {
@@ -292,9 +287,7 @@
 	};
 	int i, j;
 
-#ifdef TEKEN_UTF8
 	setlocale(LC_CTYPE, "UTF-8");
-#endif /* TEKEN_UTF8 */
 
 	tp.tp_row = ws.ws_row = NROWS;
 	tp.tp_col = ws.ws_col = NCOLS;
@@ -304,14 +297,8 @@
 		perror("forkpty");
 		exit(1);
 	case 0:
-#ifdef TEKEN_XTERM
 		setenv("TERM", "xterm", 1);
-#else /* !TEKEN_XTERM */
-		setenv("TERM", "cons25", 1);
-#endif /* TEKEN_XTERM */
-#ifdef TEKEN_UTF8
 		setenv("LC_CTYPE", "UTF-8", 0);
-#endif /* TEKEN_UTF8 */
 		execlp("zsh", "-zsh", NULL);
 		execlp("bash", "-bash", NULL);
 		execlp("sh", "-sh", NULL);
--- a/sys/dev/syscons/teken/teken_scs.h
+++ b/sys/dev/syscons/teken/teken_scs.h
@@ -26,71 +26,53 @@
  * $FreeBSD$
  */
 
-static void
-teken_scs_set(teken_t *t, unsigned int g, teken_scs_t *ts)
-{
-
-	t->t_scs[g] = ts;
-}
-
-static void
-teken_scs_switch(teken_t *t, unsigned int g)
-{
-
-	t->t_curscs = g;
-}
-
-static void
-teken_scs_restore(teken_t *t)
-{
-
-	t->t_scs[t->t_curscs] = t->t_saved_curscs;
-}
-
-static void
-teken_scs_save(teken_t *t)
-{
-
-	t->t_saved_curscs = t->t_scs[t->t_curscs];
-}
-
-static teken_char_t
+static inline teken_char_t
 teken_scs_process(teken_t *t, teken_char_t c)
 {
 
-	return (t->t_scs[t->t_curscs](c));
+	return (t->t_scs[t->t_curscs](t, c));
 }
 
 /* Unicode points for VT100 box drawing. */
-static const uint16_t teken_boxdrawing[31] = {
+static const uint16_t teken_boxdrawing_unicode[31] = {
     0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
     0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0x23ba,
     0x23bb, 0x2500, 0x23bc, 0x23bd, 0x251c, 0x2524, 0x2534, 0x252c,
     0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7
 };
 
+/* ASCII points for VT100 box drawing. */
+static const uint8_t teken_boxdrawing_8bit[31] = {
+    '?', '?', 'H', 'F', 'C', 'L', '?', '?',
+    'N', 'V', '+', '+', '+', '+', '+', '-',
+    '-', '-', '-', '-', '+', '+', '+', '+',
+    '|', '?', '?', '?', '?', '?', '?',
+};
+
 static teken_char_t
-teken_scs_special_graphics(teken_char_t c)
+teken_scs_special_graphics(teken_t *t, teken_char_t c)
 {
 
 	/* Box drawing. */
 	if (c >= '`' && c <= '~')
-		return (teken_boxdrawing[c - '`']);
+		return (t->t_stateflags & TS_8BIT ?
+		    teken_boxdrawing_8bit[c - '`'] :
+		    teken_boxdrawing_unicode[c - '`']);
 	return (c);
 }
 
 static teken_char_t
-teken_scs_uk_national(teken_char_t c)
+teken_scs_uk_national(teken_t *t, teken_char_t c)
 {
 
 	/* Pound sign. */
 	if (c == '#')
-		return (0xa3);
+		return (t->t_stateflags & TS_8BIT ? 0x9c : 0xa3);
 	return (c);
 }
 
 static teken_char_t
-teken_scs_us_ascii(teken_char_t c)
+teken_scs_us_ascii(teken_t *t __unused, teken_char_t c)
 {
 
 	/* No processing. */
--- a/sys/dev/syscons/teken/teken_stress.c
+++ b/sys/dev/syscons/teken/teken_stress.c
@@ -34,7 +34,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 
-#include "teken.h"
+#include <teken.h>
 
 static tf_bell_t	stress_bell;
 static tf_cursor_t	stress_cursor;
@@ -92,13 +92,16 @@
 {
 }
 
+static const char replacement[] =
+    { 0x1b, '[', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ';' };
+
 int
 main(int argc __unused, char *argv[] __unused)
 {
 	teken_t t;
 	int rnd;
-	unsigned int iteration = 0;
-	char buf[2048];
+	unsigned int i, iteration = 0;
+	unsigned char buf[2048];
 
 	rnd = open("/dev/urandom", O_RDONLY);
 	if (rnd < 0) {
@@ -114,6 +117,12 @@
 			exit(1);
 		}
 
+		for (i = 0; i < sizeof buf; i++) {
+			if (buf[i] >= 0x80)
+				buf[i] =
+				    replacement[buf[i] % sizeof replacement];
+		}
+
 		teken_input(&t, buf, sizeof buf);
 
 		iteration++;
--- a/sys/dev/syscons/teken/teken_subr.h
+++ b/sys/dev/syscons/teken/teken_subr.h
@@ -185,11 +185,11 @@
 {
 	teken_rect_t tr;
 
+	t->t_cursor.tp_row = t->t_cursor.tp_col = 0;
 	t->t_scrollreg.ts_begin = 0;
 	t->t_scrollreg.ts_end = t->t_winsize.tp_row;
-
-	t->t_cursor.tp_row = t->t_cursor.tp_col = 0;
-	t->t_stateflags &= ~TS_WRAPPED;
+	t->t_originreg = t->t_scrollreg;
+	t->t_stateflags &= ~(TS_WRAPPED|TS_ORIGIN);
 	teken_funcs_cursor(t);
 
 	tr.tr_begin.tp_row = 0;
@@ -202,22 +202,22 @@
 teken_subr_backspace(teken_t *t)
 {
 
-#ifdef TEKEN_XTERM
-	if (t->t_cursor.tp_col == 0)
-		return;
-
-	t->t_cursor.tp_col--;
-	t->t_stateflags &= ~TS_WRAPPED;
-#else /* !TEKEN_XTERM */
-	if (t->t_cursor.tp_col == 0) {
-		if (t->t_cursor.tp_row == t->t_originreg.ts_begin)
-			return;
-		t->t_cursor.tp_row--;
-		t->t_cursor.tp_col = t->t_winsize.tp_col - 1;
+	if (t->t_stateflags & TS_CONS25) {
+		if (t->t_cursor.tp_col == 0) {
+			if (t->t_cursor.tp_row == t->t_originreg.ts_begin)
+				return;
+			t->t_cursor.tp_row--;
+			t->t_cursor.tp_col = t->t_winsize.tp_col - 1;
+		} else {
+			t->t_cursor.tp_col--;
+		}
 	} else {
+		if (t->t_cursor.tp_col == 0)
+			return;
+
 		t->t_cursor.tp_col--;
+		t->t_stateflags &= ~TS_WRAPPED;
 	}
-#endif /* TEKEN_XTERM */
 
 	teken_funcs_cursor(t);
 }
@@ -260,7 +260,7 @@
 			break;
 
 		t->t_cursor.tp_col--;
-		
+
 		/* Tab marker set. */
 		if (teken_tab_isset(t, t->t_cursor.tp_col))
 			ntabs--;
@@ -303,7 +303,7 @@
 			break;
 
 		t->t_cursor.tp_col++;
-		
+
 		/* Tab marker set. */
 		if (teken_tab_isset(t, t->t_cursor.tp_col))
 			ntabs--;
@@ -325,7 +325,7 @@
 {
 
 	t->t_cursor.tp_row = t->t_originreg.ts_begin + row - 1;
-	if (row >= t->t_originreg.ts_end)
+	if (t->t_cursor.tp_row >= t->t_originreg.ts_end)
 		t->t_cursor.tp_row = t->t_originreg.ts_end - 1;
 
 	t->t_cursor.tp_col = col - 1;
@@ -397,6 +397,11 @@
 {
 	teken_rect_t tr;
 
+	/* Ignore if outside scrolling region. */
+	if (t->t_cursor.tp_row < t->t_scrollreg.ts_begin ||
+	    t->t_cursor.tp_row >= t->t_scrollreg.ts_end)
+		return;
+
 	tr.tr_begin.tp_col = 0;
 	tr.tr_end.tp_row = t->t_scrollreg.ts_end;
 	tr.tr_end.tp_col = t->t_winsize.tp_col;
@@ -420,10 +425,11 @@
 }
 
 static void
-teken_subr_device_control_string(teken_t *t __unused)
+teken_subr_device_control_string(teken_t *t)
 {
 
-	teken_printf("device control string???\n");
+	teken_printf("Unsupported device control string\n");
+	t->t_stateflags |= TS_INSTRING;
 }
 
 static void
@@ -535,42 +541,42 @@
 teken_subr_g0_scs_special_graphics(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 0, teken_scs_special_graphics);
+	t->t_scs[0] = teken_scs_special_graphics;
 }
 
 static void
 teken_subr_g0_scs_uk_national(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 0, teken_scs_uk_national);
+	t->t_scs[0] = teken_scs_uk_national;
 }
 
 static void
 teken_subr_g0_scs_us_ascii(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 0, teken_scs_us_ascii);
+	t->t_scs[0] = teken_scs_us_ascii;
 }
 
 static void
 teken_subr_g1_scs_special_graphics(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 1, teken_scs_special_graphics);
+	t->t_scs[1] = teken_scs_special_graphics;
 }
 
 static void
 teken_subr_g1_scs_uk_national(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 1, teken_scs_uk_national);
+	t->t_scs[1] = teken_scs_uk_national;
 }
 
 static void
 teken_subr_g1_scs_us_ascii(teken_t *t __unused)
 {
 
-	teken_scs_set(t, 1, teken_scs_us_ascii);
+	t->t_scs[1] = teken_scs_us_ascii;
 }
 
 static void
@@ -588,21 +594,8 @@
 static void
 teken_subr_horizontal_tab(teken_t *t)
 {
-#ifdef TEKEN_XTERM
-	teken_rect_t tr;
 
-	tr.tr_begin = t->t_cursor;
 	teken_subr_cursor_forward_tabulation(t, 1);
-	tr.tr_end.tp_row = tr.tr_begin.tp_row + 1;
-	tr.tr_end.tp_col = t->t_cursor.tp_col;
-
-	/* Blank region that we skipped. */
-	if (tr.tr_end.tp_col > tr.tr_begin.tp_col)
-		teken_funcs_fill(t, &tr, BLANK, &t->t_curattr);
-#else /* !TEKEN_XTERM */
-
-	teken_subr_cursor_forward_tabulation(t, 1);
-#endif /* TEKEN_XTERM */
 }
 
 static void
@@ -656,6 +649,11 @@
 {
 	teken_rect_t tr;
 
+	/* Ignore if outside scrolling region. */
+	if (t->t_cursor.tp_row < t->t_scrollreg.ts_begin ||
+	    t->t_cursor.tp_row >= t->t_scrollreg.ts_end)
+		return;
+
 	tr.tr_begin.tp_row = t->t_cursor.tp_row;
 	tr.tr_begin.tp_col = 0;
 	tr.tr_end.tp_col = t->t_winsize.tp_col;
@@ -710,19 +708,25 @@
 static void
 teken_subr_newpage(teken_t *t)
 {
-#ifdef TEKEN_XTERM
 
-	teken_subr_newline(t);
-#else /* !TEKEN_XTERM */
-	teken_rect_t tr;
+	if (t->t_stateflags & TS_CONS25) {
+		teken_rect_t tr;
 
-	tr.tr_begin.tp_row = tr.tr_begin.tp_col = 0;
-	tr.tr_end = t->t_winsize;
-	teken_funcs_fill(t, &tr, BLANK, &t->t_curattr);
+		/* Clear screen. */
+		tr.tr_begin.tp_row = t->t_originreg.ts_begin;
+		tr.tr_begin.tp_col = 0;
+		tr.tr_end.tp_row = t->t_originreg.ts_end;
+		tr.tr_end.tp_col = t->t_winsize.tp_col;
+		teken_funcs_fill(t, &tr, BLANK, &t->t_curattr);
 
-	t->t_cursor.tp_row = t->t_cursor.tp_col = 0;
-	teken_funcs_cursor(t);
-#endif /* TEKEN_XTERM */
+		/* Cursor at top left. */
+		t->t_cursor.tp_row = t->t_originreg.ts_begin;
+		t->t_cursor.tp_col = 0;
+		t->t_stateflags &= ~TS_WRAPPED;
+		teken_funcs_cursor(t);
+	} else {
+		teken_subr_newline(t);
+	}
 }
 
 static void
@@ -734,6 +738,14 @@
 }
 
 static void
+teken_subr_operating_system_command(teken_t *t)
+{
+
+	teken_printf("Unsupported operating system command\n");
+	t->t_stateflags |= TS_INSTRING;
+}
+
+static void
 teken_subr_pan_down(teken_t *t, unsigned int nrows)
 {
 
@@ -779,6 +791,20 @@
 		teken_funcs_copy(t, &ctr, &ctp);
 	}
 
+	if (width == 2 && tp->tp_col + 1 < t->t_winsize.tp_col) {
+		teken_pos_t tp2;
+
+		/*
+		 * Store a space behind double width characters before
+		 * actually printing them. This prevents artifacts when
+		 * the consumer doesn't render it using double width
+		 * glyphs.
+		 */
+		tp2.tp_row = tp->tp_row;
+		tp2.tp_col = tp->tp_col + 1;
+		teken_funcs_putchar(t, &tp2, BLANK, &t->t_curattr);
+	}
+
 	teken_funcs_putchar(t, tp, c, &t->t_curattr);
 }
 
@@ -786,16 +812,37 @@
 teken_subr_regular_character(teken_t *t, teken_char_t c)
 {
 	int width;
-	
-	c = teken_scs_process(t, c);
 
-	/* XXX: Don't process zero-width characters yet. */
-	width = teken_wcwidth(c);
-	if (width <= 0)
-		return;
+	if (t->t_stateflags & TS_8BIT) {
+		if (!(t->t_stateflags & TS_CONS25) && (c <= 0x1b || c == 0x7f))
+			return;
+		c = teken_scs_process(t, c);
+		width = 1;
+	} else {
+		c = teken_scs_process(t, c);
+		width = teken_wcwidth(c);
+		/* XXX: Don't process zero-width characters yet. */
+		if (width <= 0)
+			return;
+	}
+
+	if (t->t_stateflags & TS_CONS25) {
+		teken_subr_do_putchar(t, &t->t_cursor, c, width);
+		t->t_cursor.tp_col += width;
 
-#ifdef TEKEN_XTERM
-	if (t->t_cursor.tp_col == t->t_winsize.tp_col - 1 &&
+		if (t->t_cursor.tp_col >= t->t_winsize.tp_col) {
+			if (t->t_cursor.tp_row == t->t_scrollreg.ts_end - 1) {
+				/* Perform scrolling. */
+				teken_subr_do_scroll(t, 1);
+			} else {
+				/* No scrolling needed. */
+				if (t->t_cursor.tp_row <
+				    t->t_winsize.tp_row - 1)
+					t->t_cursor.tp_row++;
+			}
+			t->t_cursor.tp_col = 0;
+		}
+	} else if (t->t_cursor.tp_col == t->t_winsize.tp_col - 1 &&
 	    (t->t_stateflags & (TS_WRAPPED|TS_AUTOWRAP)) ==
 	    (TS_WRAPPED|TS_AUTOWRAP)) {
 		teken_pos_t tp;
@@ -839,22 +886,6 @@
 			t->t_stateflags &= ~TS_WRAPPED;
 		}
 	}
-#else /* !TEKEN_XTERM */
-	teken_subr_do_putchar(t, &t->t_cursor, c, width);
-	t->t_cursor.tp_col += width;
-
-	if (t->t_cursor.tp_col >= t->t_winsize.tp_col) {
-		if (t->t_cursor.tp_row == t->t_scrollreg.ts_end - 1) {
-			/* Perform scrolling. */
-			teken_subr_do_scroll(t, 1);
-		} else {
-			/* No scrolling needed. */
-			if (t->t_cursor.tp_row < t->t_winsize.tp_row - 1)
-				t->t_cursor.tp_row++;
-		}
-		t->t_cursor.tp_col = 0;
-	}
-#endif /* TEKEN_XTERM */
 
 	teken_funcs_cursor(t);
 }
@@ -865,7 +896,7 @@
 
 	switch (cmd) {
 	case 1: /* Cursor keys mode. */
-		teken_funcs_param(t, TP_CURSORKEYS, 0);
+		t->t_stateflags &= ~TS_CURSORKEYS;
 		break;
 	case 2: /* DECANM: ANSI/VT52 mode. */
 		teken_printf("DECRST VT52\n");
@@ -903,6 +934,9 @@
 	case 47: /* Switch to alternate buffer. */
 		teken_printf("Switch to alternate buffer\n");
 		break;
+	case 1000: /* Mouse input. */
+		teken_funcs_param(t, TP_MOUSE, 0);
+		break;
 	default:
 		teken_printf("Unknown DECRST: %u\n", cmd);
 	}
@@ -927,11 +961,15 @@
 
 	t->t_curattr = t->t_defattr;
 	t->t_cursor.tp_row = t->t_cursor.tp_col = 0;
-	t->t_stateflags = TS_AUTOWRAP;
-
-	teken_scs_set(t, 0, teken_scs_us_ascii);
-	teken_scs_set(t, 1, teken_scs_us_ascii);
-	teken_scs_switch(t, 0);
+	t->t_scrollreg.ts_begin = 0;
+	t->t_scrollreg.ts_end = t->t_winsize.tp_row;
+	t->t_originreg = t->t_scrollreg;
+	t->t_stateflags &= TS_8BIT|TS_CONS25;
+	t->t_stateflags |= TS_AUTOWRAP;
+
+	t->t_scs[0] = teken_scs_us_ascii;
+	t->t_scs[1] = teken_scs_us_ascii;
+	t->t_curscs = 0;
 
 	teken_subr_save_cursor(t);
 	teken_tab_default(t);
@@ -953,8 +991,17 @@
 
 	t->t_cursor = t->t_saved_cursor;
 	t->t_curattr = t->t_saved_curattr;
+	t->t_scs[t->t_curscs] = t->t_saved_curscs;
 	t->t_stateflags &= ~TS_WRAPPED;
-	teken_scs_restore(t);
+
+	/* Get out of origin mode when the cursor is moved outside. */
+	if (t->t_cursor.tp_row < t->t_originreg.ts_begin ||
+	    t->t_cursor.tp_row >= t->t_originreg.ts_end) {
+		t->t_stateflags &= ~TS_ORIGIN;
+		t->t_originreg.ts_begin = 0;
+		t->t_originreg.ts_end = t->t_winsize.tp_row;
+	}
+
 	teken_funcs_cursor(t);
 }
 
@@ -977,7 +1024,7 @@
 
 	t->t_saved_cursor = t->t_cursor;
 	t->t_saved_curattr = t->t_curattr;
-	teken_scs_save(t);
+	t->t_saved_curscs = t->t_scs[t->t_curscs];
 }
 
 static void
@@ -998,7 +1045,7 @@
 
 	switch (cmd) {
 	case 1: /* Cursor keys mode. */
-		teken_funcs_param(t, TP_CURSORKEYS, 1);
+		t->t_stateflags |= TS_CURSORKEYS;
 		break;
 	case 2: /* DECANM: ANSI/VT52 mode. */
 		teken_printf("DECSET VT52\n");
@@ -1036,6 +1083,9 @@
 	case 47: /* Switch to alternate buffer. */
 		teken_printf("Switch away from alternate buffer\n");
 		break;
+	case 1000: /* Mouse input. */
+		teken_funcs_param(t, TP_MOUSE, 1);
+		break;
 	default:
 		teken_printf("Unknown DECSET: %u\n", cmd);
 	}
@@ -1108,6 +1158,12 @@
 		case 37: /* Set foreground color: white */
 			t->t_curattr.ta_fgcolor = n - 30;
 			break;
+		case 38: /* Set foreground color: 256 color mode */
+			if (i + 2 >= ncmds || cmds[i + 1] != 5)
+				continue;
+			t->t_curattr.ta_fgcolor = cmds[i + 2];
+			i += 2;
+			break;
 		case 39: /* Set default foreground color. */
 			t->t_curattr.ta_fgcolor = t->t_defattr.ta_fgcolor;
 			break;
@@ -1121,9 +1177,35 @@
 		case 47: /* Set background color: white */
 			t->t_curattr.ta_bgcolor = n - 40;
 			break;
+		case 48: /* Set background color: 256 color mode */
+			if (i + 2 >= ncmds || cmds[i + 1] != 5)
+				continue;
+			t->t_curattr.ta_bgcolor = cmds[i + 2];
+			i += 2;
+			break;
 		case 49: /* Set default background color. */
 			t->t_curattr.ta_bgcolor = t->t_defattr.ta_bgcolor;
 			break;
+		case 90: /* Set bright foreground color: black */
+		case 91: /* Set bright foreground color: red */
+		case 92: /* Set bright foreground color: green */
+		case 93: /* Set bright foreground color: brown */
+		case 94: /* Set bright foreground color: blue */
+		case 95: /* Set bright foreground color: magenta */
+		case 96: /* Set bright foreground color: cyan */
+		case 97: /* Set bright foreground color: white */
+			t->t_curattr.ta_fgcolor = n - 90 + 8;
+			break;
+		case 100: /* Set bright background color: black */
+		case 101: /* Set bright background color: red */
+		case 102: /* Set bright background color: green */
+		case 103: /* Set bright background color: brown */
+		case 104: /* Set bright background color: blue */
+		case 105: /* Set bright background color: magenta */
+		case 106: /* Set bright background color: cyan */
+		case 107: /* Set bright background color: white */
+			t->t_curattr.ta_bgcolor = n - 100 + 8;
+			break;
 		default:
 			teken_printf("unsupported attribute %u\n", n);
 		}
@@ -1148,16 +1230,17 @@
 		bottom = t->t_winsize.tp_row;
 	}
 
+	/* Apply scrolling region. */
 	t->t_scrollreg.ts_begin = top;
 	t->t_scrollreg.ts_end = bottom;
-	if (t->t_stateflags & TS_ORIGIN) {
-		/* XXX: home cursor? */
+	if (t->t_stateflags & TS_ORIGIN)
 		t->t_originreg = t->t_scrollreg;
-		t->t_cursor.tp_row = t->t_originreg.ts_begin;
-		t->t_cursor.tp_col = 0;
-		t->t_stateflags &= ~TS_WRAPPED;
-		teken_funcs_cursor(t);
-	}
+
+	/* Home cursor to the top left of the scrolling region. */
+	t->t_cursor.tp_row = t->t_originreg.ts_begin;
+	t->t_cursor.tp_col = 0;
+	t->t_stateflags &= ~TS_WRAPPED;
+	teken_funcs_cursor(t);
 }
 
 static void
@@ -1178,7 +1261,10 @@
 teken_subr_string_terminator(teken_t *t __unused)
 {
 
-	teken_printf("string terminator???\n");
+	/*
+	 * Strings are already terminated in teken_input_char() when ^[
+	 * is inserted.
+	 */
 }
 
 static void
@@ -1200,10 +1286,9 @@
 {
 
 	t->t_cursor.tp_row = t->t_originreg.ts_begin + row - 1;
-	if (row >= t->t_originreg.ts_end)
+	if (t->t_cursor.tp_row >= t->t_originreg.ts_end)
 		t->t_cursor.tp_row = t->t_originreg.ts_end - 1;
 
-
 	t->t_stateflags &= ~TS_WRAPPED;
 	teken_funcs_cursor(t);
 }
--- a/sys/dev/syscons/teken/teken_subr_compat.h
+++ b/sys/dev/syscons/teken/teken_subr_compat.h
@@ -59,6 +59,18 @@
 	}
 }
 
+static const teken_color_t cons25_revcolors[8] = { 0, 4, 2, 6, 1, 5, 3, 7 };
+
+void
+teken_get_defattr_cons25(teken_t *t, int *fg, int *bg)
+{
+
+	*fg = cons25_revcolors[teken_256to8(t->t_defattr.ta_fgcolor)];
+	if (t->t_defattr.ta_format & TF_BOLD)
+		*fg += 8;
+	*bg = cons25_revcolors[teken_256to8(t->t_defattr.ta_bgcolor)];
+}
+
 static void
 teken_subr_cons25_switch_virtual_terminal(teken_t *t, unsigned int vt)
 {
@@ -75,6 +87,34 @@
 	    (duration & 0xffff));
 }
 
+static void
+teken_subr_cons25_set_graphic_rendition(teken_t *t, unsigned int cmd,
+    unsigned int param __unused)
+{
+
+	switch (cmd) {
+	case 0: /* Reset. */
+		t->t_curattr = t->t_defattr;
+		break;
+	default:
+		teken_printf("unsupported attribute %u\n", cmd);
+	}
+}
+
+static void
+teken_subr_cons25_set_terminal_mode(teken_t *t, unsigned int mode)
+{
+
+	switch (mode) {
+	case 0:	/* Switch terminal to xterm. */
+		t->t_stateflags &= ~TS_CONS25;
+		break;
+	case 1: /* Switch terminal to cons25. */
+		t->t_stateflags |= TS_CONS25;
+		break;
+	}
+}
+
 #if 0
 static void
 teken_subr_vt52_decid(teken_t *t)
