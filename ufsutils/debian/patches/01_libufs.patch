---
 include/ufs/ffs/fs.h     |    5 ++++-
 include/ufs/ufs/dinode.h |    2 ++
 include/ufs/ufs/dir.h    |    2 ++
 libufs/Makefile          |   29 ++++++++++-------------------
 libufs/type.c            |    4 +++-
 5 files changed, 21 insertions(+), 21 deletions(-)

--- a/libufs/type.c
+++ b/libufs/type.c
@@ -108,7 +108,7 @@ again:	if ((ret = stat(name, &st)) < 0)
 		 */
 		name = oname;
 	}
-	if (ret >= 0 && S_ISCHR(st.st_mode)) {
+	if (ret >= 0 && (S_ISCHR(st.st_mode) || S_ISBLK(st.st_mode) || S_ISREG(st.st_mode))) {
 		/* This is what we need, do nothing. */
 		;
 	} else if ((fs = getfsfile(name)) != NULL) {
@@ -131,8 +131,10 @@ again:	if ((ret = stat(name, &st)) < 0)
 			ERROR(disk, "could not find special device");
 			return (-1);
 		}
+#if HAVE_BSD_STATFS
 		strlcpy(dev, sfs.f_mntfromname, sizeof(dev));
 		name = dev;
+#endif
 	} else {
 		ERROR(disk, "could not find special device");
 		return (-1);
--- a/include/ufs/ffs/fs.h
+++ b/include/ufs/ffs/fs.h
@@ -33,6 +33,9 @@
 #ifndef _UFS_FFS_FS_H_
 #define _UFS_FFS_FS_H_
 
+#include <sys/types.h>
+#include <stdint.h>
+
 /*
  * Each disk drive contains some number of filesystems.
  * A filesystem consists of a number of cylinder groups.
@@ -502,7 +505,7 @@ struct cg {
  * Turn filesystem block numbers into disk block addresses.
  * This maps filesystem blocks to device size blocks.
  */
-#define	fsbtodb(fs, b)	((daddr_t)(b) << (fs)->fs_fsbtodb)
+#define	fsbtodb(fs, b)	(((intmax_t)(b)) << (fs)->fs_fsbtodb)
 #define	dbtofsb(fs, b)	((b) >> (fs)->fs_fsbtodb)
 
 /*
--- a/include/ufs/ufs/dinode.h
+++ b/include/ufs/ufs/dinode.h
@@ -68,6 +68,8 @@
 #ifndef _UFS_UFS_DINODE_H_
 #define	_UFS_UFS_DINODE_H_
 
+#include <sys/types.h>
+
 /*
  * The root inode is the root of the filesystem.  Inode 0 can't be used for
  * normal purposes and historically bad blocks were linked to inode 1, thus
--- a/include/ufs/ufs/dir.h
+++ b/include/ufs/ufs/dir.h
@@ -38,6 +38,8 @@
 #ifndef _UFS_UFS_DIR_H_
 #define	_UFS_UFS_DIR_H_
 
+#include <sys/types.h>
+
 /*
  * Theoretically, directories can be more than 2Gb in length, however, in
  * practice this seems unlikely. So, we define the type doff_t as a 32-bit
--- a/libufs/Makefile
+++ b/libufs/Makefile
@@ -1,26 +1,17 @@
 # $FreeBSD: src/lib/libufs/Makefile,v 1.14.10.1 2010/02/10 00:26:20 kensmith Exp $
 
 LIB=	ufs
-SHLIBDIR?= /lib
+SHLIB_MAJOR= 2
 
-SRCS=	block.c cgroup.c inode.c sblock.c type.c
+LIBSRCS=	block.c cgroup.c inode.c sblock.c type.c
 INCS=	libufs.h
 
-MAN=	bread.3 cgread.3 libufs.3 sbread.3 ufs_disk_close.3
-MLINKS+= bread.3 bwrite.3
-MLINKS+= cgread.3 cgread1.3
-MLINKS+= cgread.3 cgwrite1.3
-MLINKS+= sbread.3 sbwrite.3
-MLINKS+= ufs_disk_close.3 ufs_disk_fillout.3
-MLINKS+= ufs_disk_close.3 ufs_disk_fillout_blank.3
-MLINKS+= ufs_disk_close.3 ufs_disk_write.3
+LIB_type = static
+ALL_CFLAGS+= -D_LIBUFS
+ifdef LIBUFS_DEBUG
+ALL_CFLAGS+= -D_LIBUFS_DEBUGGING
+endif
+LDADD += -lbsd
+INCLUDES = -I.
 
-WARNS?=	2
-
-CFLAGS+= -D_LIBUFS
-.if defined(LIBUFS_DEBUG)
-CFLAGS+= -D_LIBUFS_DEBUGGING
-.endif
-CFLAGS+= -I${.CURDIR}
-
-.include <bsd.lib.mk>
+include ../Makefile.common
