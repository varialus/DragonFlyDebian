#DPATCHLEVEL=1
diff -Naur ufsutils.orig/fsck.ufs/dir.c ufsutils.new/fsck.ufs/dir.c
--- ufsutils.orig/fsck.ufs/dir.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/dir.c	2004-05-16 22:51:52.000000000 +0200
@@ -324,7 +324,7 @@
 		}
 		if (preen || reply("ADJUST") == 1) {
 			if (bkgrdflag == 0) {
-				DIP(dp, di_nlink) -= lcnt;
+				DIP_add(dp, di_nlink, -lcnt);
 				inodirty();
 			} else {
 				cmd.value = idesc->id_number;
@@ -474,7 +474,7 @@
 		    parentdir != (ino_t)-1)
 			(void)makeentry(orphan, lfdir, "..");
 		dp = ginode(lfdir);
-		DIP(dp, di_nlink)++;
+		DIP_add(dp, di_nlink, 1);
 		inodirty();
 		inoinfo(lfdir)->ino_linkcnt++;
 		pwarn("DIR I=%lu CONNECTED. ", (u_long)orphan);
@@ -535,7 +535,7 @@
 	idesc.id_name = strdup(name);
 	dp = ginode(parent);
 	if (DIP(dp, di_size) % DIRBLKSIZ) {
-		DIP(dp, di_size) = roundup(DIP(dp, di_size), DIRBLKSIZ);
+		DIP_set(dp, di_size, roundup(DIP(dp, di_size), DIRBLKSIZ));
 		inodirty();
 	}
 	if ((ckinode(dp, &idesc) & ALTERED) != 0)
@@ -563,10 +563,10 @@
 		return (0);
 	if ((newblk = allocblk(sblock.fs_frag)) == 0)
 		return (0);
-	DIP(dp, di_db[lastbn + 1]) = DIP(dp, di_db[lastbn]);
-	DIP(dp, di_db[lastbn]) = newblk;
-	DIP(dp, di_size) += sblock.fs_bsize;
-	DIP(dp, di_blocks) += btodb(sblock.fs_bsize);
+	DIP_set(dp, di_db[lastbn + 1], DIP(dp, di_db[lastbn]));
+	DIP_set(dp, di_db[lastbn], newblk);
+	DIP_add(dp, di_size, sblock.fs_bsize);
+	DIP_add(dp, di_blocks, btodb(sblock.fs_bsize));
 	bp = getdirblk(DIP(dp, di_db[lastbn + 1]),
 		sblksize(&sblock, DIP(dp, di_size), lastbn + 1));
 	if (bp->b_errs)
@@ -595,10 +595,10 @@
 	inodirty();
 	return (1);
 bad:
-	DIP(dp, di_db[lastbn]) = DIP(dp, di_db[lastbn + 1]);
-	DIP(dp, di_db[lastbn + 1]) = 0;
-	DIP(dp, di_size) -= sblock.fs_bsize;
-	DIP(dp, di_blocks) -= btodb(sblock.fs_bsize);
+	DIP_set(dp, di_db[lastbn], DIP(dp, di_db[lastbn + 1]));
+	DIP_set(dp, di_db[lastbn + 1], 0);
+	DIP_add(dp, di_size, -sblock.fs_bsize);
+	DIP_add(dp, di_blocks, -btodb(sblock.fs_bsize));
 	freeblk(newblk, sblock.fs_frag);
 	return (0);
 }
@@ -632,7 +632,7 @@
 	     cp += DIRBLKSIZ)
 		memmove(cp, &emptydir, sizeof emptydir);
 	dirty(bp);
-	DIP(dp, di_nlink) = 2;
+	DIP_set(dp, di_nlink, 2);
 	inodirty();
 	if (ino == ROOTINO) {
 		inoinfo(ino)->ino_linkcnt = DIP(dp, di_nlink);
@@ -654,7 +654,7 @@
 		inoinfo(parent)->ino_linkcnt++;
 	}
 	dp = ginode(parent);
-	DIP(dp, di_nlink)++;
+	DIP_add(dp, di_nlink, 1);
 	inodirty();
 	return (ino);
 }
@@ -669,7 +669,7 @@
 
 	if (ino != parent) {
 		dp = ginode(parent);
-		DIP(dp, di_nlink)--;
+		DIP_add(dp, di_nlink, -1);
 		inodirty();
 	}
 	freeino(ino);
diff -Naur ufsutils.orig/fsck.ufs/ea.c ufsutils.new/fsck.ufs/ea.c
--- ufsutils.orig/fsck.ufs/ea.c	2003-05-03 20:41:57.000000000 +0200
+++ ufsutils.new/fsck.ufs/ea.c	2004-05-13 08:18:09.000000000 +0200
@@ -38,7 +38,7 @@
 
 #include <sys/param.h>
 #include <sys/time.h>
-#include <sys/stdint.h>
+#include <stdint.h>
 
 #include <ufs/ufs/dinode.h>
 #include <ufs/ufs/dir.h>
diff -Naur ufsutils.orig/fsck.ufs/fsck_ffs.8 ufsutils.new/fsck.ufs/fsck_ffs.8
--- ufsutils.orig/fsck.ufs/fsck_ffs.8	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/fsck_ffs.8	2004-05-16 23:19:18.000000000 +0200
@@ -30,11 +30,11 @@
 .\" $FreeBSD: src/sbin/fsck_ffs/fsck_ffs.8,v 1.30 2004/04/09 19:58:28 markm Exp $
 .\"
 .Dd April 24, 2001
-.Dt FSCK_FFS 8
+.Dt FSCK.UFS 8
 .Os
 .Sh NAME
-.Nm fsck_ffs ,
-.Nm fsck_ufs
+.Nm fsck.ffs ,
+.Nm fsck.ufs
 .Nd file system consistency check and interactive repair
 .Sh SYNOPSIS
 .Nm
@@ -311,5 +311,4 @@
 .Xr fstab 5 ,
 .Xr fsck 8 ,
 .Xr fsdb 8 ,
-.Xr newfs 8 ,
 .Xr reboot 8
diff -Naur ufsutils.orig/fsck.ufs/fsck.h ufsutils.new/fsck.ufs/fsck.h
--- ufsutils.orig/fsck.ufs/fsck.h	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/fsck.h	2004-05-16 23:21:44.000000000 +0200
@@ -55,6 +55,18 @@
 #define	DIP(dp, field) \
 	((sblock.fs_magic == FS_UFS1_MAGIC) ? \
 	(dp)->dp1.field : (dp)->dp2.field)
+#define	DIP_set(dp, field, value) \
+	{if (sblock.fs_magic == FS_UFS1_MAGIC) \
+	(dp)->dp1.field = (value); else (dp)->dp2.field = (value);}
+#define	DIP_add(dp, field, value) \
+	{if (sblock.fs_magic == FS_UFS1_MAGIC) \
+	(dp)->dp1.field += (value); else (dp)->dp2.field += (value);}
+#define	DIP_and(dp, field, value) \
+	{if (sblock.fs_magic == FS_UFS1_MAGIC) \
+	(dp)->dp1.field &= (value); else (dp)->dp2.field &= (value);}
+#define	DIP_or(dp, field, value) \
+	{if (sblock.fs_magic == FS_UFS1_MAGIC) \
+	(dp)->dp1.field |= (value); else (dp)->dp2.field |= (value);}
 
 /*
  * Each inode on the file system is described by the following structure.
@@ -110,6 +122,10 @@
 #define	IBLK(bp, i) \
 	((sblock.fs_magic == FS_UFS1_MAGIC) ? \
 	(bp)->b_un.b_indir1[i] : (bp)->b_un.b_indir2[i])
+#define	IBLK_set(bp, i, value) \
+	{if (sblock.fs_magic == FS_UFS1_MAGIC) \
+	(bp)->b_un.b_indir1[i] = (value); \
+	else (bp)->b_un.b_indir2[i] = (value);}
 
 #define	B_INUSE 1
 
diff -Naur ufsutils.orig/fsck.ufs/fsutil.c ufsutils.new/fsck.ufs/fsutil.c
--- ufsutils.orig/fsck.ufs/fsutil.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/fsutil.c	2004-05-16 20:37:54.000000000 +0200
@@ -38,7 +38,9 @@
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#if HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 #include <sys/disklabel.h>
 #include <sys/stat.h>
 #include <sys/disklabel.h>
@@ -55,6 +57,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <signal.h>
 #include <unistd.h>
 
 #include "fsck.h"
@@ -136,7 +139,7 @@
 	int iloff;
 
 	if (inum > maxino)
-		errx(EEXIT, "inoinfo: inumber %d out of range", inum);
+		errx(EEXIT, "inoinfo: inumber %ld out of range", inum);
 	ilp = &inostathead[inum / sblock.fs_ipg];
 	iloff = inum % sblock.fs_ipg;
 	if (iloff >= ilp->il_numalloced)
@@ -277,11 +280,13 @@
 	if (bkgrdflag) {
 		unlink(snapname);
 		if ((!(sblock.fs_flags & FS_UNCLEAN)) != markclean) {
+#ifdef HAVE_BSD_SYSCTL
 			cmd.value = FS_UNCLEAN;
 			cmd.size = markclean ? -1 : 1;
 			if (sysctlbyname("vfs.ffs.setflags", 0, 0,
 			    &cmd, sizeof cmd) == -1)
 				rwerror("SET FILE SYSTEM FLAGS", FS_UNCLEAN);
+#endif
 			if (!preen) {
 				printf("\n***** FILE SYSTEM MARKED %s *****\n",
 				    markclean ? "CLEAN" : "DIRTY");
@@ -567,7 +572,7 @@
 }
 
 void
-catch(int sig __unused)
+catch(int sig)
 {
 
 	ckfini(0);
@@ -580,7 +585,7 @@
  * so that reboot sequence may be interrupted.
  */
 void
-catchquit(int sig __unused)
+catchquit(int sig)
 {
 	printf("returning to single-user after file system check\n");
 	returntosingle = 1;
@@ -649,11 +654,13 @@
 		 * Force foreground fsck to clean up inconsistency.
 		 */
 		if (bkgrdflag) {
+#if HAVE_BSD_SYSCTL
 			cmd.value = FS_NEEDSFSCK;
 			cmd.size = 1;
 			if (sysctlbyname("vfs.ffs.setflags", 0, 0,
 			    &cmd, sizeof cmd) == -1)
 				pwarn("CANNOT SET FS_NEEDSFSCK FLAG\n");
+#endif
 			fprintf(stdout, "CANNOT RUN IN BACKGROUND\n");
 			ckfini(0);
 			exit(EEXIT);
@@ -670,6 +677,7 @@
 	/*
 	 * Force foreground fsck to clean up inconsistency.
 	 */
+#if HAVE_BSD_SYSCTL
 	if (bkgrdflag) {
 		cmd.value = FS_NEEDSFSCK;
 		cmd.size = 1;
@@ -677,6 +685,7 @@
 		    &cmd, sizeof cmd) == -1)
 			pwarn("CANNOT SET FS_NEEDSFSCK FLAG\n");
 	}
+#endif
 	ckfini(0);
 	exit(EEXIT);
 }
diff -Naur ufsutils.orig/fsck.ufs/inode.c ufsutils.new/fsck.ufs/inode.c
--- ufsutils.orig/fsck.ufs/inode.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/inode.c	2004-05-16 23:22:10.000000000 +0200
@@ -36,7 +36,7 @@
 __FBSDID("$FreeBSD: src/sbin/fsck_ffs/inode.c,v 1.35 2004/04/09 19:58:28 markm Exp $");
 
 #include <sys/param.h>
-#include <sys/stdint.h>
+#include <stdint.h>
 #include <sys/time.h>
 #include <sys/sysctl.h>
 
@@ -47,6 +47,7 @@
 #include <err.h>
 #include <pwd.h>
 #include <string.h>
+#include <time.h>
 
 #include "fsck.h"
 
@@ -95,7 +96,8 @@
 					pathbuf);
                         	if (reply("ADJUST LENGTH") == 1) {
 					dp = ginode(idesc->id_number);
-                                	DIP(dp, di_size) = i * sblock.fs_bsize;
+					DIP_set(dp, di_size,
+						i * sblock.fs_bsize);
 					printf(
 					    "YOU MUST RERUN FSCK AFTERWARDS\n");
 					rerun = 1;
@@ -133,7 +135,7 @@
 					pathbuf);
                         	if (reply("ADJUST LENGTH") == 1) {
 					dp = ginode(idesc->id_number);
-                                	DIP(dp, di_size) -= remsize;
+					DIP_add(dp, di_size, -remsize);
 					remsize = 0;
 					printf(
 					    "YOU MUST RERUN FSCK AFTERWARDS\n");
@@ -183,7 +185,7 @@
 			if (preen) {
 				pfatal("%s", buf);
 			} else if (dofix(idesc, buf)) {
-				IBLK(bp, i) = 0;
+				IBLK_set(bp, i, 0);
 				dirty(bp);
 			}
 		}
@@ -211,7 +213,7 @@
 					pathbuf);
                         	if (reply("ADJUST LENGTH") == 1) {
 					dp = ginode(idesc->id_number);
-                                	DIP(dp, di_size) -= isize;
+					DIP_add(dp, di_size, -isize);
 					isize = 0;
 					printf(
 					    "YOU MUST RERUN FSCK AFTERWARDS\n");
@@ -282,7 +284,7 @@
 	ufs2_daddr_t iblk;
 
 	if (inumber < ROOTINO || inumber > maxino)
-		errx(EEXIT, "bad inode number %d to ginode", inumber);
+		errx(EEXIT, "bad inode number %ld to ginode", inumber);
 	if (startinum == 0 ||
 	    inumber < startinum || inumber >= startinum + INOPB(&sblock)) {
 		iblk = ino_to_fsba(&sblock, inumber);
@@ -314,7 +316,7 @@
 	static caddr_t nextinop;
 
 	if (inumber != nextino++ || inumber > lastvalidinum)
-		errx(EEXIT, "bad inode number %d to nextinode", inumber);
+		errx(EEXIT, "bad inode number %ld to nextinode", inumber);
 	if (inumber >= lastinum) {
 		readcnt++;
 		dblk = fsbtodb(&sblock, ino_to_fsba(&sblock, lastinum));
@@ -345,7 +347,7 @@
 {
 
 	if (inum % sblock.fs_ipg != 0)
-		errx(EEXIT, "bad inode number %d to setinodebuf", inum);
+		errx(EEXIT, "bad inode number %ld to setinodebuf", inum);
 	lastvalidinum = inum + sblock.fs_ipg - 1;
 	startinum = 0;
 	nextino = inum;
@@ -436,7 +438,7 @@
 			continue;
 		return (inp);
 	}
-	errx(EEXIT, "cannot find inode %d", inumber);
+	errx(EEXIT, "cannot find inode %ld", inumber);
 	return ((struct inoinfo *)0);
 }
 
@@ -630,20 +632,21 @@
 	}
 	cgdirty();
 	dp = ginode(ino);
-	DIP(dp, di_db[0]) = allocblk((long)1);
+	DIP_set(dp, di_db[0], allocblk((long)1));
 	if (DIP(dp, di_db[0]) == 0) {
 		inoinfo(ino)->ino_state = USTATE;
 		return (0);
 	}
-	DIP(dp, di_mode) = type;
-	DIP(dp, di_flags) = 0;
-	DIP(dp, di_atime) = time(NULL);
-	DIP(dp, di_mtime) = DIP(dp, di_ctime) = DIP(dp, di_atime);
-	DIP(dp, di_mtimensec) = 0;
-	DIP(dp, di_ctimensec) = 0;
-	DIP(dp, di_atimensec) = 0;
-	DIP(dp, di_size) = sblock.fs_fsize;
-	DIP(dp, di_blocks) = btodb(sblock.fs_fsize);
+	DIP_set(dp, di_mode, type);
+	DIP_set(dp, di_flags, 0);
+	DIP_set(dp, di_atime, time(NULL));
+	DIP_set(dp, di_mtime, DIP(dp, di_atime));
+	DIP_set(dp, di_ctime, DIP(dp, di_atime));
+	DIP_set(dp, di_mtimensec, 0);
+	DIP_set(dp, di_ctimensec, 0);
+	DIP_set(dp, di_atimensec, 0);
+	DIP_set(dp, di_size, sblock.fs_fsize);
+	DIP_set(dp, di_blocks, btodb(sblock.fs_fsize));
 	n_files++;
 	inodirty();
 	inoinfo(ino)->ino_type = IFTODT(type);
diff -Naur ufsutils.orig/fsck.ufs/main.c ufsutils.new/fsck.ufs/main.c
--- ufsutils.orig/fsck.ufs/main.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/main.c	2004-05-16 23:15:12.000000000 +0200
@@ -45,13 +45,22 @@
 #include <sys/stat.h>
 #include <sys/file.h>
 #include <sys/time.h>
+#ifdef HAVE_BSD_STATFS
 #include <sys/mount.h>
+#else
+#include <sys/statvfs.h>
+#define statfs statvfs
+#endif
 #include <sys/resource.h>
+#ifdef HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 #include <sys/disklabel.h>
 
 #include <ufs/ufs/dinode.h>
+#ifdef HAVE_BSD_MOUNT
 #include <ufs/ufs/ufsmount.h>
+#endif
 #include <ufs/ffs/fs.h>
 
 #include <err.h>
@@ -59,15 +68,19 @@
 #include <fstab.h>
 #include <grp.h>
 #include <paths.h>
+#include <time.h>
 #include <stdint.h>
 #include <string.h>
+#include <signal.h>
 
 #include "fsck.h"
 
-static void usage(void) __dead2;
+static void usage(char *progname) __dead2;
 static int argtoi(int flag, const char *req, const char *str, int base);
 static int checkfilesys(char *filesys);
+#ifdef HAVE_BSD_STATFS
 static struct statfs *getmntpt(const char *);
+#endif
 
 int
 main(int argc, char *argv[])
@@ -76,10 +89,11 @@
 	struct rlimit rlimit;
 	struct itimerval itimerval;
 	int ret = 0;
+	char *progname = argv[0];
 
 	sync();
 	skipclean = 1;
-	while ((ch = getopt(argc, argv, "b:Bc:dfFm:npy")) != -1) {
+	while ((ch = getopt(argc, argv, "ab:Bc:dfFm:npy")) != -1) {
 		switch (ch) {
 		case 'b':
 			skipclean = 0;
@@ -123,6 +137,7 @@
 			yflag = 0;
 			break;
 
+		case 'a':
 		case 'p':
 			preen++;
 			break;
@@ -133,20 +148,22 @@
 			break;
 
 		default:
-			usage();
+			usage(progname);
 		}
 	}
 	argc -= optind;
 	argv += optind;
 
 	if (!argc)
-		usage();
+		usage(progname);
 
 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
 		(void)signal(SIGINT, catch);
 	if (preen)
 		(void)signal(SIGQUIT, catchquit);
+#ifdef HAVE_BSD_SIGNALS
 	signal(SIGINFO, infohandler);
+#endif
 	if (bkgrdflag) {
 		signal(SIGALRM, alarmhandler);
 		itimerval.it_interval.tv_sec = 5;
@@ -191,14 +208,18 @@
 checkfilesys(char *filesys)
 {
 	ufs2_daddr_t n_ffree, n_bfree;
+#if HAVE_BSD_MOUNT
 	struct ufs_args args;
+#endif
 	struct dups *dp;
 	struct statfs *mntp;
 	struct zlncnt *zlnp;
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	struct stat snapdir;
 	struct group *grp;
+#endif
 	ufs2_daddr_t blks;
-	int cylno, ret;
+	int cylno;
 	ino_t files;
 	size_t size;
 
@@ -210,10 +231,12 @@
 	 * if it is listed among the mounted file systems. Failing that
 	 * check to see if it is listed in /etc/fstab.
 	 */
+#if HAVE_BSD_STATFS
 	mntp = getmntpt(filesys);
 	if (mntp != NULL)
 		filesys = mntp->f_mntfromname;
 	else
+#endif
 		filesys = blockcheck(filesys);
 	/*
 	 * If -F flag specified, check to see whether a background check
@@ -231,8 +254,10 @@
 		if ((sblock.fs_flags & FS_DOSOFTDEP) == 0)
 			exit(5);	/* Not running soft updates */
 		size = MIBSIZE;
+#if HAVE_BSD_SYSCTL
 		if (sysctlnametomib("vfs.ffs.adjrefcnt", adjrefcnt, &size) < 0)
 			exit(6);	/* Lacks kernel support */
+#endif
 		if ((mntp == NULL && sblock.fs_clean == 1) ||
 		    (mntp != NULL && (sblock.fs_flags & FS_UNCLEAN) == 0))
 			exit(7);	/* Filesystem clean, report it now */
@@ -245,6 +270,7 @@
 	 *	return created snapshot file
 	 *	if not found, clear bkgrdflag and proceed with normal fsck
 	 */
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	if (bkgrdflag) {
 		if (mntp == NULL) {
 			bkgrdflag = 0;
@@ -320,6 +346,7 @@
 				filesys = snapname;
 		}
 	}
+#endif
 
 	switch (setup(filesys)) {
 	case 0:
@@ -327,7 +354,9 @@
 			pfatal("CAN'T CHECK FILE SYSTEM.");
 		return (0);
 	case -1:
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	clean:
+#endif
 		pwarn("clean, %ld free ", (long)(sblock.fs_cstotal.cs_nffree +
 		    sblock.fs_frag * sblock.fs_cstotal.cs_nbfree));
 		printf("(%lld frags, %lld blocks, %.1f%% fragmentation)\n",
@@ -347,8 +376,10 @@
 	 */
 	if (preen == 0) {
 		printf("** Last Mounted on %s\n", sblock.fs_fsmnt);
+#if HAVE_BSD_STATFS
 		if (mntp != NULL && mntp->f_flags & MNT_ROOTFS)
 			printf("** Root file system\n");
+#endif
 		printf("** Phase 1 - Check Blocks and Sizes\n");
 	}
 	pass1();
@@ -415,7 +446,7 @@
 	    n_ffree * 100.0 / sblock.fs_dsize);
 	if (debug) {
 		if (files < 0)
-			printf("%d inodes missing\n", -files);
+			printf("%ld inodes missing\n", -files);
 		if (blks < 0)
 			printf("%lld blocks missing\n", -(long long)blks);
 		if (duplist != NULL) {
@@ -427,7 +458,7 @@
 		if (zlnhead != NULL) {
 			printf("The following zero link count inodes remain:");
 			for (zlnp = zlnhead; zlnp; zlnp = zlnp->next)
-				printf(" %u,", zlnp->zlncnt);
+				printf(" %lu,", zlnp->zlncnt);
 			printf("\n");
 		}
 	}
@@ -454,8 +485,13 @@
 	/*
 	 * Check to see if the file system is mounted read-write.
 	 */
+#if HAVE_BSD_STATFS
 	if (bkgrdflag == 0 && mntp != NULL && (mntp->f_flags & MNT_RDONLY) == 0)
 		resolved = 0;
+#else
+	if (bkgrdflag == 0 && mntp != NULL && (mntp->f_flag & ST_RDONLY) == 0)
+		resolved = 0;
+#endif
 	ckfini(resolved);
 
 	for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
@@ -473,6 +509,9 @@
 		 * it unless it is read-write, so we can continue using it
 		 * as safely as possible.
 		 */
+#if HAVE_BSD_STATFS && HAVE_BSD_MOUNT
+		int ret;
+
 		if (mntp->f_flags & MNT_RDONLY) {
 			args.fspec = 0;
 			args.export.ex_flags = 0;
@@ -484,6 +523,20 @@
 			pwarn("mount reload of '%s' failed: %s\n\n",
 			    mntp->f_mntonname, strerror(errno));
 		}
+//#else
+#warning "FIXME: use linux mount call"
+		if (mntp->f_flag & ST_RDONLY) {
+			args.fspec = 0;
+			args.export.ex_flags = 0;
+			args.export.ex_root = 0;
+			ret = mount("ufs", mntp->f_mntonname,
+			    mntp->f_flag | MNT_UPDATE | MNT_RELOAD, &args);
+			if (ret == 0)
+				return (0);
+			pwarn("mount reload of '%s' failed: %s\n\n",
+			    mntp->f_mntonname, strerror(errno));
+		}
+#endif
 		if (!fsmodified)
 			return (0);
 		if (!preen)
@@ -494,6 +547,7 @@
 	return (0);
 }
 
+#if HAVE_BSD_STATFS
 /*
  * Get the mount point information for name.
  */
@@ -533,13 +587,14 @@
 	statfsp = NULL;
 	return (statfsp);
 }
+#endif
 
 static void
-usage(void)
+usage(char *progname)
 {
         (void) fprintf(stderr,
             "usage: %s [-BFpfny] [-b block] [-c level] [-m mode] "
                         "file system ...\n",
-            getprogname());
+            progname);
         exit(1);
 }
diff -Naur ufsutils.orig/fsck.ufs/pass1.c ufsutils.new/fsck.ufs/pass1.c
--- ufsutils.orig/fsck.ufs/pass1.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/pass1.c	2004-05-16 23:02:25.000000000 +0200
@@ -236,8 +236,8 @@
 	}
 	if (!preen && mode == IFMT && reply("HOLD BAD BLOCK") == 1) {
 		dp = ginode(inumber);
-		DIP(dp, di_size) = sblock.fs_fsize;
-		DIP(dp, di_mode) = IFREG|0600;
+		DIP_set(dp, di_size, sblock.fs_fsize);
+		DIP_set(dp, di_mode, IFREG|0600);
 		inodirty();
 	}
 	if ((mode == IFBLK || mode == IFCHR || mode == IFIFO ||
@@ -328,9 +328,11 @@
 	inoinfo(inumber)->ino_type = IFTODT(mode);
 	badblk = dupblk = 0;
 	idesc->id_number = inumber;
+#if HAVE_UFS_SNAPSHOTS
 	if (DIP(dp, di_flags) & SF_SNAPSHOT)
 		idesc->id_type = SNAP;
 	else
+#endif
 		idesc->id_type = ADDR;
 	(void)ckinode(dp, idesc);
 	if (sblock.fs_magic == FS_UFS2_MAGIC && dp->dp2.di_extsize > 0) {
@@ -364,7 +366,7 @@
 			return;
 		if (bkgrdflag == 0) {
 			dp = ginode(inumber);
-			DIP(dp, di_blocks) = idesc->id_entryno;
+			DIP_set(dp, di_blocks, idesc->id_entryno);
 			inodirty();
 		} else {
 			cmd.value = idesc->id_number;
diff -Naur ufsutils.orig/fsck.ufs/pass2.c ufsutils.new/fsck.ufs/pass2.c
--- ufsutils.orig/fsck.ufs/pass2.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/pass2.c	2004-05-16 23:03:36.000000000 +0200
@@ -103,8 +103,8 @@
 			exit(EEXIT);
 		}
 		dp = ginode(ROOTINO);
-		DIP(dp, di_mode) &= ~IFMT;
-		DIP(dp, di_mode) |= IFDIR;
+		DIP_and(dp, di_mode, ~IFMT);
+		DIP_or(dp, di_mode, IFDIR);
 		inodirty();
 		break;
 
@@ -149,7 +149,7 @@
 			inp->i_isize = roundup(MINDIRSIZE, DIRBLKSIZ);
 			if (reply("FIX") == 1) {
 				dp = ginode(inp->i_number);
-				DIP(dp, di_size) = inp->i_isize;
+				DIP_set(dp, di_size, inp->i_isize);
 				inodirty();
 			}
 		} else if ((inp->i_isize & (DIRBLKSIZ - 1)) != 0) {
@@ -167,22 +167,22 @@
 			inp->i_isize = roundup(inp->i_isize, DIRBLKSIZ);
 			if (preen || reply("ADJUST") == 1) {
 				dp = ginode(inp->i_number);
-				DIP(dp, di_size) =
-				    roundup(inp->i_isize, DIRBLKSIZ);
+				DIP_set(dp, di_size,
+				    roundup(inp->i_isize, DIRBLKSIZ));
 				inodirty();
 			}
 		}
 		dp = &dino;
 		memset(dp, 0, sizeof(struct ufs2_dinode));
-		DIP(dp, di_mode) = IFDIR;
-		DIP(dp, di_size) = inp->i_isize;
+		DIP_set(dp, di_mode, IFDIR);
+		DIP_set(dp, di_size, inp->i_isize);
 		for (i = 0;
 		     i < (inp->i_numblks<NDADDR ? inp->i_numblks : NDADDR);
 		     i++)
-			DIP(dp, di_db[i]) = inp->i_blks[i];
+			DIP_set(dp, di_db[i], inp->i_blks[i]);
 		if (inp->i_numblks > NDADDR)
 			for (i = 0; i < NIADDR; i++)
-				DIP(dp, di_ib[i]) = inp->i_blks[NDADDR + i];
+				DIP_set(dp, di_ib[i], inp->i_blks[NDADDR + i]);
 		curino.id_number = inp->i_number;
 		curino.id_parent = inp->i_parent;
 		(void)ckinode(dp, &curino);
diff -Naur ufsutils.orig/fsck.ufs/pass4.c ufsutils.new/fsck.ufs/pass4.c
--- ufsutils.orig/fsck.ufs/pass4.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/pass4.c	2004-05-13 08:22:35.000000000 +0200
@@ -114,7 +114,7 @@
 				break;
 
 			default:
-				errx(EEXIT, "BAD STATE %d FOR INODE I=%d",
+				errx(EEXIT, "BAD STATE %d FOR INODE I=%ld",
 				    inoinfo(inumber)->ino_state, inumber);
 			}
 		}
diff -Naur ufsutils.orig/fsck.ufs/setup.c ufsutils.new/fsck.ufs/setup.c
--- ufsutils.orig/fsck.ufs/setup.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/setup.c	2004-05-13 08:04:18.000000000 +0200
@@ -36,11 +36,14 @@
 __FBSDID("$FreeBSD: src/sbin/fsck_ffs/setup.c,v 1.47 2004/04/09 19:58:28 markm Exp $");
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #define FSTYPENAMES
 #include <sys/disklabel.h>
 #include <sys/file.h>
+#if HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 
 #include <ufs/ufs/dinode.h>
 #include <ufs/ffs/fs.h>
@@ -51,6 +54,7 @@
 #include <limits.h>
 #include <stdint.h>
 #include <string.h>
+#include <unistd.h>
 
 #include "fsck.h"
 
@@ -87,6 +91,7 @@
 		}
 		return (0);
 	}
+#if HAVE_UFS_SNAPSHOTS
 	if ((statb.st_mode & S_IFMT) != S_IFCHR &&
 	    (statb.st_mode & S_IFMT) != S_IFBLK) {
 		if (bkgrdflag != 0 && (statb.st_flags & SF_SNAPSHOT) == 0) {
@@ -121,6 +126,7 @@
 			}
 		}
 	}
+#endif
 	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
 		if (bkgrdflag) {
 			unlink(snapname);
@@ -131,6 +137,7 @@
 	}
 	if (bkgrdflag) {
 		unlink(snapname);
+#if HAVE_BSD_SYSCTL
 		size = MIBSIZE;
 		if (sysctlnametomib("vfs.ffs.adjrefcnt", adjrefcnt, &size) < 0||
 		    sysctlnametomib("vfs.ffs.adjblkcnt", adjblkcnt, &size) < 0||
@@ -142,6 +149,7 @@
 		}
 		cmd.version = FFS_CMD_VERSION;
 		cmd.handle = fsreadfd;
+#endif
 		fswritefd = -1;
 	}
 	if (preen == 0)
@@ -453,6 +461,8 @@
 		return (0);
 	}
 	lp = getdisklabel(dev, devfd);
+	if (!lp)
+		return (0);
 	if (isdigit(*cp))
 		pp = &lp->d_partitions[0];
 	else
@@ -503,13 +513,17 @@
 static struct disklabel *
 getdisklabel(char *s, int fd)
 {
+#ifdef HAVE_BSD_DISKLABELS
 	static struct disklabel lab;
 
 	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
 		if (s == NULL)
+#endif
 			return ((struct disklabel *)NULL);
+#ifdef HAVE_BSD_DISKLABELS
 		pwarn("ioctl (GCINFO): %s\n", strerror(errno));
 		errx(EEXIT, "%s: can't read disk label", s);
 	}
 	return (&lab);
+#endif
 }
diff -Naur ufsutils.orig/fsck.ufs/utilities.c ufsutils.new/fsck.ufs/utilities.c
--- ufsutils.orig/fsck.ufs/utilities.c	2004-04-09 21:58:28.000000000 +0200
+++ ufsutils.new/fsck.ufs/utilities.c	2004-05-16 20:38:02.000000000 +0200
@@ -108,14 +108,16 @@
 	return (origname);
 }
 
+#ifdef HAVE_BSD_SIGNALS
 void
-infohandler(int sig __unused)
+infohandler(int sig)
 {
 	got_siginfo = 1;
 }
+#endif
 
 void
-alarmhandler(int sig __unused)
+alarmhandler(int sig)
 {
 	got_sigalarm = 1;
 }
diff -Naur ufsutils.orig/fsck.ufs/Makefile ufsutilsi.new/fsck.ufs/Makefile
--- ufsutils.orig/fsck.ufs/Makefile	2004-02-23 21:13:51.000000000 +0100
+++ ufsutils.new/fsck.ufs/Makefile	2004-05-24 02:34:48.000000000 +0200
@@ -1,16 +1,19 @@
 # $FreeBSD: src/sbin/fsck_ffs/Makefile,v 1.14 2004/02/23 20:13:51 johan Exp $
 #	@(#)Makefile	8.2 (Berkeley) 4/27/95
 
-PROG=	fsck_ffs
-LINKS+=	${BINDIR}/fsck_ffs ${BINDIR}/fsck_ufs
-LINKS+=	${BINDIR}/fsck_ffs ${BINDIR}/fsck_4.2bsd
-MAN=	fsck_ffs.8
-MLINKS=	fsck_ffs.8 fsck_ufs.8 fsck_ffs.8 fsck_4.2bsd.8
-SRCS=	dir.c ea.c fsutil.c inode.c main.c pass1.c pass1b.c pass2.c pass3.c \
-	pass4.c pass5.c setup.c utilities.c ffs_subr.c ffs_tables.c
-WARNS?=	2
-CFLAGS+= -I${.CURDIR}
+PROG = fsck.ufs
+LIB = $(PROG)
+LIB_type = static
+SRCS = main.c
+MAN = fsck_ffs.8:fsck.ufs.8
+UFS_SRCS = ../include/ufs/ffs/ffs_subr.c ../include/ufs/ffs/ffs_tables.c
+LIBSRCS = \
+	dir.c ea.c fsutil.c inode.c pass1.c pass1b.c pass2.c pass3.c pass4.c \
+	pass5.c setup.c utilities.c $(UFS_SRCS)
+WARNS = 2
 
-.PATH:	${.CURDIR}/../../sys/ufs/ffs
+LDADD = -L../libport -lport -L. -l$(LIB) -L../libufs -lufs
+INCLUDES = -I.
+
+include ../Makefile.common
 
-.include <bsd.prog.mk>
