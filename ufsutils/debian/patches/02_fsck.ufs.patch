#DPATCHLEVEL=1
Index: ufsutils/fsck.ufs/gjournal.c
===================================================================
--- ufsutils.orig/fsck.ufs/gjournal.c
+++ ufsutils/fsck.ufs/gjournal.c
@@ -54,6 +54,9 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD: src/sbin/fsck_ffs/gjournal.c,v 1.2 2006/11/01 10:56:33 ru Exp $");
 
+
+#if HAVE_UFS_SNAPSHOT
+
 #include <sys/param.h>
 #include <sys/disklabel.h>
 #include <sys/mount.h>
@@ -774,3 +777,4 @@
 	/* Write back updated statistics and super-block. */
 	putdisk();
 }
+#endif
Index: ufsutils/fsck.ufs/ea.c
===================================================================
--- ufsutils.orig/fsck.ufs/ea.c
+++ ufsutils/fsck.ufs/ea.c
@@ -38,7 +38,7 @@
 
 #include <sys/param.h>
 #include <sys/time.h>
-#include <sys/stdint.h>
+#include <stdint.h>
 
 #include <ufs/ufs/dinode.h>
 #include <ufs/ufs/dir.h>
Index: ufsutils/fsck.ufs/fsck_ffs.8
===================================================================
--- ufsutils.orig/fsck.ufs/fsck_ffs.8
+++ ufsutils/fsck.ufs/fsck_ffs.8
@@ -30,11 +30,11 @@
 .\" $FreeBSD: src/sbin/fsck_ffs/fsck_ffs.8,v 1.34 2005/09/20 08:02:38 delphij Exp $
 .\"
 .Dd April 24, 2001
-.Dt FSCK_FFS 8
+.Dt FSCK.UFS 8
 .Os
 .Sh NAME
-.Nm fsck_ffs ,
-.Nm fsck_ufs
+.Nm fsck.ffs ,
+.Nm fsck.ufs
 .Nd file system consistency check and interactive repair
 .Sh SYNOPSIS
 .Nm
@@ -313,5 +313,4 @@
 .Xr fstab 5 ,
 .Xr fsck 8 ,
 .Xr fsdb 8 ,
-.Xr newfs 8 ,
 .Xr reboot 8
Index: ufsutils/fsck.ufs/fsutil.c
===================================================================
--- ufsutils.orig/fsck.ufs/fsutil.c
+++ ufsutils/fsck.ufs/fsutil.c
@@ -38,7 +38,9 @@
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#if HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 #include <sys/disklabel.h>
 #include <sys/stat.h>
 #include <sys/disklabel.h>
@@ -55,6 +57,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <signal.h>
 #include <unistd.h>
 
 #include "fsck.h"
@@ -277,11 +280,13 @@
 	if (bkgrdflag) {
 		unlink(snapname);
 		if ((!(sblock.fs_flags & FS_UNCLEAN)) != markclean) {
+#ifdef HAVE_BSD_SYSCTL
 			cmd.value = FS_UNCLEAN;
 			cmd.size = markclean ? -1 : 1;
 			if (sysctlbyname("vfs.ffs.setflags", 0, 0,
 			    &cmd, sizeof cmd) == -1)
 				rwerror("SET FILE SYSTEM FLAGS", FS_UNCLEAN);
+#endif
 			if (!preen) {
 				printf("\n***** FILE SYSTEM MARKED %s *****\n",
 				    markclean ? "CLEAN" : "DIRTY");
@@ -565,7 +570,7 @@
 }
 
 void
-catch(int sig __unused)
+catch(int sig)
 {
 
 	ckfini(0);
@@ -578,7 +583,7 @@
  * so that reboot sequence may be interrupted.
  */
 void
-catchquit(int sig __unused)
+catchquit(int sig)
 {
 	printf("returning to single-user after file system check\n");
 	returntosingle = 1;
@@ -647,11 +652,13 @@
 		 * Force foreground fsck to clean up inconsistency.
 		 */
 		if (bkgrdflag) {
+#if HAVE_BSD_SYSCTL
 			cmd.value = FS_NEEDSFSCK;
 			cmd.size = 1;
 			if (sysctlbyname("vfs.ffs.setflags", 0, 0,
 			    &cmd, sizeof cmd) == -1)
 				pwarn("CANNOT SET FS_NEEDSFSCK FLAG\n");
+#endif
 			fprintf(stdout, "CANNOT RUN IN BACKGROUND\n");
 			ckfini(0);
 			exit(EEXIT);
@@ -668,6 +675,7 @@
 	/*
 	 * Force foreground fsck to clean up inconsistency.
 	 */
+#if HAVE_BSD_SYSCTL
 	if (bkgrdflag) {
 		cmd.value = FS_NEEDSFSCK;
 		cmd.size = 1;
@@ -675,6 +683,7 @@
 		    &cmd, sizeof cmd) == -1)
 			pwarn("CANNOT SET FS_NEEDSFSCK FLAG\n");
 	}
+#endif
 	ckfini(0);
 	exit(EEXIT);
 }
Index: ufsutils/fsck.ufs/inode.c
===================================================================
--- ufsutils.orig/fsck.ufs/inode.c
+++ ufsutils/fsck.ufs/inode.c
@@ -36,7 +36,7 @@
 __FBSDID("$FreeBSD: src/sbin/fsck_ffs/inode.c,v 1.38 2006/10/31 22:06:56 pjd Exp $");
 
 #include <sys/param.h>
-#include <sys/stdint.h>
+#include <stdint.h>
 #include <sys/time.h>
 #include <sys/sysctl.h>
 
@@ -47,6 +47,7 @@
 #include <err.h>
 #include <pwd.h>
 #include <string.h>
+#include <time.h>
 
 #include "fsck.h"
 
Index: ufsutils/fsck.ufs/main.c
===================================================================
--- ufsutils.orig/fsck.ufs/main.c
+++ ufsutils/fsck.ufs/main.c
@@ -45,9 +45,17 @@
 #include <sys/stat.h>
 #include <sys/file.h>
 #include <sys/time.h>
+#ifdef HAVE_BSD_STATFS
 #include <sys/mount.h>
+#else
+#include <sys/statvfs.h>
+#define statfs statvfs
+#define f_flags f_flag
+#endif
 #include <sys/resource.h>
+#ifdef HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 #include <sys/uio.h>
 #include <sys/disklabel.h>
 
@@ -62,14 +69,18 @@
 #include <paths.h>
 #include <stdint.h>
 #include <string.h>
+#include <time.h>
+#include <signal.h>
 
 #include "fsck.h"
 
-static void usage(void) __dead2;
+static void usage(char *progname);
 static int argtoi(int flag, const char *req, const char *str, int base);
 static int checkfilesys(char *filesys);
 static int chkdoreload(struct statfs *mntp);
+#ifdef HAVE_BSD_STATFS
 static struct statfs *getmntpt(const char *);
+#endif
 
 int
 main(int argc, char *argv[])
@@ -78,10 +89,11 @@
 	struct rlimit rlimit;
 	struct itimerval itimerval;
 	int ret = 0;
+	char *progname = argv[0];
 
 	sync();
 	skipclean = 1;
-	while ((ch = getopt(argc, argv, "b:Bc:dfFm:npy")) != -1) {
+	while ((ch = getopt(argc, argv, "ab:Bc:dfFm:npy")) != -1) {
 		switch (ch) {
 		case 'b':
 			skipclean = 0;
@@ -125,6 +137,7 @@
 			yflag = 0;
 			break;
 
+		case 'a':
 		case 'p':
 			preen++;
 			break;
@@ -135,20 +148,22 @@
 			break;
 
 		default:
-			usage();
+			usage(progname);
 		}
 	}
 	argc -= optind;
 	argv += optind;
 
 	if (!argc)
-		usage();
+		usage(progname);
 
 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
 		(void)signal(SIGINT, catch);
 	if (preen)
 		(void)signal(SIGQUIT, catchquit);
+#ifdef HAVE_BSD_SIGNALS
 	signal(SIGINFO, infohandler);
+#endif
 	if (bkgrdflag) {
 		signal(SIGALRM, alarmhandler);
 		itimerval.it_interval.tv_sec = 5;
@@ -195,8 +210,10 @@
 	ufs2_daddr_t n_ffree, n_bfree;
 	struct dups *dp;
 	struct statfs *mntp;
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	struct stat snapdir;
 	struct group *grp;
+#endif
 	ufs2_daddr_t blks;
 	struct iovec *iov;
 	char errmsg[255];
@@ -218,10 +235,14 @@
 	 * if it is listed among the mounted file systems. Failing that
 	 * check to see if it is listed in /etc/fstab.
 	 */
+#if HAVE_BSD_STATFS
 	mntp = getmntpt(filesys);
 	if (mntp != NULL)
 		filesys = mntp->f_mntfromname;
 	else
+#else
+	mntp = NULL;
+#endif
 		filesys = blockcheck(filesys);
 	/*
 	 * If -F flag specified, check to see whether a background check
@@ -239,8 +258,10 @@
 		if ((sblock.fs_flags & FS_DOSOFTDEP) == 0)
 			exit(5);	/* Not running soft updates */
 		size = MIBSIZE;
+#if HAVE_BSD_SYSCTL
 		if (sysctlnametomib("vfs.ffs.adjrefcnt", adjrefcnt, &size) < 0)
 			exit(6);	/* Lacks kernel support */
+#endif
 		if ((mntp == NULL && sblock.fs_clean == 1) ||
 		    (mntp != NULL && (sblock.fs_flags & FS_UNCLEAN) == 0))
 			exit(7);	/* Filesystem clean, report it now */
@@ -253,6 +275,7 @@
 		if ((fsreadfd = open(filesys, O_RDONLY)) < 0 || readsb(0) == 0)
 			exit(3);	/* Cannot read superblock */
 		close(fsreadfd);
+#if HAVE_UFS_SNAPSHOT
 		if ((sblock.fs_flags & FS_GJOURNAL) != 0) {
 			//printf("GJournaled file system detected on %s.\n",
 			//    filesys);
@@ -270,6 +293,7 @@
 				    "CANNOT RUN FAST FSCK\n");
 			}
 		}
+#endif
 	}
 	/*
 	 * If we are to do a background check:
@@ -278,6 +299,7 @@
 	 *	return created snapshot file
 	 *	if not found, clear bkgrdflag and proceed with normal fsck
 	 */
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	if (bkgrdflag) {
 		if (mntp == NULL) {
 			bkgrdflag = 0;
@@ -365,6 +387,7 @@
 				filesys = snapname;
 		}
 	}
+#endif
 
 	switch (setup(filesys)) {
 	case 0:
@@ -372,7 +395,9 @@
 			pfatal("CAN'T CHECK FILE SYSTEM.");
 		return (0);
 	case -1:
+#if HAVE_UFS_SNAPSHOT && HAVE_BSD_STATFS
 	clean:
+#endif
 		pwarn("clean, %ld free ", (long)(sblock.fs_cstotal.cs_nffree +
 		    sblock.fs_frag * sblock.fs_cstotal.cs_nbfree));
 		printf("(%lld frags, %lld blocks, %.1f%% fragmentation)\n",
@@ -392,8 +417,10 @@
 	 */
 	if (preen == 0) {
 		printf("** Last Mounted on %s\n", sblock.fs_fsmnt);
+#if HAVE_BSD_STATFS
 		if (mntp != NULL && mntp->f_flags & MNT_ROOTFS)
 			printf("** Root file system\n");
+#endif
 		printf("** Phase 1 - Check Blocks and Sizes\n");
 	}
 	pass1();
@@ -492,8 +519,13 @@
 	/*
 	 * Check to see if the file system is mounted read-write.
 	 */
+#if HAVE_BSD_STATFS
 	if (bkgrdflag == 0 && mntp != NULL && (mntp->f_flags & MNT_RDONLY) == 0)
 		resolved = 0;
+#else
+	if (bkgrdflag == 0 && mntp != NULL && (mntp->f_flag & ST_RDONLY) == 0)
+		resolved = 0;
+#endif
 	ckfini(resolved);
 
 	for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
@@ -536,6 +568,8 @@
 	 * it unless it is read-write, so we can continue using it
 	 * as safely as possible.
 	 */
+#if HAVE_BSD_STATFS && HAVE_BSD_MOUNT
+
 	if (mntp->f_flags & MNT_RDONLY) {
 		/*
 		 * XXX: Need to kick out MNT_ROOTFS until we fix
@@ -558,8 +592,12 @@
 		return (1);
 	}
 	return (0);
+#else
+#warning "FIXME: use linux mount call"
+#endif
 }
 
+#if HAVE_BSD_STATFS
 /*
  * Get the mount point information for name.
  */
@@ -599,13 +637,14 @@
 	statfsp = NULL;
 	return (statfsp);
 }
+#endif
 
 static void
-usage(void)
+usage(char *progname)
 {
         (void) fprintf(stderr,
             "usage: %s [-BFpfny] [-b block] [-c level] [-m mode] "
                         "filesystem ...\n",
-            getprogname());
+            progname);
         exit(1);
 }
Index: ufsutils/fsck.ufs/pass1.c
===================================================================
--- ufsutils.orig/fsck.ufs/pass1.c
+++ ufsutils/fsck.ufs/pass1.c
@@ -317,9 +317,11 @@
 	inoinfo(inumber)->ino_type = IFTODT(mode);
 	badblk = dupblk = 0;
 	idesc->id_number = inumber;
+#if HAVE_UFS_SNAPSHOT
 	if (DIP(dp, di_flags) & SF_SNAPSHOT)
 		idesc->id_type = SNAP;
 	else
+#endif
 		idesc->id_type = ADDR;
 	(void)ckinode(dp, idesc);
 	if (sblock.fs_magic == FS_UFS2_MAGIC && dp->dp2.di_extsize > 0) {
Index: ufsutils/fsck.ufs/setup.c
===================================================================
--- ufsutils.orig/fsck.ufs/setup.c
+++ ufsutils/fsck.ufs/setup.c
@@ -36,11 +36,14 @@
 __FBSDID("$FreeBSD: src/sbin/fsck_ffs/setup.c,v 1.50 2006/10/31 22:06:56 pjd Exp $");
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #define FSTYPENAMES
 #include <sys/disklabel.h>
 #include <sys/file.h>
+#if HAVE_BSD_SYSCTL
 #include <sys/sysctl.h>
+#endif
 
 #include <ufs/ufs/dinode.h>
 #include <ufs/ffs/fs.h>
@@ -51,6 +54,7 @@
 #include <limits.h>
 #include <stdint.h>
 #include <string.h>
+#include <unistd.h>
 
 #include "fsck.h"
 
@@ -87,6 +91,7 @@
 		}
 		return (0);
 	}
+#if HAVE_UFS_SNAPSHOT
 	if ((statb.st_mode & S_IFMT) != S_IFCHR &&
 	    (statb.st_mode & S_IFMT) != S_IFBLK) {
 		if (bkgrdflag != 0 && (statb.st_flags & SF_SNAPSHOT) == 0) {
@@ -121,6 +126,7 @@
 			}
 		}
 	}
+#endif
 	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
 		if (bkgrdflag) {
 			unlink(snapname);
@@ -131,6 +137,7 @@
 	}
 	if (bkgrdflag) {
 		unlink(snapname);
+#if HAVE_BSD_SYSCTL
 		size = MIBSIZE;
 		if (sysctlnametomib("vfs.ffs.adjrefcnt", adjrefcnt, &size) < 0||
 		    sysctlnametomib("vfs.ffs.adjblkcnt", adjblkcnt, &size) < 0||
@@ -160,6 +167,7 @@
 		}
 		cmd.version = FFS_CMD_VERSION;
 		cmd.handle = fsreadfd;
+#endif
 		fswritefd = -1;
 	}
 	if (preen == 0)
@@ -471,6 +479,8 @@
 		return (0);
 	}
 	lp = getdisklabel(dev, devfd);
+	if (!lp)
+		return (0);
 	if (isdigit(*cp))
 		pp = &lp->d_partitions[0];
 	else
@@ -521,13 +531,17 @@
 static struct disklabel *
 getdisklabel(char *s, int fd)
 {
+#ifdef HAVE_BSD_DISKLABEL
 	static struct disklabel lab;
 
 	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
 		if (s == NULL)
+#endif
 			return ((struct disklabel *)NULL);
+#ifdef HAVE_BSD_DISKLABEL
 		pwarn("ioctl (GCINFO): %s\n", strerror(errno));
 		errx(EEXIT, "%s: can't read disk label", s);
 	}
 	return (&lab);
+#endif
 }
Index: ufsutils/fsck.ufs/utilities.c
===================================================================
--- ufsutils.orig/fsck.ufs/utilities.c
+++ ufsutils/fsck.ufs/utilities.c
@@ -108,14 +108,16 @@
 	return (origname);
 }
 
+#ifdef HAVE_BSD_SIGNALS
 void
-infohandler(int sig __unused)
+infohandler(int sig)
 {
 	got_siginfo = 1;
 }
+#endif
 
 void
-alarmhandler(int sig __unused)
+alarmhandler(int sig)
 {
 	got_sigalarm = 1;
 }
Index: ufsutils/fsck.ufs/Makefile
===================================================================
--- ufsutils.orig/fsck.ufs/Makefile
+++ ufsutils/fsck.ufs/Makefile
@@ -1,19 +1,18 @@
 # $FreeBSD: src/sbin/fsck_ffs/Makefile,v 1.18 2007/09/19 01:24:19 rodrigc Exp $
 #	@(#)Makefile	8.2 (Berkeley) 4/27/95
 
-PROG=	fsck_ffs
-LINKS+=	${BINDIR}/fsck_ffs ${BINDIR}/fsck_ufs
-LINKS+=	${BINDIR}/fsck_ffs ${BINDIR}/fsck_4.2bsd
-MAN=	fsck_ffs.8
-MLINKS=	fsck_ffs.8 fsck_ufs.8 fsck_ffs.8 fsck_4.2bsd.8
-SRCS=	dir.c ea.c fsutil.c inode.c main.c pass1.c pass1b.c pass2.c pass3.c \
-	pass4.c pass5.c setup.c utilities.c ffs_subr.c ffs_tables.c gjournal.c \
-	getmntopts.c
-DPADD=	${LIBUFS}
-LDADD=	-lufs
-WARNS?=	2
-CFLAGS+= -I${.CURDIR} -I${.CURDIR}/../mount
+PROG = fsck.ufs
+LIB = $(PROG)
+LIB_type = static
+SRCS = main.c
+MAN = fsck_ffs.8:fsck.ufs.8
+UFS_SRCS = ../include/ufs/ffs/ffs_subr.c ../include/ufs/ffs/ffs_tables.c
+LIBSRCS= dir.c ea.c fsutil.c inode.c pass1.c pass1b.c pass2.c pass3.c \
+	pass4.c pass5.c setup.c utilities.c $(UFS_SRCS) gjournal.c \
+	../mount/getmntopts.c
 
-.PATH:	${.CURDIR}/../../sys/ufs/ffs ${.CURDIR}/../mount
+LDADD += -L../libport -lport -L. -l$(LIB) -L../libufs -lufs
+INCLUDES = -I. -I../libufs -I../mount
+
+include ../Makefile.common
 
-.include <bsd.prog.mk>
