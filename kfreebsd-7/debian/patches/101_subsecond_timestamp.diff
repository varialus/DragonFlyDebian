There is inconsistence in subsecond timestamp resolution handling. 
See #489894, try to execute

  touch k0;  echo > k1; touch k2; echo > k3; touch k4;  echo > k5
  ls --full-time k? | cut -c25-

The results are rather surprising:

 2008-07-10 00:55:01.020578000 +0200 k0
 2008-07-10 00:55:01.000000000 +0200 k1
 2008-07-10 00:55:01.022910000 +0200 k2
 2008-07-10 00:55:01.000000000 +0200 k3
 2008-07-10 00:55:01.023841000 +0200 k4
 2008-07-10 00:55:01.000000000 +0200 k5

The problem seems to be in cooperating between vfs.timestamp_precision 
and utimes/futimes syscalls. Passed NULL to them means "now",
lets the "now" have precision according to vfs.timestamp_precision.

Index: sys/kern/vfs_syscalls.c
===================================================================
--- sys/kern/vfs_syscalls.c.orig
+++ sys/kern/vfs_syscalls.c
@@ -2819,8 +2819,7 @@
 	int error;
 
 	if (usrtvp == NULL) {
-		microtime(&tv[0]);
-		TIMEVAL_TO_TIMESPEC(&tv[0], &tsp[0]);
+		vfs_timestamp(&tsp[0]);
 		tsp[1] = tsp[0];
 	} else {
 		if (tvpseg == UIO_SYSSPACE) {



