--- a/src/usr.sbin/config/main.c
+++ b/src/usr.sbin/config/main.c
@@ -76,8 +76,8 @@
 #define	CDIR	"../compile/"
 
 char *	PREFIX;
-char 	destdir[MAXPATHLEN];
-char 	srcdir[MAXPATHLEN];
+char *	destdir;
+char *	srcdir;
 
 int	debugging;
 int	profiling;
@@ -113,7 +113,7 @@
 	struct stat buf;
 	int ch, len;
 	char *p;
-	char xxx[MAXPATHLEN];
+	char *xxx = NULL;
 	char *kernfile;
 	int printmachine;
 
@@ -128,8 +128,8 @@
 			printmachine = 1;
 			break;
 		case 'd':
-			if (*destdir == '\0')
-				strlcpy(destdir, optarg, sizeof(destdir));
+			if (destdir == NULL)
+				destdir = strdup(optarg);
 			else
 				errx(EXIT_FAILURE, "directory already set");
 			break;
@@ -171,14 +171,13 @@
 			err(2, "%s", PREFIX);
 		yyfile = PREFIX;
 	}
-	if (*destdir != '\0') {
+	if (destdir != NULL) {
 		len = strlen(destdir);
 		while (len > 1 && destdir[len - 1] == '/')
 			destdir[--len] = '\0';
 		get_srcdir();
 	} else {
-		strlcpy(destdir, CDIR, sizeof(destdir));
-		strlcat(destdir, PREFIX, sizeof(destdir));
+		(void) asprintf(&destdir, CDIR "%s", PREFIX);
 	}
 
 	SLIST_INIT(&cputype);
@@ -228,10 +227,10 @@
 	 * for "sys" (to make genassym.c work along with #include <sys/xxx>)
 	 * and similarly for "machine".
 	 */
-	if (*srcdir == '\0')
-		(void)snprintf(xxx, sizeof(xxx), "../../include");
+	if (srcdir == NULL)
+		xxx = strdup("../../include");
 	else
-		(void)snprintf(xxx, sizeof(xxx), "%s/%s/include",
+		(void)asprintf(&xxx, "%s/%s/include",
 		    srcdir, machinename);
 	(void) unlink(path("machine"));
 	(void) symlink(xxx, path("machine"));
@@ -240,15 +239,16 @@
 		 * make symbolic links in compilation directory for
 		 * machinearch, if it is different than machinename.
 		 */
-		if (*srcdir == '\0')
-			(void)snprintf(xxx, sizeof(xxx), "../../../%s/include",
+		if (srcdir == NULL)
+			(void)asprintf(&xxx, "../../../%s/include",
 			    machinearch);
 		else
-			(void)snprintf(xxx, sizeof(xxx), "%s/%s/include",
+			(void)asprintf(&xxx, "%s/%s/include",
 			    srcdir, machinearch);
 		(void) unlink(path(machinearch));
 		(void) symlink(xxx, path(machinearch));
 	}
+	free(xxx);
 	configfile();			/* put config file into kernel*/
 	options();			/* make options .h files */
 	makefile();			/* build Makefile */
@@ -261,6 +261,19 @@
 	exit(0);
 }
 
+#ifndef __GLIBC__
+static char *
+canonicalize_file_name(const char *path)
+{
+	char *ret = malloc(MAXPATHLEN);
+	if (realpath(path, ret) == NULL) {
+		free(ret);
+		ret = NULL;
+	}
+	return ret;
+}
+#endif
+
 /*
  * get_srcdir
  *	determine the root of the kernel source tree
@@ -273,7 +286,9 @@
 	char *p, *pwd;
 	int i;
 
-	if (realpath("../..", srcdir) == NULL)
+	if (srcdir != NULL)
+		free(srcdir);
+	if ((srcdir = canonicalize_file_name("../..")) == NULL)
 		err(EXIT_FAILURE, "Unable to find root of source tree");
 	if ((pwd = getenv("PWD")) != NULL && *pwd == '/' &&
 	    (pwd = strdup(pwd)) != NULL) {
@@ -286,9 +301,12 @@
 			*p = '\0';
 		}
 		if (stat(pwd, &lg) != -1 && stat(srcdir, &phy) != -1 &&
-		    lg.st_dev == phy.st_dev && lg.st_ino == phy.st_ino)
-			strlcpy(srcdir, pwd, MAXPATHLEN);
-		free(pwd);
+		    lg.st_dev == phy.st_dev && lg.st_ino == phy.st_ino) {
+			free(srcdir);
+			srcdir = pwd;
+		} else {
+			free(pwd);
+		}
 	}
 }
 
--- a/src/usr.sbin/config/mkmakefile.c
+++ b/src/usr.sbin/config/mkmakefile.c
@@ -304,7 +304,7 @@
 static void
 read_file(char *fname)
 {
-	char ifname[MAXPATHLEN];
+	char *ifname = NULL;
 	FILE *fp;
 	struct file_list *tp;
 	struct device *dp;
@@ -345,8 +345,9 @@
 			    fname);
 			exit(1);
 		}
-		(void) snprintf(ifname, sizeof(ifname), "../../%s", wd);
+		(void) asprintf(&ifname, "../../%s", wd);
 		read_file(ifname);
+		free(ifname);
 		while (((wd = get_word(fp)) != (char *)EOF) && wd)
 			;
 		goto next;
@@ -543,14 +544,13 @@
 static void
 read_files(void)
 {
-	char fname[MAXPATHLEN];
+	char *fname = NULL;
 	struct files_name *nl, *tnl;
 	
-	(void) snprintf(fname, sizeof(fname), "../../conf/files");
-	read_file(fname);
-	(void) snprintf(fname, sizeof(fname),
-		       	"../../conf/files.%s", machinename);
+	read_file("../../conf/files");
+	(void) asprintf(&fname, "../../conf/files.%s", machinename);
 	read_file(fname);
+	free(fname);
 	for (nl = STAILQ_FIRST(&fntab); nl != NULL; nl = tnl) {
 		read_file(nl->f_name);
 		tnl = STAILQ_NEXT(nl, f_next);
--- a/src/usr.sbin/config/mkoptions.c
+++ b/src/usr.sbin/config/mkoptions.c
@@ -290,22 +290,21 @@
 static char *
 tooption(char *name)
 {
-	static char hbuf[MAXPATHLEN];
-	char nbuf[MAXPATHLEN];
+	char *nbuf;
 	struct opt_list *po;
 
 	/* "cannot happen"?  the otab list should be complete.. */
-	(void)strlcpy(nbuf, "options.h", sizeof(nbuf));
+	nbuf = strdup("options.h");
 
 	SLIST_FOREACH(po, &otab, o_next) {
 		if (eq(po->o_name, name)) {
-			strlcpy(nbuf, po->o_file, sizeof(nbuf));
+			free(nbuf);
+			nbuf = strdup(po->o_file);
 			break;
 		}
 	}
 
-	(void)strlcpy(hbuf, path(nbuf), sizeof(hbuf));
-	return (hbuf);
+	return (nbuf);
 }
 
 	
@@ -361,7 +360,7 @@
 {
 	FILE *fp;
 	char *wd, *this, *val;
-	char genopt[MAXPATHLEN];
+	char *genopt = NULL;
 
 	fp = fopen(fname, "r");
 	if (fp == 0)
@@ -385,7 +384,7 @@
 				exit(1);
 			}
 			char *s = ns(this);
-			(void)snprintf(genopt, sizeof(genopt), "opt_%s.h",
+			(void)asprintf(&genopt, "opt_%s.h",
 			    lower(s));
 			val = genopt;
 			free(s);
@@ -397,6 +396,7 @@
 			update_option(this, val, flags);
 	}
 	(void)fclose(fp);
+	free(genopt);
 	return (1);
 }
 
@@ -406,16 +406,17 @@
 static void
 read_options(void)
 {
-	char fname[MAXPATHLEN];
+	char *fname = NULL;
 
 	SLIST_INIT(&otab);
 	read_option_file("../../conf/options", 0);
-	(void)snprintf(fname, sizeof fname, "../../conf/options.%s",
+	(void)asprintf(&fname, "../../conf/options.%s",
 	    machinename);
 	if (!read_option_file(fname, 0)) {
-		(void)snprintf(fname, sizeof fname, "options.%s", machinename);
+		(void)asprintf(&fname, "options.%s", machinename);
 		read_option_file(fname, 0);
 	}
+	free(fname);
 	read_option_file("../../conf/options-compat", OL_ALIAS);
 }
 
