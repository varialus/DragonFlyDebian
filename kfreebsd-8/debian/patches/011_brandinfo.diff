Upstream checks the .note.ABI-tag in a bad way.
They should not only check the "GNU", but also whether OS field matches.
In both cases they should check 8 bytes, we can use it for current hack.

http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=532627
http://www.freebsd.org/cgi/query-pr.cgi?pr=135468


--- kfreebsd-8-8.0~cvs20090715.orig/sys/amd64/linux32/linux32_sysvec.c
+++ /dev/null
@@ -1,1189 +0,0 @@
-/*-
- * Copyright (c) 2004 Tim J. Robbins
- * Copyright (c) 2003 Peter Wemm
- * Copyright (c) 2002 Doug Rabson
- * Copyright (c) 1998-1999 Andrew Gallatin
- * Copyright (c) 1994-1996 Søren Schmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer
- *    in this position and unchanged.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/amd64/linux32/linux32_sysvec.c,v 1.52 2009/07/09 09:34:11 kib Exp $");
-#include "opt_compat.h"
-
-#ifndef COMPAT_IA32
-#error "Unable to compile Linux-emulator due to missing COMPAT_IA32 option!"
-#endif
-
-#define	__ELF_WORD_SIZE	32
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/exec.h>
-#include <sys/fcntl.h>
-#include <sys/imgact.h>
-#include <sys/imgact_elf.h>
-#include <sys/kernel.h>
-#include <sys/lock.h>
-#include <sys/malloc.h>
-#include <sys/module.h>
-#include <sys/mutex.h>
-#include <sys/proc.h>
-#include <sys/resourcevar.h>
-#include <sys/signalvar.h>
-#include <sys/sysctl.h>
-#include <sys/syscallsubr.h>
-#include <sys/sysent.h>
-#include <sys/sysproto.h>
-#include <sys/vnode.h>
-#include <sys/eventhandler.h>
-
-#include <vm/vm.h>
-#include <vm/pmap.h>
-#include <vm/vm_extern.h>
-#include <vm/vm_map.h>
-#include <vm/vm_object.h>
-#include <vm/vm_page.h>
-#include <vm/vm_param.h>
-
-#include <machine/cpu.h>
-#include <machine/md_var.h>
-#include <machine/pcb.h>
-#include <machine/specialreg.h>
-
-#include <amd64/linux32/linux.h>
-#include <amd64/linux32/linux32_proto.h>
-#include <compat/linux/linux_futex.h>
-#include <compat/linux/linux_emul.h>
-#include <compat/linux/linux_mib.h>
-#include <compat/linux/linux_misc.h>
-#include <compat/linux/linux_signal.h>
-#include <compat/linux/linux_util.h>
-
-MODULE_VERSION(linux, 1);
-
-MALLOC_DEFINE(M_LINUX, "linux", "Linux mode structures");
-
-#define	AUXARGS_ENTRY_32(pos, id, val)	\
-	do {				\
-		suword32(pos++, id);	\
-		suword32(pos++, val);	\
-	} while (0)
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define SHELLMAGIC      0x2123 /* #! */
-#else
-#define SHELLMAGIC      0x2321
-#endif
-
-/*
- * Allow the sendsig functions to use the ldebug() facility
- * even though they are not syscalls themselves. Map them
- * to syscall 0. This is slightly less bogus than using
- * ldebug(sigreturn).
- */
-#define	LINUX_SYS_linux_rt_sendsig	0
-#define	LINUX_SYS_linux_sendsig		0
-
-const char *linux_platform = "i686";
-static int linux_szplatform;
-extern char linux_sigcode[];
-extern int linux_szsigcode;
-
-extern struct sysent linux_sysent[LINUX_SYS_MAXSYSCALL];
-
-SET_DECLARE(linux_ioctl_handler_set, struct linux_ioctl_handler);
-SET_DECLARE(linux_device_handler_set, struct linux_device_handler);
-
-static int	elf_linux_fixup(register_t **stack_base,
-		    struct image_params *iparams);
-static register_t *linux_copyout_strings(struct image_params *imgp);
-static void	linux_prepsyscall(struct trapframe *tf, int *args, u_int *code,
-		    caddr_t *params);
-static void     linux_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask);
-static void	exec_linux_setregs(struct thread *td, u_long entry,
-				   u_long stack, u_long ps_strings);
-static void	linux32_fixlimit(struct rlimit *rl, int which);
-
-static eventhandler_tag linux_exit_tag;
-static eventhandler_tag linux_schedtail_tag;
-static eventhandler_tag linux_exec_tag;
-
-/*
- * Linux syscalls return negative errno's, we do positive and map them
- * Reference:
- *   FreeBSD: src/sys/sys/errno.h
- *   Linux:   linux-2.6.17.8/include/asm-generic/errno-base.h
- *            linux-2.6.17.8/include/asm-generic/errno.h
- */
-static int bsd_to_linux_errno[ELAST + 1] = {
-	-0,  -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,  -9,
-	-10, -35, -12, -13, -14, -15, -16, -17, -18, -19,
-	-20, -21, -22, -23, -24, -25, -26, -27, -28, -29,
-	-30, -31, -32, -33, -34, -11,-115,-114, -88, -89,
-	-90, -91, -92, -93, -94, -95, -96, -97, -98, -99,
-	-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,
-	-110,-111, -40, -36,-112,-113, -39, -11, -87,-122,
-	-116, -66,  -6,  -6,  -6,  -6,  -6, -37, -38,  -9,
-	  -6,  -6, -43, -42, -75,-125, -84, -95, -16, -74,
-	 -72, -67, -71
-};
-
-int bsd_to_linux_signal[LINUX_SIGTBLSZ] = {
-	LINUX_SIGHUP, LINUX_SIGINT, LINUX_SIGQUIT, LINUX_SIGILL,
-	LINUX_SIGTRAP, LINUX_SIGABRT, 0, LINUX_SIGFPE,
-	LINUX_SIGKILL, LINUX_SIGBUS, LINUX_SIGSEGV, LINUX_SIGSYS,
-	LINUX_SIGPIPE, LINUX_SIGALRM, LINUX_SIGTERM, LINUX_SIGURG,
-	LINUX_SIGSTOP, LINUX_SIGTSTP, LINUX_SIGCONT, LINUX_SIGCHLD,
-	LINUX_SIGTTIN, LINUX_SIGTTOU, LINUX_SIGIO, LINUX_SIGXCPU,
-	LINUX_SIGXFSZ, LINUX_SIGVTALRM, LINUX_SIGPROF, LINUX_SIGWINCH,
-	0, LINUX_SIGUSR1, LINUX_SIGUSR2
-};
-
-int linux_to_bsd_signal[LINUX_SIGTBLSZ] = {
-	SIGHUP, SIGINT, SIGQUIT, SIGILL,
-	SIGTRAP, SIGABRT, SIGBUS, SIGFPE,
-	SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2,
-	SIGPIPE, SIGALRM, SIGTERM, SIGBUS,
-	SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP,
-	SIGTTIN, SIGTTOU, SIGURG, SIGXCPU,
-	SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH,
-	SIGIO, SIGURG, SIGSYS
-};
-
-#define LINUX_T_UNKNOWN  255
-static int _bsd_to_linux_trapcode[] = {
-	LINUX_T_UNKNOWN,	/* 0 */
-	6,			/* 1  T_PRIVINFLT */
-	LINUX_T_UNKNOWN,	/* 2 */
-	3,			/* 3  T_BPTFLT */
-	LINUX_T_UNKNOWN,	/* 4 */
-	LINUX_T_UNKNOWN,	/* 5 */
-	16,			/* 6  T_ARITHTRAP */
-	254,			/* 7  T_ASTFLT */
-	LINUX_T_UNKNOWN,	/* 8 */
-	13,			/* 9  T_PROTFLT */
-	1,			/* 10 T_TRCTRAP */
-	LINUX_T_UNKNOWN,	/* 11 */
-	14,			/* 12 T_PAGEFLT */
-	LINUX_T_UNKNOWN,	/* 13 */
-	17,			/* 14 T_ALIGNFLT */
-	LINUX_T_UNKNOWN,	/* 15 */
-	LINUX_T_UNKNOWN,	/* 16 */
-	LINUX_T_UNKNOWN,	/* 17 */
-	0,			/* 18 T_DIVIDE */
-	2,			/* 19 T_NMI */
-	4,			/* 20 T_OFLOW */
-	5,			/* 21 T_BOUND */
-	7,			/* 22 T_DNA */
-	8,			/* 23 T_DOUBLEFLT */
-	9,			/* 24 T_FPOPFLT */
-	10,			/* 25 T_TSSFLT */
-	11,			/* 26 T_SEGNPFLT */
-	12,			/* 27 T_STKFLT */
-	18,			/* 28 T_MCHK */
-	19,			/* 29 T_XMMFLT */
-	15			/* 30 T_RESERVED */
-};
-#define bsd_to_linux_trapcode(code) \
-    ((code)<sizeof(_bsd_to_linux_trapcode)/sizeof(*_bsd_to_linux_trapcode)? \
-     _bsd_to_linux_trapcode[(code)]: \
-     LINUX_T_UNKNOWN)
-
-struct linux32_ps_strings {
-	u_int32_t ps_argvstr;	/* first of 0 or more argument strings */
-	u_int ps_nargvstr;	/* the number of argument strings */
-	u_int32_t ps_envstr;	/* first of 0 or more environment strings */
-	u_int ps_nenvstr;	/* the number of environment strings */
-};
-
-/*
- * If FreeBSD & Linux have a difference of opinion about what a trap
- * means, deal with it here.
- *
- * MPSAFE
- */
-static int
-translate_traps(int signal, int trap_code)
-{
-	if (signal != SIGBUS)
-		return signal;
-	switch (trap_code) {
-	case T_PROTFLT:
-	case T_TSSFLT:
-	case T_DOUBLEFLT:
-	case T_PAGEFLT:
-		return SIGSEGV;
-	default:
-		return signal;
-	}
-}
-
-static int
-elf_linux_fixup(register_t **stack_base, struct image_params *imgp)
-{
-	Elf32_Auxargs *args;
-	Elf32_Addr *base;
-	Elf32_Addr *pos, *uplatform;
-	struct linux32_ps_strings *arginfo;
-
-	arginfo = (struct linux32_ps_strings *)LINUX32_PS_STRINGS;
-	uplatform = (Elf32_Addr *)((caddr_t)arginfo - linux_szsigcode -
-	    linux_szplatform);
-
-	KASSERT(curthread->td_proc == imgp->proc,
-	    ("unsafe elf_linux_fixup(), should be curproc"));
-	base = (Elf32_Addr *)*stack_base;
-	args = (Elf32_Auxargs *)imgp->auxargs;
-	pos = base + (imgp->args->argc + imgp->args->envc + 2);
-
-	AUXARGS_ENTRY_32(pos, LINUX_AT_HWCAP, cpu_feature);
-
-	/*
-	 * Do not export AT_CLKTCK when emulating Linux kernel prior to 2.4.0,
-	 * as it has appeared in the 2.4.0-rc7 first time.
-	 * Being exported, AT_CLKTCK is returned by sysconf(_SC_CLK_TCK),
-	 * glibc falls back to the hard-coded CLK_TCK value when aux entry
-	 * is not present.
-	 * Also see linux_times() implementation.
-	 */
-	if (linux_kernver(curthread) >= LINUX_KERNVER_2004000)
-		AUXARGS_ENTRY_32(pos, LINUX_AT_CLKTCK, stclohz);
-	AUXARGS_ENTRY_32(pos, AT_PHDR, args->phdr);
-	AUXARGS_ENTRY_32(pos, AT_PHENT, args->phent);
-	AUXARGS_ENTRY_32(pos, AT_PHNUM, args->phnum);
-	AUXARGS_ENTRY_32(pos, AT_PAGESZ, args->pagesz);
-	AUXARGS_ENTRY_32(pos, AT_FLAGS, args->flags);
-	AUXARGS_ENTRY_32(pos, AT_ENTRY, args->entry);
-	AUXARGS_ENTRY_32(pos, AT_BASE, args->base);
-	AUXARGS_ENTRY_32(pos, LINUX_AT_SECURE, 0);
-	AUXARGS_ENTRY_32(pos, AT_UID, imgp->proc->p_ucred->cr_ruid);
-	AUXARGS_ENTRY_32(pos, AT_EUID, imgp->proc->p_ucred->cr_svuid);
-	AUXARGS_ENTRY_32(pos, AT_GID, imgp->proc->p_ucred->cr_rgid);
-	AUXARGS_ENTRY_32(pos, AT_EGID, imgp->proc->p_ucred->cr_svgid);
-	AUXARGS_ENTRY_32(pos, LINUX_AT_PLATFORM, PTROUT(uplatform));
-	if (args->execfd != -1)
-		AUXARGS_ENTRY_32(pos, AT_EXECFD, args->execfd);
-	AUXARGS_ENTRY_32(pos, AT_NULL, 0);
-
-	free(imgp->auxargs, M_TEMP);
-	imgp->auxargs = NULL;
-
-	base--;
-	suword32(base, (uint32_t)imgp->args->argc);
-	*stack_base = (register_t *)base;
-	return 0;
-}
-
-extern unsigned long linux_sznonrtsigcode;
-
-static void
-linux_rt_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask)
-{
-	struct thread *td = curthread;
-	struct proc *p = td->td_proc;
-	struct sigacts *psp;
-	struct trapframe *regs;
-	struct l_rt_sigframe *fp, frame;
-	int oonstack;
-	int sig;
-	int code;
-	
-	sig = ksi->ksi_signo;
-	code = ksi->ksi_code;
-	PROC_LOCK_ASSERT(p, MA_OWNED);
-	psp = p->p_sigacts;
-	mtx_assert(&psp->ps_mtx, MA_OWNED);
-	regs = td->td_frame;
-	oonstack = sigonstack(regs->tf_rsp);
-
-#ifdef DEBUG
-	if (ldebug(rt_sendsig))
-		printf(ARGS(rt_sendsig, "%p, %d, %p, %u"),
-		    catcher, sig, (void*)mask, code);
-#endif
-	/*
-	 * Allocate space for the signal handler context.
-	 */
-	if ((td->td_pflags & TDP_ALTSTACK) && !oonstack &&
-	    SIGISMEMBER(psp->ps_sigonstack, sig)) {
-		fp = (struct l_rt_sigframe *)(td->td_sigstk.ss_sp +
-		    td->td_sigstk.ss_size - sizeof(struct l_rt_sigframe));
-	} else
-		fp = (struct l_rt_sigframe *)regs->tf_rsp - 1;
-	mtx_unlock(&psp->ps_mtx);
-
-	/*
-	 * Build the argument list for the signal handler.
-	 */
-	if (p->p_sysent->sv_sigtbl)
-		if (sig <= p->p_sysent->sv_sigsize)
-			sig = p->p_sysent->sv_sigtbl[_SIG_IDX(sig)];
-
-	bzero(&frame, sizeof(frame));
-
-	frame.sf_handler = PTROUT(catcher);
-	frame.sf_sig = sig;
-	frame.sf_siginfo = PTROUT(&fp->sf_si);
-	frame.sf_ucontext = PTROUT(&fp->sf_sc);
-
-	/* Fill in POSIX parts */
-	ksiginfo_to_lsiginfo(ksi, &frame.sf_si, sig);
-
-	/*
-	 * Build the signal context to be used by sigreturn.
-	 */
-	frame.sf_sc.uc_flags = 0;		/* XXX ??? */
-	frame.sf_sc.uc_link = 0;		/* XXX ??? */
-
-	frame.sf_sc.uc_stack.ss_sp = PTROUT(td->td_sigstk.ss_sp);
-	frame.sf_sc.uc_stack.ss_size = td->td_sigstk.ss_size;
-	frame.sf_sc.uc_stack.ss_flags = (td->td_pflags & TDP_ALTSTACK)
-	    ? ((oonstack) ? LINUX_SS_ONSTACK : 0) : LINUX_SS_DISABLE;
-	PROC_UNLOCK(p);
-
-	bsd_to_linux_sigset(mask, &frame.sf_sc.uc_sigmask);
-
-	frame.sf_sc.uc_mcontext.sc_mask   = frame.sf_sc.uc_sigmask.__bits[0];
-	frame.sf_sc.uc_mcontext.sc_edi    = regs->tf_rdi;
-	frame.sf_sc.uc_mcontext.sc_esi    = regs->tf_rsi;
-	frame.sf_sc.uc_mcontext.sc_ebp    = regs->tf_rbp;
-	frame.sf_sc.uc_mcontext.sc_ebx    = regs->tf_rbx;
-	frame.sf_sc.uc_mcontext.sc_edx    = regs->tf_rdx;
-	frame.sf_sc.uc_mcontext.sc_ecx    = regs->tf_rcx;
-	frame.sf_sc.uc_mcontext.sc_eax    = regs->tf_rax;
-	frame.sf_sc.uc_mcontext.sc_eip    = regs->tf_rip;
-	frame.sf_sc.uc_mcontext.sc_cs     = regs->tf_cs;
-	frame.sf_sc.uc_mcontext.sc_gs     = regs->tf_gs;
-	frame.sf_sc.uc_mcontext.sc_fs     = regs->tf_fs;
-	frame.sf_sc.uc_mcontext.sc_es     = regs->tf_es;
-	frame.sf_sc.uc_mcontext.sc_ds     = regs->tf_ds;
-	frame.sf_sc.uc_mcontext.sc_eflags = regs->tf_rflags;
-	frame.sf_sc.uc_mcontext.sc_esp_at_signal = regs->tf_rsp;
-	frame.sf_sc.uc_mcontext.sc_ss     = regs->tf_ss;
-	frame.sf_sc.uc_mcontext.sc_err    = regs->tf_err;
-	frame.sf_sc.uc_mcontext.sc_cr2    = (u_int32_t)(uintptr_t)ksi->ksi_addr;
-	frame.sf_sc.uc_mcontext.sc_trapno = bsd_to_linux_trapcode(code);
-
-#ifdef DEBUG
-	if (ldebug(rt_sendsig))
-		printf(LMSG("rt_sendsig flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"),
-		    frame.sf_sc.uc_stack.ss_flags, td->td_sigstk.ss_sp,
-		    td->td_sigstk.ss_size, frame.sf_sc.uc_mcontext.sc_mask);
-#endif
-
-	if (copyout(&frame, fp, sizeof(frame)) != 0) {
-		/*
-		 * Process has trashed its stack; give it an illegal
-		 * instruction to halt it in its tracks.
-		 */
-#ifdef DEBUG
-		if (ldebug(rt_sendsig))
-			printf(LMSG("rt_sendsig: bad stack %p, oonstack=%x"),
-			    fp, oonstack);
-#endif
-		PROC_LOCK(p);
-		sigexit(td, SIGILL);
-	}
-
-	/*
-	 * Build context to run handler in.
-	 */
-	regs->tf_rsp = PTROUT(fp);
-	regs->tf_rip = LINUX32_PS_STRINGS - *(p->p_sysent->sv_szsigcode) +
-	    linux_sznonrtsigcode;
-	regs->tf_rflags &= ~(PSL_T | PSL_D);
-	regs->tf_cs = _ucode32sel;
-	regs->tf_ss = _udatasel;
-	regs->tf_ds = _udatasel;
-	regs->tf_es = _udatasel;
-	regs->tf_fs = _ufssel;
-	regs->tf_gs = _ugssel;
-	regs->tf_flags = TF_HASSEGS;
-	td->td_pcb->pcb_full_iret = 1;
-	PROC_LOCK(p);
-	mtx_lock(&psp->ps_mtx);
-}
-
-
-/*
- * Send an interrupt to process.
- *
- * Stack is set up to allow sigcode stored
- * in u. to call routine, followed by kcall
- * to sigreturn routine below.  After sigreturn
- * resets the signal mask, the stack, and the
- * frame pointer, it returns to the user
- * specified pc, psl.
- */
-static void
-linux_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask)
-{
-	struct thread *td = curthread;
-	struct proc *p = td->td_proc;
-	struct sigacts *psp;
-	struct trapframe *regs;
-	struct l_sigframe *fp, frame;
-	l_sigset_t lmask;
-	int oonstack, i;
-	int sig, code;
-
-	sig = ksi->ksi_signo;
-	code = ksi->ksi_code;
-	PROC_LOCK_ASSERT(p, MA_OWNED);
-	psp = p->p_sigacts;
-	mtx_assert(&psp->ps_mtx, MA_OWNED);
-	if (SIGISMEMBER(psp->ps_siginfo, sig)) {
-		/* Signal handler installed with SA_SIGINFO. */
-		linux_rt_sendsig(catcher, ksi, mask);
-		return;
-	}
-
-	regs = td->td_frame;
-	oonstack = sigonstack(regs->tf_rsp);
-
-#ifdef DEBUG
-	if (ldebug(sendsig))
-		printf(ARGS(sendsig, "%p, %d, %p, %u"),
-		    catcher, sig, (void*)mask, code);
-#endif
-
-	/*
-	 * Allocate space for the signal handler context.
-	 */
-	if ((td->td_pflags & TDP_ALTSTACK) && !oonstack &&
-	    SIGISMEMBER(psp->ps_sigonstack, sig)) {
-		fp = (struct l_sigframe *)(td->td_sigstk.ss_sp +
-		    td->td_sigstk.ss_size - sizeof(struct l_sigframe));
-	} else
-		fp = (struct l_sigframe *)regs->tf_rsp - 1;
-	mtx_unlock(&psp->ps_mtx);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Build the argument list for the signal handler.
-	 */
-	if (p->p_sysent->sv_sigtbl)
-		if (sig <= p->p_sysent->sv_sigsize)
-			sig = p->p_sysent->sv_sigtbl[_SIG_IDX(sig)];
-
-	bzero(&frame, sizeof(frame));
-
-	frame.sf_handler = PTROUT(catcher);
-	frame.sf_sig = sig;
-
-	bsd_to_linux_sigset(mask, &lmask);
-
-	/*
-	 * Build the signal context to be used by sigreturn.
-	 */
-	frame.sf_sc.sc_mask   = lmask.__bits[0];
-	frame.sf_sc.sc_gs     = regs->tf_gs;
-	frame.sf_sc.sc_fs     = regs->tf_fs;
-	frame.sf_sc.sc_es     = regs->tf_es;
-	frame.sf_sc.sc_ds     = regs->tf_ds;
-	frame.sf_sc.sc_edi    = regs->tf_rdi;
-	frame.sf_sc.sc_esi    = regs->tf_rsi;
-	frame.sf_sc.sc_ebp    = regs->tf_rbp;
-	frame.sf_sc.sc_ebx    = regs->tf_rbx;
-	frame.sf_sc.sc_edx    = regs->tf_rdx;
-	frame.sf_sc.sc_ecx    = regs->tf_rcx;
-	frame.sf_sc.sc_eax    = regs->tf_rax;
-	frame.sf_sc.sc_eip    = regs->tf_rip;
-	frame.sf_sc.sc_cs     = regs->tf_cs;
-	frame.sf_sc.sc_eflags = regs->tf_rflags;
-	frame.sf_sc.sc_esp_at_signal = regs->tf_rsp;
-	frame.sf_sc.sc_ss     = regs->tf_ss;
-	frame.sf_sc.sc_err    = regs->tf_err;
-	frame.sf_sc.sc_cr2    = (u_int32_t)(uintptr_t)ksi->ksi_addr;
-	frame.sf_sc.sc_trapno = bsd_to_linux_trapcode(code);
-
-	for (i = 0; i < (LINUX_NSIG_WORDS-1); i++)
-		frame.sf_extramask[i] = lmask.__bits[i+1];
-
-	if (copyout(&frame, fp, sizeof(frame)) != 0) {
-		/*
-		 * Process has trashed its stack; give it an illegal
-		 * instruction to halt it in its tracks.
-		 */
-		PROC_LOCK(p);
-		sigexit(td, SIGILL);
-	}
-
-	/*
-	 * Build context to run handler in.
-	 */
-	regs->tf_rsp = PTROUT(fp);
-	regs->tf_rip = LINUX32_PS_STRINGS - *(p->p_sysent->sv_szsigcode);
-	regs->tf_rflags &= ~(PSL_T | PSL_D);
-	regs->tf_cs = _ucode32sel;
-	regs->tf_ss = _udatasel;
-	regs->tf_ds = _udatasel;
-	regs->tf_es = _udatasel;
-	regs->tf_fs = _ufssel;
-	regs->tf_gs = _ugssel;
-	regs->tf_flags = TF_HASSEGS;
-	td->td_pcb->pcb_full_iret = 1;
-	PROC_LOCK(p);
-	mtx_lock(&psp->ps_mtx);
-}
-
-/*
- * System call to cleanup state after a signal
- * has been taken.  Reset signal mask and
- * stack state from context left by sendsig (above).
- * Return to previous pc and psl as specified by
- * context left by sendsig. Check carefully to
- * make sure that the user has not modified the
- * psl to gain improper privileges or to cause
- * a machine fault.
- */
-int
-linux_sigreturn(struct thread *td, struct linux_sigreturn_args *args)
-{
-	struct proc *p = td->td_proc;
-	struct l_sigframe frame;
-	struct trapframe *regs;
-	l_sigset_t lmask;
-	int eflags, i;
-	ksiginfo_t ksi;
-
-	regs = td->td_frame;
-
-#ifdef DEBUG
-	if (ldebug(sigreturn))
-		printf(ARGS(sigreturn, "%p"), (void *)args->sfp);
-#endif
-	/*
-	 * The trampoline code hands us the sigframe.
-	 * It is unsafe to keep track of it ourselves, in the event that a
-	 * program jumps out of a signal handler.
-	 */
-	if (copyin(args->sfp, &frame, sizeof(frame)) != 0)
-		return (EFAULT);
-
-	/*
-	 * Check for security violations.
-	 */
-#define	EFLAGS_SECURE(ef, oef)	((((ef) ^ (oef)) & ~PSL_USERCHANGE) == 0)
-	eflags = frame.sf_sc.sc_eflags;
-	/*
-	 * XXX do allow users to change the privileged flag PSL_RF.  The
-	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should
-	 * sometimes set it there too.  tf_eflags is kept in the signal
-	 * context during signal handling and there is no other place
-	 * to remember it, so the PSL_RF bit may be corrupted by the
-	 * signal handler without us knowing.  Corruption of the PSL_RF
-	 * bit at worst causes one more or one less debugger trap, so
-	 * allowing it is fairly harmless.
-	 */
-	if (!EFLAGS_SECURE(eflags & ~PSL_RF, regs->tf_rflags & ~PSL_RF))
-		return(EINVAL);
-
-	/*
-	 * Don't allow users to load a valid privileged %cs.  Let the
-	 * hardware check for invalid selectors, excess privilege in
-	 * other selectors, invalid %eip's and invalid %esp's.
-	 */
-#define	CS_SECURE(cs)	(ISPL(cs) == SEL_UPL)
-	if (!CS_SECURE(frame.sf_sc.sc_cs)) {
-		ksiginfo_init_trap(&ksi);
-		ksi.ksi_signo = SIGBUS;
-		ksi.ksi_code = BUS_OBJERR;
-		ksi.ksi_trapno = T_PROTFLT;
-		ksi.ksi_addr = (void *)regs->tf_rip;
-		trapsignal(td, &ksi);
-		return(EINVAL);
-	}
-
-	lmask.__bits[0] = frame.sf_sc.sc_mask;
-	for (i = 0; i < (LINUX_NSIG_WORDS-1); i++)
-		lmask.__bits[i+1] = frame.sf_extramask[i];
-	PROC_LOCK(p);
-	linux_to_bsd_sigset(&lmask, &td->td_sigmask);
-	SIG_CANTMASK(td->td_sigmask);
-	signotify(td);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Restore signal context.
-	 */
-	regs->tf_rdi    = frame.sf_sc.sc_edi;
-	regs->tf_rsi    = frame.sf_sc.sc_esi;
-	regs->tf_rbp    = frame.sf_sc.sc_ebp;
-	regs->tf_rbx    = frame.sf_sc.sc_ebx;
-	regs->tf_rdx    = frame.sf_sc.sc_edx;
-	regs->tf_rcx    = frame.sf_sc.sc_ecx;
-	regs->tf_rax    = frame.sf_sc.sc_eax;
-	regs->tf_rip    = frame.sf_sc.sc_eip;
-	regs->tf_cs     = frame.sf_sc.sc_cs;
-	regs->tf_ds     = frame.sf_sc.sc_ds;
-	regs->tf_es     = frame.sf_sc.sc_es;
-	regs->tf_fs     = frame.sf_sc.sc_fs;
-	regs->tf_gs     = frame.sf_sc.sc_gs;
-	regs->tf_rflags = eflags;
-	regs->tf_rsp    = frame.sf_sc.sc_esp_at_signal;
-	regs->tf_ss     = frame.sf_sc.sc_ss;
-	td->td_pcb->pcb_full_iret = 1;
-
-	return (EJUSTRETURN);
-}
-
-/*
- * System call to cleanup state after a signal
- * has been taken.  Reset signal mask and
- * stack state from context left by rt_sendsig (above).
- * Return to previous pc and psl as specified by
- * context left by sendsig. Check carefully to
- * make sure that the user has not modified the
- * psl to gain improper privileges or to cause
- * a machine fault.
- */
-int
-linux_rt_sigreturn(struct thread *td, struct linux_rt_sigreturn_args *args)
-{
-	struct proc *p = td->td_proc;
-	struct l_ucontext uc;
-	struct l_sigcontext *context;
-	l_stack_t *lss;
-	stack_t ss;
-	struct trapframe *regs;
-	int eflags;
-	ksiginfo_t ksi;
-
-	regs = td->td_frame;
-
-#ifdef DEBUG
-	if (ldebug(rt_sigreturn))
-		printf(ARGS(rt_sigreturn, "%p"), (void *)args->ucp);
-#endif
-	/*
-	 * The trampoline code hands us the ucontext.
-	 * It is unsafe to keep track of it ourselves, in the event that a
-	 * program jumps out of a signal handler.
-	 */
-	if (copyin(args->ucp, &uc, sizeof(uc)) != 0)
-		return (EFAULT);
-
-	context = &uc.uc_mcontext;
-
-	/*
-	 * Check for security violations.
-	 */
-#define	EFLAGS_SECURE(ef, oef)	((((ef) ^ (oef)) & ~PSL_USERCHANGE) == 0)
-	eflags = context->sc_eflags;
-	/*
-	 * XXX do allow users to change the privileged flag PSL_RF.  The
-	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should
-	 * sometimes set it there too.  tf_eflags is kept in the signal
-	 * context during signal handling and there is no other place
-	 * to remember it, so the PSL_RF bit may be corrupted by the
-	 * signal handler without us knowing.  Corruption of the PSL_RF
-	 * bit at worst causes one more or one less debugger trap, so
-	 * allowing it is fairly harmless.
-	 */
-	if (!EFLAGS_SECURE(eflags & ~PSL_RF, regs->tf_rflags & ~PSL_RF))
-		return(EINVAL);
-
-	/*
-	 * Don't allow users to load a valid privileged %cs.  Let the
-	 * hardware check for invalid selectors, excess privilege in
-	 * other selectors, invalid %eip's and invalid %esp's.
-	 */
-#define	CS_SECURE(cs)	(ISPL(cs) == SEL_UPL)
-	if (!CS_SECURE(context->sc_cs)) {
-		ksiginfo_init_trap(&ksi);
-		ksi.ksi_signo = SIGBUS;
-		ksi.ksi_code = BUS_OBJERR;
-		ksi.ksi_trapno = T_PROTFLT;
-		ksi.ksi_addr = (void *)regs->tf_rip;
-		trapsignal(td, &ksi);
-		return(EINVAL);
-	}
-
-	PROC_LOCK(p);
-	linux_to_bsd_sigset(&uc.uc_sigmask, &td->td_sigmask);
-	SIG_CANTMASK(td->td_sigmask);
-	signotify(td);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Restore signal context
-	 */
-	regs->tf_gs	= context->sc_gs;
-	regs->tf_fs	= context->sc_fs;
-	regs->tf_es	= context->sc_es;
-	regs->tf_ds	= context->sc_ds;
-	regs->tf_rdi    = context->sc_edi;
-	regs->tf_rsi    = context->sc_esi;
-	regs->tf_rbp    = context->sc_ebp;
-	regs->tf_rbx    = context->sc_ebx;
-	regs->tf_rdx    = context->sc_edx;
-	regs->tf_rcx    = context->sc_ecx;
-	regs->tf_rax    = context->sc_eax;
-	regs->tf_rip    = context->sc_eip;
-	regs->tf_cs     = context->sc_cs;
-	regs->tf_rflags = eflags;
-	regs->tf_rsp    = context->sc_esp_at_signal;
-	regs->tf_ss     = context->sc_ss;
-	td->td_pcb->pcb_full_iret = 1;
-
-	/*
-	 * call sigaltstack & ignore results..
-	 */
-	lss = &uc.uc_stack;
-	ss.ss_sp = PTRIN(lss->ss_sp);
-	ss.ss_size = lss->ss_size;
-	ss.ss_flags = linux_to_bsd_sigaltstack(lss->ss_flags);
-
-#ifdef DEBUG
-	if (ldebug(rt_sigreturn))
-		printf(LMSG("rt_sigret flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"),
-		    ss.ss_flags, ss.ss_sp, ss.ss_size, context->sc_mask);
-#endif
-	(void)kern_sigaltstack(td, &ss, NULL);
-
-	return (EJUSTRETURN);
-}
-
-/*
- * MPSAFE
- */
-static void
-linux_prepsyscall(struct trapframe *tf, int *args, u_int *code, caddr_t *params)
-{
-	args[0] = tf->tf_rbx;
-	args[1] = tf->tf_rcx;
-	args[2] = tf->tf_rdx;
-	args[3] = tf->tf_rsi;
-	args[4] = tf->tf_rdi;
-	args[5] = tf->tf_rbp;	/* Unconfirmed */
-	*params = NULL;		/* no copyin */
-}
-
-/*
- * If a linux binary is exec'ing something, try this image activator
- * first.  We override standard shell script execution in order to
- * be able to modify the interpreter path.  We only do this if a linux
- * binary is doing the exec, so we do not create an EXEC module for it.
- */
-static int	exec_linux_imgact_try(struct image_params *iparams);
-
-static int
-exec_linux_imgact_try(struct image_params *imgp)
-{
-	const char *head = (const char *)imgp->image_header;
-	char *rpath;
-	int error = -1, len;
-
-	/*
-	* The interpreter for shell scripts run from a linux binary needs
-	* to be located in /compat/linux if possible in order to recursively
-	* maintain linux path emulation.
-	*/
-	if (((const short *)head)[0] == SHELLMAGIC) {
-		/*
-		* Run our normal shell image activator.  If it succeeds attempt
-		* to use the alternate path for the interpreter.  If an
-		* alternate * path is found, use our stringspace to store it.
-		*/
-		if ((error = exec_shell_imgact(imgp)) == 0) {
-			linux_emul_convpath(FIRST_THREAD_IN_PROC(imgp->proc),
-			    imgp->interpreter_name, UIO_SYSSPACE, &rpath, 0,
-			    AT_FDCWD);
-			if (rpath != NULL) {
-				len = strlen(rpath) + 1;
-
-				if (len <= MAXSHELLCMDLEN) {
-					memcpy(imgp->interpreter_name, rpath,
-					    len);
-				}
-				free(rpath, M_TEMP);
-			}
-		}
-	}
-	return(error);
-}
-
-/*
- * Clear registers on exec
- * XXX copied from ia32_signal.c.
- */
-static void
-exec_linux_setregs(td, entry, stack, ps_strings)
-	struct thread *td;
-	u_long entry;
-	u_long stack;
-	u_long ps_strings;
-{
-	struct trapframe *regs = td->td_frame;
-	struct pcb *pcb = td->td_pcb;
-
-	mtx_lock(&dt_lock);
-	if (td->td_proc->p_md.md_ldt != NULL)
-		user_ldt_free(td);
-	else
-		mtx_unlock(&dt_lock);
-
-	critical_enter();
-	wrmsr(MSR_FSBASE, 0);
-	wrmsr(MSR_KGSBASE, 0);	/* User value while we're in the kernel */
-	pcb->pcb_fsbase = 0;
-	pcb->pcb_gsbase = 0;
-	critical_exit();
-	pcb->pcb_initial_fpucw = __LINUX_NPXCW__;
-
-	bzero((char *)regs, sizeof(struct trapframe));
-	regs->tf_rip = entry;
-	regs->tf_rsp = stack;
-	regs->tf_rflags = PSL_USER | (regs->tf_rflags & PSL_T);
-	regs->tf_gs = _ugssel;
-	regs->tf_fs = _ufssel;
-	regs->tf_es = _udatasel;
-	regs->tf_ds = _udatasel;
-	regs->tf_ss = _udatasel;
-	regs->tf_flags = TF_HASSEGS;
-	regs->tf_cs = _ucode32sel;
-	regs->tf_rbx = ps_strings;
-	td->td_pcb->pcb_full_iret = 1;
-	load_cr0(rcr0() | CR0_MP | CR0_TS);
-	fpstate_drop(td);
-
-	/* Return via doreti so that we can change to a different %cs */
-	pcb->pcb_flags |= PCB_FULLCTX | PCB_32BIT;
-	pcb->pcb_flags &= ~PCB_GS32BIT;
-	td->td_retval[1] = 0;
-}
-
-/*
- * XXX copied from ia32_sysvec.c.
- */
-static register_t *
-linux_copyout_strings(struct image_params *imgp)
-{
-	int argc, envc;
-	u_int32_t *vectp;
-	char *stringp, *destp;
-	u_int32_t *stack_base;
-	struct linux32_ps_strings *arginfo;
-
-	/*
-	 * Calculate string base and vector table pointers.
-	 * Also deal with signal trampoline code for this exec type.
-	 */
-	arginfo = (struct linux32_ps_strings *)LINUX32_PS_STRINGS;
-	destp =	(caddr_t)arginfo - linux_szsigcode - SPARE_USRSPACE -
-	    linux_szplatform - roundup((ARG_MAX - imgp->args->stringspace),
-	    sizeof(char *));
-
-	/*
-	 * install sigcode
-	 */
-	copyout(imgp->proc->p_sysent->sv_sigcode,
-	    ((caddr_t)arginfo - linux_szsigcode), linux_szsigcode);
-
-	/*
-	 * Install LINUX_PLATFORM
-	 */
-	copyout(linux_platform, ((caddr_t)arginfo - linux_szsigcode -
-	    linux_szplatform), linux_szplatform);
-
-	/*
-	 * If we have a valid auxargs ptr, prepare some room
-	 * on the stack.
-	 */
-	if (imgp->auxargs) {
-		/*
-		 * 'AT_COUNT*2' is size for the ELF Auxargs data. This is for
-		 * lower compatibility.
-		 */
-		imgp->auxarg_size = (imgp->auxarg_size) ? imgp->auxarg_size :
-		    (LINUX_AT_COUNT * 2);
-		/*
-		 * The '+ 2' is for the null pointers at the end of each of
-		 * the arg and env vector sets,and imgp->auxarg_size is room
-		 * for argument of Runtime loader.
-		 */
-		vectp = (u_int32_t *) (destp - (imgp->args->argc +
-		    imgp->args->envc + 2 + imgp->auxarg_size) *
-		    sizeof(u_int32_t));
-
-	} else
-		/*
-		 * The '+ 2' is for the null pointers at the end of each of
-		 * the arg and env vector sets
-		 */
-		vectp = (u_int32_t *)(destp - (imgp->args->argc +
-		    imgp->args->envc + 2) * sizeof(u_int32_t));
-
-	/*
-	 * vectp also becomes our initial stack base
-	 */
-	stack_base = vectp;
-
-	stringp = imgp->args->begin_argv;
-	argc = imgp->args->argc;
-	envc = imgp->args->envc;
-	/*
-	 * Copy out strings - arguments and environment.
-	 */
-	copyout(stringp, destp, ARG_MAX - imgp->args->stringspace);
-
-	/*
-	 * Fill in "ps_strings" struct for ps, w, etc.
-	 */
-	suword32(&arginfo->ps_argvstr, (uint32_t)(intptr_t)vectp);
-	suword32(&arginfo->ps_nargvstr, argc);
-
-	/*
-	 * Fill in argument portion of vector table.
-	 */
-	for (; argc > 0; --argc) {
-		suword32(vectp++, (uint32_t)(intptr_t)destp);
-		while (*stringp++ != 0)
-			destp++;
-		destp++;
-	}
-
-	/* a null vector table pointer separates the argp's from the envp's */
-	suword32(vectp++, 0);
-
-	suword32(&arginfo->ps_envstr, (uint32_t)(intptr_t)vectp);
-	suword32(&arginfo->ps_nenvstr, envc);
-
-	/*
-	 * Fill in environment portion of vector table.
-	 */
-	for (; envc > 0; --envc) {
-		suword32(vectp++, (uint32_t)(intptr_t)destp);
-		while (*stringp++ != 0)
-			destp++;
-		destp++;
-	}
-
-	/* end of vector table is a null pointer */
-	suword32(vectp, 0);
-
-	return ((register_t *)stack_base);
-}
-
-SYSCTL_NODE(_compat, OID_AUTO, linux32, CTLFLAG_RW, 0,
-    "32-bit Linux emulation");
-
-static u_long	linux32_maxdsiz = LINUX32_MAXDSIZ;
-SYSCTL_ULONG(_compat_linux32, OID_AUTO, maxdsiz, CTLFLAG_RW,
-    &linux32_maxdsiz, 0, "");
-static u_long	linux32_maxssiz = LINUX32_MAXSSIZ;
-SYSCTL_ULONG(_compat_linux32, OID_AUTO, maxssiz, CTLFLAG_RW,
-    &linux32_maxssiz, 0, "");
-static u_long	linux32_maxvmem = LINUX32_MAXVMEM;
-SYSCTL_ULONG(_compat_linux32, OID_AUTO, maxvmem, CTLFLAG_RW,
-    &linux32_maxvmem, 0, "");
-
-static void
-linux32_fixlimit(struct rlimit *rl, int which)
-{
-
-	switch (which) {
-	case RLIMIT_DATA:
-		if (linux32_maxdsiz != 0) {
-			if (rl->rlim_cur > linux32_maxdsiz)
-				rl->rlim_cur = linux32_maxdsiz;
-			if (rl->rlim_max > linux32_maxdsiz)
-				rl->rlim_max = linux32_maxdsiz;
-		}
-		break;
-	case RLIMIT_STACK:
-		if (linux32_maxssiz != 0) {
-			if (rl->rlim_cur > linux32_maxssiz)
-				rl->rlim_cur = linux32_maxssiz;
-			if (rl->rlim_max > linux32_maxssiz)
-				rl->rlim_max = linux32_maxssiz;
-		}
-		break;
-	case RLIMIT_VMEM:
-		if (linux32_maxvmem != 0) {
-			if (rl->rlim_cur > linux32_maxvmem)
-				rl->rlim_cur = linux32_maxvmem;
-			if (rl->rlim_max > linux32_maxvmem)
-				rl->rlim_max = linux32_maxvmem;
-		}
-		break;
-	}
-}
-
-struct sysentvec elf_linux_sysvec = {
-	.sv_size	= LINUX_SYS_MAXSYSCALL,
-	.sv_table	= linux_sysent,
-	.sv_mask	= 0,
-	.sv_sigsize	= LINUX_SIGTBLSZ,
-	.sv_sigtbl	= bsd_to_linux_signal,
-	.sv_errsize	= ELAST + 1,
-	.sv_errtbl	= bsd_to_linux_errno,
-	.sv_transtrap	= translate_traps,
-	.sv_fixup	= elf_linux_fixup,
-	.sv_sendsig	= linux_sendsig,
-	.sv_sigcode	= linux_sigcode,
-	.sv_szsigcode	= &linux_szsigcode,
-	.sv_prepsyscall	= linux_prepsyscall,
-	.sv_name	= "Linux ELF32",
-	.sv_coredump	= elf32_coredump,
-	.sv_imgact_try	= exec_linux_imgact_try,
-	.sv_minsigstksz	= LINUX_MINSIGSTKSZ,
-	.sv_pagesize	= PAGE_SIZE,
-	.sv_minuser	= VM_MIN_ADDRESS,
-	.sv_maxuser	= LINUX32_USRSTACK,
-	.sv_usrstack	= LINUX32_USRSTACK,
-	.sv_psstrings	= LINUX32_PS_STRINGS,
-	.sv_stackprot	= VM_PROT_ALL,
-	.sv_copyout_strings = linux_copyout_strings,
-	.sv_setregs	= exec_linux_setregs,
-	.sv_fixlimit	= linux32_fixlimit,
-	.sv_maxssiz	= &linux32_maxssiz,
-	.sv_flags	= SV_ABI_LINUX | SV_ILP32 | SV_IA32
-};
-
-static char GNULINUX_ABI_VENDOR[] = "GNU";
-
-static Elf_Brandnote linux32_brandnote = {
-	.hdr.n_namesz	= sizeof(GNULINUX_ABI_VENDOR),
-	.hdr.n_descsz	= 16,
-	.hdr.n_type	= 1,
-	.vendor		= GNULINUX_ABI_VENDOR,
-	.flags		= 0
-};
-
-static Elf32_Brandinfo linux_brand = {
-	.brand		= ELFOSABI_LINUX,
-	.machine	= EM_386,
-	.compat_3_brand	= "Linux",
-	.emul_path	= "/compat/linux",
-	.interp_path	= "/lib/ld-linux.so.1",
-	.sysvec		= &elf_linux_sysvec,
-	.interp_newpath	= NULL,
-	.brand_note	= &linux32_brandnote,
-	.flags		= BI_CAN_EXEC_DYN | BI_BRAND_NOTE
-};
-
-static Elf32_Brandinfo linux_glibc2brand = {
-	.brand		= ELFOSABI_LINUX,
-	.machine	= EM_386,
-	.compat_3_brand	= "Linux",
-	.emul_path	= "/compat/linux",
-	.interp_path	= "/lib/ld-linux.so.2",
-	.sysvec		= &elf_linux_sysvec,
-	.interp_newpath	= NULL,
-	.brand_note	= &linux32_brandnote,
-	.flags		= BI_CAN_EXEC_DYN | BI_BRAND_NOTE
-};
-
-Elf32_Brandinfo *linux_brandlist[] = {
-	&linux_brand,
-	&linux_glibc2brand,
-	NULL
-};
-
-static int
-linux_elf_modevent(module_t mod, int type, void *data)
-{
-	Elf32_Brandinfo **brandinfo;
-	int error;
-	struct linux_ioctl_handler **lihp;
-	struct linux_device_handler **ldhp;
-
-	error = 0;
-
-	switch(type) {
-	case MOD_LOAD:
-		for (brandinfo = &linux_brandlist[0]; *brandinfo != NULL;
-		     ++brandinfo)
-			if (elf32_insert_brand_entry(*brandinfo) < 0)
-				error = EINVAL;
-		if (error == 0) {
-			SET_FOREACH(lihp, linux_ioctl_handler_set)
-				linux_ioctl_register_handler(*lihp);
-			SET_FOREACH(ldhp, linux_device_handler_set)
-				linux_device_register_handler(*ldhp);
-			mtx_init(&emul_lock, "emuldata lock", NULL, MTX_DEF);
-			sx_init(&emul_shared_lock, "emuldata->shared lock");
-			LIST_INIT(&futex_list);
-			mtx_init(&futex_mtx, "ftllk", NULL, MTX_DEF);
-			linux_exit_tag = EVENTHANDLER_REGISTER(process_exit,
-			    linux_proc_exit, NULL, 1000);
-			linux_schedtail_tag = EVENTHANDLER_REGISTER(schedtail,
-			    linux_schedtail, NULL, 1000);
-			linux_exec_tag = EVENTHANDLER_REGISTER(process_exec,
-			    linux_proc_exec, NULL, 1000);
-			linux_szplatform = roundup(strlen(linux_platform) + 1,
-			    sizeof(char *));
-			linux_osd_jail_register();
-			stclohz = (stathz ? stathz : hz);
-			if (bootverbose)
-				printf("Linux ELF exec handler installed\n");
-		} else
-			printf("cannot insert Linux ELF brand handler\n");
-		break;
-	case MOD_UNLOAD:
-		for (brandinfo = &linux_brandlist[0]; *brandinfo != NULL;
-		     ++brandinfo)
-			if (elf32_brand_inuse(*brandinfo))
-				error = EBUSY;
-		if (error == 0) {
-			for (brandinfo = &linux_brandlist[0];
-			     *brandinfo != NULL; ++brandinfo)
-				if (elf32_remove_brand_entry(*brandinfo) < 0)
-					error = EINVAL;
-		}
-		if (error == 0) {
-			SET_FOREACH(lihp, linux_ioctl_handler_set)
-				linux_ioctl_unregister_handler(*lihp);
-			SET_FOREACH(ldhp, linux_device_handler_set)
-				linux_device_unregister_handler(*ldhp);
-			mtx_destroy(&emul_lock);
-			sx_destroy(&emul_shared_lock);
-			mtx_destroy(&futex_mtx);
-			EVENTHANDLER_DEREGISTER(process_exit, linux_exit_tag);
-			EVENTHANDLER_DEREGISTER(schedtail, linux_schedtail_tag);
-			EVENTHANDLER_DEREGISTER(process_exec, linux_exec_tag);
-			linux_osd_jail_deregister();
-			if (bootverbose)
-				printf("Linux ELF exec handler removed\n");
-		} else
-			printf("Could not deinstall ELF interpreter entry\n");
-		break;
-	default:
-		return EOPNOTSUPP;
-	}
-	return error;
-}
-
-static moduledata_t linux_elf_mod = {
-	"linuxelf",
-	linux_elf_modevent,
-	0
-};
-
-DECLARE_MODULE(linuxelf, linux_elf_mod, SI_SUB_EXEC, SI_ORDER_ANY);
--- kfreebsd-8-8.0~cvs20090715.orig/sys/i386/linux/linux_sysvec.c
+++ /dev/null
@@ -1,1151 +0,0 @@
-/*-
- * Copyright (c) 1994-1996 Søren Schmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer
- *    in this position and unchanged.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/i386/linux/linux_sysvec.c,v 1.167 2009/05/10 18:43:43 dchagin Exp $");
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/exec.h>
-#include <sys/fcntl.h>
-#include <sys/imgact.h>
-#include <sys/imgact_aout.h>
-#include <sys/imgact_elf.h>
-#include <sys/kernel.h>
-#include <sys/lock.h>
-#include <sys/malloc.h>
-#include <sys/module.h>
-#include <sys/mutex.h>
-#include <sys/proc.h>
-#include <sys/signalvar.h>
-#include <sys/syscallsubr.h>
-#include <sys/sysent.h>
-#include <sys/sysproto.h>
-#include <sys/vnode.h>
-#include <sys/eventhandler.h>
-
-#include <vm/vm.h>
-#include <vm/pmap.h>
-#include <vm/vm_extern.h>
-#include <vm/vm_map.h>
-#include <vm/vm_object.h>
-#include <vm/vm_page.h>
-#include <vm/vm_param.h>
-
-#include <machine/cpu.h>
-#include <machine/cputypes.h>
-#include <machine/md_var.h>
-#include <machine/pcb.h>
-
-#include <i386/linux/linux.h>
-#include <i386/linux/linux_proto.h>
-#include <compat/linux/linux_futex.h>
-#include <compat/linux/linux_emul.h>
-#include <compat/linux/linux_mib.h>
-#include <compat/linux/linux_misc.h>
-#include <compat/linux/linux_signal.h>
-#include <compat/linux/linux_util.h>
-
-MODULE_VERSION(linux, 1);
-
-MALLOC_DEFINE(M_LINUX, "linux", "Linux mode structures");
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define SHELLMAGIC      0x2123 /* #! */
-#else
-#define SHELLMAGIC      0x2321
-#endif
-
-/*
- * Allow the sendsig functions to use the ldebug() facility
- * even though they are not syscalls themselves. Map them
- * to syscall 0. This is slightly less bogus than using
- * ldebug(sigreturn).
- */
-#define	LINUX_SYS_linux_rt_sendsig	0
-#define	LINUX_SYS_linux_sendsig		0
-
-extern char linux_sigcode[];
-extern int linux_szsigcode;
-
-extern struct sysent linux_sysent[LINUX_SYS_MAXSYSCALL];
-
-SET_DECLARE(linux_ioctl_handler_set, struct linux_ioctl_handler);
-SET_DECLARE(linux_device_handler_set, struct linux_device_handler);
-
-static int	linux_fixup(register_t **stack_base,
-		    struct image_params *iparams);
-static int	elf_linux_fixup(register_t **stack_base,
-		    struct image_params *iparams);
-static void	linux_prepsyscall(struct trapframe *tf, int *args, u_int *code,
-		    caddr_t *params);
-static void     linux_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask);
-static void	exec_linux_setregs(struct thread *td, u_long entry,
-				   u_long stack, u_long ps_strings);
-static register_t *linux_copyout_strings(struct image_params *imgp);
-
-static int linux_szplatform;
-const char *linux_platform;
-
-static eventhandler_tag linux_exit_tag;
-static eventhandler_tag linux_schedtail_tag;
-static eventhandler_tag linux_exec_tag;
-
-/*
- * Linux syscalls return negative errno's, we do positive and map them
- * Reference:
- *   FreeBSD: src/sys/sys/errno.h
- *   Linux:   linux-2.6.17.8/include/asm-generic/errno-base.h
- *            linux-2.6.17.8/include/asm-generic/errno.h
- */
-static int bsd_to_linux_errno[ELAST + 1] = {
-	-0,  -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,  -9,
-	-10, -35, -12, -13, -14, -15, -16, -17, -18, -19,
-	-20, -21, -22, -23, -24, -25, -26, -27, -28, -29,
-	-30, -31, -32, -33, -34, -11,-115,-114, -88, -89,
-	-90, -91, -92, -93, -94, -95, -96, -97, -98, -99,
-	-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,
-	-110,-111, -40, -36,-112,-113, -39, -11, -87,-122,
-	-116, -66,  -6,  -6,  -6,  -6,  -6, -37, -38,  -9,
-	  -6,  -6, -43, -42, -75,-125, -84, -95, -16, -74,
-	 -72, -67, -71
-};
-
-int bsd_to_linux_signal[LINUX_SIGTBLSZ] = {
-	LINUX_SIGHUP, LINUX_SIGINT, LINUX_SIGQUIT, LINUX_SIGILL,
-	LINUX_SIGTRAP, LINUX_SIGABRT, 0, LINUX_SIGFPE,
-	LINUX_SIGKILL, LINUX_SIGBUS, LINUX_SIGSEGV, LINUX_SIGSYS,
-	LINUX_SIGPIPE, LINUX_SIGALRM, LINUX_SIGTERM, LINUX_SIGURG,
-	LINUX_SIGSTOP, LINUX_SIGTSTP, LINUX_SIGCONT, LINUX_SIGCHLD,
-	LINUX_SIGTTIN, LINUX_SIGTTOU, LINUX_SIGIO, LINUX_SIGXCPU,
-	LINUX_SIGXFSZ, LINUX_SIGVTALRM, LINUX_SIGPROF, LINUX_SIGWINCH,
-	0, LINUX_SIGUSR1, LINUX_SIGUSR2
-};
-
-int linux_to_bsd_signal[LINUX_SIGTBLSZ] = {
-	SIGHUP, SIGINT, SIGQUIT, SIGILL,
-	SIGTRAP, SIGABRT, SIGBUS, SIGFPE,
-	SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2,
-	SIGPIPE, SIGALRM, SIGTERM, SIGBUS,
-	SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP,
-	SIGTTIN, SIGTTOU, SIGURG, SIGXCPU,
-	SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH,
-	SIGIO, SIGURG, SIGSYS
-};
-
-#define LINUX_T_UNKNOWN  255
-static int _bsd_to_linux_trapcode[] = {
-	LINUX_T_UNKNOWN,	/* 0 */
-	6,			/* 1  T_PRIVINFLT */
-	LINUX_T_UNKNOWN,	/* 2 */
-	3,			/* 3  T_BPTFLT */
-	LINUX_T_UNKNOWN,	/* 4 */
-	LINUX_T_UNKNOWN,	/* 5 */
-	16,			/* 6  T_ARITHTRAP */
-	254,			/* 7  T_ASTFLT */
-	LINUX_T_UNKNOWN,	/* 8 */
-	13,			/* 9  T_PROTFLT */
-	1,			/* 10 T_TRCTRAP */
-	LINUX_T_UNKNOWN,	/* 11 */
-	14,			/* 12 T_PAGEFLT */
-	LINUX_T_UNKNOWN,	/* 13 */
-	17,			/* 14 T_ALIGNFLT */
-	LINUX_T_UNKNOWN,	/* 15 */
-	LINUX_T_UNKNOWN,	/* 16 */
-	LINUX_T_UNKNOWN,	/* 17 */
-	0,			/* 18 T_DIVIDE */
-	2,			/* 19 T_NMI */
-	4,			/* 20 T_OFLOW */
-	5,			/* 21 T_BOUND */
-	7,			/* 22 T_DNA */
-	8,			/* 23 T_DOUBLEFLT */
-	9,			/* 24 T_FPOPFLT */
-	10,			/* 25 T_TSSFLT */
-	11,			/* 26 T_SEGNPFLT */
-	12,			/* 27 T_STKFLT */
-	18,			/* 28 T_MCHK */
-	19,			/* 29 T_XMMFLT */
-	15			/* 30 T_RESERVED */
-};
-#define bsd_to_linux_trapcode(code) \
-    ((code)<sizeof(_bsd_to_linux_trapcode)/sizeof(*_bsd_to_linux_trapcode)? \
-     _bsd_to_linux_trapcode[(code)]: \
-     LINUX_T_UNKNOWN)
-
-/*
- * If FreeBSD & Linux have a difference of opinion about what a trap
- * means, deal with it here.
- *
- * MPSAFE
- */
-static int
-translate_traps(int signal, int trap_code)
-{
-	if (signal != SIGBUS)
-		return signal;
-	switch (trap_code) {
-	case T_PROTFLT:
-	case T_TSSFLT:
-	case T_DOUBLEFLT:
-	case T_PAGEFLT:
-		return SIGSEGV;
-	default:
-		return signal;
-	}
-}
-
-static int
-linux_fixup(register_t **stack_base, struct image_params *imgp)
-{
-	register_t *argv, *envp;
-
-	argv = *stack_base;
-	envp = *stack_base + (imgp->args->argc + 1);
-	(*stack_base)--;
-	**stack_base = (intptr_t)(void *)envp;
-	(*stack_base)--;
-	**stack_base = (intptr_t)(void *)argv;
-	(*stack_base)--;
-	**stack_base = imgp->args->argc;
-	return (0);
-}
-
-static int
-elf_linux_fixup(register_t **stack_base, struct image_params *imgp)
-{
-	struct proc *p;
-	Elf32_Auxargs *args;
-	Elf32_Addr *uplatform;
-	struct ps_strings *arginfo;
-	register_t *pos;
-
-	KASSERT(curthread->td_proc == imgp->proc,
-	    ("unsafe elf_linux_fixup(), should be curproc"));
-
-	p = imgp->proc;
-	arginfo = (struct ps_strings *)p->p_sysent->sv_psstrings;
-	uplatform = (Elf32_Addr *)((caddr_t)arginfo - linux_szsigcode -
-	    linux_szplatform);
-	args = (Elf32_Auxargs *)imgp->auxargs;
-	pos = *stack_base + (imgp->args->argc + imgp->args->envc + 2);
-
-	AUXARGS_ENTRY(pos, LINUX_AT_HWCAP, cpu_feature);
-
-	/*
-	 * Do not export AT_CLKTCK when emulating Linux kernel prior to 2.4.0,
-	 * as it has appeared in the 2.4.0-rc7 first time.
-	 * Being exported, AT_CLKTCK is returned by sysconf(_SC_CLK_TCK),
-	 * glibc falls back to the hard-coded CLK_TCK value when aux entry
-	 * is not present.
-	 * Also see linux_times() implementation.
-	 */
-	if (linux_kernver(curthread) >= LINUX_KERNVER_2004000)
-		AUXARGS_ENTRY(pos, LINUX_AT_CLKTCK, stclohz);
-	AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);
-	AUXARGS_ENTRY(pos, AT_PHENT, args->phent);
-	AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);
-	AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
-	AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
-	AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
-	AUXARGS_ENTRY(pos, AT_BASE, args->base);
-	AUXARGS_ENTRY(pos, LINUX_AT_SECURE, 0);
-	AUXARGS_ENTRY(pos, AT_UID, imgp->proc->p_ucred->cr_ruid);
-	AUXARGS_ENTRY(pos, AT_EUID, imgp->proc->p_ucred->cr_svuid);
-	AUXARGS_ENTRY(pos, AT_GID, imgp->proc->p_ucred->cr_rgid);
-	AUXARGS_ENTRY(pos, AT_EGID, imgp->proc->p_ucred->cr_svgid);
-	AUXARGS_ENTRY(pos, LINUX_AT_PLATFORM, PTROUT(uplatform));
-	if (args->execfd != -1)
-		AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
-	AUXARGS_ENTRY(pos, AT_NULL, 0);
-
-	free(imgp->auxargs, M_TEMP);
-	imgp->auxargs = NULL;
-
-	(*stack_base)--;
-	**stack_base = (register_t)imgp->args->argc;
-	return (0);
-}
-
-/*
- * Copied from kern/kern_exec.c
- */
-static register_t *
-linux_copyout_strings(struct image_params *imgp)
-{
-	int argc, envc;
-	char **vectp;
-	char *stringp, *destp;
-	register_t *stack_base;
-	struct ps_strings *arginfo;
-	struct proc *p;
-
-	/*
-	 * Calculate string base and vector table pointers.
-	 * Also deal with signal trampoline code for this exec type.
-	 */
-	p = imgp->proc;
-	arginfo = (struct ps_strings *)p->p_sysent->sv_psstrings;
-	destp = (caddr_t)arginfo - linux_szsigcode - SPARE_USRSPACE -
-	    linux_szplatform - roundup((ARG_MAX - imgp->args->stringspace),
-	    sizeof(char *));
-
-	/*
-	 * install sigcode
-	 */
-	copyout(p->p_sysent->sv_sigcode, ((caddr_t)arginfo -
-	    linux_szsigcode), linux_szsigcode);
-
-	/*
-	 * install LINUX_PLATFORM
-	 */
-	copyout(linux_platform, ((caddr_t)arginfo - linux_szsigcode -
-	    linux_szplatform), linux_szplatform);
-
-	/*
-	 * If we have a valid auxargs ptr, prepare some room
-	 * on the stack.
-	 */
-	if (imgp->auxargs) {
-		/*
-		 * 'AT_COUNT*2' is size for the ELF Auxargs data. This is for
-		 * lower compatibility.
-		 */
-		imgp->auxarg_size = (imgp->auxarg_size) ? imgp->auxarg_size :
-		    (LINUX_AT_COUNT * 2);
-		/*
-		 * The '+ 2' is for the null pointers at the end of each of
-		 * the arg and env vector sets,and imgp->auxarg_size is room
-		 * for argument of Runtime loader.
-		 */
-		vectp = (char **)(destp - (imgp->args->argc +
-		    imgp->args->envc + 2 + imgp->auxarg_size) * sizeof(char *));
-	} else {
-		/*
-		 * The '+ 2' is for the null pointers at the end of each of
-		 * the arg and env vector sets
-		 */
-		vectp = (char **)(destp - (imgp->args->argc + imgp->args->envc + 2) *
-		    sizeof(char *));
-	}
-
-	/*
-	 * vectp also becomes our initial stack base
-	 */
-	stack_base = (register_t *)vectp;
-
-	stringp = imgp->args->begin_argv;
-	argc = imgp->args->argc;
-	envc = imgp->args->envc;
-
-	/*
-	 * Copy out strings - arguments and environment.
-	 */
-	copyout(stringp, destp, ARG_MAX - imgp->args->stringspace);
-
-	/*
-	 * Fill in "ps_strings" struct for ps, w, etc.
-	 */
-	suword(&arginfo->ps_argvstr, (long)(intptr_t)vectp);
-	suword(&arginfo->ps_nargvstr, argc);
-
-	/*
-	 * Fill in argument portion of vector table.
-	 */
-	for (; argc > 0; --argc) {
-		suword(vectp++, (long)(intptr_t)destp);
-		while (*stringp++ != 0)
-			destp++;
-		destp++;
-	}
-
-	/* a null vector table pointer separates the argp's from the envp's */
-	suword(vectp++, 0);
-
-	suword(&arginfo->ps_envstr, (long)(intptr_t)vectp);
-	suword(&arginfo->ps_nenvstr, envc);
-
-	/*
-	 * Fill in environment portion of vector table.
-	 */
-	for (; envc > 0; --envc) {
-		suword(vectp++, (long)(intptr_t)destp);
-		while (*stringp++ != 0)
-			destp++;
-		destp++;
-	}
-
-	/* end of vector table is a null pointer */
-	suword(vectp, 0);
-
-	return (stack_base);
-}
-
-
-
-extern int _ucodesel, _udatasel;
-extern unsigned long linux_sznonrtsigcode;
-
-static void
-linux_rt_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask)
-{
-	struct thread *td = curthread;
-	struct proc *p = td->td_proc;
-	struct sigacts *psp;
-	struct trapframe *regs;
-	struct l_rt_sigframe *fp, frame;
-	int sig, code;
-	int oonstack;
-
-	sig = ksi->ksi_signo;
-	code = ksi->ksi_code;	
-	PROC_LOCK_ASSERT(p, MA_OWNED);
-	psp = p->p_sigacts;
-	mtx_assert(&psp->ps_mtx, MA_OWNED);
-	regs = td->td_frame;
-	oonstack = sigonstack(regs->tf_esp);
-
-#ifdef DEBUG
-	if (ldebug(rt_sendsig))
-		printf(ARGS(rt_sendsig, "%p, %d, %p, %u"),
-		    catcher, sig, (void*)mask, code);
-#endif
-	/*
-	 * Allocate space for the signal handler context.
-	 */
-	if ((td->td_pflags & TDP_ALTSTACK) && !oonstack &&
-	    SIGISMEMBER(psp->ps_sigonstack, sig)) {
-		fp = (struct l_rt_sigframe *)(td->td_sigstk.ss_sp +
-		    td->td_sigstk.ss_size - sizeof(struct l_rt_sigframe));
-	} else
-		fp = (struct l_rt_sigframe *)regs->tf_esp - 1;
-	mtx_unlock(&psp->ps_mtx);
-
-	/*
-	 * Build the argument list for the signal handler.
-	 */
-	if (p->p_sysent->sv_sigtbl)
-		if (sig <= p->p_sysent->sv_sigsize)
-			sig = p->p_sysent->sv_sigtbl[_SIG_IDX(sig)];
-
-	bzero(&frame, sizeof(frame));
-
-	frame.sf_handler = catcher;
-	frame.sf_sig = sig;
-	frame.sf_siginfo = &fp->sf_si;
-	frame.sf_ucontext = &fp->sf_sc;
-
-	/* Fill in POSIX parts */
-	ksiginfo_to_lsiginfo(ksi, &frame.sf_si, sig);
-
-	/*
-	 * Build the signal context to be used by sigreturn.
-	 */
-	frame.sf_sc.uc_flags = 0;		/* XXX ??? */
-	frame.sf_sc.uc_link = NULL;		/* XXX ??? */
-
-	frame.sf_sc.uc_stack.ss_sp = td->td_sigstk.ss_sp;
-	frame.sf_sc.uc_stack.ss_size = td->td_sigstk.ss_size;
-	frame.sf_sc.uc_stack.ss_flags = (td->td_pflags & TDP_ALTSTACK)
-	    ? ((oonstack) ? LINUX_SS_ONSTACK : 0) : LINUX_SS_DISABLE;
-	PROC_UNLOCK(p);
-
-	bsd_to_linux_sigset(mask, &frame.sf_sc.uc_sigmask);
-
-	frame.sf_sc.uc_mcontext.sc_mask   = frame.sf_sc.uc_sigmask.__bits[0];
-	frame.sf_sc.uc_mcontext.sc_gs     = rgs();
-	frame.sf_sc.uc_mcontext.sc_fs     = regs->tf_fs;
-	frame.sf_sc.uc_mcontext.sc_es     = regs->tf_es;
-	frame.sf_sc.uc_mcontext.sc_ds     = regs->tf_ds;
-	frame.sf_sc.uc_mcontext.sc_edi    = regs->tf_edi;
-	frame.sf_sc.uc_mcontext.sc_esi    = regs->tf_esi;
-	frame.sf_sc.uc_mcontext.sc_ebp    = regs->tf_ebp;
-	frame.sf_sc.uc_mcontext.sc_ebx    = regs->tf_ebx;
-	frame.sf_sc.uc_mcontext.sc_edx    = regs->tf_edx;
-	frame.sf_sc.uc_mcontext.sc_ecx    = regs->tf_ecx;
-	frame.sf_sc.uc_mcontext.sc_eax    = regs->tf_eax;
-	frame.sf_sc.uc_mcontext.sc_eip    = regs->tf_eip;
-	frame.sf_sc.uc_mcontext.sc_cs     = regs->tf_cs;
-	frame.sf_sc.uc_mcontext.sc_eflags = regs->tf_eflags;
-	frame.sf_sc.uc_mcontext.sc_esp_at_signal = regs->tf_esp;
-	frame.sf_sc.uc_mcontext.sc_ss     = regs->tf_ss;
-	frame.sf_sc.uc_mcontext.sc_err    = regs->tf_err;
-	frame.sf_sc.uc_mcontext.sc_cr2    = (register_t)ksi->ksi_addr;
-	frame.sf_sc.uc_mcontext.sc_trapno = bsd_to_linux_trapcode(code);
-
-#ifdef DEBUG
-	if (ldebug(rt_sendsig))
-		printf(LMSG("rt_sendsig flags: 0x%x, sp: %p, ss: 0x%x, mask: 0x%x"),
-		    frame.sf_sc.uc_stack.ss_flags, td->td_sigstk.ss_sp,
-		    td->td_sigstk.ss_size, frame.sf_sc.uc_mcontext.sc_mask);
-#endif
-
-	if (copyout(&frame, fp, sizeof(frame)) != 0) {
-		/*
-		 * Process has trashed its stack; give it an illegal
-		 * instruction to halt it in its tracks.
-		 */
-#ifdef DEBUG
-		if (ldebug(rt_sendsig))
-			printf(LMSG("rt_sendsig: bad stack %p, oonstack=%x"),
-			    fp, oonstack);
-#endif
-		PROC_LOCK(p);
-		sigexit(td, SIGILL);
-	}
-
-	/*
-	 * Build context to run handler in.
-	 */
-	regs->tf_esp = (int)fp;
-	regs->tf_eip = PS_STRINGS - *(p->p_sysent->sv_szsigcode) +
-	    linux_sznonrtsigcode;
-	regs->tf_eflags &= ~(PSL_T | PSL_VM | PSL_D);
-	regs->tf_cs = _ucodesel;
-	regs->tf_ds = _udatasel;
-	regs->tf_es = _udatasel;
-	regs->tf_fs = _udatasel;
-	regs->tf_ss = _udatasel;
-	PROC_LOCK(p);
-	mtx_lock(&psp->ps_mtx);
-}
-
-
-/*
- * Send an interrupt to process.
- *
- * Stack is set up to allow sigcode stored
- * in u. to call routine, followed by kcall
- * to sigreturn routine below.  After sigreturn
- * resets the signal mask, the stack, and the
- * frame pointer, it returns to the user
- * specified pc, psl.
- */
-static void
-linux_sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask)
-{
-	struct thread *td = curthread;
-	struct proc *p = td->td_proc;
-	struct sigacts *psp;
-	struct trapframe *regs;
-	struct l_sigframe *fp, frame;
-	l_sigset_t lmask;
-	int sig, code;
-	int oonstack, i;
-
-	PROC_LOCK_ASSERT(p, MA_OWNED);
-	psp = p->p_sigacts;
-	sig = ksi->ksi_signo;
-	code = ksi->ksi_code;
-	mtx_assert(&psp->ps_mtx, MA_OWNED);
-	if (SIGISMEMBER(psp->ps_siginfo, sig)) {
-		/* Signal handler installed with SA_SIGINFO. */
-		linux_rt_sendsig(catcher, ksi, mask);
-		return;
-	}
-	regs = td->td_frame;
-	oonstack = sigonstack(regs->tf_esp);
-
-#ifdef DEBUG
-	if (ldebug(sendsig))
-		printf(ARGS(sendsig, "%p, %d, %p, %u"),
-		    catcher, sig, (void*)mask, code);
-#endif
-
-	/*
-	 * Allocate space for the signal handler context.
-	 */
-	if ((td->td_pflags & TDP_ALTSTACK) && !oonstack &&
-	    SIGISMEMBER(psp->ps_sigonstack, sig)) {
-		fp = (struct l_sigframe *)(td->td_sigstk.ss_sp +
-		    td->td_sigstk.ss_size - sizeof(struct l_sigframe));
-	} else
-		fp = (struct l_sigframe *)regs->tf_esp - 1;
-	mtx_unlock(&psp->ps_mtx);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Build the argument list for the signal handler.
-	 */
-	if (p->p_sysent->sv_sigtbl)
-		if (sig <= p->p_sysent->sv_sigsize)
-			sig = p->p_sysent->sv_sigtbl[_SIG_IDX(sig)];
-
-	bzero(&frame, sizeof(frame));
-
-	frame.sf_handler = catcher;
-	frame.sf_sig = sig;
-
-	bsd_to_linux_sigset(mask, &lmask);
-
-	/*
-	 * Build the signal context to be used by sigreturn.
-	 */
-	frame.sf_sc.sc_mask   = lmask.__bits[0];
-	frame.sf_sc.sc_gs     = rgs();
-	frame.sf_sc.sc_fs     = regs->tf_fs;
-	frame.sf_sc.sc_es     = regs->tf_es;
-	frame.sf_sc.sc_ds     = regs->tf_ds;
-	frame.sf_sc.sc_edi    = regs->tf_edi;
-	frame.sf_sc.sc_esi    = regs->tf_esi;
-	frame.sf_sc.sc_ebp    = regs->tf_ebp;
-	frame.sf_sc.sc_ebx    = regs->tf_ebx;
-	frame.sf_sc.sc_edx    = regs->tf_edx;
-	frame.sf_sc.sc_ecx    = regs->tf_ecx;
-	frame.sf_sc.sc_eax    = regs->tf_eax;
-	frame.sf_sc.sc_eip    = regs->tf_eip;
-	frame.sf_sc.sc_cs     = regs->tf_cs;
-	frame.sf_sc.sc_eflags = regs->tf_eflags;
-	frame.sf_sc.sc_esp_at_signal = regs->tf_esp;
-	frame.sf_sc.sc_ss     = regs->tf_ss;
-	frame.sf_sc.sc_err    = regs->tf_err;
-	frame.sf_sc.sc_cr2    = (register_t)ksi->ksi_addr;
-	frame.sf_sc.sc_trapno = bsd_to_linux_trapcode(ksi->ksi_trapno);
-
-	for (i = 0; i < (LINUX_NSIG_WORDS-1); i++)
-		frame.sf_extramask[i] = lmask.__bits[i+1];
-
-	if (copyout(&frame, fp, sizeof(frame)) != 0) {
-		/*
-		 * Process has trashed its stack; give it an illegal
-		 * instruction to halt it in its tracks.
-		 */
-		PROC_LOCK(p);
-		sigexit(td, SIGILL);
-	}
-
-	/*
-	 * Build context to run handler in.
-	 */
-	regs->tf_esp = (int)fp;
-	regs->tf_eip = PS_STRINGS - *(p->p_sysent->sv_szsigcode);
-	regs->tf_eflags &= ~(PSL_T | PSL_VM | PSL_D);
-	regs->tf_cs = _ucodesel;
-	regs->tf_ds = _udatasel;
-	regs->tf_es = _udatasel;
-	regs->tf_fs = _udatasel;
-	regs->tf_ss = _udatasel;
-	PROC_LOCK(p);
-	mtx_lock(&psp->ps_mtx);
-}
-
-/*
- * System call to cleanup state after a signal
- * has been taken.  Reset signal mask and
- * stack state from context left by sendsig (above).
- * Return to previous pc and psl as specified by
- * context left by sendsig. Check carefully to
- * make sure that the user has not modified the
- * psl to gain improper privileges or to cause
- * a machine fault.
- */
-int
-linux_sigreturn(struct thread *td, struct linux_sigreturn_args *args)
-{
-	struct proc *p = td->td_proc;
-	struct l_sigframe frame;
-	struct trapframe *regs;
-	l_sigset_t lmask;
-	int eflags, i;
-	ksiginfo_t ksi;
-
-	regs = td->td_frame;
-
-#ifdef DEBUG
-	if (ldebug(sigreturn))
-		printf(ARGS(sigreturn, "%p"), (void *)args->sfp);
-#endif
-	/*
-	 * The trampoline code hands us the sigframe.
-	 * It is unsafe to keep track of it ourselves, in the event that a
-	 * program jumps out of a signal handler.
-	 */
-	if (copyin(args->sfp, &frame, sizeof(frame)) != 0)
-		return (EFAULT);
-
-	/*
-	 * Check for security violations.
-	 */
-#define	EFLAGS_SECURE(ef, oef)	((((ef) ^ (oef)) & ~PSL_USERCHANGE) == 0)
-	eflags = frame.sf_sc.sc_eflags;
-	/*
-	 * XXX do allow users to change the privileged flag PSL_RF.  The
-	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should
-	 * sometimes set it there too.  tf_eflags is kept in the signal
-	 * context during signal handling and there is no other place
-	 * to remember it, so the PSL_RF bit may be corrupted by the
-	 * signal handler without us knowing.  Corruption of the PSL_RF
-	 * bit at worst causes one more or one less debugger trap, so
-	 * allowing it is fairly harmless.
-	 */
-	if (!EFLAGS_SECURE(eflags & ~PSL_RF, regs->tf_eflags & ~PSL_RF))
-		return(EINVAL);
-
-	/*
-	 * Don't allow users to load a valid privileged %cs.  Let the
-	 * hardware check for invalid selectors, excess privilege in
-	 * other selectors, invalid %eip's and invalid %esp's.
-	 */
-#define	CS_SECURE(cs)	(ISPL(cs) == SEL_UPL)
-	if (!CS_SECURE(frame.sf_sc.sc_cs)) {
-		ksiginfo_init_trap(&ksi);
-		ksi.ksi_signo = SIGBUS;
-		ksi.ksi_code = BUS_OBJERR;
-		ksi.ksi_trapno = T_PROTFLT;
-		ksi.ksi_addr = (void *)regs->tf_eip;
-		trapsignal(td, &ksi);
-		return(EINVAL);
-	}
-
-	lmask.__bits[0] = frame.sf_sc.sc_mask;
-	for (i = 0; i < (LINUX_NSIG_WORDS-1); i++)
-		lmask.__bits[i+1] = frame.sf_extramask[i];
-	PROC_LOCK(p);
-	linux_to_bsd_sigset(&lmask, &td->td_sigmask);
-	SIG_CANTMASK(td->td_sigmask);
-	signotify(td);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Restore signal context.
-	 */
-	/* %gs was restored by the trampoline. */
-	regs->tf_fs     = frame.sf_sc.sc_fs;
-	regs->tf_es     = frame.sf_sc.sc_es;
-	regs->tf_ds     = frame.sf_sc.sc_ds;
-	regs->tf_edi    = frame.sf_sc.sc_edi;
-	regs->tf_esi    = frame.sf_sc.sc_esi;
-	regs->tf_ebp    = frame.sf_sc.sc_ebp;
-	regs->tf_ebx    = frame.sf_sc.sc_ebx;
-	regs->tf_edx    = frame.sf_sc.sc_edx;
-	regs->tf_ecx    = frame.sf_sc.sc_ecx;
-	regs->tf_eax    = frame.sf_sc.sc_eax;
-	regs->tf_eip    = frame.sf_sc.sc_eip;
-	regs->tf_cs     = frame.sf_sc.sc_cs;
-	regs->tf_eflags = eflags;
-	regs->tf_esp    = frame.sf_sc.sc_esp_at_signal;
-	regs->tf_ss     = frame.sf_sc.sc_ss;
-
-	return (EJUSTRETURN);
-}
-
-/*
- * System call to cleanup state after a signal
- * has been taken.  Reset signal mask and
- * stack state from context left by rt_sendsig (above).
- * Return to previous pc and psl as specified by
- * context left by sendsig. Check carefully to
- * make sure that the user has not modified the
- * psl to gain improper privileges or to cause
- * a machine fault.
- */
-int
-linux_rt_sigreturn(struct thread *td, struct linux_rt_sigreturn_args *args)
-{
-	struct proc *p = td->td_proc;
-	struct l_ucontext uc;
-	struct l_sigcontext *context;
-	l_stack_t *lss;
-	stack_t ss;
-	struct trapframe *regs;
-	int eflags;
-	ksiginfo_t ksi;
-
-	regs = td->td_frame;
-
-#ifdef DEBUG
-	if (ldebug(rt_sigreturn))
-		printf(ARGS(rt_sigreturn, "%p"), (void *)args->ucp);
-#endif
-	/*
-	 * The trampoline code hands us the ucontext.
-	 * It is unsafe to keep track of it ourselves, in the event that a
-	 * program jumps out of a signal handler.
-	 */
-	if (copyin(args->ucp, &uc, sizeof(uc)) != 0)
-		return (EFAULT);
-
-	context = &uc.uc_mcontext;
-
-	/*
-	 * Check for security violations.
-	 */
-#define	EFLAGS_SECURE(ef, oef)	((((ef) ^ (oef)) & ~PSL_USERCHANGE) == 0)
-	eflags = context->sc_eflags;
-	/*
-	 * XXX do allow users to change the privileged flag PSL_RF.  The
-	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should
-	 * sometimes set it there too.  tf_eflags is kept in the signal
-	 * context during signal handling and there is no other place
-	 * to remember it, so the PSL_RF bit may be corrupted by the
-	 * signal handler without us knowing.  Corruption of the PSL_RF
-	 * bit at worst causes one more or one less debugger trap, so
-	 * allowing it is fairly harmless.
-	 */
-	if (!EFLAGS_SECURE(eflags & ~PSL_RF, regs->tf_eflags & ~PSL_RF))
-		return(EINVAL);
-
-	/*
-	 * Don't allow users to load a valid privileged %cs.  Let the
-	 * hardware check for invalid selectors, excess privilege in
-	 * other selectors, invalid %eip's and invalid %esp's.
-	 */
-#define	CS_SECURE(cs)	(ISPL(cs) == SEL_UPL)
-	if (!CS_SECURE(context->sc_cs)) {
-		ksiginfo_init_trap(&ksi);
-		ksi.ksi_signo = SIGBUS;
-		ksi.ksi_code = BUS_OBJERR;
-		ksi.ksi_trapno = T_PROTFLT;
-		ksi.ksi_addr = (void *)regs->tf_eip;
-		trapsignal(td, &ksi);
-		return(EINVAL);
-	}
-
-	PROC_LOCK(p);
-	linux_to_bsd_sigset(&uc.uc_sigmask, &td->td_sigmask);
-	SIG_CANTMASK(td->td_sigmask);
-	signotify(td);
-	PROC_UNLOCK(p);
-
-	/*
-	 * Restore signal context
-	 */
-	/* %gs was restored by the trampoline. */
-	regs->tf_fs     = context->sc_fs;
-	regs->tf_es     = context->sc_es;
-	regs->tf_ds     = context->sc_ds;
-	regs->tf_edi    = context->sc_edi;
-	regs->tf_esi    = context->sc_esi;
-	regs->tf_ebp    = context->sc_ebp;
-	regs->tf_ebx    = context->sc_ebx;
-	regs->tf_edx    = context->sc_edx;
-	regs->tf_ecx    = context->sc_ecx;
-	regs->tf_eax    = context->sc_eax;
-	regs->tf_eip    = context->sc_eip;
-	regs->tf_cs     = context->sc_cs;
-	regs->tf_eflags = eflags;
-	regs->tf_esp    = context->sc_esp_at_signal;
-	regs->tf_ss     = context->sc_ss;
-
-	/*
-	 * call sigaltstack & ignore results..
-	 */
-	lss = &uc.uc_stack;
-	ss.ss_sp = lss->ss_sp;
-	ss.ss_size = lss->ss_size;
-	ss.ss_flags = linux_to_bsd_sigaltstack(lss->ss_flags);
-
-#ifdef DEBUG
-	if (ldebug(rt_sigreturn))
-		printf(LMSG("rt_sigret flags: 0x%x, sp: %p, ss: 0x%x, mask: 0x%x"),
-		    ss.ss_flags, ss.ss_sp, ss.ss_size, context->sc_mask);
-#endif
-	(void)kern_sigaltstack(td, &ss, NULL);
-
-	return (EJUSTRETURN);
-}
-
-/*
- * MPSAFE
- */
-static void
-linux_prepsyscall(struct trapframe *tf, int *args, u_int *code, caddr_t *params)
-{
-	args[0] = tf->tf_ebx;
-	args[1] = tf->tf_ecx;
-	args[2] = tf->tf_edx;
-	args[3] = tf->tf_esi;
-	args[4] = tf->tf_edi;
-	args[5] = tf->tf_ebp;	/* Unconfirmed */
-	*params = NULL;		/* no copyin */
-}
-
-/*
- * If a linux binary is exec'ing something, try this image activator
- * first.  We override standard shell script execution in order to
- * be able to modify the interpreter path.  We only do this if a linux
- * binary is doing the exec, so we do not create an EXEC module for it.
- */
-static int	exec_linux_imgact_try(struct image_params *iparams);
-
-static int
-exec_linux_imgact_try(struct image_params *imgp)
-{
-    const char *head = (const char *)imgp->image_header;
-    char *rpath;
-    int error = -1, len;
-
-    /*
-     * The interpreter for shell scripts run from a linux binary needs
-     * to be located in /compat/linux if possible in order to recursively
-     * maintain linux path emulation.
-     */
-    if (((const short *)head)[0] == SHELLMAGIC) {
-	    /*
-	     * Run our normal shell image activator.  If it succeeds attempt
-	     * to use the alternate path for the interpreter.  If an alternate
-	     * path is found, use our stringspace to store it.
-	     */
-	    if ((error = exec_shell_imgact(imgp)) == 0) {
-		    linux_emul_convpath(FIRST_THREAD_IN_PROC(imgp->proc),
-			imgp->interpreter_name, UIO_SYSSPACE, &rpath, 0, AT_FDCWD);
-		    if (rpath != NULL) {
-			    len = strlen(rpath) + 1;
-
-			    if (len <= MAXSHELLCMDLEN) {
-				    memcpy(imgp->interpreter_name, rpath, len);
-			    }
-			    free(rpath, M_TEMP);
-		    }
-	    }
-    }
-    return(error);
-}
-
-/*
- * exec_setregs may initialize some registers differently than Linux
- * does, thus potentially confusing Linux binaries. If necessary, we
- * override the exec_setregs default(s) here.
- */
-static void
-exec_linux_setregs(struct thread *td, u_long entry,
-		   u_long stack, u_long ps_strings)
-{
-	struct pcb *pcb = td->td_pcb;
-
-	exec_setregs(td, entry, stack, ps_strings);
-
-	/* Linux sets %gs to 0, we default to _udatasel */
-	pcb->pcb_gs = 0;
-	load_gs(0);
-
-	pcb->pcb_initial_npxcw = __LINUX_NPXCW__;
-}
-
-static void
-linux_get_machine(const char **dst)
-{
-
-	switch (cpu_class) {
-	case CPUCLASS_686:
-		*dst = "i686";
-		break;
-	case CPUCLASS_586:
-		*dst = "i586";
-		break;
-	case CPUCLASS_486:
-		*dst = "i486";
-		break;
-	default:
-		*dst = "i386";
-	}
-}
-
-struct sysentvec linux_sysvec = {
-	.sv_size	= LINUX_SYS_MAXSYSCALL,
-	.sv_table	= linux_sysent,
-	.sv_mask	= 0,
-	.sv_sigsize	= LINUX_SIGTBLSZ,
-	.sv_sigtbl	= bsd_to_linux_signal,
-	.sv_errsize	= ELAST + 1,
-	.sv_errtbl	= bsd_to_linux_errno,
-	.sv_transtrap	= translate_traps,
-	.sv_fixup	= linux_fixup,
-	.sv_sendsig	= linux_sendsig,
-	.sv_sigcode	= linux_sigcode,
-	.sv_szsigcode	= &linux_szsigcode,
-	.sv_prepsyscall	= linux_prepsyscall,
-	.sv_name	= "Linux a.out",
-	.sv_coredump	= NULL,
-	.sv_imgact_try	= exec_linux_imgact_try,
-	.sv_minsigstksz	= LINUX_MINSIGSTKSZ,
-	.sv_pagesize	= PAGE_SIZE,
-	.sv_minuser	= VM_MIN_ADDRESS,
-	.sv_maxuser	= VM_MAXUSER_ADDRESS,
-	.sv_usrstack	= USRSTACK,
-	.sv_psstrings	= PS_STRINGS,
-	.sv_stackprot	= VM_PROT_ALL,
-	.sv_copyout_strings = exec_copyout_strings,
-	.sv_setregs	= exec_linux_setregs,
-	.sv_fixlimit	= NULL,
-	.sv_maxssiz	= NULL,
-	.sv_flags	= SV_ABI_LINUX | SV_AOUT | SV_IA32 | SV_ILP32
-};
-
-struct sysentvec elf_linux_sysvec = {
-	.sv_size	= LINUX_SYS_MAXSYSCALL,
-	.sv_table	= linux_sysent,
-	.sv_mask	= 0,
-	.sv_sigsize	= LINUX_SIGTBLSZ,
-	.sv_sigtbl	= bsd_to_linux_signal,
-	.sv_errsize	= ELAST + 1,
-	.sv_errtbl	= bsd_to_linux_errno,
-	.sv_transtrap	= translate_traps,
-	.sv_fixup	= elf_linux_fixup,
-	.sv_sendsig	= linux_sendsig,
-	.sv_sigcode	= linux_sigcode,
-	.sv_szsigcode	= &linux_szsigcode,
-	.sv_prepsyscall	= linux_prepsyscall,
-	.sv_name	= "Linux ELF",
-	.sv_coredump	= elf32_coredump,
-	.sv_imgact_try	= exec_linux_imgact_try,
-	.sv_minsigstksz	= LINUX_MINSIGSTKSZ,
-	.sv_pagesize	= PAGE_SIZE,
-	.sv_minuser	= VM_MIN_ADDRESS,
-	.sv_maxuser	= VM_MAXUSER_ADDRESS,
-	.sv_usrstack	= USRSTACK,
-	.sv_psstrings	= PS_STRINGS,
-	.sv_stackprot	= VM_PROT_ALL,
-	.sv_copyout_strings = linux_copyout_strings,
-	.sv_setregs	= exec_linux_setregs,
-	.sv_fixlimit	= NULL,
-	.sv_maxssiz	= NULL,
-	.sv_flags	= SV_ABI_LINUX | SV_IA32 | SV_ILP32
-};
-
-static char GNULINUX_ABI_VENDOR[] = "GNU";
-
-static Elf_Brandnote linux_brandnote = {
-	.hdr.n_namesz	= sizeof(GNULINUX_ABI_VENDOR),
-	.hdr.n_descsz	= 16,
-	.hdr.n_type	= 1,
-	.vendor		= GNULINUX_ABI_VENDOR,
-	.flags		= 0
-};
-
-static Elf32_Brandinfo linux_brand = {
-	.brand		= ELFOSABI_LINUX,
-	.machine	= EM_386,
-	.compat_3_brand	= "Linux",
-	.emul_path	= "/compat/linux",
-	.interp_path	= "/lib/ld-linux.so.1",
-	.sysvec		= &elf_linux_sysvec,
-	.interp_newpath	= NULL,
-	.brand_note	= &linux_brandnote,
-	.flags		= BI_CAN_EXEC_DYN | BI_BRAND_NOTE
-};
-
-static Elf32_Brandinfo linux_glibc2brand = {
-	.brand		= ELFOSABI_LINUX,
-	.machine	= EM_386,
-	.compat_3_brand	= "Linux",
-	.emul_path	= "/compat/linux",
-	.interp_path	= "/lib/ld-linux.so.2",
-	.sysvec		= &elf_linux_sysvec,
-	.interp_newpath	= NULL,
-	.brand_note	= &linux_brandnote,
-	.flags		= BI_CAN_EXEC_DYN | BI_BRAND_NOTE
-};
-
-Elf32_Brandinfo *linux_brandlist[] = {
-	&linux_brand,
-	&linux_glibc2brand,
-	NULL
-};
-
-static int
-linux_elf_modevent(module_t mod, int type, void *data)
-{
-	Elf32_Brandinfo **brandinfo;
-	int error;
-	struct linux_ioctl_handler **lihp;
-	struct linux_device_handler **ldhp;
-
-	error = 0;
-
-	switch(type) {
-	case MOD_LOAD:
-		for (brandinfo = &linux_brandlist[0]; *brandinfo != NULL;
-		     ++brandinfo)
-			if (elf32_insert_brand_entry(*brandinfo) < 0)
-				error = EINVAL;
-		if (error == 0) {
-			SET_FOREACH(lihp, linux_ioctl_handler_set)
-				linux_ioctl_register_handler(*lihp);
-			SET_FOREACH(ldhp, linux_device_handler_set)
-				linux_device_register_handler(*ldhp);
-			mtx_init(&emul_lock, "emuldata lock", NULL, MTX_DEF);
-			sx_init(&emul_shared_lock, "emuldata->shared lock");
-			LIST_INIT(&futex_list);
-			mtx_init(&futex_mtx, "ftllk", NULL, MTX_DEF);
-			linux_exit_tag = EVENTHANDLER_REGISTER(process_exit, linux_proc_exit,
-			      NULL, 1000);
-			linux_schedtail_tag = EVENTHANDLER_REGISTER(schedtail, linux_schedtail,
-			      NULL, 1000);
-			linux_exec_tag = EVENTHANDLER_REGISTER(process_exec, linux_proc_exec,
-			      NULL, 1000);
-			linux_get_machine(&linux_platform);
-			linux_szplatform = roundup(strlen(linux_platform) + 1,
-			    sizeof(char *));
-			linux_osd_jail_register();
-			stclohz = (stathz ? stathz : hz);
-			if (bootverbose)
-				printf("Linux ELF exec handler installed\n");
-		} else
-			printf("cannot insert Linux ELF brand handler\n");
-		break;
-	case MOD_UNLOAD:
-		for (brandinfo = &linux_brandlist[0]; *brandinfo != NULL;
-		     ++brandinfo)
-			if (elf32_brand_inuse(*brandinfo))
-				error = EBUSY;
-		if (error == 0) {
-			for (brandinfo = &linux_brandlist[0];
-			     *brandinfo != NULL; ++brandinfo)
-				if (elf32_remove_brand_entry(*brandinfo) < 0)
-					error = EINVAL;
-		}
-		if (error == 0) {
-			SET_FOREACH(lihp, linux_ioctl_handler_set)
-				linux_ioctl_unregister_handler(*lihp);
-			SET_FOREACH(ldhp, linux_device_handler_set)
-				linux_device_unregister_handler(*ldhp);
-			mtx_destroy(&emul_lock);
-			sx_destroy(&emul_shared_lock);
-			mtx_destroy(&futex_mtx);
-			EVENTHANDLER_DEREGISTER(process_exit, linux_exit_tag);
-			EVENTHANDLER_DEREGISTER(schedtail, linux_schedtail_tag);
-			EVENTHANDLER_DEREGISTER(process_exec, linux_exec_tag);
-			linux_osd_jail_deregister();
-			if (bootverbose)
-				printf("Linux ELF exec handler removed\n");
-		} else
-			printf("Could not deinstall ELF interpreter entry\n");
-		break;
-	default:
-		return EOPNOTSUPP;
-	}
-	return error;
-}
-
-static moduledata_t linux_elf_mod = {
-	"linuxelf",
-	linux_elf_modevent,
-	0
-};
-
-DECLARE_MODULE(linuxelf, linux_elf_mod, SI_SUB_EXEC, SI_ORDER_ANY);
--- kfreebsd-8-8.0~cvs20090715.orig/sys/kern/imgact_elf.c
+++ /dev/null
@@ -1,1416 +0,0 @@
-/*-
- * Copyright (c) 2000 David O'Brien
- * Copyright (c) 1995-1996 Søren Schmidt
- * Copyright (c) 1996 Peter Wemm
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer
- *    in this position and unchanged.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/kern/imgact_elf.c,v 1.197 2009/04/05 09:27:19 dchagin Exp $");
-
-#include "opt_compat.h"
-
-#include <sys/param.h>
-#include <sys/exec.h>
-#include <sys/fcntl.h>
-#include <sys/imgact.h>
-#include <sys/imgact_elf.h>
-#include <sys/kernel.h>
-#include <sys/lock.h>
-#include <sys/malloc.h>
-#include <sys/mount.h>
-#include <sys/mutex.h>
-#include <sys/mman.h>
-#include <sys/namei.h>
-#include <sys/pioctl.h>
-#include <sys/proc.h>
-#include <sys/procfs.h>
-#include <sys/resourcevar.h>
-#include <sys/sf_buf.h>
-#include <sys/systm.h>
-#include <sys/signalvar.h>
-#include <sys/stat.h>
-#include <sys/sx.h>
-#include <sys/syscall.h>
-#include <sys/sysctl.h>
-#include <sys/sysent.h>
-#include <sys/vnode.h>
-
-#include <vm/vm.h>
-#include <vm/vm_kern.h>
-#include <vm/vm_param.h>
-#include <vm/pmap.h>
-#include <vm/vm_map.h>
-#include <vm/vm_object.h>
-#include <vm/vm_extern.h>
-
-#include <machine/elf.h>
-#include <machine/md_var.h>
-
-#if defined(COMPAT_IA32) && __ELF_WORD_SIZE == 32
-#include <machine/fpu.h>
-#include <compat/ia32/ia32_reg.h>
-#endif
-
-#define OLD_EI_BRAND	8
-
-static int __elfN(check_header)(const Elf_Ehdr *hdr);
-static Elf_Brandinfo *__elfN(get_brandinfo)(struct image_params *imgp,
-    const char *interp, int32_t *osrel);
-static int __elfN(load_file)(struct proc *p, const char *file, u_long *addr,
-    u_long *entry, size_t pagesize);
-static int __elfN(load_section)(struct vmspace *vmspace, vm_object_t object,
-    vm_offset_t offset, caddr_t vmaddr, size_t memsz, size_t filsz,
-    vm_prot_t prot, size_t pagesize);
-static int __CONCAT(exec_, __elfN(imgact))(struct image_params *imgp);
-static boolean_t __elfN(check_note)(struct image_params *imgp,
-    Elf_Brandnote *checknote, int32_t *osrel);
-
-SYSCTL_NODE(_kern, OID_AUTO, __CONCAT(elf, __ELF_WORD_SIZE), CTLFLAG_RW, 0,
-    "");
-
-int __elfN(fallback_brand) = -1;
-SYSCTL_INT(__CONCAT(_kern_elf, __ELF_WORD_SIZE), OID_AUTO,
-    fallback_brand, CTLFLAG_RW, &__elfN(fallback_brand), 0,
-    __XSTRING(__CONCAT(ELF, __ELF_WORD_SIZE)) " brand of last resort");
-TUNABLE_INT("kern.elf" __XSTRING(__ELF_WORD_SIZE) ".fallback_brand",
-    &__elfN(fallback_brand));
-
-static int elf_legacy_coredump = 0;
-SYSCTL_INT(_debug, OID_AUTO, __elfN(legacy_coredump), CTLFLAG_RW, 
-    &elf_legacy_coredump, 0, "");
-
-static Elf_Brandinfo *elf_brand_list[MAX_BRANDS];
-
-#define	trunc_page_ps(va, ps)	((va) & ~(ps - 1))
-#define	round_page_ps(va, ps)	(((va) + (ps - 1)) & ~(ps - 1))
-#define	aligned(a, t)	(trunc_page_ps((u_long)(a), sizeof(t)) == (u_long)(a))
-
-static const char FREEBSD_ABI_VENDOR[] = "FreeBSD";
-
-Elf_Brandnote __elfN(freebsd_brandnote) = {
-	.hdr.n_namesz	= sizeof(FREEBSD_ABI_VENDOR),
-	.hdr.n_descsz	= sizeof(int32_t),
-	.hdr.n_type	= 1,
-	.vendor		= FREEBSD_ABI_VENDOR,
-	.flags		= BN_CAN_FETCH_OSREL
-};
-
-int
-__elfN(insert_brand_entry)(Elf_Brandinfo *entry)
-{
-	int i;
-
-	for (i = 0; i < MAX_BRANDS; i++) {
-		if (elf_brand_list[i] == NULL) {
-			elf_brand_list[i] = entry;
-			break;
-		}
-	}
-	if (i == MAX_BRANDS)
-		return (-1);
-	return (0);
-}
-
-int
-__elfN(remove_brand_entry)(Elf_Brandinfo *entry)
-{
-	int i;
-
-	for (i = 0; i < MAX_BRANDS; i++) {
-		if (elf_brand_list[i] == entry) {
-			elf_brand_list[i] = NULL;
-			break;
-		}
-	}
-	if (i == MAX_BRANDS)
-		return (-1);
-	return (0);
-}
-
-int
-__elfN(brand_inuse)(Elf_Brandinfo *entry)
-{
-	struct proc *p;
-	int rval = FALSE;
-
-	sx_slock(&allproc_lock);
-	FOREACH_PROC_IN_SYSTEM(p) {
-		if (p->p_sysent == entry->sysvec) {
-			rval = TRUE;
-			break;
-		}
-	}
-	sx_sunlock(&allproc_lock);
-
-	return (rval);
-}
-
-static Elf_Brandinfo *
-__elfN(get_brandinfo)(struct image_params *imgp, const char *interp,
-    int32_t *osrel)
-{
-	const Elf_Ehdr *hdr = (const Elf_Ehdr *)imgp->image_header;
-	Elf_Brandinfo *bi;
-	boolean_t ret;
-	int i;
-
-	/*
-	 * We support four types of branding -- (1) the ELF EI_OSABI field
-	 * that SCO added to the ELF spec, (2) FreeBSD 3.x's traditional string
-	 * branding w/in the ELF header, (3) path of the `interp_path'
-	 * field, and (4) the ".note.ABI-tag" ELF section.
-	 */
-
-	/* Look for an ".note.ABI-tag" ELF section */
-	for (i = 0; i < MAX_BRANDS; i++) {
-		bi = elf_brand_list[i];
-		if (bi != NULL && hdr->e_machine == bi->machine &&
-		    (bi->flags & BI_BRAND_NOTE) != 0) {
-			ret = __elfN(check_note)(imgp, bi->brand_note, osrel);
-			if (ret)
-				return (bi);
-		}
-	}
-
-	/* If the executable has a brand, search for it in the brand list. */
-	for (i = 0; i < MAX_BRANDS; i++) {
-		bi = elf_brand_list[i];
-		if (bi != NULL && hdr->e_machine == bi->machine &&
-		    (hdr->e_ident[EI_OSABI] == bi->brand ||
-		    strncmp((const char *)&hdr->e_ident[OLD_EI_BRAND],
-		    bi->compat_3_brand, strlen(bi->compat_3_brand)) == 0))
-			return (bi);
-	}
-
-	/* Lacking a known brand, search for a recognized interpreter. */
-	if (interp != NULL) {
-		for (i = 0; i < MAX_BRANDS; i++) {
-			bi = elf_brand_list[i];
-			if (bi != NULL && hdr->e_machine == bi->machine &&
-			    strcmp(interp, bi->interp_path) == 0)
-				return (bi);
-		}
-	}
-
-	/* Lacking a recognized interpreter, try the default brand */
-	for (i = 0; i < MAX_BRANDS; i++) {
-		bi = elf_brand_list[i];
-		if (bi != NULL && hdr->e_machine == bi->machine &&
-		    __elfN(fallback_brand) == bi->brand)
-			return (bi);
-	}
-	return (NULL);
-}
-
-static int
-__elfN(check_header)(const Elf_Ehdr *hdr)
-{
-	Elf_Brandinfo *bi;
-	int i;
-
-	if (!IS_ELF(*hdr) ||
-	    hdr->e_ident[EI_CLASS] != ELF_TARG_CLASS ||
-	    hdr->e_ident[EI_DATA] != ELF_TARG_DATA ||
-	    hdr->e_ident[EI_VERSION] != EV_CURRENT ||
-	    hdr->e_phentsize != sizeof(Elf_Phdr) ||
-	    hdr->e_version != ELF_TARG_VER)
-		return (ENOEXEC);
-
-	/*
-	 * Make sure we have at least one brand for this machine.
-	 */
-
-	for (i = 0; i < MAX_BRANDS; i++) {
-		bi = elf_brand_list[i];
-		if (bi != NULL && bi->machine == hdr->e_machine)
-			break;
-	}
-	if (i == MAX_BRANDS)
-		return (ENOEXEC);
-
-	return (0);
-}
-
-static int
-__elfN(map_partial)(vm_map_t map, vm_object_t object, vm_ooffset_t offset,
-    vm_offset_t start, vm_offset_t end, vm_prot_t prot)
-{
-	struct sf_buf *sf;
-	int error;
-	vm_offset_t off;
-
-	/*
-	 * Create the page if it doesn't exist yet. Ignore errors.
-	 */
-	vm_map_lock(map);
-	vm_map_insert(map, NULL, 0, trunc_page(start), round_page(end),
-	    VM_PROT_ALL, VM_PROT_ALL, 0);
-	vm_map_unlock(map);
-
-	/*
-	 * Find the page from the underlying object.
-	 */
-	if (object) {
-		sf = vm_imgact_map_page(object, offset);
-		if (sf == NULL)
-			return (KERN_FAILURE);
-		off = offset - trunc_page(offset);
-		error = copyout((caddr_t)sf_buf_kva(sf) + off, (caddr_t)start,
-		    end - start);
-		vm_imgact_unmap_page(sf);
-		if (error) {
-			return (KERN_FAILURE);
-		}
-	}
-
-	return (KERN_SUCCESS);
-}
-
-static int
-__elfN(map_insert)(vm_map_t map, vm_object_t object, vm_ooffset_t offset,
-    vm_offset_t start, vm_offset_t end, vm_prot_t prot, int cow)
-{
-	struct sf_buf *sf;
-	vm_offset_t off;
-	vm_size_t sz;
-	int error, rv;
-
-	if (start != trunc_page(start)) {
-		rv = __elfN(map_partial)(map, object, offset, start,
-		    round_page(start), prot);
-		if (rv)
-			return (rv);
-		offset += round_page(start) - start;
-		start = round_page(start);
-	}
-	if (end != round_page(end)) {
-		rv = __elfN(map_partial)(map, object, offset +
-		    trunc_page(end) - start, trunc_page(end), end, prot);
-		if (rv)
-			return (rv);
-		end = trunc_page(end);
-	}
-	if (end > start) {
-		if (offset & PAGE_MASK) {
-			/*
-			 * The mapping is not page aligned. This means we have
-			 * to copy the data. Sigh.
-			 */
-			rv = vm_map_find(map, NULL, 0, &start, end - start,
-			    FALSE, prot | VM_PROT_WRITE, VM_PROT_ALL, 0);
-			if (rv)
-				return (rv);
-			if (object == NULL)
-				return (KERN_SUCCESS);
-			for (; start < end; start += sz) {
-				sf = vm_imgact_map_page(object, offset);
-				if (sf == NULL)
-					return (KERN_FAILURE);
-				off = offset - trunc_page(offset);
-				sz = end - start;
-				if (sz > PAGE_SIZE - off)
-					sz = PAGE_SIZE - off;
-				error = copyout((caddr_t)sf_buf_kva(sf) + off,
-				    (caddr_t)start, sz);
-				vm_imgact_unmap_page(sf);
-				if (error) {
-					return (KERN_FAILURE);
-				}
-				offset += sz;
-			}
-			rv = KERN_SUCCESS;
-		} else {
-			vm_object_reference(object);
-			vm_map_lock(map);
-			rv = vm_map_insert(map, object, offset, start, end,
-			    prot, VM_PROT_ALL, cow);
-			vm_map_unlock(map);
-			if (rv != KERN_SUCCESS)
-				vm_object_deallocate(object);
-		}
-		return (rv);
-	} else {
-		return (KERN_SUCCESS);
-	}
-}
-
-static int
-__elfN(load_section)(struct vmspace *vmspace,
-	vm_object_t object, vm_offset_t offset,
-	caddr_t vmaddr, size_t memsz, size_t filsz, vm_prot_t prot,
-	size_t pagesize)
-{
-	struct sf_buf *sf;
-	size_t map_len;
-	vm_offset_t map_addr;
-	int error, rv, cow;
-	size_t copy_len;
-	vm_offset_t file_addr;
-
-	/*
-	 * It's necessary to fail if the filsz + offset taken from the
-	 * header is greater than the actual file pager object's size.
-	 * If we were to allow this, then the vm_map_find() below would
-	 * walk right off the end of the file object and into the ether.
-	 *
-	 * While I'm here, might as well check for something else that
-	 * is invalid: filsz cannot be greater than memsz.
-	 */
-	if ((off_t)filsz + offset > object->un_pager.vnp.vnp_size ||
-	    filsz > memsz) {
-		uprintf("elf_load_section: truncated ELF file\n");
-		return (ENOEXEC);
-	}
-
-	map_addr = trunc_page_ps((vm_offset_t)vmaddr, pagesize);
-	file_addr = trunc_page_ps(offset, pagesize);
-
-	/*
-	 * We have two choices.  We can either clear the data in the last page
-	 * of an oversized mapping, or we can start the anon mapping a page
-	 * early and copy the initialized data into that first page.  We
-	 * choose the second..
-	 */
-	if (memsz > filsz)
-		map_len = trunc_page_ps(offset + filsz, pagesize) - file_addr;
-	else
-		map_len = round_page_ps(offset + filsz, pagesize) - file_addr;
-
-	if (map_len != 0) {
-		/* cow flags: don't dump readonly sections in core */
-		cow = MAP_COPY_ON_WRITE | MAP_PREFAULT |
-		    (prot & VM_PROT_WRITE ? 0 : MAP_DISABLE_COREDUMP);
-
-		rv = __elfN(map_insert)(&vmspace->vm_map,
-				      object,
-				      file_addr,	/* file offset */
-				      map_addr,		/* virtual start */
-				      map_addr + map_len,/* virtual end */
-				      prot,
-				      cow);
-		if (rv != KERN_SUCCESS)
-			return (EINVAL);
-
-		/* we can stop now if we've covered it all */
-		if (memsz == filsz) {
-			return (0);
-		}
-	}
-
-
-	/*
-	 * We have to get the remaining bit of the file into the first part
-	 * of the oversized map segment.  This is normally because the .data
-	 * segment in the file is extended to provide bss.  It's a neat idea
-	 * to try and save a page, but it's a pain in the behind to implement.
-	 */
-	copy_len = (offset + filsz) - trunc_page_ps(offset + filsz, pagesize);
-	map_addr = trunc_page_ps((vm_offset_t)vmaddr + filsz, pagesize);
-	map_len = round_page_ps((vm_offset_t)vmaddr + memsz, pagesize) -
-	    map_addr;
-
-	/* This had damn well better be true! */
-	if (map_len != 0) {
-		rv = __elfN(map_insert)(&vmspace->vm_map, NULL, 0, map_addr,
-		    map_addr + map_len, VM_PROT_ALL, 0);
-		if (rv != KERN_SUCCESS) {
-			return (EINVAL);
-		}
-	}
-
-	if (copy_len != 0) {
-		vm_offset_t off;
-
-		sf = vm_imgact_map_page(object, offset + filsz);
-		if (sf == NULL)
-			return (EIO);
-
-		/* send the page fragment to user space */
-		off = trunc_page_ps(offset + filsz, pagesize) -
-		    trunc_page(offset + filsz);
-		error = copyout((caddr_t)sf_buf_kva(sf) + off,
-		    (caddr_t)map_addr, copy_len);
-		vm_imgact_unmap_page(sf);
-		if (error) {
-			return (error);
-		}
-	}
-
-	/*
-	 * set it to the specified protection.
-	 * XXX had better undo the damage from pasting over the cracks here!
-	 */
-	vm_map_protect(&vmspace->vm_map, trunc_page(map_addr),
-	    round_page(map_addr + map_len),  prot, FALSE);
-
-	return (0);
-}
-
-/*
- * Load the file "file" into memory.  It may be either a shared object
- * or an executable.
- *
- * The "addr" reference parameter is in/out.  On entry, it specifies
- * the address where a shared object should be loaded.  If the file is
- * an executable, this value is ignored.  On exit, "addr" specifies
- * where the file was actually loaded.
- *
- * The "entry" reference parameter is out only.  On exit, it specifies
- * the entry point for the loaded file.
- */
-static int
-__elfN(load_file)(struct proc *p, const char *file, u_long *addr,
-	u_long *entry, size_t pagesize)
-{
-	struct {
-		struct nameidata nd;
-		struct vattr attr;
-		struct image_params image_params;
-	} *tempdata;
-	const Elf_Ehdr *hdr = NULL;
-	const Elf_Phdr *phdr = NULL;
-	struct nameidata *nd;
-	struct vmspace *vmspace = p->p_vmspace;
-	struct vattr *attr;
-	struct image_params *imgp;
-	vm_prot_t prot;
-	u_long rbase;
-	u_long base_addr = 0;
-	int vfslocked, error, i, numsegs;
-
-	tempdata = malloc(sizeof(*tempdata), M_TEMP, M_WAITOK);
-	nd = &tempdata->nd;
-	attr = &tempdata->attr;
-	imgp = &tempdata->image_params;
-
-	/*
-	 * Initialize part of the common data
-	 */
-	imgp->proc = p;
-	imgp->attr = attr;
-	imgp->firstpage = NULL;
-	imgp->image_header = NULL;
-	imgp->object = NULL;
-	imgp->execlabel = NULL;
-
-	NDINIT(nd, LOOKUP, MPSAFE|LOCKLEAF|FOLLOW, UIO_SYSSPACE, file,
-	    curthread);
-	vfslocked = 0;
-	if ((error = namei(nd)) != 0) {
-		nd->ni_vp = NULL;
-		goto fail;
-	}
-	vfslocked = NDHASGIANT(nd);
-	NDFREE(nd, NDF_ONLY_PNBUF);
-	imgp->vp = nd->ni_vp;
-
-	/*
-	 * Check permissions, modes, uid, etc on the file, and "open" it.
-	 */
-	error = exec_check_permissions(imgp);
-	if (error)
-		goto fail;
-
-	error = exec_map_first_page(imgp);
-	if (error)
-		goto fail;
-
-	/*
-	 * Also make certain that the interpreter stays the same, so set
-	 * its VV_TEXT flag, too.
-	 */
-	nd->ni_vp->v_vflag |= VV_TEXT;
-
-	imgp->object = nd->ni_vp->v_object;
-
-	hdr = (const Elf_Ehdr *)imgp->image_header;
-	if ((error = __elfN(check_header)(hdr)) != 0)
-		goto fail;
-	if (hdr->e_type == ET_DYN)
-		rbase = *addr;
-	else if (hdr->e_type == ET_EXEC)
-		rbase = 0;
-	else {
-		error = ENOEXEC;
-		goto fail;
-	}
-
-	/* Only support headers that fit within first page for now      */
-	/*    (multiplication of two Elf_Half fields will not overflow) */
-	if ((hdr->e_phoff > PAGE_SIZE) ||
-	    (hdr->e_phentsize * hdr->e_phnum) > PAGE_SIZE - hdr->e_phoff) {
-		error = ENOEXEC;
-		goto fail;
-	}
-
-	phdr = (const Elf_Phdr *)(imgp->image_header + hdr->e_phoff);
-	if (!aligned(phdr, Elf_Addr)) {
-		error = ENOEXEC;
-		goto fail;
-	}
-
-	for (i = 0, numsegs = 0; i < hdr->e_phnum; i++) {
-		if (phdr[i].p_type == PT_LOAD) {	/* Loadable segment */
-			prot = 0;
-			if (phdr[i].p_flags & PF_X)
-  				prot |= VM_PROT_EXECUTE;
-			if (phdr[i].p_flags & PF_W)
-  				prot |= VM_PROT_WRITE;
-			if (phdr[i].p_flags & PF_R)
-  				prot |= VM_PROT_READ;
-
-			if ((error = __elfN(load_section)(vmspace,
-			    imgp->object, phdr[i].p_offset,
-			    (caddr_t)(uintptr_t)phdr[i].p_vaddr + rbase,
-			    phdr[i].p_memsz, phdr[i].p_filesz, prot,
-			    pagesize)) != 0)
-				goto fail;
-			/*
-			 * Establish the base address if this is the
-			 * first segment.
-			 */
-			if (numsegs == 0)
-  				base_addr = trunc_page(phdr[i].p_vaddr +
-				    rbase);
-			numsegs++;
-		}
-	}
-	*addr = base_addr;
-	*entry = (unsigned long)hdr->e_entry + rbase;
-
-fail:
-	if (imgp->firstpage)
-		exec_unmap_first_page(imgp);
-
-	if (nd->ni_vp)
-		vput(nd->ni_vp);
-
-	VFS_UNLOCK_GIANT(vfslocked);
-	free(tempdata, M_TEMP);
-
-	return (error);
-}
-
-static int
-__CONCAT(exec_, __elfN(imgact))(struct image_params *imgp)
-{
-	const Elf_Ehdr *hdr = (const Elf_Ehdr *)imgp->image_header;
-	const Elf_Phdr *phdr;
-	Elf_Auxargs *elf_auxargs;
-	struct vmspace *vmspace;
-	vm_prot_t prot;
-	u_long text_size = 0, data_size = 0, total_size = 0;
-	u_long text_addr = 0, data_addr = 0;
-	u_long seg_size, seg_addr;
-	u_long addr, entry = 0, proghdr = 0;
-	int32_t osrel = 0;
-	int error = 0, i;
-	const char *interp = NULL, *newinterp = NULL;
-	Elf_Brandinfo *brand_info;
-	char *path;
-	struct sysentvec *sv;
-	u_long rbase = 0;
-
-
-	/*
-	 * Do we have a valid ELF header ?
-	 *
-	 * Only allow ET_EXEC & ET_DYN here, reject ET_DYN later
-	 * if particular brand doesn't support it.
-	 */
-	if (__elfN(check_header)(hdr) != 0 ||
-	    (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN))
-		return (-1);
-
-	/*
-	 * From here on down, we return an errno, not -1, as we've
-	 * detected an ELF file.
-	 */
-
-	if ((hdr->e_phoff > PAGE_SIZE) ||
-	    (hdr->e_phoff + hdr->e_phentsize * hdr->e_phnum) > PAGE_SIZE) {
-		/* Only support headers in first page for now */
-		return (ENOEXEC);
-	}
-	phdr = (const Elf_Phdr *)(imgp->image_header + hdr->e_phoff);
-	if (!aligned(phdr, Elf_Addr))
-		return (ENOEXEC);
-	for (i = 0; i < hdr->e_phnum; i++) {
-		if (phdr[i].p_type == PT_INTERP) {
-			/* Path to interpreter */
-			if (phdr[i].p_filesz > MAXPATHLEN ||
-			    phdr[i].p_offset + phdr[i].p_filesz > PAGE_SIZE)
-				return (ENOEXEC);
-			interp = imgp->image_header + phdr[i].p_offset;
-			break;
-		}
-	}
-
-	brand_info = __elfN(get_brandinfo)(imgp, interp, &osrel);
-	if (brand_info == NULL) {
-		uprintf("ELF binary type \"%u\" not known.\n",
-		    hdr->e_ident[EI_OSABI]);
-		return (ENOEXEC);
-	}
-#if 0
-	if (hdr->e_type == ET_DYN &&
-	    (brand_info->flags & BI_CAN_EXEC_DYN) == 0)
-		return (ENOEXEC);
-#endif
-	if (hdr->e_type == ET_DYN) {
- 	    for (i = 0; i < hdr->e_phnum; i++) {
-		if (phdr[i].p_type == PT_LOAD) {
-			if (phdr[i].p_vaddr == 0) {
-				/* we have to load at base addr 0,
-				 * so relocate somewhere (at 512 MB)
-				 */
-				rbase = 512 * 1024 * 1024;
-				break;
-			}
-		}
-	    }
-	}
-
-	sv = brand_info->sysvec;
-	if (interp != NULL && brand_info->interp_newpath != NULL && !strcmp(interp, "/libexec/ld-elf.so.1"))
-		newinterp = brand_info->interp_newpath;
-
-	/*
-	 * Avoid a possible deadlock if the current address space is destroyed
-	 * and that address space maps the locked vnode.  In the common case,
-	 * the locked vnode's v_usecount is decremented but remains greater
-	 * than zero.  Consequently, the vnode lock is not needed by vrele().
-	 * However, in cases where the vnode lock is external, such as nullfs,
-	 * v_usecount may become zero.
-	 */
-	VOP_UNLOCK(imgp->vp, 0);
-
-	error = exec_new_vmspace(imgp, sv);
-	imgp->proc->p_sysent = sv;
-
-	vn_lock(imgp->vp, LK_EXCLUSIVE | LK_RETRY);
-	if (error)
-		return (error);
-
-	vmspace = imgp->proc->p_vmspace;
-
-	for (i = 0; i < hdr->e_phnum; i++) {
-		switch (phdr[i].p_type) {
-		case PT_LOAD:	/* Loadable segment */
-			prot = 0;
-			if (phdr[i].p_flags & PF_X)
-  				prot |= VM_PROT_EXECUTE;
-			if (phdr[i].p_flags & PF_W)
-  				prot |= VM_PROT_WRITE;
-			if (phdr[i].p_flags & PF_R)
-  				prot |= VM_PROT_READ;
-
-#if defined(__ia64__) && __ELF_WORD_SIZE == 32 && defined(IA32_ME_HARDER)
-			/*
-			 * Some x86 binaries assume read == executable,
-			 * notably the M3 runtime and therefore cvsup
-			 */
-			if (prot & VM_PROT_READ)
-				prot |= VM_PROT_EXECUTE;
-#endif
-
-			if ((error = __elfN(load_section)(vmspace,
-			    imgp->object, phdr[i].p_offset,
-			    (caddr_t)(uintptr_t)phdr[i].p_vaddr + rbase,
-			    phdr[i].p_memsz, phdr[i].p_filesz, prot,
-			    sv->sv_pagesize)) != 0)
-				return (error);
-
-			/*
-			 * If this segment contains the program headers,
-			 * remember their virtual address for the AT_PHDR
-			 * aux entry. Static binaries don't usually include
-			 * a PT_PHDR entry.
-			 */
-			if (phdr[i].p_offset == 0 &&
-			    hdr->e_phoff + hdr->e_phnum * hdr->e_phentsize
-				<= phdr[i].p_filesz)
-				proghdr = phdr[i].p_vaddr + rbase + hdr->e_phoff;
-
-			seg_addr = trunc_page(phdr[i].p_vaddr);
-			seg_size = round_page(phdr[i].p_memsz +
-			    phdr[i].p_vaddr - seg_addr);
-			seg_addr += rbase;
-
-			/*
-			 * Is this .text or .data?  We can't use
-			 * VM_PROT_WRITE or VM_PROT_EXEC, it breaks the
-			 * alpha terribly and possibly does other bad
-			 * things so we stick to the old way of figuring
-			 * it out:  If the segment contains the program
-			 * entry point, it's a text segment, otherwise it
-			 * is a data segment.
-			 *
-			 * Note that obreak() assumes that data_addr + 
-			 * data_size == end of data load area, and the ELF
-			 * file format expects segments to be sorted by
-			 * address.  If multiple data segments exist, the
-			 * last one will be used.
-			 */
-			if (hdr->e_entry >= phdr[i].p_vaddr &&
-			    hdr->e_entry < (phdr[i].p_vaddr +
-			    phdr[i].p_memsz)) {
-				text_size = seg_size;
-				text_addr = seg_addr;
-				entry = (u_long)hdr->e_entry + rbase;
-			} else {
-				data_size = seg_size;
-				data_addr = seg_addr;
-			}
-			total_size += seg_size;
-			break;
-		case PT_PHDR: 	/* Program header table info */
-			proghdr = phdr[i].p_vaddr + rbase;
-			break;
-		default:
-			break;
-		}
-	}
-	
-	if (data_addr == 0 && data_size == 0) {
-		data_addr = text_addr;
-		data_size = text_size;
-	}
-
-	/*
-	 * Check limits.  It should be safe to check the
-	 * limits after loading the segments since we do
-	 * not actually fault in all the segments pages.
-	 */
-	PROC_LOCK(imgp->proc);
-	if (data_size > lim_cur(imgp->proc, RLIMIT_DATA) ||
-	    text_size > maxtsiz ||
-	    total_size > lim_cur(imgp->proc, RLIMIT_VMEM)) {
-		PROC_UNLOCK(imgp->proc);
-		return (ENOMEM);
-	}
-
-	vmspace->vm_tsize = text_size >> PAGE_SHIFT;
-	vmspace->vm_taddr = (caddr_t)(uintptr_t)text_addr;
-	vmspace->vm_dsize = data_size >> PAGE_SHIFT;
-	vmspace->vm_daddr = (caddr_t)(uintptr_t)data_addr;
-
-	/*
-	 * We load the dynamic linker where a userland call
-	 * to mmap(0, ...) would put it.  The rationale behind this
-	 * calculation is that it leaves room for the heap to grow to
-	 * its maximum allowed size.
-	 */
-	addr = round_page((vm_offset_t)imgp->proc->p_vmspace->vm_daddr +
-	    lim_max(imgp->proc, RLIMIT_DATA));
-	PROC_UNLOCK(imgp->proc);
-
-	imgp->entry_addr = entry;
-
-	if (interp != NULL) {
-		int have_interp = FALSE;
-		VOP_UNLOCK(imgp->vp, 0);
-		if (brand_info->emul_path != NULL &&
-		    brand_info->emul_path[0] != '\0') {
-			path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
-			snprintf(path, MAXPATHLEN, "%s%s",
-			    brand_info->emul_path, interp);
-			error = __elfN(load_file)(imgp->proc, path, &addr,
-			    &imgp->entry_addr, sv->sv_pagesize);
-			free(path, M_TEMP);
-			if (error == 0)
-				have_interp = TRUE;
-		}
-		if (!have_interp && newinterp != NULL) {
-			error = __elfN(load_file)(imgp->proc, newinterp, &addr,
-			    &imgp->entry_addr, sv->sv_pagesize);
-			if (error == 0)
-				have_interp = TRUE;
-		}
-		if (!have_interp) {
-			error = __elfN(load_file)(imgp->proc, interp, &addr,
-			    &imgp->entry_addr, sv->sv_pagesize);
-		}
-		vn_lock(imgp->vp, LK_EXCLUSIVE | LK_RETRY);
-		if (error != 0) {
-			uprintf("ELF interpreter %s not found\n", interp);
-			return (error);
-		}
-	} else
-		addr = 0;
-
-	/*
-	 * Construct auxargs table (used by the fixup routine)
-	 */
-	elf_auxargs = malloc(sizeof(Elf_Auxargs), M_TEMP, M_WAITOK);
-	elf_auxargs->execfd = -1;
-	elf_auxargs->phdr = proghdr;
-	elf_auxargs->phent = hdr->e_phentsize;
-	elf_auxargs->phnum = hdr->e_phnum;
-	elf_auxargs->pagesz = PAGE_SIZE;
-	elf_auxargs->base = addr;
-	elf_auxargs->flags = 0;
-	elf_auxargs->entry = entry;
-
-	imgp->auxargs = elf_auxargs;
-	imgp->interpreted = 0;
-	imgp->proc->p_osrel = osrel;
-
-	return (error);
-}
-
-#define	suword __CONCAT(suword, __ELF_WORD_SIZE)
-
-int
-__elfN(freebsd_fixup)(register_t **stack_base, struct image_params *imgp)
-{
-	Elf_Auxargs *args = (Elf_Auxargs *)imgp->auxargs;
-	Elf_Addr *base;
-	Elf_Addr *pos;
-
-	base = (Elf_Addr *)*stack_base;
-	pos = base + (imgp->args->argc + imgp->args->envc + 2);
-
-	if (args->execfd != -1)
-		AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
-	AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);
-	AUXARGS_ENTRY(pos, AT_PHENT, args->phent);
-	AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);
-	AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
-	AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
-	AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
-	AUXARGS_ENTRY(pos, AT_BASE, args->base);
-	if (imgp->execpathp != 0)
-		AUXARGS_ENTRY(pos, AT_EXECPATH, imgp->execpathp);
-	AUXARGS_ENTRY(pos, AT_NULL, 0);
-
-	free(imgp->auxargs, M_TEMP);
-	imgp->auxargs = NULL;
-
-	base--;
-	suword(base, (long)imgp->args->argc);
-	*stack_base = (register_t *)base;
-	return (0);
-}
-
-/*
- * Code for generating ELF core dumps.
- */
-
-typedef void (*segment_callback)(vm_map_entry_t, void *);
-
-/* Closure for cb_put_phdr(). */
-struct phdr_closure {
-	Elf_Phdr *phdr;		/* Program header to fill in */
-	Elf_Off offset;		/* Offset of segment in core file */
-};
-
-/* Closure for cb_size_segment(). */
-struct sseg_closure {
-	int count;		/* Count of writable segments. */
-	size_t size;		/* Total size of all writable segments. */
-};
-
-static void cb_put_phdr(vm_map_entry_t, void *);
-static void cb_size_segment(vm_map_entry_t, void *);
-static void each_writable_segment(struct thread *, segment_callback, void *);
-static int __elfN(corehdr)(struct thread *, struct vnode *, struct ucred *,
-    int, void *, size_t);
-static void __elfN(puthdr)(struct thread *, void *, size_t *, int);
-static void __elfN(putnote)(void *, size_t *, const char *, int,
-    const void *, size_t);
-
-int
-__elfN(coredump)(td, vp, limit)
-	struct thread *td;
-	struct vnode *vp;
-	off_t limit;
-{
-	struct ucred *cred = td->td_ucred;
-	int error = 0;
-	struct sseg_closure seginfo;
-	void *hdr;
-	size_t hdrsize;
-
-	/* Size the program segments. */
-	seginfo.count = 0;
-	seginfo.size = 0;
-	each_writable_segment(td, cb_size_segment, &seginfo);
-
-	/*
-	 * Calculate the size of the core file header area by making
-	 * a dry run of generating it.  Nothing is written, but the
-	 * size is calculated.
-	 */
-	hdrsize = 0;
-	__elfN(puthdr)(td, (void *)NULL, &hdrsize, seginfo.count);
-
-	if (hdrsize + seginfo.size >= limit)
-		return (EFAULT);
-
-	/*
-	 * Allocate memory for building the header, fill it up,
-	 * and write it out.
-	 */
-	hdr = malloc(hdrsize, M_TEMP, M_WAITOK);
-	if (hdr == NULL) {
-		return (EINVAL);
-	}
-	error = __elfN(corehdr)(td, vp, cred, seginfo.count, hdr, hdrsize);
-
-	/* Write the contents of all of the writable segments. */
-	if (error == 0) {
-		Elf_Phdr *php;
-		off_t offset;
-		int i;
-
-		php = (Elf_Phdr *)((char *)hdr + sizeof(Elf_Ehdr)) + 1;
-		offset = hdrsize;
-		for (i = 0; i < seginfo.count; i++) {
-			error = vn_rdwr_inchunks(UIO_WRITE, vp,
-			    (caddr_t)(uintptr_t)php->p_vaddr,
-			    php->p_filesz, offset, UIO_USERSPACE,
-			    IO_UNIT | IO_DIRECT, cred, NOCRED, NULL,
-			    curthread);
-			if (error != 0)
-				break;
-			offset += php->p_filesz;
-			php++;
-		}
-	}
-	free(hdr, M_TEMP);
-
-	return (error);
-}
-
-/*
- * A callback for each_writable_segment() to write out the segment's
- * program header entry.
- */
-static void
-cb_put_phdr(entry, closure)
-	vm_map_entry_t entry;
-	void *closure;
-{
-	struct phdr_closure *phc = (struct phdr_closure *)closure;
-	Elf_Phdr *phdr = phc->phdr;
-
-	phc->offset = round_page(phc->offset);
-
-	phdr->p_type = PT_LOAD;
-	phdr->p_offset = phc->offset;
-	phdr->p_vaddr = entry->start;
-	phdr->p_paddr = 0;
-	phdr->p_filesz = phdr->p_memsz = entry->end - entry->start;
-	phdr->p_align = PAGE_SIZE;
-	phdr->p_flags = 0;
-	if (entry->protection & VM_PROT_READ)
-		phdr->p_flags |= PF_R;
-	if (entry->protection & VM_PROT_WRITE)
-		phdr->p_flags |= PF_W;
-	if (entry->protection & VM_PROT_EXECUTE)
-		phdr->p_flags |= PF_X;
-
-	phc->offset += phdr->p_filesz;
-	phc->phdr++;
-}
-
-/*
- * A callback for each_writable_segment() to gather information about
- * the number of segments and their total size.
- */
-static void
-cb_size_segment(entry, closure)
-	vm_map_entry_t entry;
-	void *closure;
-{
-	struct sseg_closure *ssc = (struct sseg_closure *)closure;
-
-	ssc->count++;
-	ssc->size += entry->end - entry->start;
-}
-
-/*
- * For each writable segment in the process's memory map, call the given
- * function with a pointer to the map entry and some arbitrary
- * caller-supplied data.
- */
-static void
-each_writable_segment(td, func, closure)
-	struct thread *td;
-	segment_callback func;
-	void *closure;
-{
-	struct proc *p = td->td_proc;
-	vm_map_t map = &p->p_vmspace->vm_map;
-	vm_map_entry_t entry;
-	vm_object_t backing_object, object;
-	boolean_t ignore_entry;
-
-	vm_map_lock_read(map);
-	for (entry = map->header.next; entry != &map->header;
-	    entry = entry->next) {
-		/*
-		 * Don't dump inaccessible mappings, deal with legacy
-		 * coredump mode.
-		 *
-		 * Note that read-only segments related to the elf binary
-		 * are marked MAP_ENTRY_NOCOREDUMP now so we no longer
-		 * need to arbitrarily ignore such segments.
-		 */
-		if (elf_legacy_coredump) {
-			if ((entry->protection & VM_PROT_RW) != VM_PROT_RW)
-				continue;
-		} else {
-			if ((entry->protection & VM_PROT_ALL) == 0)
-				continue;
-		}
-
-		/*
-		 * Dont include memory segment in the coredump if
-		 * MAP_NOCORE is set in mmap(2) or MADV_NOCORE in
-		 * madvise(2).  Do not dump submaps (i.e. parts of the
-		 * kernel map).
-		 */
-		if (entry->eflags & (MAP_ENTRY_NOCOREDUMP|MAP_ENTRY_IS_SUB_MAP))
-			continue;
-
-		if ((object = entry->object.vm_object) == NULL)
-			continue;
-
-		/* Ignore memory-mapped devices and such things. */
-		VM_OBJECT_LOCK(object);
-		while ((backing_object = object->backing_object) != NULL) {
-			VM_OBJECT_LOCK(backing_object);
-			VM_OBJECT_UNLOCK(object);
-			object = backing_object;
-		}
-		ignore_entry = object->type != OBJT_DEFAULT &&
-		    object->type != OBJT_SWAP && object->type != OBJT_VNODE;
-		VM_OBJECT_UNLOCK(object);
-		if (ignore_entry)
-			continue;
-
-		(*func)(entry, closure);
-	}
-	vm_map_unlock_read(map);
-}
-
-/*
- * Write the core file header to the file, including padding up to
- * the page boundary.
- */
-static int
-__elfN(corehdr)(td, vp, cred, numsegs, hdr, hdrsize)
-	struct thread *td;
-	struct vnode *vp;
-	struct ucred *cred;
-	int numsegs;
-	size_t hdrsize;
-	void *hdr;
-{
-	size_t off;
-
-	/* Fill in the header. */
-	bzero(hdr, hdrsize);
-	off = 0;
-	__elfN(puthdr)(td, hdr, &off, numsegs);
-
-	/* Write it to the core file. */
-	return (vn_rdwr_inchunks(UIO_WRITE, vp, hdr, hdrsize, (off_t)0,
-	    UIO_SYSSPACE, IO_UNIT | IO_DIRECT, cred, NOCRED, NULL,
-	    td));
-}
-
-#if defined(COMPAT_IA32) && __ELF_WORD_SIZE == 32
-typedef struct prstatus32 elf_prstatus_t;
-typedef struct prpsinfo32 elf_prpsinfo_t;
-typedef struct fpreg32 elf_prfpregset_t;
-typedef struct fpreg32 elf_fpregset_t;
-typedef struct reg32 elf_gregset_t;
-#else
-typedef prstatus_t elf_prstatus_t;
-typedef prpsinfo_t elf_prpsinfo_t;
-typedef prfpregset_t elf_prfpregset_t;
-typedef prfpregset_t elf_fpregset_t;
-typedef gregset_t elf_gregset_t;
-#endif
-
-static void
-__elfN(puthdr)(struct thread *td, void *dst, size_t *off, int numsegs)
-{
-	struct {
-		elf_prstatus_t status;
-		elf_prfpregset_t fpregset;
-		elf_prpsinfo_t psinfo;
-	} *tempdata;
-	elf_prstatus_t *status;
-	elf_prfpregset_t *fpregset;
-	elf_prpsinfo_t *psinfo;
-	struct proc *p;
-	struct thread *thr;
-	size_t ehoff, noteoff, notesz, phoff;
-
-	p = td->td_proc;
-
-	ehoff = *off;
-	*off += sizeof(Elf_Ehdr);
-
-	phoff = *off;
-	*off += (numsegs + 1) * sizeof(Elf_Phdr);
-
-	noteoff = *off;
-	/*
-	 * Don't allocate space for the notes if we're just calculating
-	 * the size of the header. We also don't collect the data.
-	 */
-	if (dst != NULL) {
-		tempdata = malloc(sizeof(*tempdata), M_TEMP, M_ZERO|M_WAITOK);
-		status = &tempdata->status;
-		fpregset = &tempdata->fpregset;
-		psinfo = &tempdata->psinfo;
-	} else {
-		tempdata = NULL;
-		status = NULL;
-		fpregset = NULL;
-		psinfo = NULL;
-	}
-
-	if (dst != NULL) {
-		psinfo->pr_version = PRPSINFO_VERSION;
-		psinfo->pr_psinfosz = sizeof(elf_prpsinfo_t);
-		strlcpy(psinfo->pr_fname, p->p_comm, sizeof(psinfo->pr_fname));
-		/*
-		 * XXX - We don't fill in the command line arguments properly
-		 * yet.
-		 */
-		strlcpy(psinfo->pr_psargs, p->p_comm,
-		    sizeof(psinfo->pr_psargs));
-	}
-	__elfN(putnote)(dst, off, "FreeBSD", NT_PRPSINFO, psinfo,
-	    sizeof *psinfo);
-
-	/*
-	 * To have the debugger select the right thread (LWP) as the initial
-	 * thread, we dump the state of the thread passed to us in td first.
-	 * This is the thread that causes the core dump and thus likely to
-	 * be the right thread one wants to have selected in the debugger.
-	 */
-	thr = td;
-	while (thr != NULL) {
-		if (dst != NULL) {
-			status->pr_version = PRSTATUS_VERSION;
-			status->pr_statussz = sizeof(elf_prstatus_t);
-			status->pr_gregsetsz = sizeof(elf_gregset_t);
-			status->pr_fpregsetsz = sizeof(elf_fpregset_t);
-			status->pr_osreldate = osreldate;
-			status->pr_cursig = p->p_sig;
-			status->pr_pid = thr->td_tid;
-#if defined(COMPAT_IA32) && __ELF_WORD_SIZE == 32
-			fill_regs32(thr, &status->pr_reg);
-			fill_fpregs32(thr, fpregset);
-#else
-			fill_regs(thr, &status->pr_reg);
-			fill_fpregs(thr, fpregset);
-#endif
-		}
-		__elfN(putnote)(dst, off, "FreeBSD", NT_PRSTATUS, status,
-		    sizeof *status);
-		__elfN(putnote)(dst, off, "FreeBSD", NT_FPREGSET, fpregset,
-		    sizeof *fpregset);
-		/*
-		 * Allow for MD specific notes, as well as any MD
-		 * specific preparations for writing MI notes.
-		 */
-		__elfN(dump_thread)(thr, dst, off);
-
-		thr = (thr == td) ? TAILQ_FIRST(&p->p_threads) :
-		    TAILQ_NEXT(thr, td_plist);
-		if (thr == td)
-			thr = TAILQ_NEXT(thr, td_plist);
-	}
-
-	notesz = *off - noteoff;
-
-	if (dst != NULL)
-		free(tempdata, M_TEMP);
-
-	/* Align up to a page boundary for the program segments. */
-	*off = round_page(*off);
-
-	if (dst != NULL) {
-		Elf_Ehdr *ehdr;
-		Elf_Phdr *phdr;
-		struct phdr_closure phc;
-
-		/*
-		 * Fill in the ELF header.
-		 */
-		ehdr = (Elf_Ehdr *)((char *)dst + ehoff);
-		ehdr->e_ident[EI_MAG0] = ELFMAG0;
-		ehdr->e_ident[EI_MAG1] = ELFMAG1;
-		ehdr->e_ident[EI_MAG2] = ELFMAG2;
-		ehdr->e_ident[EI_MAG3] = ELFMAG3;
-		ehdr->e_ident[EI_CLASS] = ELF_CLASS;
-		ehdr->e_ident[EI_DATA] = ELF_DATA;
-		ehdr->e_ident[EI_VERSION] = EV_CURRENT;
-		ehdr->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
-		ehdr->e_ident[EI_ABIVERSION] = 0;
-		ehdr->e_ident[EI_PAD] = 0;
-		ehdr->e_type = ET_CORE;
-#if defined(COMPAT_IA32) && __ELF_WORD_SIZE == 32
-		ehdr->e_machine = EM_386;
-#else
-		ehdr->e_machine = ELF_ARCH;
-#endif
-		ehdr->e_version = EV_CURRENT;
-		ehdr->e_entry = 0;
-		ehdr->e_phoff = phoff;
-		ehdr->e_flags = 0;
-		ehdr->e_ehsize = sizeof(Elf_Ehdr);
-		ehdr->e_phentsize = sizeof(Elf_Phdr);
-		ehdr->e_phnum = numsegs + 1;
-		ehdr->e_shentsize = sizeof(Elf_Shdr);
-		ehdr->e_shnum = 0;
-		ehdr->e_shstrndx = SHN_UNDEF;
-
-		/*
-		 * Fill in the program header entries.
-		 */
-		phdr = (Elf_Phdr *)((char *)dst + phoff);
-
-		/* The note segement. */
-		phdr->p_type = PT_NOTE;
-		phdr->p_offset = noteoff;
-		phdr->p_vaddr = 0;
-		phdr->p_paddr = 0;
-		phdr->p_filesz = notesz;
-		phdr->p_memsz = 0;
-		phdr->p_flags = 0;
-		phdr->p_align = 0;
-		phdr++;
-
-		/* All the writable segments from the program. */
-		phc.phdr = phdr;
-		phc.offset = *off;
-		each_writable_segment(td, cb_put_phdr, &phc);
-	}
-}
-
-static void
-__elfN(putnote)(void *dst, size_t *off, const char *name, int type,
-    const void *desc, size_t descsz)
-{
-	Elf_Note note;
-
-	note.n_namesz = strlen(name) + 1;
-	note.n_descsz = descsz;
-	note.n_type = type;
-	if (dst != NULL)
-		bcopy(&note, (char *)dst + *off, sizeof note);
-	*off += sizeof note;
-	if (dst != NULL)
-		bcopy(name, (char *)dst + *off, note.n_namesz);
-	*off += roundup2(note.n_namesz, sizeof(Elf_Size));
-	if (dst != NULL)
-		bcopy(desc, (char *)dst + *off, note.n_descsz);
-	*off += roundup2(note.n_descsz, sizeof(Elf_Size));
-}
-
-/*
- * Try to find the appropriate ABI-note section for checknote,
- * fetch the osreldate for binary from the ELF OSABI-note. Only the
- * first page of the image is searched, the same as for headers.
- */
-static boolean_t
-__elfN(check_note)(struct image_params *imgp, Elf_Brandnote *checknote,
-    int32_t *osrel)
-{
-	const Elf_Note *note, *note0, *note_end;
-	const Elf_Phdr *phdr, *pnote;
-	const Elf_Ehdr *hdr;
-	const char *note_name;
-	int i;
-
-	pnote = NULL;
-	hdr = (const Elf_Ehdr *)imgp->image_header;
-	phdr = (const Elf_Phdr *)(imgp->image_header + hdr->e_phoff);
-
-	for (i = 0; i < hdr->e_phnum; i++) {
-		if (phdr[i].p_type == PT_NOTE) {
-			pnote = &phdr[i];
-			break;
-		}
-	}
-
-	if (pnote == NULL || pnote->p_offset >= PAGE_SIZE ||
-	    pnote->p_offset + pnote->p_filesz >= PAGE_SIZE)
-		return (FALSE);
-
-	note = note0 = (const Elf_Note *)(imgp->image_header + pnote->p_offset);
-	note_end = (const Elf_Note *)(imgp->image_header +
-	    pnote->p_offset + pnote->p_filesz);
-	for (i = 0; i < 100 && note >= note0 && note < note_end; i++) {
-		if (!aligned(note, Elf32_Addr))
-			return (FALSE);
-		if (note->n_namesz != checknote->hdr.n_namesz ||
-		    note->n_descsz != checknote->hdr.n_descsz ||
-		    note->n_type != checknote->hdr.n_type)
-			goto nextnote;
-		note_name = (const char *)(note + 1);
-		if (strncmp(checknote->vendor, note_name,
-		    checknote->hdr.n_namesz) != 0)
-			goto nextnote;
-
-		/*
-		 * Fetch the osreldate for binary
-		 * from the ELF OSABI-note if necessary.
-		 */
-		if ((checknote->flags & BN_CAN_FETCH_OSREL) != 0 &&
-		    osrel != NULL)
-			*osrel = *(const int32_t *) (note_name +
-			    roundup2(checknote->hdr.n_namesz,
-			    sizeof(Elf32_Addr)));
-		return (TRUE);
-
-nextnote:
-		note = (const Elf_Note *)((const char *)(note + 1) +
-		    roundup2(note->n_namesz, sizeof(Elf32_Addr)) +
-		    roundup2(note->n_descsz, sizeof(Elf32_Addr)));
-	}
-
-	return (FALSE);
-}
-
-/*
- * Tell kern_execve.c about it, with a little help from the linker.
- */
-static struct execsw __elfN(execsw) = {
-	__CONCAT(exec_, __elfN(imgact)),
-	__XSTRING(__CONCAT(ELF, __ELF_WORD_SIZE))
-};
-EXEC_SET(__CONCAT(elf, __ELF_WORD_SIZE), __elfN(execsw));
