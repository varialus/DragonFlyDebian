--- a/sys/dev/acpica/acpi.c
+++ b/sys/dev/acpica/acpi.c
@@ -2308,9 +2308,8 @@
 int
 acpi_ReqSleepState(struct acpi_softc *sc, int state)
 {
-#if defined(__i386__)
+#if defined(__amd64__) || defined(__i386__)
     struct apm_clone_data *clone;
-#endif
 
     if (state < ACPI_STATE_S1 || state > ACPI_S_STATES_MAX)
 	return (EINVAL);
@@ -2325,7 +2324,6 @@
 	    return (ENXIO);
     }
 
-#if defined(__amd64__) || defined(__i386__)
     /* If a suspend request is already in progress, just return. */
     ACPI_LOCK(acpi);
     if (sc->acpi_next_sstate != 0) {
@@ -2335,7 +2333,6 @@
 
     /* Record the pending state and notify all apm devices. */
     sc->acpi_next_sstate = state;
-#if defined(__i386__)
     STAILQ_FOREACH(clone, &sc->apm_cdevs, entries) {
 	clone->notify_status = APM_EV_NONE;
 	if ((clone->flags & ACPI_EVF_DEVD) == 0) {
@@ -2343,7 +2340,6 @@
 	    KNOTE_UNLOCKED(&clone->sel_read.si_note, 0);
 	}
     }
-#endif
 
     /* If devd(8) is not running, immediately enter the sleep state. */
     if (!devctl_process_running()) {
@@ -2414,7 +2410,6 @@
      * are writable since read-only devices couldn't ack the request.
      */
     sleeping = TRUE;
-#if defined(__i386__)
     clone->notify_status = APM_EV_ACKED;
     STAILQ_FOREACH(clone, &sc->apm_cdevs, entries) {
 	if ((clone->flags & ACPI_EVF_WRITE) != 0 &&
@@ -2423,7 +2418,6 @@
 	    break;
 	}
     }
-#endif
 
     /* If all devices have voted "yes", we will suspend now. */
     if (sleeping)
--- a/sys/i386/include/apm_bios.h
+++ b/sys/i386/include/apm_bios.h
@@ -230,12 +230,12 @@
 } *apm_pwstatus_t;
 
 struct apm_bios_arg {
-        u_long eax;
-        u_long ebx;
-        u_long ecx;
-        u_long edx;
-        u_long esi;
-        u_long edi;
+        uint32_t eax;
+        uint32_t ebx;
+        uint32_t ecx;
+        uint32_t edx;
+        uint32_t esi;
+        uint32_t edi;
 };
 
 struct apm_event_info {
--- a/sys/amd64/acpica/acpi_machdep.c
+++ b/sys/amd64/acpica/acpi_machdep.c
@@ -43,6 +43,24 @@
 
 #include <machine/nexusvar.h>
 
+/*
+ * APM driver emulation 
+ */
+
+#include <sys/condvar.h>
+#include <sys/conf.h>
+#include <sys/fcntl.h>
+#include <sys/malloc.h>
+#include <sys/poll.h>
+#include <sys/uio.h>
+
+#include <dev/acpica/acpiio.h>
+
+#include <machine/apm_bios.h>
+#include <i386/include/pc/bios.h>
+
+#include <i386/bios/apm.h>
+
 SYSCTL_DECL(_debug_acpi);
 
 int acpi_resume_beep;
@@ -54,8 +72,433 @@
 TUNABLE_INT("hw.acpi.reset_video", &acpi_reset_video);
 
 static int intr_model = ACPI_INTR_PIC;
-static struct apm_clone_data acpi_clone;
+static int apm_active;
+static struct clonedevs *apm_clones;
 
+MALLOC_DEFINE(M_APMDEV, "apmdev", "APM device emulation");
+
+static d_open_t		apmopen;
+static d_close_t	apmclose;
+static d_write_t	apmwrite;
+static d_ioctl_t	apmioctl;
+static d_poll_t		apmpoll;
+static d_kqfilter_t	apmkqfilter;
+static void		apmreadfiltdetach(struct knote *kn);
+static int		apmreadfilt(struct knote *kn, long hint);
+static struct filterops	apm_readfiltops = {
+	.f_isfd = 1,
+	.f_detach = apmreadfiltdetach,
+	.f_event = apmreadfilt,
+};
+
+static struct cdevsw apm_cdevsw = {
+	.d_version =	D_VERSION,
+	.d_flags =	D_TRACKCLOSE | D_NEEDMINOR,
+	.d_open =	apmopen,
+	.d_close =	apmclose,
+	.d_write =	apmwrite,
+	.d_ioctl =	apmioctl,
+	.d_poll =	apmpoll,
+	.d_name =	"apm",
+	.d_kqfilter =	apmkqfilter
+};
+
+static int
+acpi_capm_convert_battstate(struct  acpi_battinfo *battp)
+{
+	int	state;
+
+	state = APM_UNKNOWN;
+
+	if (battp->state & ACPI_BATT_STAT_DISCHARG) {
+		if (battp->cap >= 50)
+			state = 0;	/* high */
+		else
+			state = 1;	/* low */
+	}
+	if (battp->state & ACPI_BATT_STAT_CRITICAL)
+		state = 2;		/* critical */
+	if (battp->state & ACPI_BATT_STAT_CHARGING)
+		state = 3;		/* charging */
+
+	/* If still unknown, determine it based on the battery capacity. */
+	if (state == APM_UNKNOWN) {
+		if (battp->cap >= 50)
+			state = 0;	/* high */
+		else
+			state = 1;	/* low */
+	}
+
+	return (state);
+}
+
+static int
+acpi_capm_convert_battflags(struct  acpi_battinfo *battp)
+{
+	int	flags;
+
+	flags = 0;
+
+	if (battp->cap >= 50)
+		flags |= APM_BATT_HIGH;
+	else {
+		if (battp->state & ACPI_BATT_STAT_CRITICAL)
+			flags |= APM_BATT_CRITICAL;
+		else
+			flags |= APM_BATT_LOW;
+	}
+	if (battp->state & ACPI_BATT_STAT_CHARGING)
+		flags |= APM_BATT_CHARGING;
+	if (battp->state == ACPI_BATT_STAT_NOT_PRESENT)
+		flags = APM_BATT_NOT_PRESENT;
+
+	return (flags);
+}
+
+static int
+acpi_capm_get_info(apm_info_t aip)
+{
+	int	acline;
+	struct	acpi_battinfo batt;
+
+	aip->ai_infoversion = 1;
+	aip->ai_major       = 1;
+	aip->ai_minor       = 2;
+	aip->ai_status      = apm_active;
+	aip->ai_capabilities= 0xff00;	/* unknown */
+
+	if (acpi_acad_get_acline(&acline))
+		aip->ai_acline = APM_UNKNOWN;	/* unknown */
+	else
+		aip->ai_acline = acline;	/* on/off */
+
+	if (acpi_battery_get_battinfo(NULL, &batt) != 0) {
+		aip->ai_batt_stat = APM_UNKNOWN;
+		aip->ai_batt_life = APM_UNKNOWN;
+		aip->ai_batt_time = -1;		 /* unknown */
+		aip->ai_batteries = ~0U;	 /* unknown */
+	} else {
+		aip->ai_batt_stat = acpi_capm_convert_battstate(&batt);
+		aip->ai_batt_life = batt.cap;
+		aip->ai_batt_time = (batt.min == -1) ? -1 : batt.min * 60;
+		aip->ai_batteries = acpi_battery_get_units();
+	}
+
+	return (0);
+}
+
+static int
+acpi_capm_get_pwstatus(apm_pwstatus_t app)
+{
+	device_t dev;
+	int	acline, unit, error;
+	struct	acpi_battinfo batt;
+
+	if (app->ap_device != PMDV_ALLDEV &&
+	    (app->ap_device < PMDV_BATT0 || app->ap_device > PMDV_BATT_ALL))
+		return (1);
+
+	if (app->ap_device == PMDV_ALLDEV)
+		error = acpi_battery_get_battinfo(NULL, &batt);
+	else {
+		unit = app->ap_device - PMDV_BATT0;
+		dev = devclass_get_device(devclass_find("battery"), unit);
+		if (dev != NULL)
+			error = acpi_battery_get_battinfo(dev, &batt);
+		else
+			error = ENXIO;
+	}
+	if (error)
+		return (1);
+
+	app->ap_batt_stat = acpi_capm_convert_battstate(&batt);
+	app->ap_batt_flag = acpi_capm_convert_battflags(&batt);
+	app->ap_batt_life = batt.cap;
+	app->ap_batt_time = (batt.min == -1) ? -1 : batt.min * 60;
+
+	if (acpi_acad_get_acline(&acline))
+		app->ap_acline = APM_UNKNOWN;
+	else
+		app->ap_acline = acline;	/* on/off */
+
+	return (0);
+}
+
+/* Create single-use devices for /dev/apm and /dev/apmctl. */
+static void
+apm_clone(void *arg, struct ucred *cred, char *name, int namelen,
+    struct cdev **dev)
+{
+	int ctl_dev, unit;
+
+	if (*dev != NULL)
+		return;
+	if (strcmp(name, "apmctl") == 0)
+		ctl_dev = TRUE;
+	else if (strcmp(name, "apm") == 0)
+		ctl_dev = FALSE;
+	else
+		return;
+
+	/* Always create a new device and unit number. */
+	unit = -1;
+	if (clone_create(&apm_clones, &apm_cdevsw, &unit, dev, 0)) {
+		if (ctl_dev) {
+			*dev = make_dev(&apm_cdevsw, unit,
+			    UID_ROOT, GID_OPERATOR, 0660, "apmctl%d", unit);
+		} else {
+			*dev = make_dev(&apm_cdevsw, unit,
+			    UID_ROOT, GID_OPERATOR, 0664, "apm%d", unit);
+		}
+		if (*dev != NULL) {
+			dev_ref(*dev);
+			(*dev)->si_flags |= SI_CHEAPCLONE;
+		}
+	}
+}
+
+/* Create a struct for tracking per-device suspend notification. */
+static struct apm_clone_data *
+apm_create_clone(struct cdev *dev, struct acpi_softc *acpi_sc)
+{
+	struct apm_clone_data *clone;
+
+	clone = malloc(sizeof(*clone), M_APMDEV, M_WAITOK);
+	clone->cdev = dev;
+	clone->acpi_sc = acpi_sc;
+	clone->notify_status = APM_EV_NONE;
+	bzero(&clone->sel_read, sizeof(clone->sel_read));
+	knlist_init_mtx(&clone->sel_read.si_note, &acpi_mutex);
+
+	/*
+	 * The acpi device is always managed by devd(8) and is considered
+	 * writable (i.e., ack is required to allow suspend to proceed.)
+	 */
+	if (strcmp("acpi", devtoname(dev)) == 0)
+		clone->flags = ACPI_EVF_DEVD | ACPI_EVF_WRITE;
+	else
+		clone->flags = ACPI_EVF_NONE;
+
+	ACPI_LOCK(acpi);
+	STAILQ_INSERT_TAIL(&acpi_sc->apm_cdevs, clone, entries);
+	ACPI_UNLOCK(acpi);
+	return (clone);
+}
+
+static int
+apmopen(struct cdev *dev, int flag, int fmt, struct thread *td)
+{
+	struct	acpi_softc *acpi_sc;
+	struct 	apm_clone_data *clone;
+
+	acpi_sc = devclass_get_softc(devclass_find("acpi"), 0);
+	clone = apm_create_clone(dev, acpi_sc);
+	dev->si_drv1 = clone;
+
+	/* If the device is opened for write, record that. */
+	if ((flag & FWRITE) != 0)
+		clone->flags |= ACPI_EVF_WRITE;
+
+	return (0);
+}
+
+static int
+apmclose(struct cdev *dev, int flag, int fmt, struct thread *td)
+{
+	struct	apm_clone_data *clone;
+	struct	acpi_softc *acpi_sc;
+
+	clone = dev->si_drv1;
+	acpi_sc = clone->acpi_sc;
+
+	/* We are about to lose a reference so check if suspend should occur */
+	if (acpi_sc->acpi_next_sstate != 0 &&
+	    clone->notify_status != APM_EV_ACKED)
+		acpi_AckSleepState(clone, 0);
+
+	/* Remove this clone's data from the list and free it. */
+	ACPI_LOCK(acpi);
+	STAILQ_REMOVE(&acpi_sc->apm_cdevs, clone, apm_clone_data, entries);
+	knlist_destroy(&clone->sel_read.si_note);
+	ACPI_UNLOCK(acpi);
+	free(clone, M_APMDEV);
+	destroy_dev_sched(dev);
+	return (0);
+}
+
+static int
+apmioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flag, struct thread *td)
+{
+	int	error;
+	struct	apm_clone_data *clone;
+	struct	acpi_softc *acpi_sc;
+	struct	apm_info info;
+	struct 	apm_event_info *ev_info;
+	apm_info_old_t aiop;
+
+	error = 0;
+	clone = dev->si_drv1;
+	acpi_sc = clone->acpi_sc;
+
+	switch (cmd) {
+	case APMIO_SUSPEND:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		if (acpi_sc->acpi_next_sstate == 0) {
+			if (acpi_sc->acpi_suspend_sx != ACPI_STATE_S5) {
+				error = acpi_ReqSleepState(acpi_sc,
+				    acpi_sc->acpi_suspend_sx);
+			} else {
+				printf(
+			"power off via apm suspend not supported\n");
+				error = ENXIO;
+			}
+		} else
+			error = acpi_AckSleepState(clone, 0);
+		break;
+	case APMIO_STANDBY:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		if (acpi_sc->acpi_next_sstate == 0) {
+			if (acpi_sc->acpi_standby_sx != ACPI_STATE_S5) {
+				error = acpi_ReqSleepState(acpi_sc,
+				    acpi_sc->acpi_standby_sx);
+			} else {
+				printf(
+			"power off via apm standby not supported\n");
+				error = ENXIO;
+			}
+		} else
+			error = acpi_AckSleepState(clone, 0);
+		break;
+	case APMIO_NEXTEVENT:
+		printf("apm nextevent start\n");
+		ACPI_LOCK(acpi);
+		if (acpi_sc->acpi_next_sstate != 0 && clone->notify_status ==
+		    APM_EV_NONE) {
+			ev_info = (struct apm_event_info *)addr;
+			if (acpi_sc->acpi_next_sstate <= ACPI_STATE_S3)
+				ev_info->type = PMEV_STANDBYREQ;
+			else
+				ev_info->type = PMEV_SUSPENDREQ;
+			ev_info->index = 0;
+			clone->notify_status = APM_EV_NOTIFIED;
+			printf("apm event returning %d\n", ev_info->type);
+		} else
+			error = EAGAIN;
+		ACPI_UNLOCK(acpi);
+		break;
+	case APMIO_GETINFO_OLD:
+		if (acpi_capm_get_info(&info))
+			error = ENXIO;
+		aiop = (apm_info_old_t)addr;
+		aiop->ai_major = info.ai_major;
+		aiop->ai_minor = info.ai_minor;
+		aiop->ai_acline = info.ai_acline;
+		aiop->ai_batt_stat = info.ai_batt_stat;
+		aiop->ai_batt_life = info.ai_batt_life;
+		aiop->ai_status = info.ai_status;
+		break;
+	case APMIO_GETINFO:
+		if (acpi_capm_get_info((apm_info_t)addr))
+			error = ENXIO;
+		break;
+	case APMIO_GETPWSTATUS:
+		if (acpi_capm_get_pwstatus((apm_pwstatus_t)addr))
+			error = ENXIO;
+		break;
+	case APMIO_ENABLE:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		apm_active = 1;
+		break;
+	case APMIO_DISABLE:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		apm_active = 0;
+		break;
+	case APMIO_HALTCPU:
+		break;
+	case APMIO_NOTHALTCPU:
+		break;
+	case APMIO_DISPLAY:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		break;
+	case APMIO_BIOS:
+		if ((flag & FWRITE) == 0)
+			return (EPERM);
+		bzero(addr, sizeof(struct apm_bios_arg));
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+
+	return (error);
+}
+
+static int
+apmwrite(struct cdev *dev, struct uio *uio, int ioflag)
+{
+	return (uio->uio_resid);
+}
+
+static int
+apmpoll(struct cdev *dev, int events, struct thread *td)
+{
+	struct	apm_clone_data *clone;
+	int revents;
+
+	revents = 0;
+	ACPI_LOCK(acpi);
+	clone = dev->si_drv1;
+	if (clone->acpi_sc->acpi_next_sstate)
+		revents |= events & (POLLIN | POLLRDNORM);
+	else
+		selrecord(td, &clone->sel_read);
+	ACPI_UNLOCK(acpi);
+	return (revents);
+}
+
+static int
+apmkqfilter(struct cdev *dev, struct knote *kn)
+{
+	struct	apm_clone_data *clone;
+
+	ACPI_LOCK(acpi);
+	clone = dev->si_drv1;
+	kn->kn_hook = clone;
+	kn->kn_fop = &apm_readfiltops;
+	knlist_add(&clone->sel_read.si_note, kn, 0);
+	ACPI_UNLOCK(acpi);
+	return (0);
+}
+
+static void
+apmreadfiltdetach(struct knote *kn)
+{
+	struct	apm_clone_data *clone;
+
+	ACPI_LOCK(acpi);
+	clone = kn->kn_hook;
+	knlist_remove(&clone->sel_read.si_note, kn, 0);
+	ACPI_UNLOCK(acpi);
+}
+
+static int
+apmreadfilt(struct knote *kn, long hint)
+{
+	struct	apm_clone_data *clone;
+	int	sleeping;
+
+	ACPI_LOCK(acpi);
+	clone = kn->kn_hook;
+	sleeping = clone->acpi_sc->acpi_next_sstate ? 1 : 0;
+	ACPI_UNLOCK(acpi);
+	return (sleeping);
+}
+
 int
 acpi_machdep_init(device_t dev)
 {
@@ -63,14 +506,11 @@
 
 	sc = devclass_get_softc(devclass_find("acpi"), 0);
 
-	/* Create a fake clone for /dev/acpi. */
+	/* Create a clone for /dev/acpi also. */
 	STAILQ_INIT(&sc->apm_cdevs);
-	acpi_clone.cdev = sc->acpi_dev_t;
-	acpi_clone.acpi_sc = sc;
-	ACPI_LOCK(acpi);
-	STAILQ_INSERT_TAIL(&sc->apm_cdevs, &acpi_clone, entries);
-	ACPI_UNLOCK(acpi);
-	sc->acpi_clone = &acpi_clone;
+	sc->acpi_clone = apm_create_clone(sc->acpi_dev_t, sc);
+	clone_setup(&apm_clones);
+	EVENTHANDLER_REGISTER(dev_clone, apm_clone, 0, 1000);
 	acpi_install_wakeup_handler(sc);
 
 	if (intr_model != ACPI_INTR_PIC)
--- a/sys/amd64/include/apm_bios.h
+++ b/sys/amd64/include/apm_bios.h
@@ -0,0 +1,264 @@
+/*-
+ * APM (Advanced Power Management) BIOS Device Driver
+ *
+ * Copyright (c) 1994-1995 by HOSOKAWA, Tatsumi <hosokawa@mt.cs.keio.ac.jp>
+ *
+ * This software may be used, modified, copied, and distributed, in
+ * both source and binary form provided that the above copyright and
+ * these terms are retained. Under no circumstances is the author
+ * responsible for the proper functioning of this software, nor does
+ * the author assume any responsibility for damages incurred with its
+ * use.
+ *
+ * Aug, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)
+ *
+ * $FreeBSD$
+ */
+
+#ifndef	_MACHINE_APM_BIOS_H_
+#define	_MACHINE_APM_BIOS_H_
+
+#ifndef _KERNEL
+#include <sys/types.h>
+#endif
+#include <sys/ioccom.h>
+
+/* BIOS id */
+#define APM_BIOS		0x53
+#define APM_INT			0x15
+
+/* APM flags */
+#define APM_16BIT_SUPPORT	0x01
+#define APM_32BIT_SUPPORT	0x02
+#define APM_CPUIDLE_SLOW	0x04
+#define APM_DISABLED		0x08
+#define APM_DISENGAGED		0x10
+
+/* APM initializer physical address */
+#define APM_OURADDR		0x00080000
+
+/* APM functions */
+#define APM_INSTCHECK		0x00
+#define APM_REALCONNECT		0x01
+#define APM_PROT16CONNECT	0x02
+#define APM_PROT32CONNECT	0x03
+#define APM_DISCONNECT		0x04
+#define APM_CPUIDLE		0x05
+#define APM_CPUBUSY		0x06
+#define APM_SETPWSTATE		0x07
+#define APM_ENABLEDISABLEPM	0x08
+#define APM_RESTOREDEFAULT	0x09
+#define	APM_GETPWSTATUS		0x0a
+#define APM_GETPMEVENT		0x0b
+#define APM_GETPWSTATE		0x0c
+#define APM_ENABLEDISABLEDPM	0x0d
+#define APM_DRVVERSION		0x0e
+#define APM_ENGAGEDISENGAGEPM	0x0f
+#define APM_GETCAPABILITIES	0x10
+#define APM_RESUMETIMER		0x11
+#define APM_RESUMEONRING	0x12
+#define APM_TIMERREQUESTS	0x13
+#define APM_OEMFUNC		0x80
+
+/* error code */
+#define APME_OK			0x00
+#define APME_PMDISABLED		0x01
+#define APME_REALESTABLISHED	0x02
+#define APME_NOTCONNECTED	0x03
+#define APME_PROT16ESTABLISHED	0x05
+#define APME_PROT16NOTSUPPORTED	0x06
+#define APME_PROT32ESTABLISHED	0x07
+#define APME_PROT32NOTDUPPORTED	0x08
+#define APME_UNKNOWNDEVICEID	0x09
+#define APME_OUTOFRANGE		0x0a
+#define APME_NOTENGAGED		0x0b
+#define APME_CANTENTERSTATE	0x60
+#define APME_NOPMEVENT		0x80
+#define APME_NOAPMPRESENT	0x86
+
+
+/* device code */
+#define PMDV_APMBIOS		0x0000
+#define PMDV_ALLDEV		0x0001
+#define PMDV_DISP0		0x0100
+#define PMDV_DISP1		0x0101
+#define PMDV_DISPALL		0x01ff
+#define PMDV_2NDSTORAGE0	0x0200
+#define PMDV_2NDSTORAGE1	0x0201
+#define PMDV_2NDSTORAGE2	0x0202
+#define PMDV_2NDSTORAGE3	0x0203
+#define PMDV_PARALLEL0		0x0300
+#define PMDV_PARALLEL1		0x0301
+#define PMDV_SERIAL0		0x0400
+#define PMDV_SERIAL1		0x0401
+#define PMDV_SERIAL2		0x0402
+#define PMDV_SERIAL3		0x0403
+#define PMDV_SERIAL4		0x0404
+#define PMDV_SERIAL5		0x0405
+#define PMDV_SERIAL6		0x0406
+#define PMDV_SERIAL7		0x0407
+#define PMDV_NET0		0x0500
+#define PMDV_NET1		0x0501
+#define PMDV_NET2		0x0502
+#define PMDV_NET3		0x0503
+#define PMDV_PCMCIA0		0x0600
+#define PMDV_PCMCIA1		0x0601
+#define PMDV_PCMCIA2		0x0602
+#define PMDV_PCMCIA3		0x0603
+/* 0x0700 - 0x7fff	Reserved			*/
+#define PMDV_BATT_BASE		0x8000
+#define PMDV_BATT0		0x8001
+#define PMDV_BATT1		0x8002
+#define PMDV_BATT_ALL		0x80ff
+/* 0x8100 - 0xdfff	Reserved			*/
+/* 0xe000 - 0xefff	OEM-defined power device IDs	*/
+/* 0xf000 - 0xffff	Reserved			*/
+
+/* Power state */
+#define PMST_APMENABLED		0x0000
+#define PMST_STANDBY		0x0001
+#define PMST_SUSPEND		0x0002
+#define PMST_OFF		0x0003
+#define PMST_LASTREQNOTIFY	0x0004
+#define PMST_LASTREQREJECT	0x0005
+/* 0x0006 - 0x001f	Reserved system states		*/
+/* 0x0020 - 0x003f	OEM-defined system states	*/
+/* 0x0040 - 0x007f	OEM-defined device states	*/
+/* 0x0080 - 0xffff	Reserved device states		*/
+
+#if !defined(ASSEMBLER) && !defined(INITIALIZER)
+
+/* C definitions */
+struct apmhook {
+	struct apmhook	*ah_next;
+	int		(*ah_fun)(void *ah_arg);
+	void		*ah_arg;
+	const char	*ah_name;
+	int		ah_order;
+};
+#define APM_HOOK_NONE		(-1)
+#define APM_HOOK_SUSPEND        0
+#define APM_HOOK_RESUME         1
+#define NAPM_HOOK               2
+
+#ifdef _KERNEL
+
+void apm_suspend(int state);
+struct apmhook *apm_hook_establish (int apmh, struct apmhook *);
+void apm_hook_disestablish (int apmh, struct apmhook *);
+void apm_cpu_idle(void);
+void apm_cpu_busy(void);
+
+#endif
+
+#endif /* !ASSEMBLER && !INITIALIZER */
+
+#define APM_MIN_ORDER		0x00
+#define APM_MID_ORDER		0x80
+#define APM_MAX_ORDER		0xff
+
+/* power management event code */
+#define PMEV_NOEVENT		0x0000
+#define PMEV_STANDBYREQ		0x0001
+#define PMEV_SUSPENDREQ		0x0002
+#define PMEV_NORMRESUME		0x0003
+#define PMEV_CRITRESUME		0x0004
+#define PMEV_BATTERYLOW		0x0005
+#define PMEV_POWERSTATECHANGE	0x0006
+#define PMEV_UPDATETIME		0x0007
+#define PMEV_CRITSUSPEND	0x0008
+#define PMEV_USERSTANDBYREQ	0x0009
+#define PMEV_USERSUSPENDREQ	0x000a
+#define PMEV_STANDBYRESUME	0x000b
+#define PMEV_CAPABILITIESCHANGE 0x000c
+/* 0x000d - 0x00ff	Reserved system events	*/
+/* 0x0100 - 0x01ff	Reserved device events	*/
+/* 0x0200 - 0x02ff	OEM-defined APM events	*/
+/* 0x0300 - 0xffff	Reserved		*/
+#define PMEV_DEFAULT		0xffffffff	/* used for customization */
+
+#if !defined(ASSEMBLER) && !defined(INITIALIZER)
+
+/*
+ * Old apm_info structure, returned by the APMIO_GETINFO_OLD ioctl.  This
+ * is for backward compatibility with old executables.
+ */
+typedef struct apm_info_old {
+	u_int	ai_major;	/* APM major version */
+	u_int	ai_minor;	/* APM minor version */
+	u_int	ai_acline;	/* AC line status */
+	u_int	ai_batt_stat;	/* Battery status */
+	u_int	ai_batt_life;	/* Remaining battery life */
+	u_int	ai_status;	/* Status of APM support (enabled/disabled) */
+} *apm_info_old_t;
+
+/*
+ * Structure returned by the APMIO_GETINFO ioctl.
+ *
+ * In the comments below, the parenthesized numbers indicate the minimum
+ * value of ai_infoversion for which each field is valid.
+ */
+typedef struct apm_info {
+	u_int	ai_infoversion;	/* Indicates which fields are valid */
+	u_int	ai_major;	/* APM major version (0) */
+	u_int	ai_minor;	/* APM minor version (0) */
+	u_int	ai_acline;	/* AC line status (0) */
+	u_int	ai_batt_stat;	/* Battery status (0) */
+	u_int	ai_batt_life;	/* Remaining battery life in percent (0) */
+	int	ai_batt_time;	/* Remaining battery time in seconds (0) */
+	u_int	ai_status;	/* True if enabled (0) */
+	u_int	ai_batteries;	/* Number of batteries (1) */
+	u_int	ai_capabilities;/* APM Capabilities (1) */
+	u_int	ai_spare[6];	/* For future expansion */
+} *apm_info_t;
+
+/* Battery flag */
+#define APM_BATT_HIGH		0x01
+#define APM_BATT_LOW		0x02
+#define APM_BATT_CRITICAL	0x04
+#define APM_BATT_CHARGING	0x08
+#define APM_BATT_NOT_PRESENT	0x10
+#define APM_BATT_NO_SYSTEM	0x80
+
+typedef struct apm_pwstatus {
+	u_int	ap_device;	/* Device code of battery */
+	u_int	ap_acline;	/* AC line status (0) */
+	u_int	ap_batt_stat;	/* Battery status (0) */
+	u_int	ap_batt_flag;	/* Battery flag (0) */
+	u_int	ap_batt_life;	/* Remaining battery life in percent (0) */
+	int	ap_batt_time;	/* Remaining battery time in seconds (0) */
+} *apm_pwstatus_t;
+
+struct apm_bios_arg {
+        uint32_t eax;
+        uint32_t ebx;
+        uint32_t ecx;
+        uint32_t edx;
+        uint32_t esi;
+        uint32_t edi;
+};
+
+struct apm_event_info {
+	u_int type;
+	u_int index;
+	u_int spare[8];
+};
+
+#define APMIO_SUSPEND		_IO('P', 1)
+#define APMIO_GETINFO_OLD	_IOR('P', 2, struct apm_info_old)
+#define APMIO_ENABLE		_IO('P', 5)
+#define APMIO_DISABLE		_IO('P', 6)
+#define APMIO_HALTCPU		_IO('P', 7)
+#define APMIO_NOTHALTCPU	_IO('P', 8)
+#define APMIO_DISPLAY		_IOW('P', 9, int)
+#define APMIO_BIOS		_IOWR('P', 10, struct apm_bios_arg)
+#define APMIO_GETINFO		_IOR('P', 11, struct apm_info)
+#define APMIO_STANDBY		_IO('P', 12)
+#define APMIO_GETPWSTATUS	_IOWR('P', 13, struct apm_pwstatus)
+/* for /dev/apmctl */
+#define APMIO_NEXTEVENT		_IOR('A', 100, struct apm_event_info)
+#define APMIO_REJECTLASTREQ	_IO('P', 101)
+
+#endif /* !ASSEMBLER && !INITIALIZER */
+
+#endif /* !_MACHINE_APM_BIOS_H_ */

